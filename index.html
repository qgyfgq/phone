<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Whale-LLT å°æ‰‹æœº</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="AIèŠå¤©åŠ©æ‰‹">
    <meta name="theme-color" content="#07c160">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Whale-LLT">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Whale-LLT">
    
    <!-- PWA Icons -->
    <link rel="apple-touch-icon" sizes="152x152" href="./assets/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./assets/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./assets/icon-16x16.png">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#07c160">
    <meta name="msapplication-TileColor" content="#07c160">
    
    <!-- Manifest -->
    <link rel="manifest" href="./assets/manifest.json">
    
    
    <!-- å­—ä½“æŒ‰éœ€åŠ è½½ - ç§»é™¤é¢„åŠ è½½çš„CSSï¼Œæ”¹ä¸ºåŠ¨æ€åŠ è½½ -->
    
    <script>
/**
 * äº‘åŒæ­¥é…ç½® - è‡ªåŠ¨æ£€æµ‹éƒ¨ç½²ç¯å¢ƒ
 */
class SyncConfig {
    /**
     * è·å–APIåŸºç¡€URL
     */
    static getApiBaseUrl() {
        // å¦‚æœåœ¨æµè§ˆå™¨ç¯å¢ƒä¸­
        if (typeof window !== 'undefined') {
            const hostname = window.location.hostname;
            
            // Verceléƒ¨ç½²æ£€æµ‹
            if (hostname.includes('.vercel.app') || hostname.includes('vercel')) {
                return ''; // ç›¸å¯¹è·¯å¾„ï¼Œä½¿ç”¨å½“å‰åŸŸåçš„API
            }
            
            // Netlifyéƒ¨ç½²æ£€æµ‹ - æ”¹ä¸ºç›´æ¥è°ƒç”¨Vercel API
            if (hostname.includes('.netlify.app') || hostname.includes('netlify')) {
                // ç›´æ¥ä½¿ç”¨ç”Ÿäº§ç¯å¢ƒVercelåŸŸåï¼Œä¸å†é€šè¿‡Netlify Functionsä»£ç†
                return 'https://chat.whale-llt.top';
            }
            
            // æœ¬åœ°å¼€å‘ç¯å¢ƒ
            if (hostname === 'localhost' || hostname === '127.0.0.1') {
                // å¦‚æœæ˜¯åœ¨Vercel Devç¯å¢ƒ
                if (window.location.port === '3000') {
                    return ''; // ä½¿ç”¨æœ¬åœ°Vercel API
                }
                // å¦‚æœæ˜¯å…¶ä»–æœ¬åœ°ç¯å¢ƒï¼Œè°ƒç”¨å·²éƒ¨ç½²çš„Vercel API
                return 'https://chat.whale-llt.top';
            }
            
            // è‡ªå®šä¹‰åŸŸå - é»˜è®¤ä½¿ç”¨ç›¸å¯¹è·¯å¾„
            return '';
        }
        
        // Node.jsç¯å¢ƒï¼ˆæœåŠ¡ç«¯ï¼‰- é»˜è®¤ç›¸å¯¹è·¯å¾„
        return '';
    }
    
    /**
     * è·å–å®Œæ•´çš„API URL
     */
    static getApiUrl(endpoint) {
        const baseUrl = this.getApiBaseUrl();
        
        // æ‰€æœ‰æƒ…å†µéƒ½ä½¿ç”¨æ ‡å‡†APIè·¯å¾„ï¼Œä¸å†ä½¿ç”¨Netlifyå‡½æ•°ä»£ç†
        return `${baseUrl}/api/sync/${endpoint}`;
    }
    
    /**
     * æ£€æŸ¥å½“å‰æ˜¯å¦ä¸ºVercelç¯å¢ƒï¼ˆæœ‰APIèƒ½åŠ›ï¼‰
     */
    static isVercelEnvironment() {
        if (typeof window !== 'undefined') {
            const hostname = window.location.hostname;
            return hostname.includes('.vercel.app') || 
                   hostname.includes('vercel') ||
                   (hostname === 'localhost' && window.location.port === '3000');
        }
        return false;
    }
    
    /**
     * è·å–å¯†é’¥ç”Ÿæˆå™¨URL
     */
    static getKeyGeneratorUrl() {
        const baseUrl = this.getApiBaseUrl();
        return `${baseUrl}/sync-key-generator.html`;
    }
}
// å¯¼å‡ºé…ç½®
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SyncConfig;
} else {
    window.SyncConfig = SyncConfig;
}
</script>
    <script>
/**
 * ç¯å¢ƒé…ç½®ç³»ç»Ÿ - æ”¯æŒæ„å»ºæ—¶ç¯å¢ƒå˜é‡æ³¨å…¥
 * æ”¯æŒ Vercel å’Œ Netlify éƒ¨ç½²å¹³å°
 */
class EnvironmentConfig {
    /**
     * ç¯å¢ƒæŒ‡ç¤ºå™¨å…³é”®è¯é…ç½®
     * å½“ç¯å¢ƒæ ‡ç­¾åŒ…å«è¿™äº›å…³é”®è¯æ—¶ï¼Œå°†æ˜¾ç¤ºç¯å¢ƒæŒ‡ç¤ºå™¨
     */
    static INDICATOR_KEYWORDS = ['æµ‹è¯•', 'å¼€å‘', 'test', 'dev'];

    /**
     * æ„å»ºæ—¶ç¯å¢ƒå˜é‡å ä½ç¬¦
     * è¿™äº›å°†åœ¨æ„å»ºè¿‡ç¨‹ä¸­è¢«å®é™…å€¼æ›¿æ¢
     */
    static BUILD_TIME_CONFIG = {
        // ç¯å¢ƒç±»å‹: development, staging, production
        ENVIRONMENT: 'production',
        // åº”ç”¨ç‰ˆæœ¬
        APP_VERSION: '1.0.0',
        // æ„å»ºæ—¶é—´æˆ³
        BUILD_TIMESTAMP: '2025-09-15T15:34:10.370Z',
        // Git æäº¤å“ˆå¸Œ
        GIT_COMMIT: '4e267410f8c8f2ca802f712b0c44b36b73ab3f07',
        // æ˜¯å¦ä¸ºå¼€å‘ç‰ˆæœ¬
        IS_DEVELOPMENT: 'false',
        // è‡ªå®šä¹‰æ ‡ç­¾
        ENVIRONMENT_LABEL: ''
    };

    /**
     * è·å–å½“å‰ç¯å¢ƒé…ç½®
     */
    static getEnvironment() {
        // ä¼˜å…ˆä½¿ç”¨æ„å»ºæ—¶æ³¨å…¥çš„ç¯å¢ƒå˜é‡
        let environment = this.BUILD_TIME_CONFIG.ENVIRONMENT;
        let isDevelopment = this.BUILD_TIME_CONFIG.IS_DEVELOPMENT;
        let environmentLabel = this.BUILD_TIME_CONFIG.ENVIRONMENT_LABEL;

        // å¦‚æœæ²¡æœ‰è¢«æ›¿æ¢ï¼ˆä»ç„¶åŒ…å«èŠ±æ‹¬å·ï¼‰ï¼Œåˆ™å›é€€åˆ°è¿è¡Œæ—¶æ£€æµ‹
        if (environment.includes('{{')) {
            environment = this.detectEnvironmentFromURL();
            isDevelopment = environment !== 'production';
            environmentLabel = this.getDefaultEnvironmentLabel(environment);
        } else {
            // å¤„ç†å­—ç¬¦ä¸²å½¢å¼çš„å¸ƒå°”å€¼
            isDevelopment = isDevelopment === 'true' || isDevelopment === true;
        }

        return {
            environment,
            isDevelopment,
            environmentLabel,
            version: this.getVersion(),
            buildTime: this.getBuildTime(),
            gitCommit: this.getGitCommit()
        };
    }

    /**
     * é€šè¿‡URLæ£€æµ‹ç¯å¢ƒï¼ˆå›é€€æ–¹æ¡ˆï¼‰
     */
    static detectEnvironmentFromURL() {
        if (typeof window === 'undefined') return 'production';

        const hostname = window.location.hostname;

        // æœ¬åœ°å¼€å‘ç¯å¢ƒ
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('192.168.')) {
            return 'development';
        }

        // Vercel Preview éƒ¨ç½²
        if (hostname.includes('-git-') || hostname.includes('.vercel.app')) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯ dev åˆ†æ”¯æˆ–åŒ…å« dev ç›¸å…³æ ‡è¯†
            if (hostname.includes('-dev-') || hostname.includes('-develop-') || 
                hostname.includes('-test-') || hostname.includes('-staging-')) {
                return 'staging';
            }
            // Vercel çš„ä¸»åˆ†æ”¯éƒ¨ç½²é€šå¸¸æ˜¯ç”Ÿäº§ç¯å¢ƒ
            return hostname.includes('main') ? 'production' : 'staging';
        }

        // Netlify éƒ¨ç½²
        if (hostname.includes('.netlify.app')) {
            // æ£€æŸ¥åŸŸåä¸­æ˜¯å¦åŒ…å«å¼€å‘ç›¸å…³å…³é”®è¯
            if (hostname.includes('dev') || hostname.includes('test') || 
                hostname.includes('staging') || hostname.includes('preview')) {
                return 'staging';
            }
            
            // Netlify çš„ branch éƒ¨ç½²æ£€æµ‹ï¼ˆæ ¼å¼ï¼šbranch--sitename.netlify.appï¼‰
            if (hostname.includes('--')) {
                const parts = hostname.split('--');
                const branchName = parts[0];
                if (branchName && (branchName.includes('dev') || branchName.includes('test'))) {
                    return 'staging';
                }
            }
            
            // é»˜è®¤ä¸ºç”Ÿäº§ç¯å¢ƒ
            return 'production';
        }

        // è‡ªå®šä¹‰åŸŸåé»˜è®¤ä¸ºç”Ÿäº§ç¯å¢ƒ
        return 'production';
    }

    /**
     * è·å–é»˜è®¤ç¯å¢ƒæ ‡ç­¾
     */
    static getDefaultEnvironmentLabel(environment) {
        switch (environment) {
            case 'development':
                return 'å¼€å‘ç¯å¢ƒ';
            case 'staging':
                return 'æµ‹è¯•ç¯å¢ƒ';
            case 'production':
            default:
                return null; // ç”Ÿäº§ç¯å¢ƒä¸æ˜¾ç¤ºæ ‡ç­¾
        }
    }

    /**
     * è·å–åº”ç”¨ç‰ˆæœ¬
     */
    static getVersion() {
        // ä¼˜å…ˆä½¿ç”¨ git commit hash çš„å‰7ä½ä½œä¸ºç‰ˆæœ¬æ˜¾ç¤º
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        if (gitCommit !== 'unknown' && gitCommit.length >= 7) {
            return gitCommit.substring(0, 7);
        }
        
        // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„ git commit hashï¼Œå›é€€åˆ°åº”ç”¨ç‰ˆæœ¬å·
        let version = this.BUILD_TIME_CONFIG.APP_VERSION;
        return version.includes('{{') ? 'dev' : version;
    }

    /**
     * è·å–æ„å»ºæ—¶é—´
     */
    static getBuildTime() {
        let buildTime = this.BUILD_TIME_CONFIG.BUILD_TIMESTAMP;
        return buildTime.includes('{{') ? new Date().toISOString() : buildTime;
    }

    /**
     * è·å– Git æäº¤å“ˆå¸Œ
     */
    static getGitCommit() {
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        return gitCommit.includes('{{') ? 'unknown' : gitCommit;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦åº”è¯¥æ˜¾ç¤ºç¯å¢ƒæŒ‡ç¤ºå™¨
     * åœ¨ä»¥ä¸‹æƒ…å†µä¸‹æ˜¾ç¤ºï¼š
     * 1. éç”Ÿäº§ç¯å¢ƒ
     * 2. ç¯å¢ƒæ ‡ç­¾åŒ…å«"æµ‹è¯•"æˆ–"å¼€å‘"å…³é”®è¯
     */
    static shouldShowEnvironmentIndicator() {
        const config = this.getEnvironment();
        
        // éç”Ÿäº§ç¯å¢ƒå§‹ç»ˆæ˜¾ç¤º
        if (config.environment !== 'production') {
            return true;
        }
        
        // æ£€æŸ¥ç¯å¢ƒæ ‡ç­¾æ˜¯å¦åŒ…å«æŒ‡ç¤ºå™¨å…³é”®è¯
        if (config.environmentLabel) {
            const label = config.environmentLabel.toLowerCase();
            return this.INDICATOR_KEYWORDS.some(keyword => label.includes(keyword));
        }
        
        return false;
    }

    /**
     * è·å–ç¯å¢ƒæŒ‡ç¤ºå™¨é…ç½®
     * æ ¹æ®shouldShowEnvironmentIndicatorçš„é€»è¾‘å†³å®šæ˜¯å¦è¿”å›é…ç½®
     */
    static getEnvironmentIndicatorConfig() {
        const config = this.getEnvironment();
        
        // ä½¿ç”¨shouldShowEnvironmentIndicatoræ–¹æ³•ç»Ÿä¸€åˆ¤æ–­é€»è¾‘
        if (!this.shouldShowEnvironmentIndicator()) {
            return null;
        }

        // è¿”å›ç¯å¢ƒæŒ‡ç¤ºå™¨é…ç½®
        return {
            text: config.environmentLabel ? `${config.environmentLabel} - å¼€å‘ä¸­å†…å®¹ï¼Œä¸ä»£è¡¨æœ€ç»ˆæˆæœ` : 'å¼€å‘ä¸­å†…å®¹ï¼Œä¸ä»£è¡¨æœ€ç»ˆæˆæœ',
            version: config.version,
            environment: config.environment
        };
    }

    /**
     * æ‰“å°ç¯å¢ƒä¿¡æ¯åˆ°æ§åˆ¶å°
     */
    static printEnvironmentInfo() {
        const config = this.getEnvironment();
        console.group('ğŸŒ Environment Info');
        console.log('Environment:', config.environment);
        console.log('Development Mode:', config.isDevelopment);
        console.log('Version:', config.version);
        console.log('Build Time:', config.buildTime);
        console.log('Git Commit:', config.gitCommit);
        if (config.environmentLabel) {
            console.log('Label:', config.environmentLabel);
        }
        console.groupEnd();
    }
}

// å¯¼å‡ºé…ç½®
if (typeof module !== 'undefined' && module.exports) {
    module.exports = EnvironmentConfig;
} else {
    window.EnvironmentConfig = EnvironmentConfig;
}

</script>
    <script>
/**
 * ç¯å¢ƒæŒ‡ç¤ºå™¨ç»„ä»¶
 * åœ¨éç”Ÿäº§ç¯å¢ƒä¸‹æ˜¾ç¤ºç¯å¢ƒæç¤ºä¿¡æ¯
 */
class EnvironmentIndicator {
    constructor() {
        this.indicator = null;
        this.isVisible = false;
    }

    /**
     * åˆå§‹åŒ–ç¯å¢ƒæŒ‡ç¤ºå™¨
     */
    init() {
        // ç¡®ä¿ EnvironmentConfig å·²åŠ è½½
        if (typeof EnvironmentConfig === 'undefined') {
            console.warn('EnvironmentConfig not loaded, environment indicator disabled');
            return;
        }

        // è°ƒè¯•ï¼šæ‰“å°å½“å‰ç¯å¢ƒä¿¡æ¯
        console.log('ğŸŒ Environment Indicator Initializing...');
        const envInfo = EnvironmentConfig.getEnvironment();
        console.log('Environment Info:', envInfo);

        const config = EnvironmentConfig.getEnvironmentIndicatorConfig();
        console.log('Indicator Config:', config);
        
        if (config) {
            this.createIndicator(config);
            this.show();
            console.log('âœ… Environment indicator created and shown');
            
            // æ‰“å°ç¯å¢ƒä¿¡æ¯åˆ°æ§åˆ¶å°
            EnvironmentConfig.printEnvironmentInfo();
        } else {
            console.log('âŒ Environment indicator not shown (production or disabled)');
        }
    }

    /**
     * åˆ›å»ºæŒ‡ç¤ºå™¨DOMå…ƒç´ 
     */
    createIndicator(config) {
        // é¿å…é‡å¤åˆ›å»º
        if (this.indicator) {
            this.indicator.remove();
        }

        const indicator = document.createElement('div');
        indicator.className = 'environment-indicator';
        indicator.innerHTML = `
            <div class="environment-indicator-content">
                <span class="environment-text">${config.text}</span>
                <span class="environment-version">${config.version}</span>
            </div>
        `;

        // è®¾ç½®æ ·å¼
        this.setIndicatorStyles(indicator, config);
        
        this.indicator = indicator;
        document.body.appendChild(indicator);
    }

    /**
     * è®¾ç½®æŒ‡ç¤ºå™¨æ ·å¼
     */
    setIndicatorStyles(element, config) {
        // ä½¿ç”¨ setProperty æ–¹æ³•åº”ç”¨å…³é”®æ ·å¼ä»¥ç¡®ä¿ä¼˜å…ˆçº§
        element.style.setProperty('position', 'fixed', 'important');
        element.style.setProperty('bottom', '52px', 'important');
        element.style.setProperty('left', '50%', 'important');
        element.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
        element.style.setProperty('backgroundColor', 'transparent', 'important');
        element.style.setProperty('color', '#ff6600', 'important');
        element.style.setProperty('z-index', '999999', 'important');
        element.style.setProperty('pointer-events', 'none', 'important');
        
        // åº”ç”¨å…¶ä»–æ ·å¼
        const additionalStyles = {
            padding: '4px 0',
            borderRadius: '0',
            fontSize: '11px',
            fontWeight: '500',
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            boxShadow: 'none',
            userSelect: 'none',
            opacity: '0.8',
            maxWidth: '300px',
            lineHeight: '1.1',
            textAlign: 'center',
            transition: 'opacity 0.3s ease-in-out',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
        };

        Object.assign(element.style, additionalStyles);

        // ä¸ºå†…å®¹å®¹å™¨è®¾ç½®æ ·å¼
        const content = element.querySelector('.environment-indicator-content');
        if (content) {
            Object.assign(content.style, {
                display: 'inline', // æ”¹ä¸ºå†…è”æ˜¾ç¤º
                gap: '0'
            });
        }

        // ä¸ºç‰ˆæœ¬å·è®¾ç½®æ ·å¼
        const version = element.querySelector('.environment-version');
        if (version) {
            Object.assign(version.style, {
                fontSize: '10px',
                opacity: '0.7',
                fontWeight: 'normal',
                marginLeft: '4px'
            });
        }
    }

    /**
     * æ˜¾ç¤ºæŒ‡ç¤ºå™¨
     */
    show() {
        if (this.indicator && !this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
            this.indicator.style.setProperty('opacity', '0.8', 'important');
            this.isVisible = true;
        }
    }

    /**
     * éšè—æŒ‡ç¤ºå™¨
     */
    hide() {
        if (this.indicator && this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(100%)', 'important');
            this.indicator.style.setProperty('opacity', '0', 'important');
            this.isVisible = false;
            
            // å»¶è¿Ÿç§»é™¤å…ƒç´ 
            setTimeout(() => {
                if (this.indicator && this.indicator.parentNode) {
                    this.indicator.parentNode.removeChild(this.indicator);
                }
                this.indicator = null;
            }, 300);
        }
    }

    /**
     * åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
     */
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.init();
        }
    }

    /**
     * é”€æ¯æŒ‡ç¤ºå™¨
     */
    destroy() {
        this.hide();
    }
}

/**
 * å…¨å±€ç¯å¢ƒæŒ‡ç¤ºå™¨å®ä¾‹
 */
window.environmentIndicator = new EnvironmentIndicator();

/**
 * DOMåŠ è½½å®Œæˆåè‡ªåŠ¨åˆå§‹åŒ–
 */
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.environmentIndicator.init();
    });
} else {
    // å¦‚æœDOMå·²ç»åŠ è½½å®Œæˆ
    window.environmentIndicator.init();
}

/**
 * å¼€å‘è°ƒè¯•åŠŸèƒ½
 * åœ¨æ§åˆ¶å°ä¸­å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š
 * - environmentIndicator.toggle() - åˆ‡æ¢æ˜¾ç¤º
 * - environmentIndicator.hide() - éšè—æŒ‡ç¤ºå™¨  
 * - environmentIndicator.show() - æ˜¾ç¤ºæŒ‡ç¤ºå™¨
 * - EnvironmentConfig.printEnvironmentInfo() - æ‰“å°ç¯å¢ƒä¿¡æ¯
 */
if (typeof EnvironmentConfig !== 'undefined') {
    const config = EnvironmentConfig.getEnvironment();
    if (config.isDevelopment) {
        console.log('ğŸ”§ Environment Indicator Debug Commands:');
        console.log('  environmentIndicator.toggle() - Toggle indicator');
        console.log('  environmentIndicator.hide() - Hide indicator');
        console.log('  environmentIndicator.show() - Show indicator');
        console.log('  EnvironmentConfig.printEnvironmentInfo() - Print env info');
    }
}
</script>
    <script>
/**
 * APIé…ç½®ç®¡ç†å™¨
 * æ”¯æŒå¤šç»„APIé…ç½®çš„å¢åˆ æ”¹æŸ¥å’Œåˆ‡æ¢
 * åŒ…å«API Keyä½¿ç”¨ç»Ÿè®¡åŠŸèƒ½
 * éµå¾ªé¡¹ç›®çš„IndexedDBå­˜å‚¨è§„èŒƒ
 */
class APIConfigManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.dbVersion = 14; // éœ€è¦ä¸ä¸»é¡¹ç›®ä¿æŒä¸€è‡´
        this.settingsStore = 'apiSettings'; // ç»Ÿä¸€ä½¿ç”¨apiSettingsè¡¨å­˜å‚¨æ‰€æœ‰é…ç½®
        // ä¸å†ä½¿ç”¨å®ä¾‹å˜é‡å­˜å‚¨dbè¿æ¥ï¼Œç›´æ¥ä½¿ç”¨window.db
        this.defaultConfigKey = 'settings'; // é»˜è®¤é…ç½®ä½¿ç”¨'settings'é”®ä¿æŒå…¼å®¹æ€§
        
        // é»˜è®¤é…ç½®æ¨¡æ¿ - ç§»é™¤æ¨¡å‹å­—æ®µ
        this.defaultConfig = {
            id: '',
            name: 'é»˜è®¤é…ç½®',
            url: '',
            key: '',
            contextMessageCount: 10,
            timeout: 60,
            isDefault: false,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        // å…¨å±€æ¨¡å‹é…ç½®é”®
        this.globalModelConfigKey = 'global_model_config';
        
        // å½“å‰æ¿€æ´»çš„é…ç½®ID
        this.activeConfigId = null;
        this.availableModels = new Map(); // ç¼“å­˜æ¯ä¸ªé…ç½®çš„å¯ç”¨æ¨¡å‹åˆ—è¡¨
        
        // API Keyç»Ÿè®¡åŠŸèƒ½
        this.statsStorageKey = 'apiKeyUsageStats';
        // console.log(`[APIç»Ÿè®¡è°ƒè¯•] APIConfigManageræ„é€ å‡½æ•°è¢«è°ƒç”¨ï¼ŒstatsStorageKey=${this.statsStorageKey}`);
        this.stats = this.loadStats();
        // console.log(`[APIç»Ÿè®¡è°ƒè¯•] æ„é€ å‡½æ•°ä¸­åŠ è½½çš„stats:`, JSON.stringify(this.stats, null, 2));
        this.cleanupInterval = null;
    }

    /**
     * åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
     */
    async init() {
        return await ensureDBReady(async () => {
            // ä¸å†ç¼“å­˜ window.dbï¼Œç›´æ¥ä½¿ç”¨å…¨å±€å˜é‡
            await this.migrateExistingConfig();
            await this.loadActiveConfig();

            // åˆå§‹åŒ–å…¨å±€æ¨¡å‹é…ç½®
            await this.initGlobalModelConfig();

            // å¯åŠ¨ç»Ÿè®¡åŠŸèƒ½
            this.startAutoCleanup();
            console.log('APIé…ç½®ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
            return { success: true };
        }, 'APIé…ç½®ç®¡ç†å™¨åˆå§‹åŒ–');
    }

    /**
     * åˆå§‹åŒ–å¤šé…ç½®ç³»ç»Ÿï¼Œä¸éœ€è¦è¿ç§»ï¼Œç›´æ¥å¤ç”¨ç°æœ‰settings
     */
    async migrateExistingConfig() {
        try {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const existingSettings = await promisifyRequest(store.get(this.defaultConfigKey), 'æ£€æŸ¥ç°æœ‰APIè®¾ç½®');
            
            if (existingSettings && existingSettings.url && existingSettings.key) {
                // ä¸ºç°æœ‰settingsæ·»åŠ å¤šé…ç½®ç³»ç»Ÿéœ€è¦çš„å…ƒæ•°æ®
                const enhancedSettings = {
                    ...existingSettings,
                    configName: 'é»˜è®¤é…ç½®',
                    isDefault: true,
                    createdAt: existingSettings.createdAt || Date.now(),
                    updatedAt: Date.now()
                };
                
                // æ›´æ–°ç°æœ‰settingsä»¥åŒ…å«å¤šé…ç½®å…ƒæ•°æ®
                const writeTransaction = window.db.transaction([this.settingsStore], 'readwrite');
                const writeStore = writeTransaction.objectStore(this.settingsStore);
                await promisifyRequest(writeStore.put(enhancedSettings), 'å¢å¼ºç°æœ‰é…ç½®');
                
                // è®¾ç½®ä¸ºå½“å‰æ¿€æ´»é…ç½®
                this.activeConfigId = this.defaultConfigKey;
                await this.saveActiveConfigId(this.defaultConfigKey);
                console.log('ç°æœ‰é…ç½®å·²å¢å¼ºä¸ºå¤šé…ç½®ç³»ç»Ÿ');
            }
        } catch (error) {
            console.log('é…ç½®åˆå§‹åŒ–è·³è¿‡ï¼ˆå¯èƒ½æ˜¯æ–°å®‰è£…ï¼‰:', error.message);
        }
    }

    /**
     * ç”Ÿæˆæ–°çš„é…ç½®ID
     */
    generateConfigId() {
        return 'config_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * åˆ¤æ–­æ˜¯å¦ä¸ºé…ç½®é”®
     */
    isConfigKey(key) {
        return key === this.defaultConfigKey || key.startsWith('config_');
    }

    /**
     * è·å–æ‰€æœ‰é…ç½®
     */
    async getAllConfigs() {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const allItems = await promisifyRequest(store.getAll(), 'è·å–æ‰€æœ‰APIé…ç½®');
            
            // ç­›é€‰å‡ºé…ç½®é¡¹å¹¶æ·»åŠ configIdå­—æ®µ
            const configs = allItems
                .filter(item => this.isConfigKey(item.id))
                .map(item => ({
                    ...item,
                    configId: item.id,
                    configName: item.configName || (item.id === this.defaultConfigKey ? 'é»˜è®¤é…ç½®' : 'æœªå‘½åé…ç½®')
                }))
                .sort((a, b) => {
                    // é»˜è®¤é…ç½®æ’åœ¨æœ€å‰
                    if (a.id === this.defaultConfigKey) return -1;
                    if (b.id === this.defaultConfigKey) return 1;
                    return (b.updatedAt || 0) - (a.updatedAt || 0);
                });
            
            return configs;
        }, 'è·å–æ‰€æœ‰APIé…ç½®');
    }

    /**
     * æ ¹æ®IDè·å–é…ç½®
     */
    async getConfigById(id) {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const config = await promisifyRequest(store.get(id), 'è·å–APIé…ç½®');
            if (config && this.isConfigKey(id)) {
                return {
                    ...config,
                    configId: id,
                    configName: config.configName || (id === this.defaultConfigKey ? 'é»˜è®¤é…ç½®' : 'æœªå‘½åé…ç½®')
                };
            }
            return null;
        }, 'è·å–æŒ‡å®šAPIé…ç½®');
    }

    /**
     * ä¿å­˜é…ç½®
     */
    async saveConfig(config) {
        return await ensureDBReady(async () => {
            const now = Date.now();
            let configId = config.configId || config.id;
            
            if (!configId) {
                configId = this.generateConfigId();
            }
            
            // ä½¿ç”¨ä¼ å…¥çš„apiKeysç»“æ„ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ„å»ºé»˜è®¤ç»“æ„
            let apiKeys;
            if (config.apiKeys && Array.isArray(config.apiKeys)) {
                // ä½¿ç”¨å‰ç«¯ä¼ å…¥çš„å®Œæ•´apiKeysç»“æ„
                apiKeys = config.apiKeys;
                console.log('[APIConfigManager] ä½¿ç”¨å‰ç«¯ä¼ å…¥çš„apiKeysç»“æ„ï¼Œå¯ç”¨çš„key:', 
                    apiKeys.filter(k => k.enabled).map(k => `index${k.index}:${k.key.substring(0, 10)}...`));
            } else {
                // å…¼å®¹æ—§çš„additionalKeysæ ¼å¼
                apiKeys = [
                    {
                        key: config.key || '',
                        name: 'ä¸»Key',
                        enabled: true,
                        index: 0
                    },
                    ...(config.additionalKeys || []).map((keyItem, index) => {
                        // å¤„ç†ä¸åŒçš„æ•°æ®æ ¼å¼ï¼šå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
                        const keyValue = typeof keyItem === 'string' ? keyItem : (keyItem.key || keyItem);
                        const keyName = typeof keyItem === 'object' && keyItem.name ? keyItem.name : `Key ${index + 1}`;
                        const keyEnabled = typeof keyItem === 'object' && keyItem.enabled ? keyItem.enabled : false;
                        
                        return {
                            key: keyValue,
                            name: keyName,
                            enabled: keyEnabled,
                            index: index + 1
                        };
                    })
                ];
                console.log('[APIConfigManager] ä½¿ç”¨å…¼å®¹æ€§apiKeysç»“æ„');
            }

            // APIé…ç½®æ•°æ® - ä»…ä¿å­˜è¿æ¥ç›¸å…³ä¿¡æ¯
            const configData = {
                id: configId,
                url: config.url || '',
                key: config.key || '',
                contextMessageCount: config.contextMessageCount || 10,
                timeout: config.timeout || 60,
                apiKeys: apiKeys,
                configName: config.configName || config.name || 'æœªå‘½åé…ç½®',
                isDefault: config.isDefault || false,
                createdAt: config.createdAt || now,
                updatedAt: now
            };

            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(configData), 'ä¿å­˜APIé…ç½®');
            
            // æ¸…é™¤è¯¥é…ç½®çš„æ¨¡å‹ç¼“å­˜
            this.availableModels.delete(configId);
            
            console.log('APIé…ç½®ä¿å­˜å®Œæˆ:', configData.configName);
            return configData;
        }, 'ä¿å­˜APIé…ç½®');
    }

    /**
     * åˆ é™¤é…ç½®
     */
    async deleteConfig(id) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(id);
            if (!config) {
                throw new Error('é…ç½®ä¸å­˜åœ¨');
            }
            
            if (id === this.defaultConfigKey) {
                throw new Error('ä¸èƒ½åˆ é™¤é»˜è®¤é…ç½®');
            }

            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.delete(id), 'åˆ é™¤APIé…ç½®');
            
            // æ¸…é™¤æ¨¡å‹ç¼“å­˜
            this.availableModels.delete(id);
            
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ¿€æ´»é…ç½®ï¼Œåˆ‡æ¢åˆ°é»˜è®¤é…ç½®
            if (this.activeConfigId === id) {
                const configs = await this.getAllConfigs();
                const defaultConfig = configs.find(c => c.id === this.defaultConfigKey);
                if (defaultConfig) {
                    await this.switchToConfig(this.defaultConfigKey);
                }
            }
            
            console.log('APIé…ç½®åˆ é™¤å®Œæˆ:', config.configName || config.name);
            return true;
        }, 'åˆ é™¤APIé…ç½®');
    }

    /**
     * åˆ‡æ¢åˆ°æŒ‡å®šé…ç½®
     */
    async switchToConfig(configId) {
        const config = await this.getConfigById(configId);
        if (!config) {
            throw new Error('é…ç½®ä¸å­˜åœ¨');
        }

        this.activeConfigId = configId;
        await this.saveActiveConfigId(configId);
        
        // æ›´æ–°å…¨å±€apiSettings - åªåŒ…å«APIè¿æ¥ä¿¡æ¯
        Object.assign(window.apiSettings, {
            url: config.url || '',
            key: this.getEnabledKey(config),
            contextMessageCount: config.contextMessageCount || 10,
            timeout: config.timeout || 60
        });

        // æ¸…ç©ºå…¨å±€æ¨¡å‹é…ç½®ï¼Œåˆ‡æ¢APIé…ç½®æ—¶é‡ç½®æ¨¡å‹é€‰æ‹©
        await this.clearGlobalModelConfig();

        // è§¦å‘é…ç½®åˆ‡æ¢äº‹ä»¶
        window.dispatchEvent(new CustomEvent('apiConfigChanged', {
            detail: { configId, config }
        }));
        
        console.log('å·²åˆ‡æ¢åˆ°é…ç½®:', config.configName || config.name);
        return config;
    }

    /**
     * è·å–å½“å‰æ¿€æ´»çš„é…ç½®
     */
    async getActiveConfig() {
        if (this.activeConfigId) {
            return await this.getConfigById(this.activeConfigId);
        }
        
        // å¦‚æœæ²¡æœ‰æ¿€æ´»é…ç½®ï¼Œå°è¯•è·å–é»˜è®¤é…ç½®
        const configs = await this.getAllConfigs();
        const defaultConfig = configs.find(c => c.id === this.defaultConfigKey) || configs[0];
        
        if (defaultConfig) {
            await this.switchToConfig(defaultConfig.id);
            return defaultConfig;
        }
        
        return null;
    }

    /**
     * æµ‹è¯•é…ç½®è¿æ¥å¹¶ç¼“å­˜å¯ç”¨æ¨¡å‹
     */
    async testConfigConnection(configId) {
        const config = await this.getConfigById(configId);
        if (!config || !config.url || !config.key) {
            throw new Error('é…ç½®ä¸å®Œæ•´');
        }

        try {
            const data = await window.apiService.testConnection(config.url, config.key);
            const models = data.data ? data.data.map(m => m.id).sort() : [];
            
            // ç¼“å­˜æ¨¡å‹åˆ—è¡¨
            this.availableModels.set(configId, models);
            
            return { success: true, models, config };
        } catch (error) {
            throw new Error(`è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * è·å–é…ç½®çš„å¯ç”¨æ¨¡å‹åˆ—è¡¨
     */
    async getConfigModels(configId) {
        // å…ˆæ£€æŸ¥ç¼“å­˜
        if (this.availableModels.has(configId)) {
            return this.availableModels.get(configId);
        }

        // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œæµ‹è¯•è¿æ¥è·å–
        try {
            const result = await this.testConfigConnection(configId);
            return result.models;
        } catch (error) {
            console.warn('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error.message);
            return [];
        }
    }

    /**
     * è·å–é…ç½®ä¸­å¯ç”¨çš„key
     */
    getEnabledKey(config) {
        if (!config.apiKeys || config.apiKeys.length === 0) {
            return config.key || '';
        }
        
        const enabledKey = config.apiKeys.find(k => k.enabled);
        return enabledKey ? enabledKey.key : (config.key || '');
    }

    /**
     * è®¾ç½®é…ç½®ä¸­çš„keyå¯ç”¨çŠ¶æ€
     */
    async setKeyEnabled(configId, keyIndex, enabled) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(configId);
            if (!config || !config.apiKeys || keyIndex >= config.apiKeys.length) {
                throw new Error('é…ç½®æˆ–keyä¸å­˜åœ¨');
            }

            if (enabled) {
                // å¯ç”¨æŒ‡å®škeyï¼Œç¦ç”¨å…¶ä»–key
                config.apiKeys.forEach((key, index) => {
                    key.enabled = (index === keyIndex);
                });
            } else {
                // ç¦ç”¨æŒ‡å®škey
                config.apiKeys[keyIndex].enabled = false;
                // å¦‚æœç¦ç”¨çš„æ˜¯å½“å‰å¯ç”¨çš„keyï¼Œå¯ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„key
                const hasEnabledKey = config.apiKeys.some(k => k.enabled);
                if (!hasEnabledKey && config.apiKeys.length > 0) {
                    config.apiKeys[0].enabled = true;
                }
            }

            config.updatedAt = Date.now();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(config), 'æ›´æ–°keyå¯ç”¨çŠ¶æ€');

            // å¦‚æœæ˜¯å½“å‰æ¿€æ´»çš„é…ç½®ï¼Œæ›´æ–°å…¨å±€apiSettings
            if (this.activeConfigId === configId) {
                const enabledKey = this.getEnabledKey(config);
                window.apiSettings.key = enabledKey;
            }

            return config;
        }, 'è®¾ç½®keyå¯ç”¨çŠ¶æ€');
    }

    /**
     * æ·»åŠ æ–°çš„keyåˆ°é…ç½®
     */
    async addKeyToConfig(configId, keyValue, keyName) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(configId);
            if (!config) {
                throw new Error('é…ç½®ä¸å­˜åœ¨');
            }

            if (!config.apiKeys) {
                config.apiKeys = [];
            }

            const newIndex = config.apiKeys.length;
            config.apiKeys.push({
                key: keyValue,
                name: keyName || `Key ${newIndex + 1}`,
                enabled: false,
                index: newIndex
            });

            config.updatedAt = Date.now();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(config), 'æ·»åŠ æ–°key');

            return config;
        }, 'æ·»åŠ æ–°key');
    }

    /**
     * ä»é…ç½®ä¸­åˆ é™¤key
     */
    async removeKeyFromConfig(configId, keyIndex) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(configId);
            if (!config || !config.apiKeys || keyIndex >= config.apiKeys.length) {
                throw new Error('é…ç½®æˆ–keyä¸å­˜åœ¨');
            }

            // ä¸èƒ½åˆ é™¤æœ€åä¸€ä¸ªkey
            if (config.apiKeys.length <= 1) {
                throw new Error('è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªkey');
            }

            const removedKey = config.apiKeys[keyIndex];
            config.apiKeys.splice(keyIndex, 1);

            // é‡æ–°è®¾ç½®index
            config.apiKeys.forEach((key, index) => {
                key.index = index;
            });

            // å¦‚æœåˆ é™¤çš„æ˜¯å¯ç”¨çš„keyï¼Œå¯ç”¨ç¬¬ä¸€ä¸ªkey
            if (removedKey.enabled && config.apiKeys.length > 0) {
                config.apiKeys[0].enabled = true;
            }

            config.updatedAt = Date.now();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(config), 'åˆ é™¤key');

            // å¦‚æœæ˜¯å½“å‰æ¿€æ´»çš„é…ç½®ï¼Œæ›´æ–°å…¨å±€apiSettings
            if (this.activeConfigId === configId) {
                const enabledKey = this.getEnabledKey(config);
                window.apiSettings.key = enabledKey;
            }

            return config;
        }, 'åˆ é™¤key');
    }

    /**
     * ä¿å­˜å½“å‰æ¿€æ´»é…ç½®ID
     */
    async saveActiveConfigId(configId) {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put({ 
                id: 'activeConfigId', 
                value: configId,
                updatedAt: Date.now()
            }), 'ä¿å­˜å½“å‰é…ç½®ID');
        }, 'ä¿å­˜å½“å‰é…ç½®ID');
    }

    /**
     * åŠ è½½å½“å‰æ¿€æ´»é…ç½®ID
     */
    async loadActiveConfig() {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const result = await promisifyRequest(store.get('activeConfigId'), 'åŠ è½½å½“å‰é…ç½®ID');
            
            if (result && result.value) {
                this.activeConfigId = result.value;
            }
        }, 'åŠ è½½å½“å‰é…ç½®ID');
    }

    /**
     * å¤åˆ¶é…ç½®
     */
    async duplicateConfig(id) {
        const originalConfig = await this.getConfigById(id);
        if (!originalConfig) {
            throw new Error('æºé…ç½®ä¸å­˜åœ¨');
        }

        const duplicatedConfig = {
            ...originalConfig,
            configId: undefined, // å°†ç”Ÿæˆæ–°ID
            configName: (originalConfig.configName || originalConfig.name || 'æœªå‘½åé…ç½®') + ' - å‰¯æœ¬',
            isDefault: false,
            createdAt: undefined,
            updatedAt: undefined
        };

        return await this.saveConfig(duplicatedConfig);
    }

    // ========== å…¨å±€æ¨¡å‹é…ç½®ç®¡ç† ==========

    /**
     * ä¿å­˜å…¨å±€æ¨¡å‹é…ç½®
     */
    async saveGlobalModelConfig(modelConfig) {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);

            const globalModelData = {
                id: this.globalModelConfigKey,
                apiConfigId: modelConfig.apiConfigId || '',
                primaryModel: modelConfig.primaryModel || '',
                secondaryModel: modelConfig.secondaryModel || '',
                updatedAt: Date.now()
            };

            await promisifyRequest(store.put(globalModelData), 'ä¿å­˜å…¨å±€æ¨¡å‹é…ç½®');

            // æ›´æ–°å…¨å±€å˜é‡
            if (!window.modelSettings) {
                window.modelSettings = {};
            }
            window.modelSettings.apiConfigId = globalModelData.apiConfigId;
            window.modelSettings.primaryModel = globalModelData.primaryModel;
            window.modelSettings.secondaryModel = globalModelData.secondaryModel;

            console.log('å…¨å±€æ¨¡å‹é…ç½®ä¿å­˜å®Œæˆ:', globalModelData);
            return globalModelData;
        }, 'ä¿å­˜å…¨å±€æ¨¡å‹é…ç½®');
    }

    /**
     * è·å–å…¨å±€æ¨¡å‹é…ç½®
     */
    async getGlobalModelConfig() {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const modelConfig = await promisifyRequest(store.get(this.globalModelConfigKey), 'è·å–å…¨å±€æ¨¡å‹é…ç½®');

            if (modelConfig) {
                return {
                    apiConfigId: modelConfig.apiConfigId || '',
                    primaryModel: modelConfig.primaryModel || '',
                    secondaryModel: modelConfig.secondaryModel || ''
                };
            }

            // è¿”å›é»˜è®¤ç©ºé…ç½®
            return {
                apiConfigId: '',
                primaryModel: '',
                secondaryModel: ''
            };
        }, 'è·å–å…¨å±€æ¨¡å‹é…ç½®');
    }

    /**
     * æ¸…ç©ºå…¨å±€æ¨¡å‹é…ç½®ï¼ˆåˆ‡æ¢APIé…ç½®æ—¶è°ƒç”¨ï¼‰
     */
    async clearGlobalModelConfig() {
        await this.saveGlobalModelConfig({
            apiConfigId: '',
            primaryModel: '',
            secondaryModel: ''
        });
        console.log('å…¨å±€æ¨¡å‹é…ç½®å·²æ¸…ç©º');
    }

    /**
     * è·å–å½“å‰ä½¿ç”¨çš„å®Œæ•´APIè¿æ¥ä¿¡æ¯ï¼ˆç»“åˆAPIé…ç½®å’Œæ¨¡å‹é…ç½®ï¼‰
     */
    async getCurrentApiConnection() {
        const modelConfig = await this.getGlobalModelConfig();

        if (!modelConfig.apiConfigId) {
            throw new Error('æœªè®¾ç½®å…¨å±€æ¨¡å‹é…ç½®');
        }

        const apiConfig = await this.getConfigById(modelConfig.apiConfigId);
        if (!apiConfig) {
            throw new Error('APIé…ç½®ä¸å­˜åœ¨');
        }

        return {
            // APIè¿æ¥ä¿¡æ¯
            url: apiConfig.url,
            key: this.getEnabledKey(apiConfig),
            timeout: apiConfig.timeout || 60,
            contextMessageCount: apiConfig.contextMessageCount || 10,
            // æ¨¡å‹ä¿¡æ¯
            primaryModel: modelConfig.primaryModel,
            secondaryModel: modelConfig.secondaryModel,
            // é…ç½®ä¿¡æ¯
            apiConfigId: modelConfig.apiConfigId,
            configName: apiConfig.configName
        };
    }

    /**
     * åˆå§‹åŒ–å…¨å±€æ¨¡å‹é…ç½®ï¼ˆåº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨ï¼‰
     */
    async initGlobalModelConfig() {
        try {
            const modelConfig = await this.getGlobalModelConfig();

            // åˆå§‹åŒ–å…¨å±€modelSettingså˜é‡
            if (!window.modelSettings) {
                window.modelSettings = {};
            }

            window.modelSettings.apiConfigId = modelConfig.apiConfigId;
            window.modelSettings.primaryModel = modelConfig.primaryModel;
            window.modelSettings.secondaryModel = modelConfig.secondaryModel;

            console.log('å…¨å±€æ¨¡å‹é…ç½®åˆå§‹åŒ–å®Œæˆ:', modelConfig);
        } catch (error) {
            console.warn('å…¨å±€æ¨¡å‹é…ç½®åˆå§‹åŒ–å¤±è´¥:', error);
            // åˆå§‹åŒ–ä¸ºç©ºé…ç½®
            if (!window.modelSettings) {
                window.modelSettings = {
                    apiConfigId: '',
                    primaryModel: '',
                    secondaryModel: ''
                };
            }
        }
    }

    /**
     * è®¾ç½®é»˜è®¤é…ç½®
     */
    async setDefaultConfig(id) {
        return await ensureDBReady(async () => {
            // å…ˆå–æ¶ˆæ‰€æœ‰é…ç½®çš„é»˜è®¤çŠ¶æ€
            const configs = await this.getAllConfigs();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            
            for (const config of configs) {
                if (config.isDefault) {
                    config.isDefault = false;
                    await promisifyRequest(store.put(config), 'æ›´æ–°é…ç½®é»˜è®¤çŠ¶æ€');
                }
            }
            
            // è®¾ç½®æ–°çš„é»˜è®¤é…ç½®
            const targetConfig = configs.find(c => c.id === id);
            if (targetConfig) {
                targetConfig.isDefault = true;
                targetConfig.updatedAt = Date.now();
                await promisifyRequest(store.put(targetConfig), 'è®¾ç½®é»˜è®¤é…ç½®');
            }
            
            console.log('é»˜è®¤é…ç½®å·²æ›´æ–°');
            return targetConfig;
        }, 'è®¾ç½®é»˜è®¤é…ç½®');
    }

    // ========== API Key ä½¿ç”¨ç»Ÿè®¡åŠŸèƒ½ ==========

    /**
     * ä»localStorageåŠ è½½ç»Ÿè®¡æ•°æ®
     */
    loadStats() {
        try {
            // console.log(`[APIç»Ÿè®¡è°ƒè¯•] ä»localStorageåŠ è½½ç»Ÿè®¡æ•°æ®ï¼ŒstorageKey=${this.statsStorageKey}`);
            const stored = localStorage.getItem(this.statsStorageKey);
            // console.log(`[APIç»Ÿè®¡è°ƒè¯•] localStorageä¸­çš„åŸå§‹æ•°æ®:`, stored);
            if (stored) {
                const parsed = JSON.parse(stored);
                // console.log(`[APIç»Ÿè®¡è°ƒè¯•] è§£æåçš„ç»Ÿè®¡æ•°æ®:`, JSON.stringify(parsed, null, 2));
                return parsed;
            } else {
                console.log(`[APIç»Ÿè®¡è°ƒè¯•] localStorageä¸­æ²¡æœ‰æ‰¾åˆ°ç»Ÿè®¡æ•°æ®`);
            }
        } catch (error) {
            console.warn('åŠ è½½API Keyç»Ÿè®¡å¤±è´¥:', error);
        }
        console.log(`[APIç»Ÿè®¡è°ƒè¯•] è¿”å›é»˜è®¤ç»Ÿè®¡æ•°æ®`);
        return this.getDefaultStats();
    }

    /**
     * è·å–é»˜è®¤çš„ç»Ÿè®¡ç»“æ„
     */
    getDefaultStats() {
        return {
            version: 1,
            lastCleanup: Date.now(),
            keyStats: {} // keyId -> { calls: [], totalCalls: number, successCalls: number }
        };
    }

    /**
     * ä¿å­˜ç»Ÿè®¡æ•°æ®åˆ°localStorage
     */
    saveStats() {
        try {
            // console.log(`[APIç»Ÿè®¡è°ƒè¯•] ä¿å­˜ç»Ÿè®¡æ•°æ®åˆ°localStorage:`, JSON.stringify(this.stats, null, 2));
            localStorage.setItem(this.statsStorageKey, JSON.stringify(this.stats));
            console.log(`[APIç»Ÿè®¡è°ƒè¯•] ä¿å­˜æˆåŠŸ`);
        } catch (error) {
            console.error('ä¿å­˜API Keyç»Ÿè®¡å¤±è´¥:', error);
        }
    }

    /**
     * è®°å½•ä¸€æ¬¡APIè°ƒç”¨
     */
    recordCall(configId, keyIndex, keyValue, success = true) {
        // console.log(`[APIç»Ÿè®¡è°ƒè¯•] è®°å½•APIè°ƒç”¨: configId=${configId}, keyIndex=${keyIndex}, success=${success}`);
        console.log(`[APIç»Ÿè®¡è°ƒè¯•] API Keyå‰ç¼€: ${keyValue.substring(0, 10)}...`);
        
        const keyId = this.generateKeyId(configId, keyIndex, keyValue);
        const now = Date.now();
                
        if (!this.stats.keyStats[keyId]) {
            this.stats.keyStats[keyId] = {
                configId,
                keyIndex,
                keyValueHash: this.hashKey(keyValue),
                calls: [],
                totalCalls: 0,
                successCalls: 0
            };
        }
        
        const keyStat = this.stats.keyStats[keyId];
        
        keyStat.calls.push({
            timestamp: now,
            success
        });
        
        keyStat.totalCalls++;
        if (success) {
            keyStat.successCalls++;
        }
                
        this.saveStats();
        
        window.dispatchEvent(new CustomEvent('apiKeyStatsUpdated', {
            detail: { keyId, stats: keyStat }
        }));
    }

    /**
     * ç”Ÿæˆkeyçš„å”¯ä¸€ID
     */
    generateKeyId(configId, keyIndex, keyValue) {
        return `${configId}_${keyIndex}_${this.hashKey(keyValue)}`;
    }

    /**
     * ç”Ÿæˆkeyçš„hashï¼ˆç”¨äºå®‰å…¨å­˜å‚¨ï¼‰
     */
    hashKey(keyValue) {
        let hash = 0;
        for (let i = 0; i < keyValue.length; i++) {
            const char = keyValue.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
    }

    /**
     * è·å–æŒ‡å®škeyåœ¨è¿‘24å°æ—¶å†…çš„è°ƒç”¨ç»Ÿè®¡
     */
    getKeyStats(configId, keyIndex, keyValue) {
        
        const keyId = this.generateKeyId(configId, keyIndex, keyValue);
        
        const keyStat = this.stats.keyStats[keyId];
        
        if (!keyStat) {
            console.log(`[APIç»Ÿè®¡è°ƒè¯•] æœªæ‰¾åˆ°ç»Ÿè®¡è®°å½•ï¼Œè¿”å›é»˜è®¤å€¼`);
            return {
                totalCalls: 0,
                recentCalls: 0,
                successRate: 0
            };
        }
        
        const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
        const recentCalls = keyStat.calls.filter(call => call.timestamp >= twentyFourHoursAgo);
        const recentSuccessCalls = recentCalls.filter(call => call.success);
        
        const result = {
            totalCalls: keyStat.totalCalls,
            recentCalls: recentCalls.length,
            recentSuccessCalls: recentSuccessCalls.length,
            successRate: recentCalls.length > 0 ? (recentSuccessCalls.length / recentCalls.length * 100).toFixed(1) : 0,
            lastUsed: recentCalls.length > 0 ? recentCalls[recentCalls.length - 1].timestamp : null
        };
        
        // console.log(`[APIç»Ÿè®¡è°ƒè¯•] è¿”å›çš„ç»Ÿè®¡ç»“æœ:`, result);
        return result;
    }

    /**
     * æ©ç æ˜¾ç¤ºKeyï¼ˆåªæ˜¾ç¤ºå‰3ä½å’Œå3ä½ï¼‰
     */
    maskKey(keyValue) {
        // ç¡®ä¿keyValueæ˜¯å­—ç¬¦ä¸²
        if (typeof keyValue === 'object') {
            keyValue = keyValue.key || keyValue.toString();
        }
        
        if (typeof keyValue !== 'string') {
            keyValue = String(keyValue);
        }
        
        if (!keyValue || keyValue.length <= 8) {
            return '*'.repeat(keyValue.length || 8);
        }
        return keyValue.substring(0, 3) + '*'.repeat(keyValue.length - 6) + keyValue.substring(keyValue.length - 3);
    }

    /**
     * æ¸…ç†è¶…è¿‡24å°æ—¶çš„è®°å½•
     */
    cleanup() {
        const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
        let cleanedCount = 0;
        
        for (const [keyId, keyStat] of Object.entries(this.stats.keyStats)) {
            const originalLength = keyStat.calls.length;
            keyStat.calls = keyStat.calls.filter(call => call.timestamp >= twentyFourHoursAgo);
            
            if (keyStat.calls.length < originalLength) {
                cleanedCount++;
                
                if (keyStat.calls.length === 0) {
                    keyStat.totalCalls = 0;
                    keyStat.successCalls = 0;
                } else {
                    keyStat.totalCalls = keyStat.calls.length;
                    keyStat.successCalls = keyStat.calls.filter(call => call.success).length;
                }
            }
        }
        
        if (cleanedCount > 0) {
            this.stats.lastCleanup = Date.now();
            this.saveStats();
            console.log(`API Keyç»Ÿè®¡æ¸…ç†å®Œæˆï¼Œæ¸…ç†äº† ${cleanedCount} ä¸ªkeyçš„è¿‡æœŸè®°å½•`);
        }
    }

    /**
     * å¯åŠ¨è‡ªåŠ¨æ¸…ç†ä»»åŠ¡
     */
    startAutoCleanup() {
        this.cleanupInterval = setInterval(() => {
            this.cleanup();
        }, 60 * 60 * 1000); // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡
        
        this.cleanup(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ¸…ç†
    }

    /**
     * åœæ­¢è‡ªåŠ¨æ¸…ç†ä»»åŠ¡
     */
    stopAutoCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
    }
}

// å…¨å±€å®ä¾‹
window.apiConfigManager = new APIConfigManager();

// å¯¼å‡º
if (typeof module !== 'undefined' && module.exports) {
    module.exports = APIConfigManager;
}
</script>
    <script>
/**
 * æ¨¡å‹èƒ½åŠ›æ£€æµ‹å™¨
 * ç”¨äºæ£€æµ‹AIæ¨¡å‹æ˜¯å¦æ”¯æŒå›¾åƒè§†è§‰èƒ½åŠ›
 */
class ModelCapabilityDetector {
    constructor() {
        // æ”¯æŒè§†è§‰èƒ½åŠ›çš„æ¨¡å‹åˆ—è¡¨ - ä½¿ç”¨å…³é”®è¯æ¨¡ç³ŠåŒ¹é…
        this.visionSupportedModels = [
            // OpenAI
            'chatgpt-4o-latest',
            'gpt-4-turbo',
            'gpt-4-vision',
            'gpt-4.1',
            'gpt-4.5-preview',
            'gpt-4o',
            'gpt-5',
            'o1',
            'o3',
            'o4-mini',
            // Claude
            'claude-3',
            'claude-opus-4',
            'claude-sonnet-4',
            // Cohere
            'c4ai-aya-vision',
            'command-a-vision',
            // Google AI Studio
            'gemini-1.5',
            'gemini-2.0',
            'gemini-2.5',
            'gemini-exp-1206',
            'learnlm',
            // MistralAI
            'mistral-small-2503',
            'mistral-small-2506',
            'mistral-small-latest',
            'mistral-medium-latest',
            'mistral-medium-2505',
            'mistral-medium-2508',
            'pixtral',
            // xAI (Grok)
            'grok-4',
            'grok-2-vision',
            'grok-vision',
            // Moonshot
            'moonshot-v1-8k-vision-preview',
            'moonshot-v1-32k-vision-preview',
            'moonshot-v1-128k-vision-preview',
        ];
        
        console.log(`[ModelCapabilityDetector] åˆå§‹åŒ–å®Œæˆï¼Œæ”¯æŒ ${this.visionSupportedModels.length} ç§è§†è§‰æ¨¡å‹`);
    }

    /**
     * æ£€æµ‹æ¨¡å‹æ˜¯å¦æ”¯æŒå›¾åƒè§†è§‰èƒ½åŠ›ï¼Œè¿”å›åŒ¹é…çš„æ¨¡å‹æˆ–null
     * ä½¿ç”¨æ¨¡ç³ŠåŒ¹é…ï¼šæå–å…³é”®è¯ï¼ˆé™¤æ ‡ç‚¹ï¼‰ï¼Œæ£€æŸ¥æ˜¯å¦å…¨éƒ¨åŒ¹é…
     * @param {string} modelName - è¦æ£€æŸ¥çš„æ¨¡å‹åç§°
     * @returns {string|null} åŒ¹é…çš„æ”¯æŒæ¨¡å‹åç§°ï¼Œå¦‚æœä¸æ”¯æŒåˆ™è¿”å›null
     */
    _findMatchedVisionModel(modelName) {
        if (!modelName || typeof modelName !== 'string') {
            return null;
        }

        // è§„èŒƒåŒ–è¾“å…¥çš„æ¨¡å‹åç§°ï¼šè½¬å°å†™ï¼Œæå–å…³é”®è¯
        const inputKeywords = this.extractKeywords(modelName.toLowerCase());
        
        // éå†æ”¯æŒçš„æ¨¡å‹åˆ—è¡¨ï¼Œè¿›è¡Œæ¨¡ç³ŠåŒ¹é…
        for (const supportedModel of this.visionSupportedModels) {
            const supportedKeywords = this.extractKeywords(supportedModel.toLowerCase());
            
            // æ£€æŸ¥æ”¯æŒæ¨¡å‹çš„æ‰€æœ‰å…³é”®è¯æ˜¯å¦éƒ½åœ¨è¾“å…¥æ¨¡å‹ä¸­å‡ºç°
            const isMatch = supportedKeywords.every(keyword => 
                inputKeywords.includes(keyword)
            );
            
            if (isMatch) {
                console.log(`[ModelCapabilityDetector] æ¨¡å‹ "${modelName}" åŒ¹é…åˆ°æ”¯æŒè§†è§‰çš„æ¨¡å‹ "${supportedModel}"`);
                return supportedModel;
            }
        }
        
        console.log(`[ModelCapabilityDetector] æ¨¡å‹ "${modelName}" ä¸æ”¯æŒè§†è§‰èƒ½åŠ›`);
        return null;
    }

    /**
     * æ£€æµ‹æ¨¡å‹æ˜¯å¦æ”¯æŒå›¾åƒè§†è§‰èƒ½åŠ›
     * @param {string} modelName - è¦æ£€æŸ¥çš„æ¨¡å‹åç§°
     * @returns {boolean} æ˜¯å¦æ”¯æŒè§†è§‰èƒ½åŠ›
     */
    supportsVision(modelName) {
        return this._findMatchedVisionModel(modelName) !== null;
    }

    /**
     * æå–å…³é”®è¯ï¼šç§»é™¤æ ‡ç‚¹ç¬¦å·ï¼ŒæŒ‰åˆ†éš”ç¬¦æ‹†åˆ†
     * @param {string} modelName - æ¨¡å‹åç§°
     * @returns {string[]} å…³é”®è¯æ•°ç»„
     */
    extractKeywords(modelName) {
        // ç§»é™¤å¸¸è§æ ‡ç‚¹ç¬¦å·ï¼Œä¿ç•™å­—æ¯æ•°å­—å’Œè¿å­—ç¬¦
        const cleaned = modelName.replace(/[^\w\-\.]/g, ' ');
        
        // æŒ‰ç©ºæ ¼ã€è¿å­—ç¬¦ã€ç‚¹å·åˆ†å‰²ï¼Œè¿‡æ»¤ç©ºå­—ç¬¦ä¸²
        const keywords = cleaned
            .split(/[\s\-\.]+/)
            .filter(word => word.length > 0)
            .map(word => word.toLowerCase());
            
        return keywords;
    }

    /**
     * è·å–æ‰€æœ‰æ”¯æŒè§†è§‰çš„æ¨¡å‹åˆ—è¡¨
     * @returns {string[]} æ”¯æŒè§†è§‰çš„æ¨¡å‹åˆ—è¡¨
     */
    getSupportedVisionModels() {
        return [...this.visionSupportedModels];
    }

    /**
     * æ£€æŸ¥æ¨¡å‹åç§°å¹¶è¿”å›è¯¦ç»†ä¿¡æ¯
     * @param {string} modelName - æ¨¡å‹åç§°
     * @returns {Object} æ£€æŸ¥ç»“æœè¯¦æƒ…
     */
    checkModelCapability(modelName) {
        const matchedModel = this._findMatchedVisionModel(modelName);
        const supportsVision = matchedModel !== null;
        const inputKeywords = this.extractKeywords(modelName?.toLowerCase() || '');
        
        return {
            modelName: modelName || '',
            supportsVision,
            matchedModel,
            inputKeywords,
            supportedModelsCount: this.visionSupportedModels.length
        };
    }
}

// å¯¼å‡ºç±»
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ModelCapabilityDetector;
} else {
    // æµè§ˆå™¨ç¯å¢ƒï¼ŒæŒ‚è½½åˆ°windowå¯¹è±¡
    window.ModelCapabilityDetector = ModelCapabilityDetector;
}
</script>
    <script>
/**
 * å­—ä½“æŒ‰éœ€åŠ è½½ç®¡ç†å™¨
 * æ ¹æ®ç”¨æˆ·è‡ªå®šä¹‰æ°”æ³¡é…ç½®ä¸­çš„å­—ä½“è®¾ç½®ï¼ŒåŠ¨æ€åŠ è½½å¯¹åº”çš„å­—ä½“æ–‡ä»¶
 */

class FontLoader {
    constructor() {
        // å­—ä½“åç§°åˆ°CDN URLçš„æ˜ å°„
        this.fontUrlMapping = {
            'Inter': null, // é»˜è®¤å­—ä½“ï¼Œæ— éœ€åŠ è½½é¢å¤–CSS
            'Source Han Serif CN VF': 'https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css',
            'LXGW WenKai': 'https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css',
            'DouyinSansBold': 'https://chinese-fonts-cdn.deno.dev/packages/dymh/dist/DouyinSansBold/result.css',
            'æ±‡æ–‡æ˜æœä½“': 'https://chinese-fonts-cdn.deno.dev/packages/hwmct/dist/æ±‡æ–‡æ˜æœä½“/result.css',
            'ToneOZ-PinyinW-Kai-Simplified': 'https://chinese-fonts-cdn.deno.dev/packages/ToneOZ-Pinyin-Kai/dist/ToneOZ-PinyinW-Kai-Simplified/result.css',
            'ChillRoundFBold': 'https://chinese-fonts-cdn.deno.dev/packages/hcqyt/dist/ChillRoundFBold/result.css',
            'å³„å±±ç¢‘ç¯†ä½“': 'https://chinese-fonts-cdn.deno.dev/packages/ysbzt/dist/å³„å±±ç¢‘ç¯†ä½“/result.css',
            'YuFanXinYu-Medium': 'https://chinese-fonts-cdn.deno.dev/packages/yfxy/dist/YuFanXinYu-Medium/result.css'
        };
        
        // è®°å½•å·²åŠ è½½çš„å­—ä½“ï¼Œé¿å…é‡å¤åŠ è½½
        this.loadedFonts = new Set();
        
        // è®°å½•åŠ è½½ä¸­çš„å­—ä½“ï¼Œé¿å…å¹¶å‘åŠ è½½åŒä¸€å­—ä½“
        this.loadingFonts = new Map();
    }

    /**
     * æ ¹æ®å­—ä½“åç§°è·å–å¯¹åº”çš„CDN URL
     * @param {string} fontFamily - å­—ä½“åç§°
     * @returns {string|null} CDN URLæˆ–nullï¼ˆå¯¹äºé»˜è®¤å­—ä½“ï¼‰
     */
    getFontUrl(fontFamily) {
        return this.fontUrlMapping[fontFamily] || null;
    }

    /**
     * åŠ¨æ€åŠ è½½å­—ä½“CSSæ–‡ä»¶
     * @param {string} fontFamily - å­—ä½“åç§°
     * @returns {Promise<boolean>} æ˜¯å¦åŠ è½½æˆåŠŸ
     */
    async loadFont(fontFamily) {
        // å¦‚æœæ˜¯é»˜è®¤å­—ä½“æˆ–å·²ç»åŠ è½½è¿‡ï¼Œç›´æ¥è¿”å›æˆåŠŸ
        if (!fontFamily || fontFamily === 'Inter' || this.loadedFonts.has(fontFamily)) {
            return true;
        }

        // å¦‚æœæ­£åœ¨åŠ è½½ä¸­ï¼Œç­‰å¾…åŠ è½½å®Œæˆ
        if (this.loadingFonts.has(fontFamily)) {
            return await this.loadingFonts.get(fontFamily);
        }

        const fontUrl = this.getFontUrl(fontFamily);
        if (!fontUrl) {
            console.warn(`æœªæ‰¾åˆ°å­—ä½“ ${fontFamily} çš„CDNæ˜ å°„`);
            return false;
        }

        // åˆ›å»ºåŠ è½½Promise
        const loadingPromise = this._loadFontStylesheet(fontUrl, fontFamily);
        this.loadingFonts.set(fontFamily, loadingPromise);

        try {
            const success = await loadingPromise;
            if (success) {
                this.loadedFonts.add(fontFamily);
                console.log(`å­—ä½“åŠ è½½æˆåŠŸ: ${fontFamily}`);
            }
            return success;
        } finally {
            // æ¸…ç†åŠ è½½çŠ¶æ€
            this.loadingFonts.delete(fontFamily);
        }
    }

    /**
     * å®é™…åŠ è½½å­—ä½“æ ·å¼è¡¨çš„ç§æœ‰æ–¹æ³•
     * @param {string} url - CSSæ–‡ä»¶URL
     * @param {string} fontFamily - å­—ä½“åç§°ï¼ˆç”¨äºæ—¥å¿—ï¼‰
     * @returns {Promise<boolean>} æ˜¯å¦åŠ è½½æˆåŠŸ
     */
    _loadFontStylesheet(url, fontFamily) {
        return new Promise((resolve) => {
            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒURLçš„é“¾æ¥
            const existingLink = document.querySelector(`link[href="${url}"]`);
            if (existingLink) {
                console.log(`å­—ä½“æ ·å¼è¡¨å·²å­˜åœ¨: ${fontFamily}`);
                resolve(true);
                return;
            }

            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            link.crossOrigin = 'anonymous'; // æ·»åŠ è·¨åŸŸæ”¯æŒ

            link.onerror = () => {
                console.error(`å­—ä½“æ ·å¼è¡¨åŠ è½½å¤±è´¥: ${fontFamily} (${url})`);
                resolve(false);
            };

            // è®¾ç½®è¶…æ—¶ï¼Œé¿å…é•¿æ—¶é—´ç­‰å¾…
            const timeout = setTimeout(() => {
                console.warn(`å­—ä½“åŠ è½½è¶…æ—¶: ${fontFamily}`);
                resolve(false);
            }, 10000); // 10ç§’è¶…æ—¶

            link.onload = () => {
                clearTimeout(timeout);
                console.log(`å­—ä½“æ ·å¼è¡¨åŠ è½½å®Œæˆ: ${fontFamily}`);
                resolve(true);
            };

            // æ’å…¥åˆ°headä¸­
            document.head.appendChild(link);
        });
    }

    /**
     * ä»IndexedDBåŠ è½½ç”¨æˆ·é…ç½®å¹¶åŠ è½½å¯¹åº”å­—ä½“
     * @returns {Promise<void>}
     */
    async loadFontsFromUserConfig() {
        try {
            // ç¡®ä¿æ•°æ®åº“å·²å°±ç»ª
            if (!window.isIndexedDBReady || !window.db) {
                console.warn('æ•°æ®åº“æœªå°±ç»ªï¼Œè·³è¿‡å­—ä½“åŠ è½½');
                return;
            }

            // è¯»å–ç”¨æˆ·çš„æ°”æ³¡é…ç½®
            const [bubbleStyleSelf, bubbleStyleKare] = await Promise.all([
                this._loadConfigFromDB('bubbleStyleSelf'),
                this._loadConfigFromDB('bubbleStyle')
            ]);

            // æ”¶é›†éœ€è¦åŠ è½½çš„å­—ä½“
            const fontsToLoad = new Set();
            
            if (bubbleStyleSelf?.fontFamily) {
                fontsToLoad.add(bubbleStyleSelf.fontFamily);
            }
            
            if (bubbleStyleKare?.fontFamily) {
                fontsToLoad.add(bubbleStyleKare.fontFamily);
            }

            // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“
            if (fontsToLoad.size === 0) {
                console.log('æœªæ‰¾åˆ°å­—ä½“é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“');
                return;
            }

            console.log('å¼€å§‹åŠ è½½ç”¨æˆ·é…ç½®çš„å­—ä½“:', Array.from(fontsToLoad));

            // å¹¶è¡ŒåŠ è½½æ‰€æœ‰éœ€è¦çš„å­—ä½“
            const loadPromises = Array.from(fontsToLoad).map(font => this.loadFont(font));
            const results = await Promise.all(loadPromises);
            
            const successCount = results.filter(Boolean).length;
            console.log(`å­—ä½“åŠ è½½å®Œæˆ: ${successCount}/${fontsToLoad.size} æˆåŠŸ`);

        } catch (error) {
            console.error('ä»ç”¨æˆ·é…ç½®åŠ è½½å­—ä½“å¤±è´¥:', error);
        }
    }

    /**
     * ä»IndexedDBåŠ è½½é…ç½®çš„ç§æœ‰æ–¹æ³•
     * @param {string} configKey - é…ç½®é”®å
     * @returns {Promise<Object|null>} é…ç½®å¯¹è±¡æˆ–null
     */
    _loadConfigFromDB(configKey) {
        return new Promise((resolve) => {
            try {
                const transaction = window.db.transaction(['themeConfig'], 'readonly');
                const store = transaction.objectStore('themeConfig');
                const request = store.get(configKey);

                request.onsuccess = () => {
                    const result = request.result;
                    if (result && result.enabled !== false) {
                        resolve(result);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = () => {
                    console.warn(`è¯»å–é…ç½®å¤±è´¥: ${configKey}`, request.error);
                    resolve(null);
                };

                transaction.onerror = () => {
                    console.warn(`äº‹åŠ¡å¤±è´¥: ${configKey}`, transaction.error);
                    resolve(null);
                };
            } catch (error) {
                console.warn(`æ•°æ®åº“æ“ä½œå¼‚å¸¸: ${configKey}`, error);
                resolve(null);
            }
        });
    }

    /**
     * é¢„åŠ è½½æŒ‡å®šçš„å­—ä½“
     * @param {string|string[]} fonts - å­—ä½“åç§°æˆ–å­—ä½“æ•°ç»„
     * @returns {Promise<boolean[]>} åŠ è½½ç»“æœæ•°ç»„
     */
    async preloadFonts(fonts) {
        const fontArray = Array.isArray(fonts) ? fonts : [fonts];
        const loadPromises = fontArray.map(font => this.loadFont(font));
        return await Promise.all(loadPromises);
    }

    /**
     * è·å–å·²åŠ è½½çš„å­—ä½“åˆ—è¡¨
     * @returns {string[]} å·²åŠ è½½çš„å­—ä½“åç§°æ•°ç»„
     */
    getLoadedFonts() {
        return Array.from(this.loadedFonts);
    }

    /**
     * æ¸…ç†åŠ è½½çŠ¶æ€ï¼ˆç”¨äºè°ƒè¯•ï¼‰
     */
    reset() {
        this.loadedFonts.clear();
        this.loadingFonts.clear();
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
window.fontLoader = new FontLoader();

// åœ¨æ•°æ®åº“å°±ç»ªåè‡ªåŠ¨åŠ è½½å­—ä½“
document.addEventListener('DOMContentLoaded', async () => {
    // ä½¿ç”¨ ensureDBReady ç¡®ä¿æ•°æ®åº“å·²å°±ç»ª
    if (typeof ensureDBReady === 'function') {
        try {
            await ensureDBReady(async () => {
                await window.fontLoader.loadFontsFromUserConfig();
            }, 'æŒ‰éœ€åŠ è½½å­—ä½“');
        } catch (error) {
            console.error('æŒ‰éœ€å­—ä½“åŠ è½½å¤±è´¥:', error);
        }
    } else {
        // é™çº§æ–¹æ¡ˆï¼šç›´æ¥å°è¯•åŠ è½½
        setTimeout(async () => {
            await window.fontLoader.loadFontsFromUserConfig();
        }, 2000);
    }
});

// å¯¼å‡ºåˆ°å…¨å±€ä½œç”¨åŸŸï¼Œæ–¹ä¾¿å…¶ä»–æ¨¡å—ä½¿ç”¨
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FontLoader;
}
</script>

    <!-- Analytics -->
    <script defer src="https://umami.whale-llt.top/script.js" data-website-id="00c95749-7c0d-4333-9ec1-2ad2701799a3"></script>

  <style rel="stylesheet" crossorigin>:root{--theme-primary: #07c160;--theme-primary-light: rgba(7, 193, 96, .1);--theme-primary-hover: #06a84f;--theme-secondary: #1890ff;--theme-secondary-hover: #0078d4;--theme-secondary-active: #106ebe;--theme-gradient-direction: to right;--theme-gradient: linear-gradient(var(--theme-gradient-direction), var(--theme-primary), var(--theme-secondary));--use-gradient: 0;--bg-primary: #ffffff;--bg-secondary: #f5f5f5;--bg-tertiary: #ededed;--text-primary: #333333;--text-secondary: #666666;--text-tertiary: #999999;--border-color: #e0e0e0;--shadow-color: rgba(0, 0, 0, .1);--input-bg: #ffffff;--modal-bg: #ffffff;--overlay-bg: rgba(0, 0, 0, .5)}.dark-mode{--bg-primary: #1a1a1a;--bg-secondary: #2d2d2d;--bg-tertiary: #363636;--text-primary: #ffffff;--text-secondary: #cccccc;--text-tertiary: #999999;--border-color: #404040;--shadow-color: rgba(0, 0, 0, .3);--input-bg: #2d2d2d;--modal-bg: #1a1a1a;--overlay-bg: rgba(0, 0, 0, .7);--theme-secondary-hover: #4dabf7;--theme-secondary-active: #339af0}@media (prefers-color-scheme: dark){.system-theme{--bg-primary: #1a1a1a;--bg-secondary: #2d2d2d;--bg-tertiary: #363636;--text-primary: #ffffff;--text-secondary: #cccccc;--text-tertiary: #999999;--border-color: #404040;--shadow-color: rgba(0, 0, 0, .3);--input-bg: #2d2d2d;--modal-bg: #1a1a1a;--overlay-bg: rgba(0, 0, 0, .7);--theme-secondary-hover: #4dabf7;--theme-secondary-active: #339af0}}.gradient-mode{--theme-background: var(--theme-gradient)}.gradient-mode .apply-custom-color-btn,.gradient-mode .apply-gradient-btn,.gradient-mode .send-btn,.gradient-mode .memory-panel-btn:active,.gradient-mode .generate-moment-btn,.gradient-mode .form-submit,.gradient-mode .header-btn,.gradient-mode .song-item.active{background:var(--theme-gradient)!important}*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Helvetica Neue,Helvetica,Arial,sans-serif;background-color:var(--bg-tertiary);color:var(--text-primary);height:100vh;overflow:hidden;position:relative;transition:background-color .3s ease,color .3s ease}.main-container{position:relative;height:100vh;height:var(--viewport-height, 100vh);padding-bottom:var(--nav-height, 50px)}.contact-list-page,.moments-page,.profile-page,.weibo-page,.data-management-page,.memory-management-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out,background-color .3s ease;background-color:var(--bg-secondary);display:flex;flex-direction:column;padding-left:var(--safe-area-left, 0px);padding-right:var(--safe-area-right, 0px);padding-bottom:var(--safe-area-bottom, 0px);overflow:hidden}.chat-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out,background-color .3s ease;background-color:var(--bg-tertiary);display:flex;flex-direction:column;padding-left:var(--safe-area-left, 0px);padding-right:var(--safe-area-right, 0px);overflow:hidden}.contact-list-page.active,.chat-page.active,.moments-page.active,.profile-page.active,.weibo-page.active,.data-management-page.active,.memory-management-page.active{opacity:1;pointer-events:auto;z-index:10}.chat-page.active{z-index:50}.contact-list-page{background-color:var(--bg-primary)}.contact-list-page .wechat-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:background-color .3s ease,color .3s ease,border-color .3s ease}.contact-list-page:not(.active) .wechat-header,.chat-page:not(.active) .chat-header,.moments-page:not(.active) .moments-header,.profile-page:not(.active) .chat-header,.data-management-page:not(.active) .chat-header,.memory-management-page:not(.active) .chat-header{display:none}.interactive-page:not(.active){display:none}.header-title{font-size:17px;font-weight:500}.header-actions{display:flex;gap:20px}.header-icon{width:20px;height:20px;cursor:pointer}.search-bar{padding:8px 15px;background-color:var(--bg-tertiary);flex-shrink:0;transition:background-color .3s ease}.search-input{width:100%;height:32px;background-color:var(--input-bg);color:var(--text-primary);border:1px solid var(--border-color);border-radius:4px;padding:0 10px;font-size:14px;transition:all .3s ease}.search-input::placeholder{color:var(--text-tertiary)}.search-input:focus{outline:none;border-color:var(--theme-primary);box-shadow:0 0 0 2px #07c1601a}#contactList{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-bottom:var(--nav-height, 50px)}.contact-item{display:flex;align-items:center;padding:12px 15px;background-color:var(--bg-primary);border-bottom:.5px solid var(--border-color);cursor:pointer;position:relative;transition:all .3s ease}.contact-item:active{background-color:var(--bg-secondary)}.contact-avatar{width:48px;height:48px;border-radius:4px;margin-right:12px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:20px;flex-shrink:0;overflow:hidden}.contact-avatar img{width:100%;height:100%;object-fit:cover}.contact-info{flex:1;overflow:hidden}.contact-name{font-size:17px;color:var(--text-primary);margin-bottom:4px;transition:color .3s ease}.contact-message{font-size:13px;color:var(--text-secondary);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;transition:color .3s ease}.contact-time{position:absolute;right:15px;top:15px;font-size:12px;color:var(--text-tertiary);transition:color .3s ease}.chat-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:all .3s ease}.chat-header-spacer{width:24px;height:24px;flex-shrink:0}.memory-panel-header{padding-top:10px}.back-btn{display:flex;align-items:center;gap:5px;font-size:17px;color:var(--theme-primary);cursor:pointer;transition:color .3s ease}.chat-title{position:absolute;left:50%;transform:translate(-50%);font-size:17px;font-weight:500;color:var(--text-primary);transition:color .3s ease}.chat-header-actions{display:flex;align-items:center;gap:15px}.chat-more,.memory-btn{width:24px;height:24px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:700}.chat-messages{flex:1;overflow-y:auto;padding:15px;padding-bottom:calc(80px + var(--safe-area-bottom, 0px));background-size:cover;background-position:center;background-repeat:no-repeat;-webkit-overflow-scrolling:touch;scroll-behavior:smooth}.messages-scroll-content{transform:translateZ(0)}.message-timestamp{text-align:center;color:#999;font-size:12px;margin:0 auto 15px;padding:2px 8px;background-color:#0000000d;border-radius:4px;display:inline-block;left:50%;position:relative;transform:translate(-50%)}.message{display:flex;margin-bottom:15px;align-items:flex-start;animation:slideInFromBottom .3s ease-out}@keyframes slideInFromBottom{0%{transform:translateY(15px);opacity:0}to{transform:translateY(0);opacity:1}}.message.new-message{animation:slideInFromBottom .5s cubic-bezier(.25,.46,.45,.94)}#typingIndicator{animation:slideInFromBottom .4s ease-out}.message.sent{flex-direction:row-reverse}.message-avatar{width:40px;height:40px;border-radius:4px;margin:0 10px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:16px;flex-shrink:0;overflow:hidden}.message-avatar img{width:100%;height:100%;object-fit:cover}.message-bubble,.custom-bubble-container{max-width:calc(100% - 120px);position:relative}.message-content{padding:10px 12px;border-radius:8px;font-size:16px;line-height:1.5;word-wrap:break-word;position:relative}.custom-bubble-container *{word-wrap:break-word!important;overflow-wrap:break-word!important}.message.received .message-content{background-color:#fff;color:#000}.message.sent .message-content{background-color:#95ec69;color:#000}.message-content:before{content:"";position:absolute;top:10px;width:0;height:0;border-style:solid}.message.received .message-content:before{left:-5px;border-width:6px 6px 6px 0;border-color:transparent #fff transparent transparent}.message.sent .message-content:before{right:-5px;border-width:6px 0 6px 6px;border-color:transparent transparent transparent #95ec69}.message-emoji{max-width:100px;max-height:100px;border-radius:8px;display:block}.message-content.red-packet{background-color:#fa9d3b;color:#fff;padding:0;width:240px;cursor:pointer;border-radius:8px;overflow:hidden}.red-packet-body{display:flex;align-items:center;padding:12px}.red-packet-icon{width:40px;height:40px;margin-right:10px}.red-packet-text{flex:1}.red-packet-text div:first-child{font-size:15px;font-weight:500;margin-bottom:2px}.red-packet-text div:last-child{font-size:14px}.red-packet-footer{background-color:#fff;color:#999;font-size:12px;padding:4px 12px;border-top:.5px solid rgba(0,0,0,.05)}.message.sent .message-content.red-packet:before,.message.received .message-content.red-packet:before{border-color:transparent transparent transparent #fa9d3b}.message.received .message-content.red-packet:before{border-color:transparent #fa9d3b transparent transparent}.message-content.chat-image{padding:0;background:none;border:none;border-radius:0;overflow:visible;max-width:280px}.chat-image-content{width:100%;max-width:280px;max-height:200px;border-radius:0;border:none;object-fit:cover;cursor:pointer;transition:transform .2s ease;display:block}.chat-image-content:hover{transform:scale(1.02)}.message-content.chat-image-placeholder,.message-content.chat-image-error{padding:20px;text-align:center;background:var(--bg-secondary);border-radius:12px;color:var(--text-secondary);max-width:200px}.message-content.chat-image-placeholder .image-placeholder{display:flex;flex-direction:column;align-items:center;gap:8px}.message-content.chat-image-placeholder span{font-size:24px}.image-error{padding:20px;text-align:center;background:var(--bg-secondary);border-radius:8px;color:var(--text-secondary)}.message.sent .message-content.chat-image:before,.message.received .message-content.chat-image:before{display:none}.chat-input-area{background-color:var(--bg-primary);border-top:.5px solid var(--border-color);padding:8px 10px 10px;padding-bottom:calc(10px + var(--safe-area-bottom, 0px));padding-left:calc(10px + var(--safe-area-left, 0px));padding-right:calc(10px + var(--safe-area-right, 0px));display:flex;align-items:flex-end;gap:6px;flex-shrink:0;position:fixed;bottom:0;left:0;right:0;transition:all .3s ease;z-index:102}.input-actions{display:flex;align-items:center;gap:4px;flex-shrink:0}.action-btn{width:28px;height:28px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:50%;background-color:var(--bg-primary);font-size:20px;transition:background-color .3s ease}.action-btn:active{background-color:var(--bg-secondary)}.chat-input{flex:1;min-height:36px;max-height:120px;min-width:0;padding:8px 12px;border:1px solid var(--border-color);border-radius:4px;background-color:var(--input-bg);color:var(--text-primary);font-size:16px;resize:none;outline:none;transition:all .3s ease}.chat-input::placeholder{color:var(--text-tertiary)}.chat-input:focus{border-color:var(--theme-primary);box-shadow:0 0 0 2px #07c1601a}.send-btn{padding:8px 12px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:4px;font-size:14px;cursor:pointer;flex-shrink:0;white-space:nowrap}.send-btn:active{background-color:#06a652}.send-btn:disabled{background-color:#ccc;cursor:not-allowed}.memory-panel{position:absolute;top:0;left:0;right:0;bottom:0;background-color:#f7f7f7;z-index:100;transform:translateY(100%);transition:transform .3s ease-in-out,visibility 0s linear .3s,opacity .3s ease-in-out;overflow-y:auto;-webkit-overflow-scrolling:touch;visibility:hidden;opacity:0;pointer-events:none}.memory-panel.active{transform:translateY(0);visibility:visible;opacity:1;pointer-events:auto;transition:transform .3s ease-in-out,visibility 0s linear 0s,opacity .3s ease-in-out}.memory-panel-header{padding:10px 15px;display:flex;justify-content:space-between;align-items:center;background-color:#ededed;border-bottom:.5px solid #d9d9d9;position:sticky;top:0;z-index:1}.memory-panel-title{font-size:17px;font-weight:500}.memory-panel-actions{display:flex;gap:15px}.memory-panel-btn{font-size:16px;color:#576b95;cursor:pointer;background:none;border:none;padding:5px}.memory-panel-btn:active{color:var(--theme-primary)}.memory-panel-content{padding:15px;background-color:#f7f7f7}.memory-textarea{width:100%;height:calc(100vh - 150px);border:1px solid #ddd;border-radius:4px;outline:none;resize:none;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;color:#333;padding:10px}.memory-table-view{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif;color:#333;line-height:1.6}.memory-table-view h1,.memory-table-view h2,.memory-table-view h3,.memory-table-view h4{font-weight:600;color:#111;margin-top:24px;margin-bottom:16px}.memory-table-view h1{font-size:1.5em}.memory-table-view h2{font-size:1.3em}.memory-table-view h3{font-size:1.1em}.memory-table-view h4{font-size:1em}.memory-table-view p{margin-bottom:16px}.memory-table-view ul{padding-left:20px;margin-bottom:16px}.memory-table-view table{width:100%;border-collapse:collapse;margin-bottom:24px;background-color:#fff;border-radius:8px;overflow:hidden;box-shadow:0 1px 3px #0000000d;table-layout:fixed}.memory-table-view th,.memory-table-view td{padding:12px 15px;text-align:left;border-bottom:1px solid #f0f0f0;word-wrap:break-word;word-break:break-word;white-space:pre-wrap;max-width:0;overflow-wrap:break-word}.memory-table-view th{background-color:#fafafa;font-weight:600;color:#555}.memory-table-view tr:last-child th,.memory-table-view tr:last-child td{border-bottom:none}.memory-table-view hr{border:none;border-top:1px solid #e5e5e5;margin:24px 0}.bottom-nav{position:fixed;bottom:0;left:0;right:0;height:var(--nav-height, 50px);padding-bottom:var(--safe-area-bottom, 0px);padding-left:var(--safe-area-left, 0px);padding-right:var(--safe-area-right, 0px);background-color:var(--bg-primary);border-top:.5px solid var(--border-color);display:flex;justify-content:space-around;align-items:center;z-index:200;transition:all .3s ease}body:has(.chat-page.active) .bottom-nav{display:none}body.chat-active .bottom-nav,body.no-has-support.chat-active .bottom-nav{display:none!important}.nav-item{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;cursor:pointer;position:relative}.nav-icon{width:24px;height:24px}.nav-text{font-size:10px;color:var(--text-tertiary);transition:color .3s ease}.nav-item.active .nav-text{color:var(--theme-primary)}.moments-page{position:fixed;top:0;left:0;right:0;bottom:50px;background-color:#f5f5f5;display:flex;flex-direction:column;z-index:120;padding-bottom:calc(50px + env(safe-area-inset-bottom));padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right)}.moment-images-preview{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-top:10px;max-width:300px}.moment-image-item{position:relative;aspect-ratio:1;border-radius:4px;overflow:hidden;border:1px solid #e0e0e0}.moment-image-item img{width:100%;height:100%;object-fit:cover}.moment-image-remove{position:absolute;top:2px;right:2px;width:18px;height:18px;background-color:#f00c;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;cursor:pointer}.moment-images-grid{display:grid;gap:4px;margin:10px 0;border-radius:8px;overflow:hidden}.moment-images-grid.grid-1{grid-template-columns:1fr;max-width:200px}.moment-images-grid.grid-2{grid-template-columns:repeat(2,1fr);max-width:200px}.moment-images-grid.grid-3,.moment-images-grid.grid-4,.moment-images-grid.grid-5,.moment-images-grid.grid-6,.moment-images-grid.grid-7,.moment-images-grid.grid-8,.moment-images-grid.grid-9{grid-template-columns:repeat(3,1fr);max-width:200px}.moment-image-container{position:relative;width:100%;aspect-ratio:1;overflow:hidden}.moment-grid-image{width:100%;height:100%;object-fit:cover;cursor:pointer}.moment-image-error{position:absolute;top:0;left:0;width:100%;height:100%;background-color:#f5f5f5;border:1px solid #e0e0e0;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#999;font-size:12px}.image-error-icon{font-size:24px;margin-bottom:4px;opacity:.6}.image-error-text{font-size:10px;text-align:center}.comment-time{font-size:11px;color:#999;margin-left:8px}.moment-menu-btn{position:absolute;top:8px;right:8px;width:24px;height:24px;background-color:#0000001a;color:#666;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:16px;cursor:pointer;font-weight:700;transition:background-color .2s}.moment-menu-btn:hover{background-color:#0003;color:#333}.moment-menu{position:absolute;top:32px;right:0;background:#fff;border:1px solid #e0e0e0;border-radius:8px;box-shadow:0 2px 10px #0000001a;z-index:1000;min-width:120px}.moment-menu-item{padding:12px 16px;cursor:pointer;font-size:14px;color:#333;border-bottom:1px solid #f0f0f0;transition:background-color .2s}.moment-menu-item:last-child{border-bottom:none}.moment-menu-item:hover{background-color:#f5f5f5}.moment-menu-item:first-child:hover{color:#e53e3e}.moment-header{position:relative}.moments-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:all .3s ease}.moments-content{flex:1;overflow-y:auto;padding:15px;padding-bottom:calc(var(--nav-height, 50px) + 15px);-webkit-overflow-scrolling:touch;background-color:var(--bg-secondary);transition:background-color .3s ease}.moments-empty{text-align:center;padding:50px 20px;color:var(--text-secondary);transition:color .3s ease}.moments-empty-icon{font-size:48px;margin-bottom:15px}.moments-empty-text{font-size:16px;margin-bottom:20px}.moments-empty-btn{background-color:var(--theme-primary);color:#fff;border:none;border-radius:20px;padding:10px 20px;font-size:14px;cursor:pointer}.moments-list{display:flex;flex-direction:column;gap:15px}.moment-item{background-color:var(--bg-primary);color:var(--text-primary);border-radius:8px;padding:15px;box-shadow:0 1px 3px var(--shadow-color);margin-top:8px;transition:all .3s ease}.moment-header{display:flex;align-items:center;margin-bottom:10px}.moment-avatar img{width:100%;height:100%;object-fit:cover}.moment-info{flex:1}.moment-name{font-size:16px;font-weight:500;margin-bottom:2px;color:var(--text-primary);transition:color .3s ease}.moment-time{font-size:12px;color:var(--text-tertiary);transition:color .3s ease}.moment-time-location,.user-profile-moment-time-location{font-size:12px;color:var(--text-tertiary);display:flex;align-items:center;gap:8px}.moment-location{color:var(--theme-primary);font-weight:500}.moment-content{font-size:15px;line-height:1.5;word-wrap:break-word;word-break:break-word;overflow-wrap:break-word;white-space:pre-wrap;color:var(--text-primary);transition:color .3s ease}.moment-image{width:100%;max-width:300px;border-radius:8px;margin-bottom:10px}.publish-moment-modal{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background-color:#00000080;z-index:2000}.publish-moment-content{position:absolute;bottom:0;left:0;right:0;background-color:#fff;border-radius:12px 12px 0 0;max-height:80vh;overflow-y:auto;animation:slideUp .3s ease}.publish-moment-header{padding:15px;border-bottom:.5px solid #e5e5e5;display:flex;justify-content:space-between;align-items:center}.publish-moment-title{font-size:17px;font-weight:500}.publish-moment-close{font-size:14px;color:#576b95;cursor:pointer}.publish-moment-body{padding:15px}.generate-moment-section{text-align:center;padding:20px;background-color:#f8f9fa;border-radius:8px;margin-bottom:20px}.generate-moment-btn{background-color:var(--theme-primary);color:#fff;border:none;border-radius:8px;padding:12px 24px;font-size:16px;cursor:pointer;margin-bottom:10px}.generate-moment-hint{font-size:14px;color:#666;line-height:1.5}.moment-preview{display:none;border:1px solid #e5e5e5;border-radius:8px;padding:15px;margin-bottom:20px;background-color:#f8f9fa}.moment-preview-title{font-size:14px;font-weight:500;margin-bottom:10px;color:#333}.moment-preview-content{font-size:15px;line-height:1.5;margin-bottom:10px}.moment-preview-image{width:100%;max-width:200px;border-radius:8px}.unsplash-key-section{margin-bottom:20px}.unsplash-key-label{font-size:14px;color:#333;margin-bottom:8px;display:block}.unsplash-key-input{width:100%;padding:10px;border:1px solid #e5e5e5;border-radius:4px;font-size:16px;outline:none}.unsplash-key-input:focus{border-color:var(--theme-primary)}.publish-moment-submit{width:100%;padding:12px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:4px;font-size:16px;cursor:pointer}.publish-moment-submit:active{background-color:#06a652}.publish-moment-submit:disabled{background-color:#ccc;cursor:not-allowed}.modal{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background-color:var(--overlay-bg);z-index:2000;transition:background-color .3s ease}.modal-content{position:absolute;bottom:0;left:0;right:0;background-color:var(--modal-bg);color:var(--text-primary);border-radius:12px 12px 0 0;max-height:80vh;overflow-y:auto;animation:slideUp .3s ease;transition:background-color .3s ease,color .3s ease}@keyframes slideUp{0%{transform:translateY(100%)}to{transform:translateY(0)}}.modal-header{padding:15px;border-bottom:.5px solid #e5e5e5;display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:17px;font-weight:500}.modal-close{font-size:14px;color:#576b95;cursor:pointer}.modal-body{padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #eee}#updateModal .modal-body{max-height:60vh;overflow-y:auto;padding-right:20px}#updateModal .modal-footer{display:none}#updateModal .modal-footer.visible{display:block}.form-group{margin-bottom:15px}.form-label{font-size:14px;color:var(--text-primary);margin-bottom:8px;display:block;transition:color .3s ease}.form-input,.form-textarea{width:100%;padding:10px;background-color:var(--input-bg);color:var(--text-primary);border:1px solid var(--border-color);border-radius:4px;font-size:16px;outline:none;transition:all .3s ease}.form-input::placeholder,.form-textarea::placeholder{color:var(--text-tertiary)}.form-input:focus,.form-textarea:focus{border-color:var(--theme-primary);box-shadow:0 0 0 2px #07c1601a}.form-textarea{min-height:80px;resize:vertical}.api-key-row{display:flex;gap:10px;align-items:center}.api-key-input{flex:1}.timeout-group{display:flex;align-items:center;gap:4px;white-space:nowrap}.timeout-label{font-size:12px;color:#666}.timeout-input{width:50px;padding:8px 4px;border:1px solid #e5e5e5;border-radius:4px;font-size:14px;outline:none;text-align:center}.timeout-input:focus{border-color:var(--theme-primary)}.timeout-unit{font-size:12px;color:#666}.api-provider-row{border-left:3px solid #e1e5e9;margin-left:8px;background-color:#f8f9fa;border-radius:4px;padding:12px;margin-bottom:8px}.api-provider-row.enabled{border-left:3px solid #28a745;background-color:#28a7450d}.remove-provider-btn{background:#ff4757;color:#fff;border:none;border-radius:50%;width:20px;height:20px;font-size:14px;cursor:pointer;margin-left:8px;line-height:1;display:inline-flex;align-items:center;justify-content:center}.remove-provider-btn:hover{background:#ff3838}.model-selection-row{display:flex;gap:10px;align-items:center}.model-config-select{flex:1;min-width:120px}.model-select{flex:2;min-width:180px}.config-list{padding:16px}.config-list-empty{text-align:center;padding:40px 20px;color:#666}.empty-icon{font-size:48px;margin-bottom:16px}.empty-text{font-size:16px;margin-bottom:20px}.empty-action-btn{background:var(--theme-primary);color:#fff;border:none;border-radius:8px;padding:12px 24px;font-size:14px;cursor:pointer}.config-item{background:#fff;border:1px solid #e5e5e5;border-radius:8px;padding:16px;margin-bottom:12px;cursor:pointer}.config-item:hover{background:#f8f9fa}.config-item-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}.config-item-name{font-weight:700;font-size:16px}.config-item-actions{display:flex;gap:8px}.config-item-btn{background:none;border:none;font-size:18px;cursor:pointer;padding:4px}.config-item-edit{color:#007bff}.config-item-delete{color:#dc3545}.config-item-url{color:#666;font-size:14px;margin-bottom:4px}.config-item-status{font-size:12px;padding:2px 8px;border-radius:12px;color:#fff}.config-item-status.active{background:#28a745}.config-item-status.inactive{background:#6c757d}.config-form{position:fixed;top:0;left:0;right:0;bottom:0;background:#fff;z-index:1000;padding:16px;overflow-y:auto}.config-form-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:16px;border-bottom:1px solid #e5e5e5}.close-form-btn{background:none;border:none;font-size:24px;cursor:pointer;color:#666}.form-actions{display:flex;gap:12px;margin-top:24px}.form-button{flex:1;padding:12px;border:none;border-radius:8px;font-size:16px;cursor:pointer}.form-button.primary{background:var(--theme-primary);color:#fff}.form-button.secondary{background:#6c757d;color:#fff}.form-submit{width:100%;padding:12px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:4px;font-size:16px;cursor:pointer}.form-submit:active{background-color:#06a652}.emoji-panel{display:none;position:absolute;bottom:100%;left:0;right:0;background-color:var(--bg-primary);border-top:.5px solid var(--border-color);max-height:250px;overflow-y:auto;margin-bottom:8px;box-shadow:0 -2px 10px var(--shadow-color);transition:all .3s ease}.emoji-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:10px}.emoji-item{aspect-ratio:1;display:flex;align-items:center;justify-content:center;background-color:#fff;border-radius:8px;cursor:pointer;overflow:hidden;position:relative}.emoji-item:active{background-color:#e5e5e5}.emoji-item img{width:100%;height:100%;object-fit:cover}.emoji-delete-btn{position:absolute;top:2px;right:2px;width:20px;height:20px;background-color:#f00c;color:#fff;border-radius:50%;display:none;align-items:center;justify-content:center;font-size:12px;cursor:pointer}.emoji-item:hover .emoji-delete-btn{display:flex}.add-emoji-btn{grid-column:span 4;padding:10px;background-color:var(--bg-primary);border:1px dashed var(--theme-primary);border-radius:8px;color:var(--theme-primary);text-align:center;cursor:pointer;transition:all .3s ease}.add-emoji-btn:hover{background-color:var(--theme-primary-light)}.contact-settings-page{display:none;position:fixed;top:0;left:0;width:100%;height:var(--viewport-height, 100vh);background-color:var(--bg-secondary);z-index:1000;transform:translate(100%);transition:transform .3s ease-in-out}.contact-settings-page.active{display:block;transform:translate(0)}.contact-settings-content{padding:0;height:calc(100vh - 60px);overflow-y:auto;background-color:var(--bg-secondary)}.settings-section{background-color:var(--bg-primary);margin:15px 0;border-radius:12px;overflow:hidden;box-shadow:0 2px 8px var(--shadow-color)}.settings-section-title{padding:15px 20px 12px;font-size:14px;font-weight:600;color:var(--text-secondary);background-color:var(--bg-secondary);border-bottom:1px solid var(--border-color)}.settings-item{display:flex;align-items:center;padding:16px 20px;cursor:pointer;transition:background-color .2s;border-bottom:1px solid var(--border-color)}.settings-item:last-child{border-bottom:none}.settings-item:hover{background-color:var(--bg-tertiary)}.settings-item:active{background-color:var(--theme-primary-light)}.settings-item-icon{font-size:20px;margin-right:15px;display:flex;align-items:center;justify-content:center;width:32px;height:32px;border-radius:8px;background-color:var(--theme-primary-light)}.settings-item-content{flex:1;display:flex;flex-direction:column;gap:2px}.settings-item-label{font-size:16px;font-weight:500;color:var(--text-primary)}.settings-item-desc{font-size:13px;color:var(--text-secondary);line-height:1.4}.settings-item-arrow{font-size:18px;color:var(--text-tertiary);margin-left:8px}.settings-item.danger-item .settings-item-icon{background-color:#f5222d1a;color:#f5222d}.settings-item.danger-item .settings-item-label{color:#f5222d}.settings-item.danger-item:hover{background-color:#f5222d0d}.settings-item.danger-item:active{background-color:#f5222d1a}.dark-mode .settings-section{box-shadow:0 2px 8px #0006}.dark-mode .settings-item.danger-item .settings-item-icon{background-color:#f5222d33}.dark-mode .settings-item.danger-item:hover{background-color:#f5222d1a}.dark-mode .settings-item.danger-item:active{background-color:#f5222d26}.settings-menu{display:none;position:fixed;top:50px;right:10px;background-color:#4c4c4c;border-radius:4px;padding:8px 0;min-width:120px;box-shadow:0 2px 10px #0003;z-index:1500}.settings-menu:before{content:"";position:absolute;top:-6px;right:20px;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:6px solid #4c4c4c}.menu-item{padding:10px 20px;color:#fff;font-size:14px;cursor:pointer}.menu-item:active{background-color:#3c3c3c}.menu-item.delete-item{color:#f44}.menu-item.delete-item:active{background-color:#8b0000}.typing-indicator{display:flex;align-items:center;gap:4px;padding:10px}.typing-dot{width:8px;height:8px;background-color:#999;border-radius:50%;animation:typing 1.4s infinite}.typing-dot:nth-child(2){animation-delay:.2s}.typing-dot:nth-child(3){animation-delay:.4s}@keyframes typing{0%,60%,to{opacity:.3}30%{opacity:1}}.toast{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#000c;color:#fff;padding:12px 24px;border-radius:6px;font-size:14px;z-index:3000;display:none;max-width:400px;text-align:center;box-shadow:0 4px 12px #00000026}.toast.show{display:block;animation:fadeInOut 2s ease}.toast.toast-error{background-color:#dc3545;color:#fff}.toast.toast-success{background-color:#28a745;color:#fff}.toast.toast-warning{background-color:#ffc107;color:#212529}.toast.toast-info{background-color:#17a2b8;color:#fff}@keyframes fadeInOut{0%,to{opacity:0}10%,90%{opacity:1}}.top-notification{position:fixed;top:20px;left:50%;transform:translate(-50%);background-color:#000c;color:#fff;padding:10px 20px;border-radius:20px;font-size:14px;z-index:3000;display:none}.top-notification.show{display:block;animation:slideDown 1.5s ease}@keyframes slideDown{0%{opacity:0;transform:translate(-50%) translateY(-20px)}20%{opacity:1;transform:translate(-50%) translateY(0)}80%{opacity:1;transform:translate(-50%) translateY(0)}to{opacity:0;transform:translate(-50%) translateY(-20px)}}.model-list{max-height:200px;overflow-y:auto;border:1px solid #e5e5e5;border-radius:4px;margin-top:10px}.model-item{padding:12px;border-bottom:.5px solid #e5e5e5;cursor:pointer;font-size:14px}.model-item:last-child{border-bottom:none}.model-item:active{background-color:#f5f5f5}.model-item.selected{background-color:#e8f5e9;color:var(--theme-primary)}.loading-text{text-align:center;padding:20px;color:#999;font-size:14px}.prompt-section{margin-top:20px;padding-top:20px;border-top:1px solid #e5e5e5}.prompt-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.prompt-title{font-size:14px;font-weight:500}.prompt-actions{display:flex;gap:10px}.prompt-btn{padding:5px 10px;background-color:#f5f5f5;border:1px solid #e5e5e5;border-radius:4px;font-size:12px;cursor:pointer}.prompt-btn:active{background-color:#e5e5e5}.file-input{display:none}.profile-page{position:fixed;top:0;left:0;right:0;bottom:50px;background-color:var(--bg-secondary);z-index:150;overflow-y:auto;padding-top:env(safe-area-inset-top);padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);transition:background-color .3s ease}.profile-header{background-color:var(--bg-primary);padding:20px 15px;text-align:center;border-bottom:10px solid var(--bg-secondary);transition:all .3s ease}.profile-avatar{width:80px;height:80px;border-radius:8px;margin:0 auto 15px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:32px;overflow:hidden}.profile-avatar img{width:100%;height:100%;object-fit:cover}.profile-name{font-size:18px;font-weight:500;margin-bottom:5px;color:var(--text-primary);transition:color .3s ease}.profile-id{font-size:14px;color:var(--text-secondary);transition:color .3s ease}.profile-section{background-color:var(--bg-primary);margin-bottom:10px;transition:background-color .3s ease}.profile-item{display:flex;align-items:center;padding:15px;border-bottom:.5px solid var(--border-color);cursor:pointer;background-color:var(--bg-primary);transition:all .3s ease}.profile-item:last-child{border-bottom:none}.profile-item:active{background-color:var(--bg-secondary)}.profile-item-label{flex:1;font-size:16px;color:var(--text-primary);transition:color .3s ease}.profile-item-value{color:var(--text-secondary);font-size:14px;margin-right:5px;transition:color .3s ease}.profile-item-arrow{color:var(--text-tertiary);transition:color .3s ease}.profile-version{text-align:center;padding:15px;margin-top:10px;background-color:transparent}.profile-version #profileVersionText{font-size:12px;color:#999;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;-webkit-user-select:none;user-select:none;opacity:.8}.feature-hint{position:absolute;bottom:60px;right:15px;background:var(--theme-primary);color:#fff;padding:8px 12px;border-radius:18px;font-size:12px;z-index:150;box-shadow:0 2px 8px #0000001a;animation:pulse 2s infinite}@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.05)}to{transform:scale(1)}}.context-control{background-color:#fff;padding:12px 15px;border-radius:8px;margin-top:10px;box-shadow:0 1px 3px #0000001a;position:relative}.context-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.context-title{font-size:15px;font-weight:500;color:#333}.context-value{font-size:14px;color:var(--theme-primary);font-weight:700;min-width:40px;text-align:right}.context-slider{width:100%;height:6px;-webkit-appearance:none;background:#e0e0e0;border-radius:3px;outline:none;margin-top:10px}.context-slider::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;border-radius:50%;background:var(--theme-primary);cursor:pointer;box-shadow:0 2px 5px #0003}.context-info{font-size:12px;color:#666;margin-top:10px;line-height:1.4}.music-modal{display:none;position:fixed;z-index:2000;left:0;top:0;width:100%;height:100%;background-color:#0006}.music-modal-content{background-color:var(--bg-primary);margin:5% auto;padding:20px;border:1px solid #888;width:90%;max-width:600px;border-radius:10px;max-height:80vh;overflow-y:auto}.close-btn{color:#aaa;float:right;font-size:28px;font-weight:700;cursor:pointer}.close-btn:hover{color:#000}.playlist-container{margin:20px 0;border:1px solid #ddd;border-radius:5px;padding:10px;max-height:200px;overflow-y:auto}.song-item{padding:10px;margin:5px 0;background:#f0f0f0;border-radius:5px;cursor:pointer;display:flex;justify-content:space-between;align-items:center}.song-item:hover{background:#e0e0e0}.song-item.active{background:var(--theme-primary);color:#fff}.delete-song{color:#f44;cursor:pointer;padding:0 10px}.player-controls{margin:20px 0;padding:15px;background:#f9f9f9;border-radius:5px}.progress-bar{width:100%;height:4px;background:#ddd;border-radius:2px;margin:10px 0;cursor:pointer}.progress-fill{height:100%;background:var(--theme-primary);border-radius:2px;width:0%;transition:width .1s}.time-display{display:flex;justify-content:space-between;font-size:12px;color:#666}.floating-lyrics{position:fixed;bottom:100px;left:50%;transform:translate(-50%);background:#000c;color:#fff;padding:12px 24px;border-radius:25px;font-size:16px;z-index:999;transition:all .3s ease;max-width:80%;text-align:center;box-shadow:0 4px 6px #0000001a}.debug-info{position:fixed;top:20px;right:10px;background:#ffffffe6;padding:10px;border-radius:5px;font-size:12px;box-shadow:0 2px 4px #0000001a}.group-avatar{width:48px;height:48px;border-radius:4px;margin-right:12px;background-color:#4a90e2;display:flex;align-items:center;justify-content:center;color:#fff;font-size:20px;flex-shrink:0;overflow:hidden;position:relative}.group-avatar-inner{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:repeat(2,1fr);grid-template-rows:repeat(2,1fr)}.group-avatar-item{display:flex;align-items:center;justify-content:center;font-size:12px;overflow:hidden;border:1px solid white;background-color:var(--theme-primary)}.group-avatar-item img{width:100%;height:100%;object-fit:cover}.create-group-section{margin-top:20px;padding-top:20px;border-top:1px solid #e5e5e5}.group-member-list{max-height:200px;overflow-y:auto;border:1px solid #e5e5e5;border-radius:4px;margin-top:10px;padding:10px}.group-member-item{display:flex;align-items:center;padding:8px;border-bottom:.5px solid #eee;cursor:pointer}.group-member-item:last-child{border-bottom:none}.group-member-item.selected{background-color:#e6f7ff}.group-member-avatar{width:32px;height:32px;border-radius:4px;margin-right:10px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:14px;overflow:hidden}.group-member-avatar img{width:100%;height:100%;object-fit:cover}.group-member-name{flex:1;font-size:14px}.group-member-checkbox{width:20px;height:20px;border-radius:4px;border:1px solid #ddd;display:flex;align-items:center;justify-content:center}.group-member-checkbox.selected{background-color:var(--theme-primary);color:#fff;border-color:var(--theme-primary)}.group-message-header{display:flex;align-items:center;margin-bottom:4px}.group-message-name{font-size:12px;font-weight:700;color:#576b95}.group-message-time{font-size:10px;color:#999;margin-left:8px}.group-info-hint{background-color:#f0f0f0;color:#666;font-size:12px;text-align:center;padding:8px;border-radius:4px;margin:10px 0}.weibo-page{background-color:var(--bg-secondary)}.weibo-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:all .3s ease}.weibo-page:not(.active) .weibo-header{display:none}.weibo-container{max-width:600px;margin:0 auto;background:var(--bg-secondary);transition:background-color .3s ease;flex:1;display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow-y:auto;padding-bottom:calc(var(--nav-height, 50px) + 15px);-webkit-overflow-scrolling:touch}.weibo-scroll-content{transform:translateZ(0)}.weibo-container>.post{min-width:0;max-width:100%}.post{background:var(--bg-primary);color:var(--text-primary);margin-bottom:8px;padding:16px;width:100%;box-sizing:border-box;flex-shrink:0;transform:translateZ(0);transition:all .3s ease}.post-header{display:flex;align-items:flex-start;margin-bottom:12px;position:relative}.post-menu{position:absolute;top:16px;right:16px;width:24px;height:24px;display:flex;align-items:center;justify-content:center;font-size:20px;color:#666;cursor:pointer;border-radius:50%}.post-menu:hover{background-color:var(--bg-secondary)}.post-menu-dropdown{display:none;position:absolute;top:100%;right:0;background-color:var(--bg-primary);border-radius:4px;box-shadow:0 2px 10px var(--shadow-color);z-index:10;min-width:80px;padding:4px 0;transition:all .3s ease}.post-menu-dropdown .menu-item{padding:8px 12px;font-size:14px;color:var(--text-primary);cursor:pointer;transition:all .3s ease}.post-menu-dropdown .menu-item:hover{background-color:var(--bg-secondary)}.avatar{width:50px;height:50px;border-radius:50%;background:linear-gradient(45deg,#ff8a80,#ff5722);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;margin-right:12px;font-size:16px;flex-shrink:0;overflow:hidden}.avatar img{width:100%;height:100%;object-fit:cover}.post-info{flex:1}.user-name{font-size:16px;color:var(--text-primary);font-weight:500;margin-bottom:4px;transition:color .3s ease}.vip-badge{display:inline-block;background:linear-gradient(45deg,#ffb74d,#ff9800);color:#fff;padding:1px 4px;border-radius:2px;font-size:10px;margin-left:4px;vertical-align:middle}.post-time{font-size:12px;color:var(--text-tertiary);margin-bottom:4px;transition:color .3s ease}.post-source{font-size:12px;color:var(--text-tertiary);transition:color .3s ease}.post-content{font-size:15px;line-height:1.6;margin-bottom:12px;color:var(--text-primary);word-wrap:break-word;transition:color .3s ease}.hashtag,.mention{color:var(--theme-primary);text-decoration:none}.post-image-desc{width:120px;height:120px;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:8px;margin:12px 0;display:flex;align-items:center;justify-content:center;font-size:10px;color:var(--text-secondary);transition:all .3s ease;text-align:center;padding:12px;line-height:1.2;overflow:hidden;word-wrap:break-word;-webkit-hyphens:auto;hyphens:auto}.post-actions{display:flex;justify-content:space-around;align-items:center;padding-top:12px;border-top:1px solid #f0f0f0;margin-top:12px}.action-btn-weibo{display:flex;align-items:center;color:#666;font-size:13px;text-decoration:none;padding:4px 8px;border-radius:4px;transition:background-color .2s}.action-btn-weibo:hover{background-color:#f5f5f5}.action-icon{margin-right:4px;font-size:16px}.comments-section{background:var(--bg-secondary);margin:12px -16px -16px;padding:12px 16px;transition:background-color .3s ease}.comment{margin-bottom:8px;font-size:14px;line-height:1.5}.comment:last-child{margin-bottom:0}.comment-user{color:var(--theme-primary);font-weight:500;margin-right:4px;transition:color .3s ease}.comment-content{color:var(--text-primary);transition:color .3s ease}.comment-time{color:var(--text-tertiary);font-size:12px;margin-left:8px;transition:color .3s ease}.load-more-messages{text-align:center;padding:10px;color:#576b95;font-size:14px;cursor:pointer;margin-bottom:10px}.load-more-messages:hover{text-decoration:underline}.load-more-posts{text-align:center;padding:15px;color:#576b95;font-size:14px;cursor:pointer;margin:10px 0;border:1px dashed #d0d0d0;border-radius:8px;background:#f9f9f9}.load-more-posts:hover{background:#f0f0f0;text-decoration:underline}.data-management-container{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-bottom:calc(var(--nav-height, 50px) + 15px);background-color:var(--bg-secondary);transition:background-color .3s ease}.virtual-spacer-top,.virtual-spacer-bottom{width:100%;background:transparent;flex-shrink:0;box-sizing:border-box;margin:0;padding:0}.confirm-dialog-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:4000}#updateModalBody{max-height:60vh;overflow-y:auto;padding-bottom:15px}#updateModalBody h2{font-size:1.2em;margin-top:1em;margin-bottom:.5em;text-align:center}#updateModalBody h3{font-size:1.1em;margin-top:1em;margin-bottom:.5em;color:var(--theme-primary)}#updateModalBody ul{padding-left:20px;margin-bottom:1em}#updateModalBody li{margin-bottom:.5em;line-height:1.6}.modal-footer{padding:15px;border-top:.5px solid #e5e5e5}.reply-box{margin-top:12px;padding-top:12px;padding-bottom:60px;border-top:1px solid #f0f0f0;display:flex;gap:8px}.reply-input{flex:1;padding:8px 12px;border:1px solid #e1e8ed;border-radius:18px;font-size:14px;resize:none;outline:none;transition:border-color .2s}.reply-input:focus{border-color:#4a90e2}.reply-button{padding:8px 16px;background-color:#4a90e2;color:#fff;border:none;border-radius:18px;font-size:14px;cursor:pointer;transition:background-color .2s}.reply-button:hover{background-color:#357bd8}.reply-button:disabled{background-color:#ccc;cursor:not-allowed}.confirm-dialog{background-color:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px #0000001a;width:80%;max-width:300px;text-align:center}.confirm-dialog-title{font-size:18px;font-weight:500;margin-bottom:10px}.confirm-dialog-message{font-size:14px;color:#666;margin-bottom:20px}.confirm-dialog-buttons{display:flex;justify-content:space-between}.confirm-dialog-btn{flex:1;padding:10px;border:none;border-radius:4px;font-size:16px;cursor:pointer}.confirm-dialog-btn.cancel{background-color:#f0f0f0;color:#333;margin-right:10px}.confirm-dialog-btn.confirm{background-color:#f44;color:#fff}.post-choice-container{display:flex;flex-direction:column;gap:15px}.choice-option{padding:20px;border:2px solid var(--border-color);border-radius:12px;cursor:pointer;transition:all .3s ease;text-align:center;background-color:var(--bg-primary);color:var(--text-primary)}.choice-option:hover{border-color:var(--theme-primary);background-color:var(--theme-primary-light)}.choice-option:active{transform:scale(.98)}.choice-icon{font-size:32px;margin-bottom:10px}.choice-title{font-size:18px;font-weight:600;margin-bottom:8px;color:#333}.choice-description{font-size:14px;color:#666;line-height:1.4}#manualPostModal .form-input{width:100%}#manualPostModal textarea.form-input{resize:vertical;min-height:80px}#manualPostAuthor{background-color:#f5f5f5;color:#666}.message-selected{background-color:#ff636333!important;border-left:4px solid #ff6b6b!important}.message-selected .message-bubble{background-color:#ff636326!important}.multi-select-buttons{position:fixed;bottom:0;left:0;right:0;display:none;justify-content:space-around;align-items:center;z-index:1001;height:80px;background:#fffffffa;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border-top:1px solid rgba(0,0,0,.1)}.multi-select-btn{padding:12px 30px;border:none;border-radius:25px;font-size:16px;font-weight:600;cursor:pointer;transition:all .3s ease;min-width:120px;height:45px}.multi-select-btn.cancel-btn{background-color:#6c757d;color:#fff}.multi-select-btn.cancel-btn:hover{background-color:#5a6268}.multi-select-btn.delete-btn{background-color:#dc3545;color:#fff}.multi-select-btn.delete-btn:hover{background-color:#c82333}.voice-message{position:relative;cursor:pointer;transition:opacity .2s}.voice-message:hover{opacity:.9}.voice-icon{display:inline-block;margin-right:6px;margin-left:2px;vertical-align:middle;line-height:1;-webkit-user-select:none;user-select:none;color:inherit}.voice-icon svg{display:inline-block;vertical-align:middle;width:16px;height:16px;stroke:currentColor}.voice-message.playing .voice-icon{animation:pulse 1.5s infinite}@keyframes pulse{0%,to{opacity:1;transform:scale(1)}50%{opacity:.7;transform:scale(1.1)}}.voice-message.loading .voice-icon{animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.voice-player,.play-button,.waveform,.duration{display:none!important}.message-content.has-voice-player{border-top:none;padding-top:0;margin-top:0}.debug-log-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out;background-color:#f5f5f5;display:flex;flex-direction:column;overflow-y:auto;-webkit-overflow-scrolling:touch}.debug-log-page.active{opacity:1;pointer-events:auto;z-index:10}.debug-log-container{flex:1;display:flex;flex-direction:column;padding:15px 15px 70px;background-color:var(--bg-secondary);transition:background-color .3s ease}.database-stats{background:var(--bg-primary)!important;color:var(--text-primary);padding:15px;border-radius:8px;margin:15px;transition:all .3s ease;border:1px solid var(--border-color)}.import-export-actions>div{background:var(--bg-primary)!important;color:var(--text-primary)!important;border-color:var(--border-color)!important}.context-control{background-color:var(--bg-primary)!important;color:var(--text-primary)!important;border-color:var(--border-color)!important}.import-warning{background-color:var(--bg-secondary)!important;color:var(--text-primary)!important;border-color:var(--border-color)!important}#migrationStatusDetails,#chatEmojiMigrationStatusDetails,#imageKeywordConfigStatus,#databaseStatsContent{background-color:var(--bg-primary)!important;color:var(--text-primary)!important;border:1px solid var(--border-color)!important}#syncKeyInput{background-color:var(--input-bg)!important;color:var(--text-primary)!important;border:1px solid var(--border-color)!important}#syncKeyInput::placeholder{color:var(--text-tertiary)!important}#characterSelector{background-color:var(--input-bg)!important;color:var(--text-primary)!important;border:1px solid var(--border-color)!important}.debug-log-info{margin-bottom:15px}.debug-log-stats{font-size:14px;color:var(--text-secondary);margin-bottom:5px;transition:color .3s ease}.debug-log-hint{font-size:12px;color:var(--text-tertiary);line-height:1.4;transition:color .3s ease}.debug-log-content{flex:1;background:var(--bg-primary);border-radius:8px;padding:10px;max-height:calc(100vh - 200px);transition:background-color .3s ease;overflow-y:auto;-webkit-overflow-scrolling:touch}.debug-log-empty{text-align:center;color:#999;padding:40px 20px;font-size:14px}.debug-log-item{margin-bottom:8px;padding:8px;border-radius:4px;border-left:3px solid var(--border-color);background-color:var(--bg-secondary);color:var(--text-primary);font-size:13px;word-break:break-all;transition:all .3s ease}.debug-log-item.debug-log-error{background:#e53e3e1a;border-left-color:#e53e3e}.debug-log-item.debug-log-warn{background:#dd6b201a;border-left-color:#dd6b20}.debug-log-item.debug-log-info{background:#3182ce1a;border-left-color:#3182ce}.debug-log-item.debug-log-log{background:var(--bg-secondary);border-left-color:#718096}.debug-log-item.debug-log-debug{background:#38a1691a;border-left-color:#38a169}.debug-log-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}.debug-log-time{color:var(--text-tertiary);font-size:11px;transition:color .3s ease}.debug-log-level{font-size:10px;font-weight:600;padding:2px 6px;border-radius:3px;text-transform:uppercase}.debug-log-error .debug-log-level{background:#e53e3e;color:#fff}.debug-log-warn .debug-log-level{background:#dd6b20;color:#fff}.debug-log-info .debug-log-level{background:#3182ce;color:#fff}.debug-log-log .debug-log-level{background:#718096;color:#fff}.debug-log-debug .debug-log-level{background:#38a169;color:#fff}.debug-log-message{font-family:Monaco,Menlo,Ubuntu Mono,monospace;line-height:1.4;white-space:pre-wrap;color:var(--text-primary);transition:color .3s ease}.header-btn{background:var(--theme-primary);color:#fff;border:none;padding:6px 12px;border-radius:4px;font-size:12px;cursor:pointer;margin-left:8px}.header-btn:hover{background:#06ad56}.header-actions{display:flex;align-items:center}.memory-management-container{flex:1;display:flex;flex-direction:column;padding-bottom:70px;overflow:hidden}.memory-tabs{display:flex;background:var(--bg-primary);border-bottom:1px solid var(--border-color);transition:all .3s ease}.memory-tab{flex:1;padding:15px;border:none;background:none;font-size:16px;cursor:pointer;color:var(--text-secondary);border-bottom:2px solid transparent;transition:all .3s ease}.memory-tab.active{color:var(--theme-primary);border-bottom-color:var(--theme-primary);font-weight:600}.memory-content{flex:1;display:flex;flex-direction:column;overflow:hidden}.memory-section{flex:1;display:flex;flex-direction:column;padding:15px;overflow:hidden}.memory-section.hidden,.hidden{display:none}.character-selector{margin-bottom:15px}.character-selector select{width:100%;padding:12px;border:1px solid #e0e0e0;border-radius:8px;font-size:16px;background:#fff}.memory-list{flex:1;display:flex;flex-direction:column;gap:10px;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-bottom:15px}.memory-empty{text-align:center;color:#999;font-size:14px;padding:40px 20px}.memory-item{background:#fff;border-radius:8px;border:1px solid #e0e0e0;margin-bottom:8px;transition:all .3s ease}.memory-item:hover{border-color:var(--theme-primary);box-shadow:0 2px 8px var(--theme-primary-light)}.memory-item.single-item{padding:12px 15px}.memory-single-content{display:flex;flex-direction:column;gap:8px}.memory-text{font-size:14px;color:#333;line-height:1.5;word-break:break-word}.memory-meta{display:flex;justify-content:space-between;align-items:center;padding-top:8px;border-top:1px solid #f0f0f0}.memory-date{font-size:12px;color:#999}.memory-header{padding:12px 15px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;background:#f9f9f9;border-bottom:1px solid #e0e0e0}.memory-title{font-size:14px;color:#333;font-weight:500;flex:1}.memory-expand-icon{font-size:14px;color:#666;transition:transform .3s ease}.memory-item.expanded .memory-expand-icon{transform:rotate(90deg)}.memory-content-wrapper{max-height:0;overflow:hidden;transition:max-height .3s ease}.memory-item.expanded .memory-content-wrapper{max-height:500px}.memory-content-text{padding:15px;color:#333;line-height:1.6;font-size:14px}.memory-content-text h1,.memory-content-text h2,.memory-content-text h3{margin:0 0 8px;font-weight:600}.memory-content-text h1{font-size:18px}.memory-content-text h2{font-size:16px}.memory-content-text h3{font-size:14px}.memory-content-text ul,.memory-content-text ol{margin:8px 0;padding-left:20px}.memory-content-text li{margin:4px 0}.memory-actions{padding:10px 15px;background:#f9f9f9;display:flex;gap:10px;justify-content:flex-end;border-top:1px solid #e0e0e0}.memory-edit-btn{padding:8px 16px;border:1px solid #e0e0e0;border-radius:4px;background:#fff;color:#333;font-size:12px;cursor:pointer;transition:all .3s ease;min-width:60px}.memory-btn:hover{border-color:var(--theme-primary);color:var(--theme-primary)}.memory-btn.delete{color:#e53e3e;border-color:#e53e3e}.memory-btn.delete:hover{background:#e53e3e;color:#fff}.form-hint{font-size:12px;color:#999;margin-top:5px}.user-profile-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out;background-color:#f5f5f5;display:flex;flex-direction:column;overflow:visible}.user-profile-page.active{opacity:1;pointer-events:auto;z-index:10}.user-profile-header{background-color:var(--bg-primary);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);padding:10px 15px;padding-top:calc(10px + env(safe-area-inset-top));padding-left:calc(15px + env(safe-area-inset-left));padding-right:calc(15px + env(safe-area-inset-right));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);position:absolute;top:0;left:0;right:0;z-index:100;height:calc(44px + env(safe-area-inset-top));transition:all .3s ease}.dark-mode .user-profile-header{background-color:#1a1a1af2}.system-theme .user-profile-header{background-color:var(--bg-primary)}.user-profile-content{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-top:calc(44px + env(safe-area-inset-top));padding-bottom:calc(50px + env(safe-area-inset-bottom));position:relative;z-index:0}.user-profile-banner{width:100%;height:30vh;background:linear-gradient(135deg,#667eea,#764ba2);position:relative;overflow:visible;z-index:2}.user-profile-avatar-container{position:absolute;right:20px;bottom:0;display:flex;flex-direction:row;align-items:flex-end;gap:15px;z-index:20}.user-profile-avatar{width:80px;height:80px;border-radius:8px;background-color:#fff;display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:700;color:#333;border:3px solid #fff;box-shadow:0 2px 8px #00000026;background-size:cover;background-position:center;transform:translateY(50%);z-index:25;position:relative}.user-profile-name{color:#fff;font-size:20px;font-weight:700;text-shadow:0 1px 3px rgba(0,0,0,.3);text-align:right;max-width:200px;word-wrap:break-word;align-self:flex-end;margin-bottom:13px}.user-profile-moments{background-color:var(--bg-secondary);min-height:60vh;padding-top:40px;position:relative;z-index:1;overflow:visible;transition:background-color .3s ease}.user-profile-moments-empty{text-align:center;padding:80px 20px;color:var(--text-secondary);transition:color .3s ease}.user-profile-moments-list{padding:0 15px;background-color:var(--bg-secondary);overflow:visible;transition:background-color .3s ease}.user-profile-moment-item{background-color:var(--bg-primary);margin-bottom:8px;padding:15px;border-radius:8px;box-shadow:0 1px 3px var(--shadow-color);position:relative;overflow:visible;transition:all .3s ease}.user-profile-moment-content{font-size:14px;line-height:1.4;color:var(--text-primary);margin-bottom:10px;transition:color .3s ease}.user-profile-moment-images{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-bottom:10px}.user-profile-moment-image{width:100%;aspect-ratio:1;object-fit:cover;border-radius:4px}.user-profile-moment-meta{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:#999}.user-profile-moment-time{flex:1}.user-profile-moment-actions{display:flex;gap:15px}.user-profile-moment-action{color:var(--text-tertiary);cursor:pointer;transition:color .3s ease}.user-profile-moment-action:hover{color:var(--theme-primary)}.moment-actions-container{position:relative;display:inline-block}.moment-collapse-btn{display:inline-flex;align-items:center;justify-content:center;width:40px;height:20px;background:var(--bg-secondary);border:none;border-radius:10px;transition:background-color .3s ease;font-size:12px;color:var(--text-secondary);cursor:pointer;-webkit-user-select:none;user-select:none}.moment-collapse-btn:hover{background:#e0e0e0;color:#333}.moment-actions-menu{position:absolute;display:flex;background:#fff;border-radius:15px;box-shadow:0 2px 8px #00000026;opacity:0;visibility:hidden;bottom:120%;left:50%;transform:translate(-50%,10px);transition:opacity .2s ease,transform .2s ease;z-index:9999}.moment-actions-menu.active{opacity:1;visibility:visible;transform:translate(-50%)}.moment-action-btn{display:flex;align-items:center;justify-content:center;width:40px;height:30px;border:none;background:transparent;font-size:16px;cursor:pointer;transition:background-color .3s ease;-webkit-user-select:none;user-select:none}.moment-action-btn:first-child{border-radius:15px 0 0 15px}.moment-action-btn:last-child{border-radius:0 15px 15px 0}.moment-action-btn:only-child{border-radius:15px}.moment-action-btn:hover{background:#f5f5f5}.moment-likes{margin-top:8px;padding:8px 0;font-size:13px;color:#576b95;border-bottom:1px solid #f0f0f0}.moment-likes:empty{display:none}.moment-comment{color:var(--text-primary);margin-left:4px;transition:color .3s ease}.profile-moment-comments{margin-top:8px}.profile-moment-comment-item{align-items:flex-start}.profile-moment-comment{margin-bottom:8px;padding:8px;background:var(--bg-secondary);border-radius:4px;font-size:13px;position:relative;word-wrap:break-word;word-break:break-word;overflow-wrap:break-word;white-space:pre-wrap;transition:background-color .3s ease}.profile-moment-comment-author{color:var(--theme-primary);font-weight:700;cursor:pointer;line-height:16px;margin:0;transition:color .3s ease}.profile-moment-comment-text{font-size:14px;color:var(--text-primary);word-wrap:break-word;word-break:break-word;overflow-wrap:break-word;line-height:18px;margin:0;transition:color .3s ease}.profile-moment-comment-reply-btn{position:absolute;top:8px;right:8px;background:none;border:none;color:var(--text-tertiary);font-size:12px;cursor:pointer;padding:2px 6px;border-radius:3px;transition:all .3s ease}.profile-moment-comment-reply-btn:hover{background:var(--bg-tertiary);color:var(--text-secondary)}.moment-reply-input-container{margin-top:8px;padding:8px;background:var(--bg-primary);border:1px solid var(--border-color);border-radius:4px;display:none!important;transition:all .3s ease}.moment-reply-input-container.active{display:block!important}.moment-reply-input-container:not(.active) .moment-reply-input{display:none!important}.moment-reply-input-container:not(.active) .moment-reply-actions{display:none!important}.moment-reply-input{width:100%;border:none;outline:none;resize:none;font-size:13px;padding:8px;min-height:60px;border-radius:4px;background:var(--input-bg);color:var(--text-primary);transition:all .3s ease}.moment-reply-input::placeholder{color:var(--text-tertiary)}} .moment-reply-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:8px}.moment-reply-btn{padding:6px 12px;border:none;border-radius:4px;font-size:12px;cursor:pointer;transition:all .3s ease}.moment-reply-submit{background:var(--theme-primary);color:#fff}.moment-reply-submit:hover{background:#06ad56}.moment-reply-cancel{background:#f0f0f0;color:#666}.moment-reply-cancel:hover{background:#e0e0e0}.user-profile-banner:hover .banner-upload-hint{opacity:1!important}.banner-upload-container{margin-bottom:20px}.banner-upload-area{border:2px dashed #ddd;border-radius:8px;padding:40px 20px;text-align:center;cursor:pointer;transition:all .3s ease;background:#fafafa}.banner-upload-area:hover{border-color:#667eea;background:#f8f9ff}.banner-upload-area.dragover{border-color:#667eea;background:#e8f0ff}.banner-upload-icon{font-size:48px;margin-bottom:15px;opacity:.6}.banner-upload-text{font-size:16px;color:#333;margin-bottom:8px;font-weight:500}.banner-upload-hint{font-size:12px;color:#999}.banner-preview-container{margin-top:20px}.banner-preview-title{font-size:16px;color:#333;margin-bottom:15px;font-weight:500}.banner-preview-wrapper{border:2px solid #ddd;border-radius:8px;overflow:hidden;margin-bottom:15px;background:#f5f5f5;display:flex;justify-content:center;align-items:center}#bannerPreviewCanvas{display:block;max-width:100%;height:auto}.banner-crop-controls{margin-bottom:20px;display:flex;align-items:center;gap:10px}.banner-crop-controls label{font-size:14px;color:#333;min-width:100px}#bannerCropSlider{flex:1;height:6px;border-radius:3px;background:#ddd;outline:none;-webkit-appearance:none}#bannerCropSlider::-webkit-slider-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;background:#667eea;cursor:pointer;border:2px solid #fff;box-shadow:0 2px 4px #0003}#bannerCropSlider::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:#667eea;cursor:pointer;border:2px solid #fff;box-shadow:0 2px 4px #0003}.banner-upload-buttons{display:flex;gap:10px;justify-content:flex-end}.btn-secondary{padding:8px 16px;border:1px solid #ddd;border-radius:4px;background:#fff;color:#666;cursor:pointer;font-size:14px;transition:all .3s ease}.btn-secondary:hover{background:#f5f5f5;border-color:#bbb}.btn-primary{padding:8px 16px;border:none;border-radius:4px;background:#667eea;color:#fff;cursor:pointer;font-size:14px;transition:all .3s ease}.btn-primary:hover{background:#5a67d8}.appearance-management-page{position:absolute;top:0;left:0;width:100%;height:var(--viewport-height, 100vh);background-color:var(--bg-secondary);z-index:10;display:none;transition:background-color .3s ease}.appearance-management-page.active{display:block}.appearance-content{padding:20px;overflow-y:auto;height:calc(100vh - 60px)}.appearance-section{background:var(--bg-primary);border-radius:12px;padding:16px;margin-bottom:16px;box-shadow:0 2px 8px var(--shadow-color);transition:all .3s ease}.appearance-section-title{font-size:16px;font-weight:600;color:var(--text-primary);margin-bottom:6px;transition:color .3s ease}.appearance-section-desc{color:var(--text-secondary);font-size:13px;margin-bottom:12px;line-height:1.4;transition:color .3s ease}.theme-mode-grid{display:grid;grid-template-columns:1fr;gap:12px;margin-bottom:24px}.theme-mode-option{display:flex;align-items:flex-start;cursor:pointer;padding:16px;border-radius:12px;transition:all .3s ease;border:2px solid var(--border-color);background-color:var(--bg-primary);color:var(--text-primary)}.theme-mode-option:hover{border-color:var(--theme-primary);background-color:var(--theme-primary-light);transform:translateY(-2px);box-shadow:0 4px 12px var(--shadow-color)}.theme-mode-option.active{border-color:var(--theme-primary);background-color:var(--theme-primary-light);box-shadow:0 2px 8px var(--shadow-color)}.theme-mode-icon{font-size:24px;margin-right:12px;flex-shrink:0}.theme-mode-content{flex:1}.theme-mode-name{font-size:16px;font-weight:500;color:var(--text-primary);margin-bottom:4px}.theme-mode-desc{font-size:13px;color:var(--text-secondary)}.theme-color-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:16px}.theme-color-option{display:flex;flex-direction:column;align-items:center;cursor:pointer;padding:8px;border-radius:8px;transition:all .2s ease;border:2px solid transparent}.theme-color-option:hover{background-color:var(--bg-secondary);transform:translateY(-2px)}.theme-color-option.active{border-color:var(--theme-primary);background-color:var(--theme-primary-light)}.theme-color-preview{width:32px;height:32px;border-radius:50%;margin-bottom:6px;box-shadow:0 2px 6px #00000026;position:relative}.theme-color-option.active .theme-color-preview:after{content:"âœ“";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-weight:700;font-size:14px;text-shadow:0 1px 2px rgba(0,0,0,.3)}.theme-color-name{font-size:11px;color:var(--text-secondary);text-align:center;transition:color .3s ease}.theme-color-option.active .theme-color-name{color:var(--theme-primary);font-weight:600}.custom-color-section{border-top:1px solid var(--border-color);padding-top:16px;transition:border-color .3s ease}.custom-color-label{display:block;font-size:14px;font-weight:600;color:var(--text-primary);margin-bottom:8px;transition:color .3s ease}.custom-color-desc{color:var(--text-secondary);transition:color .3s ease;font-size:12px;margin-bottom:16px;line-height:1.4}.custom-color-preview-row{display:flex;align-items:center;gap:12px;margin-bottom:12px;flex-wrap:wrap}@media (max-width: 480px){.custom-color-preview-row{flex-direction:column;gap:16px;align-items:stretch}}.custom-color-preview-container{display:flex;flex-direction:column;align-items:center;gap:8px}.custom-color-preview-circle{width:60px;height:60px;border-radius:50%;border:3px solid #e0e0e0;cursor:pointer;transition:all .2s ease;position:relative;overflow:hidden;box-shadow:0 2px 8px #0000001a}.custom-color-preview-circle:hover{transform:scale(1.05);border-color:var(--theme-primary)}.custom-color-picker-hidden{position:absolute;top:-5px;left:-5px;width:70px;height:70px;border:none;background:none;opacity:0;cursor:pointer}.custom-color-picker-hidden::-webkit-color-swatch-wrapper{padding:0}.custom-color-picker-hidden::-webkit-color-swatch{border:none}.custom-color-preview-label{font-size:12px;color:#666;font-weight:500}.custom-color-input-container{display:flex;align-items:center;gap:8px;flex:1;min-width:0}@media (max-width: 480px){.custom-color-input-container{width:100%}}.custom-color-text{flex:1;padding:12px 16px;border:2px solid var(--border-color);border-radius:8px;background-color:var(--input-bg);color:var(--text-primary);font-family:SF Mono,Monaco,Inconsolata,Roboto Mono,monospace;font-size:14px;font-weight:500;text-transform:uppercase;transition:all .2s ease}.custom-color-text::placeholder{color:var(--text-tertiary)}.custom-color-text:focus{outline:none;border-color:var(--theme-primary);box-shadow:0 0 0 3px var(--theme-primary-light)}.custom-color-text.invalid{border-color:#ff4d4f;background-color:#fff2f0}.apply-custom-color-btn{padding:12px 16px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;min-width:60px;white-space:nowrap}@media (max-width: 480px){.apply-custom-color-btn{width:100%;margin-top:8px}}.apply-custom-color-btn:hover{background-color:var(--theme-primary-hover);transform:translateY(-1px)}.apply-custom-color-btn:active{transform:translateY(0)}.apply-custom-color-btn:disabled{background-color:#ccc;cursor:not-allowed;transform:none}.color-input-tips{margin-top:12px;padding:8px 12px;background-color:#f8f9fa;border-radius:6px;border-left:3px solid var(--theme-primary)}.color-input-tips small{color:#666;font-size:12px}.gradient-toggle-container{margin-bottom:20px}.gradient-toggle-label{display:flex;align-items:center;gap:12px;cursor:pointer;font-size:16px;font-weight:600;color:var(--text-primary);transition:color .3s ease}.gradient-toggle-input{display:none}.gradient-toggle-slider{width:50px;height:26px;background-color:#ccc;border-radius:13px;position:relative;transition:all .3s ease}.gradient-toggle-slider:before{content:"";position:absolute;width:20px;height:20px;border-radius:50%;background-color:#fff;top:3px;left:3px;transition:all .3s ease;box-shadow:0 2px 4px #0003}.gradient-toggle-input:checked+.gradient-toggle-slider{background-color:var(--theme-primary)}.gradient-toggle-input:checked+.gradient-toggle-slider:before{transform:translate(24px)}.gradient-settings{border-top:1px solid #eee;padding-top:20px;margin-top:20px}.gradient-color-row{display:flex;gap:20px;margin-bottom:20px}@media (max-width: 480px){.gradient-color-row{flex-direction:column;gap:16px}}.gradient-color-group{flex:1}.gradient-color-label{display:block;font-size:14px;font-weight:600;color:#333;margin-bottom:8px}.gradient-color-picker-container{display:flex;align-items:center;gap:8px}.gradient-color-preview{width:40px;height:40px;border-radius:8px;border:2px solid #e0e0e0;cursor:pointer;transition:all .2s ease;position:relative;overflow:hidden}.gradient-color-preview:hover{transform:scale(1.05);border-color:var(--theme-primary)}.gradient-color-picker-hidden{position:absolute;top:-2px;left:-2px;width:44px;height:44px;border:none;background:none;opacity:0;cursor:pointer}.gradient-color-text{flex:1;padding:10px 12px;border:2px solid #e0e0e0;border-radius:6px;font-family:SF Mono,Monaco,Inconsolata,Roboto Mono,monospace;font-size:13px;font-weight:500;text-transform:uppercase;transition:all .2s ease}.gradient-color-text:focus{outline:none;border-color:var(--theme-primary);box-shadow:0 0 0 2px var(--theme-primary-light)}.gradient-preview-container{margin-bottom:20px}.gradient-preview-label{display:block;font-size:14px;font-weight:600;color:#333;margin-bottom:8px}.gradient-preview-demo{height:80px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(to right,#07c160,#1890ff);box-shadow:0 4px 12px #0000001a}.gradient-preview-text{color:#fff;font-size:16px;font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,.3)}.gradient-direction-container{margin-bottom:20px}.gradient-direction-label{display:block;font-size:14px;font-weight:600;color:#333;margin-bottom:12px}.gradient-direction-options{display:flex;gap:12px;flex-wrap:wrap}.gradient-direction-option{display:flex;align-items:center;gap:6px;cursor:pointer;padding:8px 12px;border:2px solid #e0e0e0;border-radius:8px;transition:all .2s ease;background-color:#fff}.gradient-direction-option:hover{border-color:var(--theme-primary);background-color:#f8f9fa}.gradient-direction-option input[type=radio]{margin:0}.gradient-direction-option input[type=radio]:checked+.gradient-direction-text{color:var(--theme-primary);font-weight:600}.gradient-direction-option:has(input[type=radio]:checked){border-color:var(--theme-primary);background-color:var(--theme-primary-light)}.gradient-direction-text{font-size:14px;color:#666;transition:all .2s ease}.apply-gradient-btn{width:100%;padding:14px 20px;background:linear-gradient(135deg,var(--theme-primary),var(--theme-primary-hover));color:#fff;border:none;border-radius:10px;font-size:16px;font-weight:600;cursor:pointer;transition:all .2s ease;box-shadow:0 4px 12px #0000001a}.apply-gradient-btn:hover{transform:translateY(-2px);box-shadow:0 6px 16px #00000026}.apply-gradient-btn:active{transform:translateY(0)}.bubble-designer-option{margin-top:12px}.bubble-designer-btn{display:flex;align-items:center;width:100%;padding:16px;background:linear-gradient(135deg,#667eea,#764ba2);border:none;border-radius:12px;color:#fff;cursor:pointer;transition:all .3s ease;position:relative;overflow:hidden}.bubble-designer-btn:hover{transform:translateY(-2px);box-shadow:0 8px 25px #667eea66}.bubble-designer-btn:active{transform:translateY(0)}.bubble-designer-btn:before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);transition:left .5s}.bubble-designer-btn:hover:before{left:100%}.bubble-designer-icon{font-size:28px;margin-right:16px;flex-shrink:0;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.bubble-designer-info{flex:1;text-align:left}.bubble-designer-title{font-size:16px;font-weight:600;margin-bottom:4px;line-height:1.2}.bubble-designer-desc{font-size:13px;opacity:.9;line-height:1.3}.bubble-designer-arrow{font-size:20px;margin-left:12px;flex-shrink:0;opacity:.8}.coming-soon{display:flex;flex-direction:column;align-items:center;padding:40px 20px;color:#999}.coming-soon-icon{font-size:48px;margin-bottom:16px}.coming-soon-text{font-size:16px}html[data-keyboard-visible=true]{overflow:hidden}html[data-keyboard-visible=true] body{height:100vh;height:var(--viewport-height, 100vh)}html[data-keyboard-visible=true] .chat-input-area{transform:translateY(calc(-1 * var(--keyboard-height, 0px)));transition:transform .25s ease-out}html[data-keyboard-visible=true] .chat-messages{max-height:calc(var(--chat-content-height, 100vh) - var(--keyboard-height, 0px) - 60px);transition:max-height .25s ease-out}input,textarea,[contenteditable=true]{-webkit-user-select:text!important;-moz-user-select:text!important;-ms-user-select:text!important;user-select:text!important;-webkit-touch-callout:default!important}.chat-input:focus,input:focus,textarea:focus{outline:none;scroll-margin:20px}html{scroll-behavior:smooth;overscroll-behavior:contain}body{overscroll-behavior-y:contain;touch-action:pan-x pan-y}@supports (-webkit-touch-callout: none){.main-container{overscroll-behavior:none;-webkit-overflow-scrolling:touch}.chat-page{position:fixed;transform:translateZ(0)}}#qixiRetryModal .modal-content{background:linear-gradient(135deg,#ff9a9e,#fecfef,#fecfef);color:#8b5cf6;border-radius:20px;box-shadow:0 20px 40px #ff69b44d;animation:qixiModalShow .4s ease-out}#qixiRetryModal .modal-header{background:transparent;border-bottom:2px solid rgba(255,255,255,.3);padding:20px 24px 16px}#qixiRetryModal .modal-title{font-size:20px;font-weight:700;text-align:center;color:#8b5cf6;text-shadow:0 1px 2px rgba(255,255,255,.8)}#qixiRetryModal .modal-close{background:#ffffff4d;color:#8b5cf6;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:16px;font-weight:700;transition:all .3s ease}#qixiRetryModal .modal-close:hover{background:#ffffff80;transform:scale(1.1)}.qixi-retry-content{text-align:center;padding:20px 24px 24px}.qixi-retry-icon{font-size:48px;margin-bottom:16px;animation:qixiHeartbeat 1.5s ease-in-out infinite}.qixi-retry-message{color:#8b5cf6;line-height:1.6}.qixi-retry-message p{margin-bottom:12px;font-size:16px}.qixi-retry-message strong{color:#7c3aed;font-weight:600}.qixi-retry-buttons{display:flex;gap:12px;padding:0 24px 24px;flex-direction:column}.qixi-retry-btn{background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;border:none;border-radius:12px;padding:14px 20px;font-size:16px;font-weight:600;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 15px #8b5cf64d}.qixi-retry-btn:hover{transform:translateY(-2px);box-shadow:0 6px 20px #8b5cf666}.qixi-cancel-btn{background:#ffffffb3;color:#8b5cf6;border:2px solid rgba(139,92,246,.3);border-radius:12px;padding:12px 20px;font-size:14px;font-weight:500;cursor:pointer;transition:all .3s ease}.qixi-cancel-btn:hover{background:#ffffffe6;border-color:#8b5cf680}@keyframes qixiModalShow{0%{opacity:0;transform:translateY(20px) scale(.95)}to{opacity:1;transform:translateY(0) scale(1)}}@keyframes qixiHeartbeat{0%,to{transform:scale(1)}50%{transform:scale(1.1)}}@media (max-width: 480px){.qixi-retry-buttons{flex-direction:column;gap:8px}.qixi-retry-icon{font-size:40px}.qixi-retry-message p{font-size:15px}}.config-management-section{margin-bottom:24px;padding:16px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-color)}.config-selector-row{display:flex;align-items:end;gap:12px}.config-selector-group{flex:1}.config-actions{display:flex;gap:6px}.config-action-btn{width:36px;height:36px;border:1px solid var(--border-color);background:var(--bg-primary);color:var(--text-primary);border-radius:6px;cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;transition:all .2s ease}.config-action-btn:hover{background:var(--theme-primary-light);border-color:var(--theme-primary)}.config-delete-btn:hover{background:#ff4d4f1a;border-color:#ff4d4f;color:#ff4d4f}.config-section{margin-bottom:20px;padding:16px;border:1px solid var(--border-color);border-radius:8px;background:var(--bg-secondary)}.config-section-title{font-weight:600;font-size:16px;color:var(--text-primary);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border-color)}.form-actions{margin-top:20px;padding-top:16px;border-top:1px solid var(--border-color)}#configSelector{font-weight:500}#configSelector option[data-is-default=true]{font-weight:600;color:var(--theme-primary)}.key-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}.key-header .form-label{margin:0;flex:1}.compact-key-row{display:flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid #e1e5e9;border-radius:6px;background:#f8f9fa;margin-top:5px;position:relative}.main-key-row{background:#f8f9fa;border-color:#e1e5e9}.main-key-row.enabled{background:linear-gradient(135deg,#e8f5e8,#f0f8f0);border-color:#28a745}.additional-key-row{background:#f5f5f5}.compact-key-input{flex:1;min-width:120px;font-size:14px;padding:6px 8px;border:1px solid #ddd;border-radius:4px}.timeout-group{display:flex;align-items:center;gap:2px;white-space:nowrap}.timeout-input{width:40px;padding:4px;border:1px solid #ddd;border-radius:3px;font-size:12px;text-align:center}.timeout-unit{font-size:12px;color:#666;min-width:8px}.key-status-btn,.key-enable-btn{width:24px;height:24px;border:none;border-radius:50%;font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;background:#6c757d}.key-enable-btn:hover{opacity:.8}.main-key-status{background:transparent!important;cursor:default}.key-stats-compact{position:absolute;bottom:2px;right:8px;font-size:10px;color:#666;text-align:right;line-height:1.2}.key-masked-compact{font-family:monospace;font-size:9px;color:#777;margin-bottom:1px}.stats-compact{font-size:9px;color:#888}.remove-provider-btn{background:#dc3545;color:#fff;border:none;border-radius:50%;width:18px;height:18px;font-size:11px;cursor:pointer;margin-left:6px;padding:0;line-height:18px;display:inline-flex;align-items:center;justify-content:center;vertical-align:middle;box-sizing:border-box;flex-shrink:0;position:relative;z-index:10;pointer-events:auto}.remove-provider-btn:hover{background:#c82333}.remove-provider-btn:active{transform:scale(.95)}@media (max-width: 480px){.config-selector-row{flex-direction:column;align-items:stretch;gap:8px}.config-actions{justify-content:center;margin-top:8px}.config-section{margin-bottom:16px;padding:12px}.compact-key-row{flex-wrap:wrap;padding:6px 8px;gap:6px}.compact-key-input{min-width:100px;font-size:14px}.timeout-group{order:3}.key-status-btn,.key-enable-btn{order:2}.key-stats-compact{position:static;order:4;width:100%;text-align:left;margin-top:4px;font-size:11px}.timeout-input{width:35px}}#persistentStatusIndicator[data-status=persistent]{color:#28a745}#persistentStatusIndicator[data-status=not-persistent]{color:#ffc107}#persistentStatusIndicator[data-status=unknown],#persistentStatusIndicator[data-status=requesting]{color:#6c757d}#persistentStatusIndicator[data-status=error]{color:#dc3545}.info-modal.modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background-color:var(--overlay-bg);display:flex;align-items:center;justify-content:center;z-index:10000;padding:20px;transition:opacity .2s ease-in-out}.info-modal.modal-overlay.hidden{display:none}.info-modal .modal-content{background:var(--modal-bg);border-radius:8px;padding:0;max-width:400px;max-height:80vh;overflow:hidden;box-shadow:0 4px 12px var(--shadow-color);color:var(--text-primary);animation:infoModalSlideIn .2s ease-out}@keyframes infoModalSlideIn{0%{opacity:0;transform:translateY(-20px)}to{opacity:1;transform:translateY(0)}}.info-modal .modal-header{font-size:16px;font-weight:700;padding:20px 20px 15px;color:var(--text-primary);border-bottom:1px solid var(--border-color)}.info-modal .modal-body{padding:20px;font-size:14px;line-height:1.6;color:var(--text-secondary);max-height:50vh;overflow-y:auto}.info-modal .modal-body p{margin-bottom:10px}.info-modal .modal-body ul{margin:8px 0;padding-left:20px}.info-modal .modal-body li{margin-bottom:4px}.info-modal .modal-footer{padding:15px 20px;border-top:1px solid var(--border-color);display:flex;justify-content:flex-end}.info-modal .modal-close-btn{flex:1;padding:10px;background:var(--theme-secondary);color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:14px;transition:background-color .2s ease}.info-modal .modal-close-btn:hover{background:var(--theme-secondary-hover)}.info-modal .modal-close-btn:active{background:var(--theme-secondary-active)}.info-button{width:18px;height:18px;border-radius:50%;background:var(--theme-primary);color:#fff;border:none;cursor:pointer;font-size:10px;display:flex;align-items:center;justify-content:center;font-weight:700;transition:background-color .2s ease}.info-button:hover{background:var(--theme-primary-hover)}.info-button:active{background:var(--theme-primary);transform:scale(.95)}.request-persistent-btn{padding:5px 10px;font-size:12px;background:#17a2b8;color:#fff;border:none;border-radius:4px;cursor:pointer;transition:background-color .2s ease}.request-persistent-btn:hover{background:#138496}.request-persistent-btn:disabled{background:#6c757d;cursor:not-allowed}.request-persistent-btn:active{background:#117a8b}@media (max-width: 480px){.info-modal .modal-content{max-width:90vw;margin:0 auto}.info-modal .modal-header{font-size:15px;padding:15px}.info-modal .modal-body{padding:15px;font-size:13px}.info-modal .modal-footer{padding:15px}.chat-input-area{padding:6px 8px 8px;gap:4px}.input-actions{gap:2px}.action-btn{width:26px;height:26px;font-size:18px}.chat-input{padding:6px 10px;font-size:16px}.send-btn{padding:6px 10px;font-size:13px}}@media (max-width: 360px){.chat-input-area{padding:4px 6px 6px;gap:3px}.input-actions{gap:1px}.action-btn{width:24px;height:24px;font-size:16px}.send-btn{padding:4px 8px;font-size:12px}.chat-input{padding:4px 8px}}.form-step-hint{display:none;margin-top:10px;padding:8px 12px;background-color:#e8f5e8;border-radius:4px;font-size:12px;color:#2d5a2d;border-left:3px solid #28a745;animation:slideInDown .3s ease-out}.form-step-reminder{padding:10px 15px;background-color:#fff3cd;border-left:4px solid #ffc107;border-radius:4px;font-size:13px;color:#856404;margin-bottom:15px;animation:fadeIn .5s ease-out}.form-submit small{opacity:.8;font-weight:400;font-size:11px}@keyframes slideInDown{0%{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.form-step-reminder strong{color:#d4470b;font-weight:600}.form-step-hint:before{content:"";display:inline-block;width:4px;height:4px;background-color:#28a745;border-radius:50%;margin-right:6px;animation:pulse 1.5s infinite}@keyframes pulse{0%{opacity:1}50%{opacity:.5}to{opacity:1}}.dark-mode .form-step-hint{background-color:#1a2f1a;color:#8bc48b;border-left-color:#28a745}.dark-mode .form-step-reminder{background-color:#2a2516;color:#d4c669;border-left-color:#ffc107}.dark-mode .form-step-reminder strong{color:#f8a15b}.final-step-hint{margin:15px 0 10px;padding:8px 12px;background-color:#f0f8ff;border-left:3px solid #0066cc;border-radius:4px;font-size:13px;color:#06c;animation:fadeIn .5s ease-out}.dark-mode .final-step-hint{background-color:#1a2a3a;color:#66b3ff;border-left-color:#09f}@keyframes slideInDown{0%{opacity:0;transform:translate(-50%) translateY(-20px)}to{opacity:1;transform:translate(-50%) translateY(0)}}@keyframes slideOutUp{0%{opacity:1;transform:translate(-50%) translateY(0)}to{opacity:0;transform:translate(-50%) translateY(-20px)}}.image-container{position:relative;display:inline-block}.vision-support-indicator{position:absolute;top:4px;right:4px;width:20px;height:20px;background:var(--theme-primary);color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700;box-shadow:0 2px 4px #0003;border:2px solid white;z-index:10;animation:fadeIn .3s ease-in-out}.gradient-mode .vision-support-indicator{background:var(--theme-gradient)}.dark-mode .vision-support-indicator{border-color:var(--bg-primary);box-shadow:0 2px 4px #0006}</style>
</head>
<body>
    <!-- é¡µé¢ä¸»ä½“å†…å®¹ä¿æŒä¸å˜ -->
    <div class="main-container">
        <div class="contact-list-page active" id="contactListPage">
            <div class="wechat-header">
                <div class="header-title">Whale-LLT</div>
                <div class="header-actions">
                    <span class="header-icon" id="apiSettingsIcon">âš™ï¸</span>
                    <span class="header-icon" id="musicIcon" onclick="showMusicModal()" data-umami-event="Music Open">ğŸµ</span>
                    <span class="header-icon" onclick="showAddContactModal()" data-umami-event="Add Contact Open">â•</span>
                    <span class="header-icon" onclick="showCreateGroupModal()" data-umami-event="Create Group Open">ğŸ‘¥</span>
                </div>
            </div>
            
            <div class="search-bar">
                <input type="text" class="search-input" placeholder="æœç´¢">
            </div>
            
            <div id="contactList"></div>
        </div>

        <div class="chat-page" id="chatPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>â€¹</span>
                    <span>Whale-LLT</span>
                </div>
                <div class="chat-title" id="chatTitle">èŠå¤©</div>
                <div class="chat-header-actions">
                    <div class="memory-btn" onclick="event.stopPropagation(); toggleMemoryPanel()">
                        <svg t="1689237694389" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4338" width="24" height="24"><path d="M896 96H128C110.4 96 96 110.4 96 128v768c0 17.6 14.4 32 32 32h768c17.6 0 32-14.4 32-32V128c0-17.6-14.4-32-32-32zM384 832H192v-64h192v64z m0-192H192v-64h192v64z m0-192H192v-64h192v64z m448 384H448v-64h384v64z m0-192H448v-64h384v64z m0-192H448v-64h384v64z" p-id="4339" fill="#515151"></path></svg>
                    </div>
                    <div class="chat-more" onclick="openContactSettingsPage()">â‹¯</div>
                </div>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="messages-scroll-content"></div>
            </div>
            
            <div class="chat-input-area">
                <div class="feature-hint" id="featureHint">æŒ‰Enterå‘é€æ¶ˆæ¯ï¼Œç‚¹"å‘é€"æŒ‰é’®è·å–AIå›å¤</div>
                <div class="input-actions">
                    <div class="action-btn" onclick="toggleEmojiPanel()" data-umami-event="Emoji Panel Toggle">ğŸ˜Š</div>
                    <div class="action-btn" onclick="showRedPacketModal()" data-umami-event="Red Packet Open">ğŸ§§</div>
                    <div class="action-btn" onclick="triggerImageUpload()" data-umami-event="Image Upload Open">ğŸï¸</div>
                </div>
                
                <!-- éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† -->
                <input type="file" id="chatImageInput" accept="image/*" style="display: none;" onchange="handleChatImageUpload(event)">
                <textarea class="chat-input" id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯" rows="1"></textarea>
                <button class="send-btn" id="sendBtn" onclick="sendMessage()" data-umami-event="Message Send">å‘é€</button>
                
                <div class="emoji-panel" id="emojiPanel">
                    <div class="emoji-grid" id="emojiGrid">
                        <div class="add-emoji-btn" onclick="showAddEmojiModal()">+ æ·»åŠ è¡¨æƒ…</div>
                    </div>
                </div>
            </div>

            <div class="memory-panel" id="memoryPanel">
                <div class="memory-panel-header">
                    <div class="memory-panel-title">è®°å¿†è¡¨æ ¼</div>
                    <div class="memory-panel-actions">
                         <button id="memoryEditBtn" class="memory-panel-btn" onclick="toggleMemoryEditMode()" data-umami-event="Memory Table Edit Toggle">ç¼–è¾‘</button>
                         <button class="memory-panel-btn" onclick="event.stopPropagation(); toggleMemoryPanel()">å…³é—­</button>
                    </div>
                </div>
                <div class="memory-panel-content">
                    <div id="memoryTableView" class="memory-table-view"></div>
                    <textarea id="memoryTextarea" class="memory-textarea" style="display: none;"></textarea>
                </div>
            </div>
        </div>

        <div class="moments-page" id="momentsPage">
            <div class="moments-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="chat-title">æœ‹å‹åœˆ</div>
                <div class="chat-more" onclick="showPublishMomentModal()">â•</div>
            </div>
            
            <div class="moments-content" id="momentsContent">
                <div class="moments-empty" id="momentsEmpty">
                    <div class="moments-empty-icon">ğŸ“</div>
                    <div class="moments-empty-text">è¿˜æ²¡æœ‰æœ‹å‹åœˆåŠ¨æ€</div>
                    <button class="moments-empty-btn" onclick="showPublishMomentModal()">å‘å¸ƒç¬¬ä¸€æ¡åŠ¨æ€</button>
                </div>
                
                <div class="moments-list" id="momentsList" style="display: none;"></div>
            </div>
        </div>

        <div class="interactive-page" id="interactivePage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>â€¹</span>
                    <span>äº’åŠ¨ç•Œé¢</span>
                </div>
                <div class="header-actions">
                    <div class="sync-btn" onclick="syncInteractiveData()" title="åŒæ­¥è§’è‰²æ•°æ®">ğŸ”„</div>
                </div>
            </div>
            <div class="interactive-content">
                <iframe id="interactiveFrame" srcdoc="<!DOCTYPE html>
<html lang=&quot;zh-CN&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;>
    <title>äº’åŠ¨é¡µé¢</title>
    <script src=&quot;https://cdn.tailwindcss.com&quot;></script>
    <script src=&quot;https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js&quot;></script>
    
    <!-- Environment Configuration -->
    <script>
/**
 * ç¯å¢ƒé…ç½®ç³»ç»Ÿ - æ”¯æŒæ„å»ºæ—¶ç¯å¢ƒå˜é‡æ³¨å…¥
 * æ”¯æŒ Vercel å’Œ Netlify éƒ¨ç½²å¹³å°
 */
class EnvironmentConfig {
    /**
     * ç¯å¢ƒæŒ‡ç¤ºå™¨å…³é”®è¯é…ç½®
     * å½“ç¯å¢ƒæ ‡ç­¾åŒ…å«è¿™äº›å…³é”®è¯æ—¶ï¼Œå°†æ˜¾ç¤ºç¯å¢ƒæŒ‡ç¤ºå™¨
     */
    static INDICATOR_KEYWORDS = ['æµ‹è¯•', 'å¼€å‘', 'test', 'dev'];

    /**
     * æ„å»ºæ—¶ç¯å¢ƒå˜é‡å ä½ç¬¦
     * è¿™äº›å°†åœ¨æ„å»ºè¿‡ç¨‹ä¸­è¢«å®é™…å€¼æ›¿æ¢
     */
    static BUILD_TIME_CONFIG = {
        // ç¯å¢ƒç±»å‹: development, staging, production
        ENVIRONMENT: 'production',
        // åº”ç”¨ç‰ˆæœ¬
        APP_VERSION: '1.0.0',
        // æ„å»ºæ—¶é—´æˆ³
        BUILD_TIMESTAMP: '2025-09-15T15:34:10.370Z',
        // Git æäº¤å“ˆå¸Œ
        GIT_COMMIT: '4e267410f8c8f2ca802f712b0c44b36b73ab3f07',
        // æ˜¯å¦ä¸ºå¼€å‘ç‰ˆæœ¬
        IS_DEVELOPMENT: 'false',
        // è‡ªå®šä¹‰æ ‡ç­¾
        ENVIRONMENT_LABEL: ''
    };

    /**
     * è·å–å½“å‰ç¯å¢ƒé…ç½®
     */
    static getEnvironment() {
        // ä¼˜å…ˆä½¿ç”¨æ„å»ºæ—¶æ³¨å…¥çš„ç¯å¢ƒå˜é‡
        let environment = this.BUILD_TIME_CONFIG.ENVIRONMENT;
        let isDevelopment = this.BUILD_TIME_CONFIG.IS_DEVELOPMENT;
        let environmentLabel = this.BUILD_TIME_CONFIG.ENVIRONMENT_LABEL;

        // å¦‚æœæ²¡æœ‰è¢«æ›¿æ¢ï¼ˆä»ç„¶åŒ…å«èŠ±æ‹¬å·ï¼‰ï¼Œåˆ™å›é€€åˆ°è¿è¡Œæ—¶æ£€æµ‹
        if (environment.includes('{{')) {
            environment = this.detectEnvironmentFromURL();
            isDevelopment = environment !== 'production';
            environmentLabel = this.getDefaultEnvironmentLabel(environment);
        } else {
            // å¤„ç†å­—ç¬¦ä¸²å½¢å¼çš„å¸ƒå°”å€¼
            isDevelopment = isDevelopment === 'true' || isDevelopment === true;
        }

        return {
            environment,
            isDevelopment,
            environmentLabel,
            version: this.getVersion(),
            buildTime: this.getBuildTime(),
            gitCommit: this.getGitCommit()
        };
    }

    /**
     * é€šè¿‡URLæ£€æµ‹ç¯å¢ƒï¼ˆå›é€€æ–¹æ¡ˆï¼‰
     */
    static detectEnvironmentFromURL() {
        if (typeof window === 'undefined') return 'production';

        const hostname = window.location.hostname;

        // æœ¬åœ°å¼€å‘ç¯å¢ƒ
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('192.168.')) {
            return 'development';
        }

        // Vercel Preview éƒ¨ç½²
        if (hostname.includes('-git-') || hostname.includes('.vercel.app')) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯ dev åˆ†æ”¯æˆ–åŒ…å« dev ç›¸å…³æ ‡è¯†
            if (hostname.includes('-dev-') || hostname.includes('-develop-') || 
                hostname.includes('-test-') || hostname.includes('-staging-')) {
                return 'staging';
            }
            // Vercel çš„ä¸»åˆ†æ”¯éƒ¨ç½²é€šå¸¸æ˜¯ç”Ÿäº§ç¯å¢ƒ
            return hostname.includes('main') ? 'production' : 'staging';
        }

        // Netlify éƒ¨ç½²
        if (hostname.includes('.netlify.app')) {
            // æ£€æŸ¥åŸŸåä¸­æ˜¯å¦åŒ…å«å¼€å‘ç›¸å…³å…³é”®è¯
            if (hostname.includes('dev') || hostname.includes('test') || 
                hostname.includes('staging') || hostname.includes('preview')) {
                return 'staging';
            }
            
            // Netlify çš„ branch éƒ¨ç½²æ£€æµ‹ï¼ˆæ ¼å¼ï¼šbranch--sitename.netlify.appï¼‰
            if (hostname.includes('--')) {
                const parts = hostname.split('--');
                const branchName = parts[0];
                if (branchName &amp;&amp; (branchName.includes('dev') || branchName.includes('test'))) {
                    return 'staging';
                }
            }
            
            // é»˜è®¤ä¸ºç”Ÿäº§ç¯å¢ƒ
            return 'production';
        }

        // è‡ªå®šä¹‰åŸŸåé»˜è®¤ä¸ºç”Ÿäº§ç¯å¢ƒ
        return 'production';
    }

    /**
     * è·å–é»˜è®¤ç¯å¢ƒæ ‡ç­¾
     */
    static getDefaultEnvironmentLabel(environment) {
        switch (environment) {
            case 'development':
                return 'å¼€å‘ç¯å¢ƒ';
            case 'staging':
                return 'æµ‹è¯•ç¯å¢ƒ';
            case 'production':
            default:
                return null; // ç”Ÿäº§ç¯å¢ƒä¸æ˜¾ç¤ºæ ‡ç­¾
        }
    }

    /**
     * è·å–åº”ç”¨ç‰ˆæœ¬
     */
    static getVersion() {
        // ä¼˜å…ˆä½¿ç”¨ git commit hash çš„å‰7ä½ä½œä¸ºç‰ˆæœ¬æ˜¾ç¤º
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        if (gitCommit !== 'unknown' &amp;&amp; gitCommit.length >= 7) {
            return gitCommit.substring(0, 7);
        }
        
        // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„ git commit hashï¼Œå›é€€åˆ°åº”ç”¨ç‰ˆæœ¬å·
        let version = this.BUILD_TIME_CONFIG.APP_VERSION;
        return version.includes('{{') ? 'dev' : version;
    }

    /**
     * è·å–æ„å»ºæ—¶é—´
     */
    static getBuildTime() {
        let buildTime = this.BUILD_TIME_CONFIG.BUILD_TIMESTAMP;
        return buildTime.includes('{{') ? new Date().toISOString() : buildTime;
    }

    /**
     * è·å– Git æäº¤å“ˆå¸Œ
     */
    static getGitCommit() {
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        return gitCommit.includes('{{') ? 'unknown' : gitCommit;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦åº”è¯¥æ˜¾ç¤ºç¯å¢ƒæŒ‡ç¤ºå™¨
     * åœ¨ä»¥ä¸‹æƒ…å†µä¸‹æ˜¾ç¤ºï¼š
     * 1. éç”Ÿäº§ç¯å¢ƒ
     * 2. ç¯å¢ƒæ ‡ç­¾åŒ…å«&quot;æµ‹è¯•&quot;æˆ–&quot;å¼€å‘&quot;å…³é”®è¯
     */
    static shouldShowEnvironmentIndicator() {
        const config = this.getEnvironment();
        
        // éç”Ÿäº§ç¯å¢ƒå§‹ç»ˆæ˜¾ç¤º
        if (config.environment !== 'production') {
            return true;
        }
        
        // æ£€æŸ¥ç¯å¢ƒæ ‡ç­¾æ˜¯å¦åŒ…å«æŒ‡ç¤ºå™¨å…³é”®è¯
        if (config.environmentLabel) {
            const label = config.environmentLabel.toLowerCase();
            return this.INDICATOR_KEYWORDS.some(keyword => label.includes(keyword));
        }
        
        return false;
    }

    /**
     * è·å–ç¯å¢ƒæŒ‡ç¤ºå™¨é…ç½®
     * æ ¹æ®shouldShowEnvironmentIndicatorçš„é€»è¾‘å†³å®šæ˜¯å¦è¿”å›é…ç½®
     */
    static getEnvironmentIndicatorConfig() {
        const config = this.getEnvironment();
        
        // ä½¿ç”¨shouldShowEnvironmentIndicatoræ–¹æ³•ç»Ÿä¸€åˆ¤æ–­é€»è¾‘
        if (!this.shouldShowEnvironmentIndicator()) {
            return null;
        }

        // è¿”å›ç¯å¢ƒæŒ‡ç¤ºå™¨é…ç½®
        return {
            text: config.environmentLabel ? `${config.environmentLabel} - å¼€å‘ä¸­å†…å®¹ï¼Œä¸ä»£è¡¨æœ€ç»ˆæˆæœ` : 'å¼€å‘ä¸­å†…å®¹ï¼Œä¸ä»£è¡¨æœ€ç»ˆæˆæœ',
            version: config.version,
            environment: config.environment
        };
    }

    /**
     * æ‰“å°ç¯å¢ƒä¿¡æ¯åˆ°æ§åˆ¶å°
     */
    static printEnvironmentInfo() {
        const config = this.getEnvironment();
        console.group('ğŸŒ Environment Info');
        console.log('Environment:', config.environment);
        console.log('Development Mode:', config.isDevelopment);
        console.log('Version:', config.version);
        console.log('Build Time:', config.buildTime);
        console.log('Git Commit:', config.gitCommit);
        if (config.environmentLabel) {
            console.log('Label:', config.environmentLabel);
        }
        console.groupEnd();
    }
}

// å¯¼å‡ºé…ç½®
if (typeof module !== 'undefined' &amp;&amp; module.exports) {
    module.exports = EnvironmentConfig;
} else {
    window.EnvironmentConfig = EnvironmentConfig;
}

</script>
    <script>
/**
 * ç¯å¢ƒæŒ‡ç¤ºå™¨ç»„ä»¶
 * åœ¨éç”Ÿäº§ç¯å¢ƒä¸‹æ˜¾ç¤ºç¯å¢ƒæç¤ºä¿¡æ¯
 */
class EnvironmentIndicator {
    constructor() {
        this.indicator = null;
        this.isVisible = false;
    }

    /**
     * åˆå§‹åŒ–ç¯å¢ƒæŒ‡ç¤ºå™¨
     */
    init() {
        // ç¡®ä¿ EnvironmentConfig å·²åŠ è½½
        if (typeof EnvironmentConfig === 'undefined') {
            console.warn('EnvironmentConfig not loaded, environment indicator disabled');
            return;
        }

        // è°ƒè¯•ï¼šæ‰“å°å½“å‰ç¯å¢ƒä¿¡æ¯
        console.log('ğŸŒ Environment Indicator Initializing...');
        const envInfo = EnvironmentConfig.getEnvironment();
        console.log('Environment Info:', envInfo);

        const config = EnvironmentConfig.getEnvironmentIndicatorConfig();
        console.log('Indicator Config:', config);
        
        if (config) {
            this.createIndicator(config);
            this.show();
            console.log('âœ… Environment indicator created and shown');
            
            // æ‰“å°ç¯å¢ƒä¿¡æ¯åˆ°æ§åˆ¶å°
            EnvironmentConfig.printEnvironmentInfo();
        } else {
            console.log('âŒ Environment indicator not shown (production or disabled)');
        }
    }

    /**
     * åˆ›å»ºæŒ‡ç¤ºå™¨DOMå…ƒç´ 
     */
    createIndicator(config) {
        // é¿å…é‡å¤åˆ›å»º
        if (this.indicator) {
            this.indicator.remove();
        }

        const indicator = document.createElement('div');
        indicator.className = 'environment-indicator';
        indicator.innerHTML = `
            <div class=&quot;environment-indicator-content&quot;>
                <span class=&quot;environment-text&quot;>${config.text}</span>
                <span class=&quot;environment-version&quot;>${config.version}</span>
            </div>
        `;

        // è®¾ç½®æ ·å¼
        this.setIndicatorStyles(indicator, config);
        
        this.indicator = indicator;
        document.body.appendChild(indicator);
    }

    /**
     * è®¾ç½®æŒ‡ç¤ºå™¨æ ·å¼
     */
    setIndicatorStyles(element, config) {
        // ä½¿ç”¨ setProperty æ–¹æ³•åº”ç”¨å…³é”®æ ·å¼ä»¥ç¡®ä¿ä¼˜å…ˆçº§
        element.style.setProperty('position', 'fixed', 'important');
        element.style.setProperty('bottom', '52px', 'important');
        element.style.setProperty('left', '50%', 'important');
        element.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
        element.style.setProperty('backgroundColor', 'transparent', 'important');
        element.style.setProperty('color', '#ff6600', 'important');
        element.style.setProperty('z-index', '999999', 'important');
        element.style.setProperty('pointer-events', 'none', 'important');
        
        // åº”ç”¨å…¶ä»–æ ·å¼
        const additionalStyles = {
            padding: '4px 0',
            borderRadius: '0',
            fontSize: '11px',
            fontWeight: '500',
            fontFamily: '-apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, sans-serif',
            boxShadow: 'none',
            userSelect: 'none',
            opacity: '0.8',
            maxWidth: '300px',
            lineHeight: '1.1',
            textAlign: 'center',
            transition: 'opacity 0.3s ease-in-out',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
        };

        Object.assign(element.style, additionalStyles);

        // ä¸ºå†…å®¹å®¹å™¨è®¾ç½®æ ·å¼
        const content = element.querySelector('.environment-indicator-content');
        if (content) {
            Object.assign(content.style, {
                display: 'inline', // æ”¹ä¸ºå†…è”æ˜¾ç¤º
                gap: '0'
            });
        }

        // ä¸ºç‰ˆæœ¬å·è®¾ç½®æ ·å¼
        const version = element.querySelector('.environment-version');
        if (version) {
            Object.assign(version.style, {
                fontSize: '10px',
                opacity: '0.7',
                fontWeight: 'normal',
                marginLeft: '4px'
            });
        }
    }

    /**
     * æ˜¾ç¤ºæŒ‡ç¤ºå™¨
     */
    show() {
        if (this.indicator &amp;&amp; !this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
            this.indicator.style.setProperty('opacity', '0.8', 'important');
            this.isVisible = true;
        }
    }

    /**
     * éšè—æŒ‡ç¤ºå™¨
     */
    hide() {
        if (this.indicator &amp;&amp; this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(100%)', 'important');
            this.indicator.style.setProperty('opacity', '0', 'important');
            this.isVisible = false;
            
            // å»¶è¿Ÿç§»é™¤å…ƒç´ 
            setTimeout(() => {
                if (this.indicator &amp;&amp; this.indicator.parentNode) {
                    this.indicator.parentNode.removeChild(this.indicator);
                }
                this.indicator = null;
            }, 300);
        }
    }

    /**
     * åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
     */
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.init();
        }
    }

    /**
     * é”€æ¯æŒ‡ç¤ºå™¨
     */
    destroy() {
        this.hide();
    }
}

/**
 * å…¨å±€ç¯å¢ƒæŒ‡ç¤ºå™¨å®ä¾‹
 */
window.environmentIndicator = new EnvironmentIndicator();

/**
 * DOMåŠ è½½å®Œæˆåè‡ªåŠ¨åˆå§‹åŒ–
 */
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.environmentIndicator.init();
    });
} else {
    // å¦‚æœDOMå·²ç»åŠ è½½å®Œæˆ
    window.environmentIndicator.init();
}

/**
 * å¼€å‘è°ƒè¯•åŠŸèƒ½
 * åœ¨æ§åˆ¶å°ä¸­å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š
 * - environmentIndicator.toggle() - åˆ‡æ¢æ˜¾ç¤º
 * - environmentIndicator.hide() - éšè—æŒ‡ç¤ºå™¨  
 * - environmentIndicator.show() - æ˜¾ç¤ºæŒ‡ç¤ºå™¨
 * - EnvironmentConfig.printEnvironmentInfo() - æ‰“å°ç¯å¢ƒä¿¡æ¯
 */
if (typeof EnvironmentConfig !== 'undefined') {
    const config = EnvironmentConfig.getEnvironment();
    if (config.isDevelopment) {
        console.log('ğŸ”§ Environment Indicator Debug Commands:');
        console.log('  environmentIndicator.toggle() - Toggle indicator');
        console.log('  environmentIndicator.hide() - Hide indicator');
        console.log('  environmentIndicator.show() - Show indicator');
        console.log('  EnvironmentConfig.printEnvironmentInfo() - Print env info');
    }
}
</script>
    
    <!-- ğŸ”¥ ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨ - æ›¿ä»£æ‰€æœ‰æ•°æ®åº“ç›¸å…³æ¨¡å— -->
    <script>
/**
 * ğŸ”¥ ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨ - ç»ˆæç®€åŒ–ç‰ˆ
 * 
 * è®¾è®¡ç›®æ ‡ï¼š
 * 1. å•ä¸€è´£ä»»ï¼šæ‰€æœ‰æ•°æ®åº“æ“ä½œçš„å”¯ä¸€å…¥å£
 * 2. çŠ¶æ€åŒæ­¥ï¼šè‡ªåŠ¨å¤„ç†è·¨é¡µé¢çŠ¶æ€åŒæ­¥
 * 3. ç®€å•å¯é ï¼šå•ä¸€åˆå§‹åŒ–æ–¹æ³•ï¼Œè‡ªåŠ¨é”™è¯¯æ¢å¤
 * 4. åŠŸèƒ½å®Œæ•´ï¼šæ•´åˆæ‰€æœ‰ç°æœ‰æ•°æ®åº“åŠŸèƒ½
 * 5. å‘åå…¼å®¹ï¼šä¿æŒç°æœ‰APIæ¥å£ä¸å˜
 * 
 * âš ï¸ ARCHITECTURAL DEBT WARNING:
 * This file currently mixes database operations with UI concerns (DOM manipulation,
 * alerts, confirm dialogs, toast notifications). This violates separation of concerns
 * and harms maintainability and testability.
 * 
 * TODO - Future Refactoring Plan:
 * 1. Create DatabaseUIManager class for all UI interactions
 * 2. Keep UnifiedDBManager focused only on pure database operations
 * 3. Move StorageManager, DatabaseManager UI functions to separate UI layer
 * 4. Use event system or callbacks for UI notifications instead of direct coupling
 * 5. Make functions pure and testable by removing side effects
 */

class UnifiedDBManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.version = 14; // ç‰ˆæœ¬å‡çº§åˆ°14ï¼Œæ”¯æŒå›¾ç‰‡åˆ†ç±»åŠŸèƒ½
        this.db = null;
        this.isReady = false;
        this.initPromise = null;
        this.urlCache = new Map(); // æ–‡ä»¶URLç¼“å­˜
        
        // å®šä¹‰ä¸å‚ä¸æ‰‹åŠ¨å¯¼å…¥å¯¼å‡ºçš„å­˜å‚¨ï¼ˆå›¾ç‰‡ç­‰å¤§æ•°æ®ï¼‰ - ä¸åŸå§‹dataMigrator.jså®Œå…¨ä¸€è‡´
        this.excludedFromManualExport = ['emojiImages', 'fileStorage', 'imageUsageMetadata'];
        
        // æ–‡ä»¶ç±»å‹æ˜ å°„
        this.mimeTypes = {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg', 
            'png': 'image/png',
            'gif': 'image/gif',
            'webp': 'image/webp',
            'bmp': 'image/bmp',
            'svg': 'image/svg+xml'
        };

        // å›¾ç‰‡ä½¿ç”¨ç±»å‹æšä¸¾
        this.imageUsageTypes = {
            PERMANENT: 'permanent',     // æŒç»­ä½¿ç”¨çš„è¡¨æƒ…åŒ…
            TEMPORARY: 'temporary',     // ä¸´æ—¶æ€§å›¾ç‰‡ï¼ˆæœ‹å‹åœˆç­‰ï¼‰
            RECENT: 'recent',          // æœ€è¿‘ä½¿ç”¨
            ARCHIVE: 'archive'         // å½’æ¡£ï¼ˆä¸å¸¸ç”¨ï¼‰
        };

        // å®šä¹‰å®Œæ•´çš„æ•°æ®åº“æ¨¡å¼ - ä¸åŸå§‹dataMigrator.jså®Œå…¨ä¸€è‡´
        this.stores = {
            songs: { keyPath: 'id', autoIncrement: true },
            contacts: { keyPath: 'id' },
            apiSettings: { keyPath: 'id' },
            emojis: { keyPath: 'id' },
            emojiImages: { keyPath: 'tag' }, // å­˜å‚¨è¡¨æƒ…å›¾ç‰‡çš„base64æ•°æ®ï¼ˆå°†é€æ­¥è¿ç§»åˆ°fileStorageï¼‰
            backgrounds: { keyPath: 'id' },
            userProfile: { keyPath: 'id' },
            moments: { keyPath: 'id' },
            weiboPosts: { keyPath: 'id', autoIncrement: true },
            hashtagCache: { keyPath: 'id' },
            characterMemories: { keyPath: 'contactId' },
            conversationCounters: { keyPath: 'id' },
            globalMemory: { keyPath: 'id' },
            memoryProcessedIndex: { keyPath: 'contactId' },
            fileStorage: { keyPath: 'fileId' }, // æ–°å¢ï¼šå­˜å‚¨åŸå§‹æ–‡ä»¶Blobæ•°æ®
            fileReferences: { keyPath: 'referenceId' }, // æ–°å¢ï¼šå­˜å‚¨æ–‡ä»¶å¼•ç”¨å…³ç³»
            themeConfig: { keyPath: 'type' }, // æ–°å¢ï¼šå­˜å‚¨ä¸»é¢˜é…ç½®ï¼ˆé¢œè‰²ã€æ¸å˜ç­‰ï¼‰
            imageUsageMetadata: { keyPath: 'fileId' } // æ–°å¢ï¼šå›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®è¡¨
        };
        
        console.log('ğŸ”¥ [UnifiedDB] ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨å·²åˆ›å»º');
    }

    /**
     * åˆå§‹åŒ–æ•°æ®åº“ - å”¯ä¸€å…¥å£æ–¹æ³•
     */
    async init() {
        // å¦‚æœå·²ç»åˆå§‹åŒ–è¿‡ï¼Œç›´æ¥è¿”å›
        if (this.isReady &amp;&amp; this.db) {
            console.log('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å·²åˆå§‹åŒ–ï¼Œç›´æ¥è¿”å›');
            this.syncToGlobal();
            return this.db;
        }

        // å¦‚æœæ­£åœ¨åˆå§‹åŒ–ï¼Œç­‰å¾…ç°æœ‰åˆå§‹åŒ–å®Œæˆ
        if (this.initPromise) {
            console.log('ğŸ”¥ [UnifiedDB] æ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œç­‰å¾…å®Œæˆ...');
            return await this.initPromise;
        }

        // å¼€å§‹æ–°çš„åˆå§‹åŒ–æµç¨‹
        console.log('ğŸ”¥ [UnifiedDB] å¼€å§‹æ•°æ®åº“åˆå§‹åŒ–...');
        this.initPromise = this._performInit();
        
        try {
            const result = await this.initPromise;
            this.initPromise = null;
            return result;
        } catch (error) {
            this.initPromise = null;
            throw error;
        }
    }

    /**
     * æ‰§è¡Œå®é™…çš„åˆå§‹åŒ–å·¥ä½œ
     */
    async _performInit() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => {
                const error = new Error(`æ•°æ®åº“æ‰“å¼€å¤±è´¥: ${request.error?.message}`);
                console.error('ğŸ”¥ [UnifiedDB]', error);
                reject(error);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                this.isReady = true;
                
                console.log(`ğŸ”¥ [UnifiedDB] åˆå§‹åŒ–æˆåŠŸï¼Œç‰ˆæœ¬: ${this.db.version}`);
                console.log(`ğŸ”¥ [UnifiedDB] å¯ç”¨å­˜å‚¨:`, Array.from(this.db.objectStoreNames));
                
                // åŒæ­¥åˆ°å…¨å±€çŠ¶æ€
                this.syncToGlobal();
                
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                console.log('ğŸ”¥ [UnifiedDB] æ•°æ®åº“éœ€è¦å‡çº§...');
                const db = event.target.result;
                this._createStores(db, event.oldVersion);
            };
        });
    }

    /**
     * åˆ›å»ºæ‰€æœ‰å¿…è¦çš„å¯¹è±¡å­˜å‚¨ - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsé€»è¾‘
     */
    _createStores(db, oldVersion) {
        console.log(`ğŸ”¥ [UnifiedDB] æ•°æ®åº“å‡çº§: ç‰ˆæœ¬${oldVersion} -> ç‰ˆæœ¬${this.version}`);
        
        try {
            // å¤„ç†åºŸå¼ƒå­˜å‚¨çš„åˆ é™¤ - ä¸åŸå§‹é€»è¾‘å®Œå…¨ä¸€è‡´
            if (this.version >= 12) {
                // ç‰ˆæœ¬12åŠä»¥ä¸Šç§»é™¤äº†bubbleDesignerStickers
                if (db.objectStoreNames.contains('bubbleDesignerStickers')) {
                    db.deleteObjectStore('bubbleDesignerStickers');
                    console.log('ğŸ”¥ [UnifiedDB] åˆ é™¤åºŸå¼ƒçš„ bubbleDesignerStickers å­˜å‚¨');
                }
            }
            
            // åˆ›å»ºæ‰€æœ‰å¯¹è±¡å­˜å‚¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            Object.entries(this.stores).forEach(([storeName, config]) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    try {
                        const store = db.createObjectStore(storeName, config);
                        console.log(`ğŸ”¥ [UnifiedDB] åˆ›å»º ${storeName} å­˜å‚¨æˆåŠŸ`);
                        
                        // ä¸ºç‰¹å®šå­˜å‚¨æ·»åŠ ç´¢å¼•
                        if (storeName === 'fileReferences') {
                            // ä¸ºæ–‡ä»¶å¼•ç”¨è¡¨æ·»åŠ categoryç´¢å¼•ï¼Œæ–¹ä¾¿æŒ‰ç±»å‹æŸ¥è¯¢
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('fileId', 'fileId', { unique: false });
                            console.log('ğŸ”¥ [UnifiedDB] ä¸º fileReferences æ·»åŠ ç´¢å¼•');
                        }
                        
                        if (storeName === 'imageUsageMetadata') {
                            // ä¸ºå›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®è¡¨æ·»åŠ ç®€åŒ–çš„ç´¢å¼•
                            store.createIndex('usageType', 'usageType', { unique: false });
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('createdAt', 'createdAt', { unique: false });
                            console.log('ğŸ”¥ [UnifiedDB] ä¸º imageUsageMetadata æ·»åŠ ç´¢å¼•');
                        }
                        
                    } catch (storeError) {
                        console.error(`ğŸ”¥ [UnifiedDB] åˆ›å»ºå­˜å‚¨ ${storeName} å¤±è´¥:`, storeError);
                        throw storeError;
                    }
                }
            });
            
            console.log('ğŸ”¥ [UnifiedDB] æ•°æ®åº“ç»“æ„å‡çº§å®Œæˆ');
            
        } catch (upgradeError) {
            console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å‡çº§è¿‡ç¨‹ä¸­å‡ºé”™:', upgradeError);
            throw upgradeError;
        }
    }

    /**
     * åŒæ­¥çŠ¶æ€åˆ°å…¨å±€å¯¹è±¡ - ç®€åŒ–çš„è·¨é¡µé¢é€šä¿¡
     */
    syncToGlobal() {
        if (typeof window !== 'undefined') {
            // è®¾ç½®å…¨å±€æ•°æ®åº“çŠ¶æ€
            window.db = this.db;
            window.isIndexedDBReady = this.isReady;
            // ç§»é™¤æ··ä¹±çš„å®ä¾‹èµ‹å€¼ - ç»Ÿä¸€ä½¿ç”¨ window.unifiedDB ä½œä¸ºå®ä¾‹å¼•ç”¨
            
            // ğŸ”¥ ç®€åŒ–çš„è·¨é¡µé¢é€šçŸ¥ï¼šåªä½¿ç”¨localStorageäº‹ä»¶
            try {
                // å†™å…¥çŠ¶æ€ä¿¡æ¯
                const dbStatus = {
                    isReady: true,
                    version: this.db.version,
                    timestamp: Date.now(),
                    page: window.location.pathname
                };
                localStorage.setItem('dbStatus', JSON.stringify(dbStatus));
                
                // è§¦å‘è·¨é¡µé¢äº‹ä»¶
                localStorage.setItem('dbSyncTrigger', Date.now().toString());
                localStorage.removeItem('dbSyncTrigger');
                
                console.log('ğŸ”¥ [UnifiedDB] å·²åŒæ­¥çŠ¶æ€åˆ°å…¨å±€å¹¶è§¦å‘è·¨é¡µé¢äº‹ä»¶');
            } catch (e) {
                console.warn('ğŸ”¥ [UnifiedDB] localStorage åŒæ­¥å¤±è´¥:', e);
            }
        }
    }

    /**
     * ç­‰å¾…æ•°æ®åº“å°±ç»ª
     */
    static async waitForReady(timeout = 8000) {
        console.log('ğŸ”¥ [UnifiedDB] å¼€å§‹ç­‰å¾…æ•°æ®åº“å°±ç»ª...');
        
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            let resolved = false;
            let timeoutId = null;

            // ç›‘å¬localStorageäº‹ä»¶
            const storageListener = (event) => {
                if (event.key === 'dbSyncTrigger' &amp;&amp; !resolved) {
                    console.log('ğŸ”¥ [UnifiedDB] æ”¶åˆ°è·¨é¡µé¢åŒæ­¥äº‹ä»¶');
                    setTimeout(checkReady, 50);
                }
            };

            // æ¸…ç†å‡½æ•° - ç¡®ä¿åœ¨æ‰€æœ‰é€€å‡ºè·¯å¾„ä¸­éƒ½è°ƒç”¨
            const cleanup = () => {
                window.removeEventListener('storage', storageListener);
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
            };

            // æˆåŠŸè§£æå‡½æ•°
            const resolveWithCleanup = (result) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    resolve(result);
                }
            };

            // å¤±è´¥æ‹’ç»å‡½æ•°
            const rejectWithCleanup = (error) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    reject(error);
                }
            };

            const checkReady = () => {
                if (resolved) return;

                // æ£€æŸ¥å…¨å±€çŠ¶æ€
                if (window.isIndexedDBReady &amp;&amp; window.db &amp;&amp; window.db.version >= 14) {
                    console.log('ğŸ”¥ [UnifiedDB] æ£€æµ‹åˆ°æ•°æ®åº“å·²å°±ç»ª');
                    resolveWithCleanup(window.db);
                    return;
                }

                // æ£€æŸ¥localStorageçŠ¶æ€  
                try {
                    const dbStatus = JSON.parse(localStorage.getItem('dbStatus') || '{}');
                    if (dbStatus.isReady &amp;&amp; dbStatus.version >= 14) {
                        console.log('ğŸ”¥ [UnifiedDB] ä»localStorageæ£€æµ‹åˆ°æ•°æ®åº“çŠ¶æ€ï¼Œå°è¯•å»ºç«‹è¿æ¥...');
                        
                        // å°è¯•ä¸ºå½“å‰é¡µé¢å»ºç«‹æ•°æ®åº“è¿æ¥
                        if (window.unifiedDB) {
                            window.unifiedDB.init().then(db => {
                                resolveWithCleanup(db);
                            }).catch(err => {
                                console.warn('ğŸ”¥ [UnifiedDB] è¿æ¥å»ºç«‹å¤±è´¥:', err);
                                rejectWithCleanup(err);
                            });
                        }
                        // ç§»é™¤äº†ä¸å¯è¾¾çš„ getInstance é€»è¾‘ - window.unifiedDB æ£€æŸ¥å·²ç»å¤„ç†äº†æ‰€æœ‰æƒ…å†µ
                    }
                } catch (e) {
                    console.warn('ğŸ”¥ [UnifiedDB] localStorageè¯»å–å¤±è´¥:', e);
                }

                // è¶…æ—¶æ£€æŸ¥
                if (Date.now() - startTime > timeout) {
                    rejectWithCleanup(new Error(`ç­‰å¾…æ•°æ®åº“å°±ç»ªè¶…æ—¶ (${timeout}ms)`));
                    return;
                }

                // ç»§ç»­æ£€æŸ¥
                setTimeout(checkReady, 100);
            };

            // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
            window.addEventListener('storage', storageListener);
            
            // è®¾ç½®è¶…æ—¶
            timeoutId = setTimeout(() => {
                rejectWithCleanup(new Error(`ç­‰å¾…æ•°æ®åº“å°±ç»ªè¶…æ—¶ (${timeout}ms)`));
            }, timeout);

            // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
            checkReady();
        });
    }

    /**
     * è·å–å…¨å±€å®ä¾‹ - æ­£ç¡®çš„å•ä¾‹æ¨¡å¼å®ç°
     */
    static getInstance() {
        if (!window.unifiedDB) {
            window.unifiedDB = new UnifiedDBManager();
        }
        return window.unifiedDB;
    }

    /**
     * æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å°±ç»ª
     */
    static isReady() {
        return window.isIndexedDBReady &amp;&amp; window.db &amp;&amp; window.db.version >= 14;
    }

    // ============================================
    // æ•°æ®åº“æ“ä½œæ–¹æ³• - ç»Ÿä¸€API
    // ============================================

    /**
     * é€šç”¨æ•°æ®åº“æ“ä½œå°è£…
     */
    async _dbOperation(storeName, mode, operation, description) {
        if (!this.db) {
            await this.init();
        }

        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], mode);
                const store = transaction.objectStore(storeName);

                transaction.onerror = (event) => {
                    console.error(`ğŸ”¥ [UnifiedDB] Transaction failed for ${description}:`, event.target.error);
                    reject(event.target.error);
                };

                const result = operation(store);

                if (mode === 'readwrite') {
                    // For write operations, the transaction's completion is the source of truth.
                    let operationResult;
                    const resultPromise = Promise.resolve(result);
                    
                    resultPromise.then(res => {
                        operationResult = res;
                    }).catch(reject); // Propagate errors from the inner promise.

                    transaction.oncomplete = () => {
                        resolve(operationResult);
                    };
                } else { // readonly
                    if (result &amp;&amp; typeof result.then === 'function') {
                        result.then(resolve).catch(reject);
                    } else if (result &amp;&amp; result.onsuccess !== undefined) {
                        result.onsuccess = () => resolve(result.result);
                        result.onerror = (event) => reject(event.target.error);
                    } else {
                        resolve(result);
                    }
                }
            } catch (error) {
                console.error(`ğŸ”¥ [UnifiedDB] ${description || 'æ•°æ®åº“æ“ä½œ'}å¤±è´¥:`, error);
                reject(error);
            }
        });
    }

    /**
     * è·å–æ•°æ®
     */
    async get(storeName, key) {
        return this._dbOperation(storeName, 'readonly', store => store.get(key), `è·å–æ•°æ® ${storeName}:${key}`);
    }

    /**
     * è·å–æ‰€æœ‰æ•°æ®
     */
    async getAll(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.getAll(), `è·å–æ‰€æœ‰æ•°æ® ${storeName}`);
    }

    /**
     * ä¿å­˜æ•°æ®
     */
    async put(storeName, data) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.put(data);
            // Return a promise that resolves when the put operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `ä¿å­˜æ•°æ®åˆ° ${storeName}`);
    }

    /**
     * åˆ é™¤æ•°æ®
     */
    async delete(storeName, key) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.delete(key);
            // Return a promise that resolves when the delete operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `åˆ é™¤æ•°æ® ${storeName}:${key}`);
    }

    /**
     * è®¡æ•°æ•°æ®
     */
    async count(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.count(), `è®¡æ•° ${storeName}`);
    }

    /**
     * å¯¼å‡ºæ•´ä¸ªæ•°æ®åº“ - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsæ ¼å¼
     */
    async exportDatabase(options = {}) {
        try {
            if (!this.db) {
                await this.init();
            }

            const { stores = null, includeMetadata = true } = options;
            const exportData = {};
            
            // æ·»åŠ å…ƒæ•°æ®
            if (includeMetadata) {
                exportData._metadata = await this.getDatabaseInfo();
            }

            // ç¡®å®šè¦å¯¼å‡ºçš„å­˜å‚¨
            const storesToExport = stores || Array.from(this.db.objectStoreNames);
            
            // å¯¼å‡ºæ¯ä¸ªå¯¹è±¡å­˜å‚¨çš„æ•°æ®
            for (const storeName of storesToExport) {
                if (this.db.objectStoreNames.contains(storeName)) {
                    exportData[storeName] = await this.exportStore(storeName);
                }
            }

            return exportData;
            
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å¯¼å‡ºå¤±è´¥:', error);
            throw new Error(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¯¼å‡ºå•ä¸ªå¯¹è±¡å­˜å‚¨
     */
    async exportStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                let result = request.result;
                
                // ä¸ºä¿æŠ¤ç”¨æˆ·éšç§ï¼Œåœ¨å¯¼å‡ºæ—¶ç§»é™¤APIå¯†é’¥
                if (storeName === 'apiSettings') {
                    result = result.map(item => {
                        const sanitized = { ...item };
                        // æ¸…ç†æ•æ„Ÿä¿¡æ¯
                        if (sanitized.apiKey) delete sanitized.apiKey;
                        if (sanitized.password) delete sanitized.password;
                        return sanitized;
                    });
                }
                
                resolve(result);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * è·å–æ•°æ®åº“ç‰ˆæœ¬ä¿¡æ¯
     */
    async getDatabaseInfo() {
        if (!this.db) {
            await this.init();
        }
        
        return {
            name: this.db.name,
            version: this.db.version,  // è¿™é‡Œä½¿ç”¨å®é™…æ•°æ®åº“ç‰ˆæœ¬ï¼Œä¸æ˜¯ç›®æ ‡ç‰ˆæœ¬
            stores: Array.from(this.db.objectStoreNames),
            exportTime: new Date().toISOString()
        };
    }

    /**
     * å¯¼å…¥æ•°æ®åº“æ•°æ® - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsé€»è¾‘
     */
    async importDatabase(importData, options = {}) {
        try {
            const { 
                overwrite = false, 
                validateVersion = true,
                stores = null,
                enableMigration = true
            } = options;

            if (!this.db) {
                await this.init();
            }

            // éªŒè¯æ•°æ®æ ¼å¼
            if (!importData || typeof importData !== 'object') {
                throw new Error('å¯¼å…¥æ•°æ®æ ¼å¼æ— æ•ˆ');
            }

            // ç‰ˆæœ¬æ£€æŸ¥å’Œè¿ç§»å¤„ç†
            let migratedData = importData;
            if (importData._metadata &amp;&amp; importData._metadata.version !== this.version) {
                if (enableMigration &amp;&amp; importData._metadata.version < this.version) {
                    console.log(`ğŸ”¥ [UnifiedDB] æ£€æµ‹åˆ°ç‰ˆæœ¬ ${importData._metadata.version}ï¼Œå¼€å§‹è¿ç§»åˆ°ç‰ˆæœ¬ ${this.version}`);
                    migratedData = await this.migrateData(importData);
                } else if (validateVersion) {
                    throw new Error(`æ•°æ®åº“ç‰ˆæœ¬ä¸åŒ¹é…ã€‚å½“å‰ç‰ˆæœ¬: ${this.version}, å¯¼å…¥ç‰ˆæœ¬: ${importData._metadata.version}`);
                }
            }

            // ç¡®å®šè¦å¯¼å…¥çš„å­˜å‚¨
            const storesToImport = stores || Object.keys(migratedData).filter(key => key !== '_metadata');
            
            // æ¸…ç©ºç°æœ‰æ•°æ®ï¼ˆå¦‚æœé€‰æ‹©è¦†ç›–ï¼‰
            if (overwrite) {
                for (const storeName of storesToImport) {
                    if (this.db.objectStoreNames.contains(storeName)) {
                        await this.clearStore(storeName);
                    }
                }
            }

            // å¯¼å…¥æ•°æ®
            const importResults = {};
            for (const storeName of storesToImport) {
                if (this.db.objectStoreNames.contains(storeName) &amp;&amp; migratedData[storeName]) {
                    const result = await this.importStore(storeName, migratedData[storeName], overwrite);
                    importResults[storeName] = result;
                }
            }

            return { success: true, importedStores: storesToImport, results: importResults, migrated: migratedData !== importData };
            
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å¯¼å…¥å¤±è´¥:', error);
            throw new Error(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¯¼å…¥å•ä¸ªå­˜å‚¨çš„æ•°æ®
     */
    async importStore(storeName, data, overwrite = false) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            let addedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;

            // æ‰¹é‡å¯¼å…¥æ•°æ®
            data.forEach(item => {
                const request = overwrite ? store.put(item) : store.add(item);
                
                request.onsuccess = () => {
                    addedCount++;
                };
                
                request.onerror = () => {
                    if (request.error.name === 'ConstraintError') {
                        skippedCount++;
                    } else {
                        errorCount++;
                    }
                };
            });

            transaction.oncomplete = () => {
                resolve({
                    total: data.length,
                    added: addedCount,
                    skipped: skippedCount,
                    errors: errorCount
                });
            };

            transaction.onerror = () => reject(transaction.error);
        });
    }

    /**
     * æ¸…ç©ºæŒ‡å®šå­˜å‚¨çš„æ‰€æœ‰æ•°æ®
     */
    async clearStore(storeName) {
        if (!this.db) {
            await this.init();
        }
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                
                const store = transaction.objectStore(storeName);
                store.clear();
            } catch (error) {
                console.error(`ğŸ”¥ [UnifiedDB] æ¸…ç©ºå­˜å‚¨ ${storeName} å¤±è´¥:`, error);
                reject(error);
            }
        });
    }

    /**
     * æ•°æ®è¿ç§»å‡½æ•° - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsé€»è¾‘
     */
    async migrateData(importData) {
        const { _metadata } = importData;
        const fromVersion = _metadata ? _metadata.version : 1;
        const toVersion = this.version;
        
        console.log(`ğŸ”¥ [UnifiedDB] å¼€å§‹æ•°æ®è¿ç§»ï¼šä»ç‰ˆæœ¬ ${fromVersion} åˆ°ç‰ˆæœ¬ ${toVersion}`);
        
        // åˆ›å»ºè¿ç§»åçš„æ•°æ®å‰¯æœ¬
        const migratedData = JSON.parse(JSON.stringify(importData));
        
        // æ›´æ–°å…ƒæ•°æ®ç‰ˆæœ¬
        migratedData._metadata.version = toVersion;
        migratedData._metadata.migrationTime = new Date().toISOString();
        migratedData._metadata.originalVersion = fromVersion;
        
        // æ ¹æ®ç‰ˆæœ¬å·®å¼‚è¿›è¡Œè¿ç§»
        if (fromVersion <= 4 &amp;&amp; toVersion >= 5) {
            // ç‰ˆæœ¬4åˆ°5çš„è¿ç§»ï¼šæ·»åŠ ç¼ºå¤±çš„å­˜å‚¨
            this.migrateFrom4To5(migratedData);
        }
        
        if (fromVersion <= 5 &amp;&amp; toVersion >= 6) {
            // ç‰ˆæœ¬5åˆ°6çš„è¿ç§»ï¼ˆå¦‚æœæœ‰éœ€è¦çš„è¯ï¼‰
            this.migrateFrom5To6(migratedData);
        }
        
        if (fromVersion <= 6 &amp;&amp; toVersion >= 7) {
            // ç‰ˆæœ¬6åˆ°7çš„è¿ç§»ï¼ˆå¦‚æœæœ‰éœ€è¦çš„è¯ï¼‰
            this.migrateFrom6To7(migratedData);
        }
        
        if (fromVersion <= 7 &amp;&amp; toVersion >= 8) {
            // ç‰ˆæœ¬7åˆ°8çš„è¿ç§»ï¼šæ·»åŠ æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
            this.migrateFrom7To8(migratedData);
        }
        
        if (fromVersion <= 8 &amp;&amp; toVersion >= 9) {
            // ç‰ˆæœ¬8åˆ°9çš„è¿ç§»ï¼šå®Œå–„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
            this.migrateFrom8To9(migratedData);
        }
        
        if (fromVersion <= 9 &amp;&amp; toVersion >= 10) {
            // ç‰ˆæœ¬9åˆ°10çš„è¿ç§»ï¼šæ·»åŠ ä¸»é¢˜é…ç½®ç³»ç»Ÿ
            this.migrateFrom9To10(migratedData);
        }
        
        if (fromVersion <= 10 &amp;&amp; toVersion >= 11) {
            // ç‰ˆæœ¬10åˆ°11çš„è¿ç§»ï¼šæ·»åŠ æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“
            this.migrateFrom10To11(migratedData);
        }
        
        if (fromVersion <= 11 &amp;&amp; toVersion >= 12) {
            // ç‰ˆæœ¬11åˆ°12çš„è¿ç§»ï¼šç§»é™¤æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“
            this.migrateFrom11To12(migratedData);
        }
        
        if (fromVersion <= 12 &amp;&amp; toVersion >= 13) {
            // ç‰ˆæœ¬12åˆ°13çš„è¿ç§»ï¼šä¼˜åŒ–æ•°æ®ç»“æ„
            this.migrateFrom12To13(migratedData);
        }
        
        if (fromVersion <= 13 &amp;&amp; toVersion >= 14) {
            // ç‰ˆæœ¬13åˆ°14çš„è¿ç§»ï¼šæ·»åŠ å›¾ç‰‡åˆ†ç±»åŠŸèƒ½
            await this.migrateFrom13To14(migratedData);
        }
        
        console.log(`ğŸ”¥ [UnifiedDB] æ•°æ®è¿ç§»å®Œæˆï¼šç‰ˆæœ¬ ${fromVersion} -> ${toVersion}`);
        return migratedData;
    }

    // è¿ç§»æ–¹æ³•å ä½ç¬¦ - éœ€è¦æ—¶å¯ä»¥å®ç°å…·ä½“é€»è¾‘
    migrateFrom4To5(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 4->5 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ ç¼ºå¤±çš„å­˜å‚¨åˆå§‹åŒ–
        if (!data.characterMemories) data.characterMemories = [];
        if (!data.globalMemory) data.globalMemory = [];
    }

    migrateFrom5To6(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 5->6 ç‰ˆæœ¬è¿ç§»');
        // å¯ä»¥æ·»åŠ å…·ä½“è¿ç§»é€»è¾‘
    }

    migrateFrom6To7(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 6->7 ç‰ˆæœ¬è¿ç§»');
        // å¯ä»¥æ·»åŠ å…·ä½“è¿ç§»é€»è¾‘
    }

    migrateFrom7To8(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 7->8 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
        if (!data.fileStorage) data.fileStorage = [];
        if (!data.fileReferences) data.fileReferences = [];
    }

    migrateFrom8To9(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 8->9 ç‰ˆæœ¬è¿ç§»');
        // å®Œå–„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
    }

    migrateFrom9To10(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 9->10 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ ä¸»é¢˜é…ç½®ç³»ç»Ÿ
        if (!data.themeConfig) data.themeConfig = [];
    }

    migrateFrom10To11(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 10->11 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“ï¼ˆå·²åœ¨v12ä¸­ç§»é™¤ï¼‰
    }

    migrateFrom11To12(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 11->12 ç‰ˆæœ¬è¿ç§»');
        // ç§»é™¤æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“
        if (data.bubbleDesignerStickers) {
            delete data.bubbleDesignerStickers;
        }
    }

    migrateFrom12To13(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 12->13 ç‰ˆæœ¬è¿ç§»');
        // ä¼˜åŒ–æ•°æ®ç»“æ„
    }

    /**
     * ç‰ˆæœ¬13åˆ°14çš„è¿ç§»ï¼šæ·»åŠ å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®è¡¨
     * @param {Object} data - æ•°æ®
     */
    async migrateFrom13To14(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 13->14 ç‰ˆæœ¬è¿ç§»ï¼šæ·»åŠ å›¾ç‰‡åˆ†ç±»åŠŸèƒ½');
        // imageUsageMetadata è¡¨ä¼šåœ¨ _createStores ä¸­è‡ªåŠ¨åˆ›å»º
        
        try {
            // ä¸ºç°æœ‰çš„è¡¨æƒ…åŒ…åˆ›å»ºç®€åŒ–çš„ metadataï¼ˆä¸åŒºåˆ† temp/permanentï¼‰
            if (data.emojis &amp;&amp; Array.isArray(data.emojis)) {
                console.log('ğŸ”¥ [UnifiedDB] ä¸ºç°æœ‰è¡¨æƒ…åŒ…åˆ›å»ºå›¾åº“å…ƒæ•°æ®');
                for (const emoji of data.emojis) {
                    if (emoji.id &amp;&amp; emoji.tag) {
                        // æŸ¥æ‰¾å¯¹åº”çš„æ–‡ä»¶è®°å½•
                        const fileReferences = data.fileReferences || [];
                        const emojiFile = fileReferences.find(ref => 
                            ref.referenceType === 'emoji' &amp;&amp; ref.referenceKey === emoji.tag
                        );
                        
                        if (emojiFile &amp;&amp; emojiFile.fileId) {
                            await this.setImageUsageMetadata(emojiFile.fileId, 'general', {
                                category: 'emoji',
                                tags: [emoji.tag],
                                createdAt: emoji.createdAt || new Date().toISOString(),
                                fileName: emoji.tag
                            });
                        }
                    }
                }
            }
            
            // ä¸ºç°æœ‰çš„æœ‹å‹åœˆå›¾ç‰‡åˆ›å»ºç®€åŒ–çš„ metadata
            if (data.moments &amp;&amp; Array.isArray(data.moments)) {
                console.log('ğŸ”¥ [UnifiedDB] ä¸ºç°æœ‰æœ‹å‹åœˆå›¾ç‰‡åˆ›å»ºå›¾åº“å…ƒæ•°æ®');
                for (const moment of data.moments) {
                    if (moment.imageFileIds &amp;&amp; Array.isArray(moment.imageFileIds)) {
                        for (let i = 0; i < moment.imageFileIds.length; i++) {
                            const fileId = moment.imageFileIds[i];
                            await this.setImageUsageMetadata(fileId, 'general', {
                                category: 'moments',
                                tags: ['æœ‹å‹åœˆ', moment.authorName || 'æœªçŸ¥'],
                                createdAt: moment.timestamp || new Date().toISOString(),
                                fileName: `moment_${moment.id}_${i + 1}.jpg`
                            });
                        }
                    }
                }
            }
            
            console.log('ğŸ”¥ [UnifiedDB] å†å²å›¾ç‰‡å…ƒæ•°æ®è¿ç§»å®Œæˆ');
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] è¿ç§»å†å²å›¾ç‰‡å…ƒæ•°æ®å¤±è´¥:', error);
            // è¿ç§»å¤±è´¥ä¸å½±å“æ•´ä½“å‡çº§
        }
    }

    // ============================================
    // æ–‡ä»¶å­˜å‚¨åŠŸèƒ½
    // ============================================

    /**
     * ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶ID
     */
    generateFileId() {
        return 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * ä»base64å­—ç¬¦ä¸²ä¸­æå–MIMEç±»å‹
     */
    getMimeTypeFromBase64(base64String) {
        const match = base64String.match(/^data:([^;]+);base64,/);
        return match ? match[1] : 'image/jpeg';
    }

    /**
     * å°†base64å­—ç¬¦ä¸²è½¬æ¢ä¸ºBlob
     */
    base64ToBlob(base64String) {
        try {
            const mimeType = this.getMimeTypeFromBase64(base64String);
            const base64Data = base64String.split(',')[1];
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] base64è½¬æ¢Blobå¤±è´¥:', error);
            return null;
        }
    }

    /**
     * å­˜å‚¨æ–‡ä»¶åˆ°æ•°æ®åº“
     */
    async storeFile(fileData, metadata = {}) {
        let blob;
        
        if (typeof fileData === 'string' &amp;&amp; fileData.startsWith('data:')) {
            // base64å­—ç¬¦ä¸²
            blob = this.base64ToBlob(fileData);
            if (!blob) {
                throw new Error('æ— æ³•è½¬æ¢base64æ•°æ®');
            }
        } else if (fileData instanceof File || fileData instanceof Blob) {
            // Fileæˆ–Blobå¯¹è±¡
            blob = fileData;
        } else {
            throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ•°æ®ç±»å‹: ${typeof fileData}`);
        }

        const fileId = this.generateFileId();
        const fileRecord = {
            fileId: fileId,
            blob: blob,
            type: blob.type,
            size: blob.size,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileStorage', fileRecord);
        
        console.log('ğŸ”¥ [UnifiedDB] æ–‡ä»¶å­˜å‚¨æˆåŠŸï¼ŒID:', fileId);
        return {
            fileId: fileId,
            type: blob.type,
            size: blob.size
        };
    }

    /**
     * è·å–æ–‡ä»¶
     */
    async getFile(fileId) {
        const result = await this.get('fileStorage', fileId);
        if (!result) {
            throw new Error(`æ–‡ä»¶ä¸å­˜åœ¨: ${fileId}`);
        }
        return result;
    }

    /**
     * åˆ›å»ºæ–‡ä»¶çš„ä¸´æ—¶URL
     */
    async createFileURL(fileId) {
        try {
            // æ£€æŸ¥ç¼“å­˜
            if (this.urlCache.has(fileId)) {
                return this.urlCache.get(fileId);
            }

            const fileRecord = await this.getFile(fileId);
            
            // æ›´å®½æ¾çš„blobæ£€æŸ¥ - å…¼å®¹IndexedDBåºåˆ—åŒ–çš„blob
            if (!fileRecord.blob) {
                throw new Error(`æ–‡ä»¶è®°å½•ä¸­ç¼ºå°‘blobæ•°æ®: ${fileId}`);
            }
            
            let blob = fileRecord.blob;
            
            // å¦‚æœä¸æ˜¯æ ‡å‡†Blobå®ä¾‹ï¼Œå°è¯•é‡æ–°æ„é€ 
            if (!(blob instanceof Blob)) {
                try {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç±»ä¼¼Blobçš„å¯¹è±¡
                    if (blob.size !== undefined &amp;&amp; blob.type !== undefined) {
                        // å¦‚æœæœ‰sizeå’Œtypeå±æ€§ï¼Œå¯èƒ½æ˜¯åºåˆ—åŒ–çš„Blobï¼Œå°è¯•é‡æ–°æ„é€ 
                        console.log(`ğŸ”¥ [UnifiedDB] æ£€æµ‹åˆ°éæ ‡å‡†Blobå¯¹è±¡ï¼Œå°è¯•é‡æ–°æ„é€ : ${fileId}`);
                        
                        // å¦‚æœblobæœ‰streamæ–¹æ³•ï¼Œè¯´æ˜å®ƒä»ç„¶æ˜¯æœ‰æ•ˆçš„Blob-likeå¯¹è±¡
                        if (typeof blob.stream === 'function' || typeof blob.arrayBuffer === 'function') {
                            // ç›´æ¥ä½¿ç”¨ï¼Œå¯èƒ½æ˜¯æµè§ˆå™¨å†…éƒ¨çš„Blobè¡¨ç¤º
                            console.log(`ğŸ”¥ [UnifiedDB] ä½¿ç”¨ç±»Blobå¯¹è±¡åˆ›å»ºURL: ${fileId}`);
                        } else {
                            throw new Error('Blobå¯¹è±¡ç¼ºå°‘å¿…è¦çš„æ–¹æ³•');
                        }
                    } else {
                        throw new Error('æ— æ•ˆçš„blobæ•°æ®ç»“æ„');
                    }
                } catch (reconstructError) {
                    throw new Error(`æ— æ³•å¤„ç†blobæ•°æ®: ${reconstructError.message}`);
                }
            }
            
            const url = URL.createObjectURL(blob);
            
            // ç¼“å­˜URL
            this.urlCache.set(fileId, url);
            
            return url;
        } catch (error) {
            console.error(`ğŸ”¥ [UnifiedDB] åˆ›å»ºæ–‡ä»¶URLå¤±è´¥ (${fileId}):`, error);
            return '';
        }
    }

    /**
     * æ¸…ç†æ–‡ä»¶URLç¼“å­˜
     */
    revokeFileURL(fileId) {
        if (this.urlCache.has(fileId)) {
            const url = this.urlCache.get(fileId);
            URL.revokeObjectURL(url);
            this.urlCache.delete(fileId);
        }
    }

    // === å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®ç®¡ç†æ–¹æ³• ===

    /**
     * åˆ›å»ºæˆ–æ›´æ–°å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®
     * @param {string} fileId - æ–‡ä»¶ID
     * @param {string} usageType - ä½¿ç”¨ç±»å‹ (permanent/temporary/recent/archive)
     * @param {Object} metadata - é¢å¤–å…ƒæ•°æ®
     */
    async setImageUsageMetadata(fileId, usageType, metadata = {}) {
        const usageData = {
            fileId: fileId,
            usageType: usageType,
            createdAt: metadata.createdAt || new Date().toISOString(),
            category: metadata.category || 'general', // emoji, moment, chat, avatar, background
            tags: metadata.tags || [],
            size: metadata.size || 0,
            fileName: metadata.fileName || null
        };

        await this.put('imageUsageMetadata', usageData);
        console.log(`ğŸ”¥ [UnifiedDB] è®¾ç½®å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®: ${fileId} -> ${usageType}`);
        return usageData;
    }


    /**
     * è·å–å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®
     * @param {string} fileId - æ–‡ä»¶ID
     */
    async getImageUsageMetadata(fileId) {
        return await this.get('imageUsageMetadata', fileId);
    }

    /**
     * æ ¹æ®ä½¿ç”¨ç±»å‹æŸ¥è¯¢å›¾ç‰‡
     * @param {string} usageType - ä½¿ç”¨ç±»å‹
     * @param {number} limit - é™åˆ¶æ•°é‡
     */
    async getImagesByUsageType(usageType, limit = 100) {
        return await this._dbOperation('imageUsageMetadata', 'readonly', (store) => {
            const index = store.index('usageType');
            const request = index.getAll(usageType);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const results = request.result.slice(0, limit);
                    resolve(results);
                };
                request.onerror = () => reject(request.error);
            });
        }, `æŸ¥è¯¢${usageType}ç±»å‹å›¾ç‰‡`);
    }

    /**
     * æ¸…ç†è¿‡æœŸçš„ä¸´æ—¶å›¾ç‰‡
     * @param {string[]} fileIds - è¦åˆ é™¤çš„æ–‡ä»¶IDæ•°ç»„
     */
    async cleanupSelectedImages(fileIds) {
        if (!Array.isArray(fileIds) || fileIds.length === 0) {
            return { deletedCount: 0, errors: [] };
        }

        try {
            let deletedCount = 0;
            const errors = [];

            for (const fileId of fileIds) {
                try {
                    // åˆ é™¤æ–‡ä»¶
                    await this.deleteFile(fileId);
                    // åˆ é™¤å…ƒæ•°æ®
                    await this.delete('imageUsageMetadata', fileId);
                    // åˆ é™¤ç›¸å…³å¼•ç”¨
                    await this.cleanupFileReferences(fileId);
                    deletedCount++;
                    console.log(`ğŸ”¥ [UnifiedDB] å·²åˆ é™¤å›¾ç‰‡: ${fileId}`);
                } catch (error) {
                    console.warn(`åˆ é™¤å›¾ç‰‡å¤±è´¥: ${fileId}`, error);
                    errors.push({ fileId, error: error.message });
                }
            }

            console.log(`ğŸ”¥ [UnifiedDB] æ‰‹åŠ¨æ¸…ç†å›¾ç‰‡å®Œæˆ: ${deletedCount}/${fileIds.length}`);
            return { deletedCount, totalRequested: fileIds.length, errors };
        } catch (error) {
            console.error('æ‰¹é‡åˆ é™¤å›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ¸…ç†æŒ‡å®šæ–‡ä»¶çš„æ‰€æœ‰å¼•ç”¨
     * @param {string} fileId - æ–‡ä»¶ID
     */
    async cleanupFileReferences(fileId) {
        return await this._dbOperation('fileReferences', 'readwrite', (store) => {
            return new Promise((resolve, reject) => {
                try {
                    const index = store.index('fileId');
                    const request = index.openCursor(IDBKeyRange.only(fileId));
                    let deletedCount = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            deletedCount++;
                            cursor.continue();
                        } else {
                            // æ‰€æœ‰åŒ¹é…çš„è®°å½•éƒ½å·²å¤„ç†å®Œæˆ
                            console.log(`ğŸ”¥ [UnifiedDB] æ¸…ç†æ–‡ä»¶å¼•ç”¨: ${fileId} (${deletedCount}ä¸ªå¼•ç”¨)`);
                            resolve(deletedCount);
                        }
                    };

                    request.onerror = (event) => {
                        console.warn('æ¸…ç†æ–‡ä»¶å¼•ç”¨å¤±è´¥:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.warn('æ¸…ç†æ–‡ä»¶å¼•ç”¨å¤±è´¥:', error);
                    reject(error);
                }
            });
        }, `æ¸…ç†æ–‡ä»¶å¼•ç”¨: ${fileId}`);
    }

    /**
     * è·å–å›¾ç‰‡ä½¿ç”¨ç»Ÿè®¡
     */
    async getImageUsageStats() {
        try {
            const allMetadata = await this.getAll('imageUsageMetadata');
            const stats = {
                total: allMetadata.length,
                byType: {},
                byCategory: {},
                totalSize: 0
            };

            allMetadata.forEach(meta => {
                // æŒ‰ç±»å‹ç»Ÿè®¡
                stats.byType[meta.usageType] = (stats.byType[meta.usageType] || 0) + 1;
                
                // æŒ‰åˆ†ç±»ç»Ÿè®¡
                stats.byCategory[meta.category] = (stats.byCategory[meta.category] || 0) + 1;
                
                // æ€»å¤§å°
                stats.totalSize += meta.size || 0;
            });

            return stats;
        } catch (error) {
            console.error('è·å–å›¾ç‰‡ä½¿ç”¨ç»Ÿè®¡å¤±è´¥:', error);
            return null;
        }
    }

    /**
     * åˆ é™¤æ–‡ä»¶
     */
    async deleteFile(fileId) {
        await this.delete('fileStorage', fileId);
        this.revokeFileURL(fileId);
        console.log(`ğŸ”¥ [UnifiedDB] æ–‡ä»¶åˆ é™¤æˆåŠŸ: ${fileId}`);
    }

    /**
     * åˆ›å»ºæ–‡ä»¶å¼•ç”¨å…³ç³»
     */
    async createFileReference(fileId, referenceType, referenceKey, metadata = {}) {
        const referenceId = `${referenceType}_${referenceKey}`;
        const reference = {
            referenceId: referenceId,
            fileId: fileId,
            category: referenceType,
            referenceKey: referenceKey,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileReferences', reference);
        console.log('ğŸ”¥ [UnifiedDB] æ–‡ä»¶å¼•ç”¨å­˜å‚¨æˆåŠŸ:', reference);
        return reference;
    }

    /**
     * è·å–æ–‡ä»¶å¼•ç”¨
     */
    async getFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        return await this.get('fileReferences', referenceId);
    }

    /**
     * åˆ é™¤æ–‡ä»¶å¼•ç”¨
     */
    async deleteFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        await this.delete('fileReferences', referenceId);
        console.log(`ğŸ”¥ [UnifiedDB] æ–‡ä»¶å¼•ç”¨åˆ é™¤æˆåŠŸ: ${referenceId}`);
    }

    // ============================================
    // å‘åå…¼å®¹çš„è¾…åŠ©æ–¹æ³•å’Œé”™è¯¯å¤„ç†
    // ============================================

    /**
     * å…¼å®¹æ—§çš„promisifyRequestæ–¹æ³•
     */
    promisifyRequest(request, description = '') {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => {
                console.error(`ğŸ”¥ [UnifiedDB] ${description}å¤±è´¥:`, request.error);
                reject(request.error);
            };
        });
    }

    /**
     * å…¼å®¹æ—§çš„ensureDBReadyæ–¹æ³•
     */
    async ensureDBReady(operation, description = '') {
        if (!this.isReady) {
            await this.init();
        }
        
        try {
            return await operation();
        } catch (error) {
            console.error(`ğŸ”¥ [UnifiedDB] ${description}å¤±è´¥:`, error);
            throw error;
        }
    }

    /**
     * é‡è¯•æœºåˆ¶ - å‘åå…¼å®¹
     */
    async retryWithBackoff(operation, context, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                lastError = error;
                console.warn(`ğŸ”¥ [UnifiedDB] ${context} - å°è¯• ${attempt}/${maxRetries} å¤±è´¥:`, error);
                
                if (attempt < maxRetries) {
                    // æŒ‡æ•°é€€é¿å»¶è¿Ÿ
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.error(`ğŸ”¥ [UnifiedDB] ${context} - æ‰€æœ‰é‡è¯•å¤±è´¥`);
                    throw lastError;
                }
            }
        }
        
        throw lastError;
    }
}

// ============================================
// å…¨å±€å¯¼å‡ºå’Œå…¼å®¹æ€§è®¾ç½® - ç«‹å³æ‰§è¡Œ
// ============================================

/**
 * æ˜¾ç¤ºæ•°æ®åº“é”™è¯¯å¯¹è¯æ¡† - å‘åå…¼å®¹
 */
function showDatabaseErrorDialog(error, isRetrying = false) {
    const title = isRetrying ? 'æ•°æ®åº“é‡è¯•ä¸­...' : 'æ•°æ®åº“è¿æ¥å¤±è´¥';
    const message = isRetrying 
        ? `æ•°æ®åº“è¿æ¥å¼‚å¸¸ï¼Œæ­£åœ¨è‡ªåŠ¨é‡è¯•...\n\né”™è¯¯ä¿¡æ¯: ${error.message}`
        : `æ•°æ®åº“è¿æ¥å¤±è´¥ã€‚\n\né”™è¯¯ä¿¡æ¯: ${error.message}\n\nå»ºè®®:\n1. åˆ·æ–°é¡µé¢é‡è¯•\n2. æ¸…é™¤æµè§ˆå™¨ç¼“å­˜\n3. æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒIndexedDB`;
    
    console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“é”™è¯¯:', error);
    
    // Event-driven error dialog - replace direct alert() with custom event
    window.dispatchEvent(new CustomEvent('database:errorDialog', {
        detail: {
            title: title,
            message: message,
            error: error,
            isRetrying: isRetrying,
            suggestions: isRetrying ? [] : [
                'åˆ·æ–°é¡µé¢é‡è¯•',
                'æ¸…é™¤æµè§ˆå™¨ç¼“å­˜', 
                'æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒIndexedDB'
            ]
        }
    }));
}

/**
 * é‡è¯•æ‰§è¡Œå‡½æ•° - å‘åå…¼å®¹
 */
async function executeWithRetry(operation, context = 'æ•°æ®åº“æ“ä½œ') {
    if (window.unifiedDB &amp;&amp; typeof window.unifiedDB.retryWithBackoff === 'function') {
        return await window.unifiedDB.retryWithBackoff(operation, context);
    }
    
    // ç®€å•é‡è¯•é€»è¾‘ä½œä¸ºåå¤‡
    try {
        return await operation();
    } catch (error) {
        console.error(`ğŸ”¥ [UnifiedDB] ${context} å¤±è´¥:`, error);
        throw error;
    }
}

// ğŸ”¥ ç«‹å³å¯¼å‡ºè¿™äº›å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œç¡®ä¿å…¶ä»–è„šæœ¬å¯ä»¥ä½¿ç”¨
if (typeof window !== 'undefined') {
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
}

// è·å–å…¨å±€å•ä¾‹å®ä¾‹
const unifiedDB = UnifiedDBManager.getInstance();

// åˆ›å»ºå‘½åç©ºé—´ä»¥å‡å°‘å…¨å±€æ±¡æŸ“
const AppDB = {
    // æ ¸å¿ƒç®¡ç†å™¨
    UnifiedDBManager: UnifiedDBManager,
    unifiedDB: unifiedDB,
    
    // å·¥å…·å‡½æ•°
    executeWithRetry: executeWithRetry,
    showDatabaseErrorDialog: showDatabaseErrorDialog,
    promisifyRequest: (request, description) => unifiedDB.promisifyRequest(request, description),
    ensureDBReady: (operation, description) => unifiedDB.ensureDBReady(operation, description),
    initUnifiedDB: () => unifiedDB.init(),
    
    // ç®¡ç†å™¨å¯¹è±¡ï¼ˆå°†åœ¨ä¸‹é¢å®šä¹‰ï¼‰
    StorageManager: null,
    DatabaseManager: null,
    
    // å¯¼å…¥å¯¼å‡ºå‡½æ•°ï¼ˆå°†åœ¨ä¸‹é¢å®šä¹‰ï¼‰
    exportDatabase: null,
    exportFileStorage: null,
    importDatabase: null,
    performImport: null,
    
    // æ–‡ä»¶å¤„ç†å‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼‰
    performFileStorageImport: null,
    importPrompts: null,
    
    // UIå‡½æ•°ç°åœ¨ç”±UIManagerå¤„ç†
    // handleFileSelect, handleFileStorageImport, confirmFileExport, cancelFileExport, refreshDatabaseStats
    // triggerFileSelect, triggerFileStorageImport
    
    // æ–‡ä»¶å­˜å‚¨ç®¡ç†å™¨åˆ«å
    FileStorageManager: unifiedDB
};

// å¯¼å‡ºåˆ°windowå¯¹è±¡
if (typeof window !== 'undefined') {
    window.AppDB = AppDB;
    
    // å‘åå…¼å®¹ï¼šä¿ç•™å…³é”®çš„ç›´æ¥windowå¯¼å‡º
    window.UnifiedDBManager = UnifiedDBManager;
    window.unifiedDB = unifiedDB;
    window.promisifyRequest = AppDB.promisifyRequest;
    window.ensureDBReady = AppDB.ensureDBReady;
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
    window.initUnifiedDB = AppDB.initUnifiedDB;
    
    // ğŸ”¥ å®Œæ•´çš„ StorageManager å¯¹è±¡
    AppDB.StorageManager = {
        /**
         * ç”³è¯·æŒä¹…åŒ–å­˜å‚¨ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼Œä¸æ¶‰åŠUIï¼‰
         */
        async requestPersistentStorage() {
            try {
                console.log('[StorageManager] ç”³è¯·æŒä¹…åŒ–å­˜å‚¨...');
                
                if (!navigator.storage || !navigator.storage.persist) {
                    const result = { success: false, error: 'æµè§ˆå™¨ä¸æ”¯æŒæŒä¹…åŒ–å­˜å‚¨åŠŸèƒ½' };
                    window.dispatchEvent(new CustomEvent('storage:persistentUnsupported', { detail: result }));
                    return result;
                }

                // ç”³è¯·æŒä¹…åŒ–å­˜å‚¨
                const granted = await navigator.storage.persist();
                const estimate = await navigator.storage.estimate();
                
                const result = {
                    success: true,
                    granted: granted,
                    estimate: estimate,
                    message: granted ? 'æŒä¹…åŒ–å­˜å‚¨ç”³è¯·æˆåŠŸ' : 'æŒä¹…åŒ–å­˜å‚¨ç”³è¯·è¢«æ‹’ç»'
                };

                // å‘å‡ºäº‹ä»¶é€šçŸ¥UIå±‚
                const eventType = granted ? 'storage:persistentGranted' : 'storage:persistentDenied';
                window.dispatchEvent(new CustomEvent(eventType, { detail: result }));
                
                console.log(`[StorageManager] æŒä¹…åŒ–å­˜å‚¨ç”³è¯·${granted ? 'æˆåŠŸ' : 'è¢«æ‹’ç»'}`);
                
                // é€šçŸ¥éœ€è¦åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯
                window.dispatchEvent(new CustomEvent('storage:statsRefreshNeeded'));
                
                return result;

            } catch (error) {
                console.error('[StorageManager] ç”³è¯·æŒä¹…åŒ–å­˜å‚¨å¤±è´¥:', error);
                const result = { success: false, error: error.message };
                window.dispatchEvent(new CustomEvent('storage:persistentError', { detail: result }));
                return result;
            }
        },

        /**
         * æ£€æŸ¥æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€
         */
        async checkPersistentStorageStatus() {
            try {
                if (!navigator.storage || !navigator.storage.persisted) {
                    return false;
                }
                return await navigator.storage.persisted();
            } catch (error) {
                console.error('[StorageManager] æ£€æŸ¥æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€å¤±è´¥:', error);
                return false;
            }
        },

        /**
         * è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
         */
        async getStorageUsage() {
            try {
                if (!navigator.storage || !navigator.storage.estimate) {
                    return null;
                }
                return await navigator.storage.estimate();
            } catch (error) {
                console.error('[StorageManager] è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥:', error);
                return null;
            }
        },

        /**
         * æ£€æŸ¥IndexedDBæ˜¯å¦ä¸ºæŒä¹…åŒ–å­˜å‚¨
         */
        async checkPersistentStorage() {
            try {
                if ('storage' in navigator &amp;&amp; 'persisted' in navigator.storage) {
                    const isPersistent = await navigator.storage.persisted();
                    const estimate = await navigator.storage.estimate();
                    
                    return {
                        success: true,
                        isPersistent: isPersistent,
                        estimate: estimate
                    };
                } else {
                    return {
                        success: false,
                        error: 'æµè§ˆå™¨ä¸æ”¯æŒStorage API',
                        isPersistent: false
                    };
                }
            } catch (error) {
                console.error('æ£€æŸ¥æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€å¤±è´¥:', error);
                return {
                    success: false,
                    error: error.message,
                    isPersistent: false
                };
            }
        },

        // åˆ é™¤é‡å¤æ–¹æ³• - requestPersistentStorage() å·²åœ¨ä¸Šé¢å®šä¹‰
    };

    // å‘åå…¼å®¹ï¼šä¿ç•™ StorageManager çš„ç›´æ¥ window è®¿é—®
    window.StorageManager = AppDB.StorageManager;

    // ğŸ”¥ å®Œæ•´çš„ DatabaseManager å¯¹è±¡
    AppDB.DatabaseManager = {
        init: () => unifiedDB.init(),
        
        /**
         * æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€å¹¶æä¾›ä¿®å¤é€‰é¡¹
         */
        async checkAndOfferRepair() {
            try {
                console.log('[DatabaseManager] å¼€å§‹æ•°æ®åº“å¥åº·æ£€æŸ¥...');
                
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    console.warn('[DatabaseManager] æ•°æ®åº“æœªå°±ç»ªï¼Œè·³è¿‡å¥åº·æ£€æŸ¥');
                    return { success: false, error: 'æ•°æ®åº“æœªå°±ç»ª' };
                }

                // æ£€æŸ¥æ‰€æœ‰é¢„æœŸçš„å­˜å‚¨æ˜¯å¦å­˜åœ¨
                const expectedStores = [
                    'contacts', 'apiSettings', 'emojis', 'backgrounds', 
                    'userProfile', 'moments', 'weiboPosts', 'hashtagCache',
                    'characterMemories', 'globalMemory', 'conversationCounters', 
                    'memoryProcessedIndex', 'themeConfig'
                ];

                const db = window.unifiedDB.db;
                const missingStores = expectedStores.filter(storeName => 
                    !db.objectStoreNames.contains(storeName)
                );

                if (missingStores.length > 0) {
                    console.warn('[DatabaseManager] å‘ç°ç¼ºå¤±çš„å­˜å‚¨:', missingStores);
                    
                    // å‘å‡ºäº‹ä»¶ï¼Œè®©UIå±‚å†³å®šæ˜¯å¦ä¿®å¤
                    const repairResult = await new Promise((resolve) => {
                        const eventData = { missingStores, resolve };
                        window.dispatchEvent(new CustomEvent('database:repairNeeded', { detail: eventData }));
                    });
                    
                    if (repairResult) {
                        return await this.repairDatabase(missingStores);
                    }
                    
                    return { success: false, message: 'ç”¨æˆ·å–æ¶ˆä¿®å¤', missingStores };
                } else {
                    console.log('[DatabaseManager] æ•°æ®åº“ç»“æ„å®Œæ•´');
                    return { success: true, message: 'æ•°æ®åº“ç»“æ„å®Œæ•´' };
                }

                return { success: true, message: 'å¥åº·æ£€æŸ¥å®Œæˆ' };

            } catch (error) {
                console.error('[DatabaseManager] å¥åº·æ£€æŸ¥å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * ä¿®å¤æ•°æ®åº“ç»“æ„
         */
        async repairDatabase(missingStores) {
            try {
                console.log('[DatabaseManager] å¼€å§‹ä¿®å¤æ•°æ®åº“...');
                
                // å…³é—­ç°æœ‰è¿æ¥
                if (window.unifiedDB &amp;&amp; window.unifiedDB.db) {
                    window.unifiedDB.db.close();
                }

                // é‡æ–°åˆå§‹åŒ–æ•°æ®åº“ä»¥åˆ›å»ºç¼ºå¤±çš„å­˜å‚¨
                await window.unifiedDB.init();
                
                // å‘å‡ºä¿®å¤æˆåŠŸäº‹ä»¶
                window.dispatchEvent(new CustomEvent('database:repairSuccess', {
                    detail: { message: 'æ•°æ®åº“ä¿®å¤å®Œæˆ' }
                }));

                return { success: true, message: 'æ•°æ®åº“ä¿®å¤å®Œæˆ' };

            } catch (error) {
                console.error('[DatabaseManager] æ•°æ®åº“ä¿®å¤å¤±è´¥:', error);
                
                // å‘å‡ºä¿®å¤å¤±è´¥äº‹ä»¶
                window.dispatchEvent(new CustomEvent('database:repairError', {
                    detail: { error: error.message }
                }));

                return { success: false, error: error.message };
            }
        },

        /**
         * è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
         */
        async getStats() {
            try {
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    return { success: false, error: 'æ•°æ®åº“æœªå°±ç»ª' };
                }

                const db = window.unifiedDB.db;
                const stats = {};

                // éå†æ‰€æœ‰å¯¹è±¡å­˜å‚¨è·å–è®°å½•æ•°
                const storeNames = Array.from(db.objectStoreNames);
                
                for (const storeName of storeNames) {
                    try {
                        const count = await window.unifiedDB.count(storeName);
                        stats[storeName] = count;
                    } catch (error) {
                        console.warn(`[DatabaseManager] è·å–å­˜å‚¨ ${storeName} ç»Ÿè®¡å¤±è´¥:`, error);
                        stats[storeName] = 0;
                    }
                }

                return { success: true, stats };

            } catch (error) {
                console.error('[DatabaseManager] è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * é‡ç½®åº”ç”¨çŠ¶æ€ - æ¸…ç©ºå†…å­˜ä¸­çš„å…¨å±€å˜é‡
         * åœ¨æ•°æ®åº“å¯¼å…¥åä½¿ç”¨ï¼Œç¡®ä¿åº”ç”¨çŠ¶æ€ä¸æ•°æ®åº“åŒæ­¥
         */
        resetApplicationState() {
            // è”ç³»äººç›¸å…³
            if (typeof window.contacts !== 'undefined') {
                window.contacts = [];
            }
            if (typeof window.currentContact !== 'undefined') {
                window.currentContact = null;
            }
            
            // è¡¨æƒ…ç›¸å…³
            if (typeof window.emojis !== 'undefined') {
                window.emojis = [];
            }
            
            // èƒŒæ™¯ç›¸å…³
            if (typeof window.backgrounds !== 'undefined') {
                window.backgrounds = {};
            }
            
            // ç”¨æˆ·èµ„æ–™
            if (typeof window.userProfile !== 'undefined') {
                window.userProfile = { name: 'æˆ‘çš„æ˜µç§°', avatar: '', personality: '' };
            }
            
            // åŠ¨æ€ç›¸å…³
            if (typeof window.moments !== 'undefined') {
                window.moments = [];
            }
            if (typeof window.weiboPosts !== 'undefined') {
                window.weiboPosts = [];
            }
            
            console.log('[DatabaseManager] åº”ç”¨çŠ¶æ€å·²é‡ç½®');
        },

        /**
         * å¯¼å‡ºå¹¶ä¸‹è½½æ•°æ®åº“
         */
        async exportAndDownload() {
            try {
                console.log('[DatabaseManager] å¼€å§‹å¯¼å‡ºæ•°æ®åº“...');
                
                const exportData = await window.unifiedDB.exportDatabase();
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `freeapp_backup_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                return { success: true, message: 'æ•°æ®åº“å¯¼å‡ºæˆåŠŸ' };

            } catch (error) {
                console.error('[DatabaseManager] å¯¼å‡ºæ•°æ®åº“å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * ä»æ–‡ä»¶å¯¼å…¥æ•°æ®åº“
         */
        async importFromFile(file, overwrite = false) {
            try {
                console.log('[DatabaseManager] å¼€å§‹å¯¼å…¥æ•°æ®åº“...');
                
                const text = await this.readFileAsText(file);
                const importData = JSON.parse(text);
                
                const result = await window.unifiedDB.importDatabase(importData, { overwrite });
                
                return { 
                    success: true, 
                    message: 'æ•°æ®åº“å¯¼å…¥æˆåŠŸ',
                    result: result
                };

            } catch (error) {
                console.error('[DatabaseManager] å¯¼å…¥æ•°æ®åº“å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * è¯»å–æ–‡ä»¶å†…å®¹ä¸ºæ–‡æœ¬
         */
        readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                reader.readAsText(file);
            });
        }
    };

    // å‘åå…¼å®¹ï¼šä¿ç•™ DatabaseManager çš„ç›´æ¥ window è®¿é—®
    window.DatabaseManager = AppDB.DatabaseManager;

    // ğŸ”¥ æ•°æ®åº“ç»Ÿè®¡åˆ·æ–°å‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIåˆ†ç¦»ï¼‰
    AppDB.refreshDatabaseStats = async function() {
        try {
            // å‘å‡ºåˆ·æ–°å¼€å§‹äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:statsRefreshStart'));
            
            const [result, persistentResult] = await Promise.all([
                window.DatabaseManager.getStats(),
                window.StorageManager.checkPersistentStorage()
            ]);
            
            if (result.success) {
                // å‘å‡ºæˆåŠŸäº‹ä»¶ï¼Œè®©UIå±‚å¤„ç†æ˜¾ç¤º
                window.dispatchEvent(new CustomEvent('database:statsRefreshSuccess', {
                    detail: { result, persistentResult }
                }));
                return { success: true, result, persistentResult };
            } else {
                // å‘å‡ºé”™è¯¯äº‹ä»¶
                window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                    detail: { error: result.error }
                }));
                return { success: false, error: result.error };
            }
            
        } catch (error) {
            console.error('åˆ·æ–°æ•°æ®åº“ç»Ÿè®¡å¤±è´¥:', error);
            // å‘å‡ºé”™è¯¯äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                detail: { error: error.message }
            }));
            return { success: false, error: error.message };
        }
    };

    // å‘åå…¼å®¹ï¼šrefreshDatabaseStats ç°åœ¨é€šè¿‡ UIManager å¤„ç†
    // window.refreshDatabaseStats is now assigned in uiManager.js

    // ğŸ”¥ æ•°æ®åº“å¯¼å‡ºå‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼‰
    AppDB.exportDatabase = async function() {
        try {
            // å‘å‡ºå¯¼å‡ºå¼€å§‹äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:exportStart'));
            
            const result = await window.DatabaseManager.exportAndDownload();
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:exportSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:exportError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('å¯¼å‡ºå‡ºé”™:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:exportError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // ğŸ”¥ æ–‡ä»¶å­˜å‚¨å¯¼å‡ºå‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼Œé…ç½®é€šè¿‡äº‹ä»¶è·å–
    AppDB.exportFileStorage = async function() {
        try {
            // é€šè¿‡äº‹ä»¶è¯·æ±‚å¯¼å‡ºé…ç½®
            const config = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:exportConfigNeeded', {
                    detail: { resolve }
                }));
            });

            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportStart', {
                detail: { config }
            }));

            const exporter = new FileStorageExporter();
            const result = await exporter.downloadFileStorageAsZip(config);

            if (result.success) {
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:exportSuccess', {
                    detail: { 
                        message: 'æ–‡ä»¶å­˜å‚¨å¯¼å‡ºæˆåŠŸï¼',
                        result: result
                    }
                }));
            } else {
                throw new Error(result.error || 'å¯¼å‡ºå¤±è´¥');
            }

        } catch (error) {
            console.error('æ–‡ä»¶å­˜å‚¨å¯¼å‡ºå¤±è´¥:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
        }
    };

    // ğŸ”¥ å¤„ç†æ–‡ä»¶é€‰æ‹©å‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œç§»è‡³UIManager
    AppDB.handleFileSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: 'æœªé€‰æ‹©æ–‡ä»¶' };
        }
        
        console.log('é€‰æ‹©çš„æ–‡ä»¶:', file.name, file.type, file.size);
        
        try {
            const result = await window.importDatabase(file);
            
            // å‘å‡ºæ–‡ä»¶å¤„ç†å®Œæˆäº‹ä»¶ï¼Œè®©UIå±‚å¤„ç†æ¸…ç©ºæ“ä½œ
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('å¯¼å…¥è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('database:importError', {
                detail: {
                    error: error,
                    type: 'import_operation'
                }
            }));
            
            // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // ğŸ”¥ å¤„ç†æ–‡ä»¶å­˜å‚¨é€‰æ‹©å‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œé€šè¿‡äº‹ä»¶å¤„ç†
    AppDB.handleFileStorageSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: 'æœªé€‰æ‹©æ–‡ä»¶' };
        }
        
        console.log('é€‰æ‹©çš„æ–‡ä»¶å­˜å‚¨æ–‡ä»¶:', file.name, file.type, file.size);
        
        try {
            // è¯·æ±‚UIæä¾›å¯¼å…¥é€‰é¡¹
            const options = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:importOptionsNeeded', {
                    detail: { resolve }
                }));
            });
            
            // è°ƒç”¨ä¸šåŠ¡é€»è¾‘æ‰§è¡Œå¯¼å…¥
            const result = await window.performFileStorageImport(file, options);
            
            // å‘å‡ºæ–‡ä»¶å¤„ç†å®Œæˆäº‹ä»¶ï¼Œè®©UIå±‚å¤„ç†æ¸…ç©ºæ“ä½œ
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('æ–‡ä»¶å­˜å‚¨å¯¼å…¥è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:importError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
            
            // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // ğŸ”¥ æ•°æ®åº“å¯¼å…¥å‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼‰
    AppDB.importDatabase = async function(file) {
        if (!file) {
            return { success: false, error: 'æœªæä¾›æ–‡ä»¶' };
        }
        
        try {
            // è¯·æ±‚UIç¡®è®¤
            const confirmed = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('database:importConfirmationNeeded', { 
                    detail: { file, resolve } 
                }));
            });
            
            if (!confirmed) {
                console.log('ç”¨æˆ·å–æ¶ˆå¯¼å…¥');
                return { success: false, message: 'ç”¨æˆ·å–æ¶ˆå¯¼å…¥' };
            }
            
            // å‘å‡ºå¯¼å…¥å¼€å§‹äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:importStart', { 
                detail: { fileName: file.name } 
            }));
            
            // ğŸ¯ ç¡®ä¿performImportå‡½æ•°å·²å°±ç»ª
            if (!window.performImport || typeof window.performImport !== 'function') {
                console.log('â³ [Import] performImportæœªå°±ç»ªï¼Œç­‰å¾…åˆå§‹åŒ–...');
                await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        console.warn('âš ï¸ [Import] performImportç­‰å¾…è¶…æ—¶ï¼Œå°è¯•ç»§ç»­');
                        resolve();
                    }, 3000);

                    const checkReady = () => {
                        if (window.performImport &amp;&amp; typeof window.performImport === 'function') {
                            clearTimeout(timeout);
                            console.log('âœ… [Import] performImportå·²å°±ç»ª');
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }

            const overwrite = true;
            const result = await window.performImport(file, overwrite);

            // ğŸ” å®½å®¹çš„ç»“æœæ£€æŸ¥ - å…è®¸undefinedè¿”å›ï¼Œé€šå¸¸åˆ·æ–°åä¼šæ­£å¸¸
            if (result === undefined) {
                console.warn('âš ï¸ [Import] performImportè¿”å›undefinedï¼Œè¿™é€šå¸¸åœ¨åˆ·æ–°åä¼šè‡ªè¡Œä¿®å¤');
                return {
                    success: false,
                    error: 'å¯¼å…¥åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•',
                    needsRefresh: true
                };
            }
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:importSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:importError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('å¯¼å…¥å¤±è´¥:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:importError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // ğŸ”¥ æ‰§è¡Œå¯¼å…¥å‡½æ•° - é‡æ„ä¸ºäº‹ä»¶é©±åŠ¨æ¶æ„
    AppDB.performImport = async function(file, overwrite) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('database:importProgress', {
                detail: { message: 'æ­£åœ¨å¯¼å…¥æ•°æ®åº“...', stage: 'starting' }
            }));
            
            if (!window.DatabaseManager) {
                console.error('window.DatabaseManager ä¸å­˜åœ¨ï¼');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('æ•°æ®åº“ç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•'),
                        type: 'initialization_error',
                        critical: true
                    }
                }));
                return;
            }
            
            if (!window.DatabaseManager.importFromFile) {
                console.error('importFromFile æ–¹æ³•ä¸å­˜åœ¨ï¼');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('å¯¼å…¥åŠŸèƒ½ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ä»£ç '),
                        type: 'function_missing',
                        critical: true
                    }
                }));
                return;
            }
            
            const result = await window.DatabaseManager.importFromFile(file, overwrite);
            
            if (result.success) {
                // åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯
                if (typeof window.refreshDatabaseStats === 'function') {
                    window.refreshDatabaseStats();
                }
                
                // é‡ç½®åº”ç”¨çŠ¶æ€ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
                window.DatabaseManager.resetApplicationState();
                
                // Event-driven success notification with reload intent
                window.dispatchEvent(new CustomEvent('database:importSuccess', {
                    detail: { 
                        message: 'æ•°æ®åº“å¯¼å…¥æˆåŠŸï¼é¡µé¢å°†åœ¨3ç§’åè‡ªåŠ¨åˆ·æ–°...',
                        result: result,
                        autoReload: true,
                        reloadDelay: 3000
                    }
                }));
                
                // å»¶è¿Ÿåˆ·æ–°é¡µé¢ä»¥ç¡®ä¿ç”¨æˆ·çœ‹åˆ°æˆåŠŸæ¶ˆæ¯
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
                
            } else {
                throw new Error(result.error || 'å¯¼å…¥å¤±è´¥');
            }
            
        } catch (error) {
            console.error('å¯¼å…¥å¤±è´¥:', error.message);
            throw error; // é‡æ–°æŠ›å‡ºä»¥ä¾¿ä¸Šå±‚å¤„ç†
        }
    };

    // ğŸ”¥ æ‰§è¡Œæ–‡ä»¶å­˜å‚¨å¯¼å…¥å‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ˆUIäº¤äº’å·²ç§»è‡³UIManagerï¼‰
    AppDB.performFileStorageImport = async function(file, options) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:importProgress', {
                detail: { message: 'æ­£åœ¨å¯¼å…¥æ–‡ä»¶å­˜å‚¨...', stage: 'starting' }
            }));

            const importer = new FileStorageImporter();
            const response = await importer.importFromZipFile(file, options);

            if (response.success) {
                // æ˜ å°„è¿”å›ç»“æœæ ¼å¼ä»¥ä¿æŒå…¼å®¹æ€§
                const result = {
                    imported: response.results.created,
                    skipped: response.results.skipped,
                    failed: response.results.failed,
                    matched: response.results.matched,
                    processed: response.results.processed,
                    totalFiles: response.results.totalFiles
                };

                const detailedMessage = `æ–‡ä»¶å­˜å‚¨å¯¼å…¥æˆåŠŸï¼\n\nå¯¼å…¥ç»Ÿè®¡ï¼š\nâ€¢ æˆåŠŸå¯¼å…¥ ${result.imported} ä¸ªæ–‡ä»¶\nâ€¢ è·³è¿‡ ${result.skipped} ä¸ªæ–‡ä»¶\nâ€¢ å¤±è´¥ ${result.failed} ä¸ªæ–‡ä»¶`;
                
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:importSuccess', {
                    detail: { 
                        message: 'æ–‡ä»¶å­˜å‚¨å¯¼å…¥æˆåŠŸï¼',
                        detailedMessage: detailedMessage,
                        stats: {
                            imported: result.imported,
                            skipped: result.skipped,
                            failed: result.failed
                        },
                        result: result
                    }
                }));
                
                // åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯
                if (typeof window.refreshDatabaseStats === 'function') {
                    setTimeout(() => {
                        window.refreshDatabaseStats();
                    }, 1000);
                }

            } else {
                throw new Error(response.error || 'å¯¼å…¥å¤±è´¥');
            }

        } catch (error) {
            console.error('æ–‡ä»¶å­˜å‚¨å¯¼å…¥å¤±è´¥:', error);
            throw error; // é‡æ–°æŠ›å‡ºä»¥ä¾¿ä¸Šå±‚å¤„ç†
        }
    };

    // ğŸ”¥ ç¡®è®¤æ–‡ä»¶å¯¼å‡ºå‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œç§»è‡³UIManager
    AppDB.confirmFileExport = async function() {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportProgress', {
                detail: { message: 'æ­£åœ¨å¯¼å‡ºæ–‡ä»¶å­˜å‚¨...', stage: 'confirming' }
            }));

            // å‘å‡ºéšè—é€‰é¡¹é¢æ¿äº‹ä»¶
            window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));

            const result = await window.exportFileStorage();
            return result;

        } catch (error) {
            console.error('ç¡®è®¤æ–‡ä»¶å¯¼å‡ºå¤±è´¥:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'confirmation_error'
                }
            }));
            return { success: false, error: error.message };
        }
    };

    // ğŸ”¥ å–æ¶ˆæ–‡ä»¶å¯¼å‡ºå‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œç§»è‡³UIManager
    AppDB.cancelFileExport = function() {
        // å‘å‡ºéšè—é€‰é¡¹é¢æ¿äº‹ä»¶
        window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));
        
        // Event-driven cancellation notification
        window.dispatchEvent(new CustomEvent('fileStorage:exportCancelled', {
            detail: { message: 'ç”¨æˆ·å–æ¶ˆäº†æ–‡ä»¶å¯¼å‡º' }
        }));
        
        return { success: true, message: 'ç”¨æˆ·å–æ¶ˆäº†æ–‡ä»¶å¯¼å‡º' };
    };

    // ğŸ”¥ å¯¼å…¥æç¤ºè¯å‡½æ•° - é‡æ„ä¸ºäº‹ä»¶é©±åŠ¨æ¶æ„
    AppDB.importPrompts = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                const prompts = JSON.parse(content);
                
                if (Array.isArray(prompts)) {
                    localStorage.setItem('customPrompts', JSON.stringify(prompts));
                    // Event-driven success notification
                    window.dispatchEvent(new CustomEvent('prompts:importSuccess', {
                        detail: { 
                            message: `æˆåŠŸå¯¼å…¥ ${prompts.length} ä¸ªæç¤ºè¯`,
                            count: prompts.length,
                            prompts: prompts
                        }
                    }));
                } else {
                    throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œåº”ä¸ºæç¤ºè¯æ•°ç»„');
                }
            } catch (error) {
                console.error('å¯¼å…¥æç¤ºè¯å¤±è´¥:', error);
                // Event-driven error notification
                window.dispatchEvent(new CustomEvent('prompts:importError', {
                    detail: {
                        error: error,
                        type: 'format_error'
                    }
                }));
            }
        };
        reader.readAsText(file);
        
        // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
        event.target.value = '';
    };
    
    // å‘åå…¼å®¹ï¼šä¿ç•™æ‰€æœ‰å‡½æ•°çš„ç›´æ¥ window è®¿é—®
    window.exportDatabase = AppDB.exportDatabase;
    window.exportFileStorage = AppDB.exportFileStorage;
    // Pure database operations that remain in UnifiedDBManager
    window.importDatabase = AppDB.importDatabase;
    window.performImport = AppDB.performImport;
    window.performFileStorageImport = AppDB.performFileStorageImport;
    window.importPrompts = AppDB.importPrompts;
    
    // UI-related functions are now handled by UIManager
    // window.triggerFileSelect, window.triggerFileStorageImport, etc. are assigned in uiManager.js
    
    window.FileStorageManager = unifiedDB; // ç›´æ¥æ˜ å°„åˆ°ç»Ÿä¸€ç®¡ç†å™¨
    
    console.log('ğŸ”¥ [UnifiedDB] ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨å·²å…¨å±€å¯¼å‡ºï¼ŒåŒ…å«æ‰€æœ‰æ•°æ®åº“ç›¸å…³åŠŸèƒ½');

    // ğŸ¯ é€šçŸ¥æ‰€æœ‰ä¾èµ–å‡½æ•°å·²å°±ç»ª - è§£å†³å•æ–‡ä»¶æ„å»ºæ—¶åºé—®é¢˜
    setTimeout(() => {
        window.dispatchEvent(new CustomEvent('unifieddb:ready', {
            detail: {
                timestamp: Date.now(),
                message: 'æ‰€æœ‰å¯¼å…¥å¯¼å‡ºåŠŸèƒ½å·²å°±ç»ª',
                functions: ['performImport', 'importDatabase', 'exportDatabase', 'performFileStorageImport']
            }
        }));
        console.log('âœ… [UnifiedDB] å°±ç»ªäº‹ä»¶å·²å‘é€ï¼Œå¯¼å…¥åŠŸèƒ½å¯ç”¨');
    }, 0);
}

// ğŸ”¥ Module export removed for browser compatibility
// ES Moduleå¯¼å‡º (removed for standard script loading)

/*
================================================================================
ğŸ“š EVENT-DRIVEN UI ARCHITECTURE DOCUMENTATION
================================================================================

æœ¬æ–‡æ¡£è¯´æ˜äº†é‡æ„åçš„äº‹ä»¶é©±åŠ¨UIæ¶æ„ã€‚æ‰€æœ‰UIäº¤äº’ç°åœ¨é€šè¿‡è‡ªå®šä¹‰äº‹ä»¶è¿›è¡Œï¼Œ
å®ç°äº†ä¸šåŠ¡é€»è¾‘ä¸UIå±‚çš„å®Œå…¨åˆ†ç¦»ã€‚

ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿ï¼š
- âœ… çº¯ä¸šåŠ¡é€»è¾‘ï¼Œå¯å•å…ƒæµ‹è¯•
- âœ… çµæ´»çš„UIå®ç°ï¼ˆå¯ç”¨ä»»ä½•æ¡†æ¶ï¼‰  
- âœ… ä¸€è‡´çš„é”™è¯¯å¤„ç†æ¨¡å¼
- âœ… æ›´å¥½çš„ç”¨æˆ·ä½“éªŒï¼ˆéé˜»å¡äº¤äº’ï¼‰

ğŸ“‹ äº‹ä»¶ç±»å‹æ±‡æ€»ï¼š

ğŸ—‚ï¸ æ–‡ä»¶å­˜å‚¨ç›¸å…³äº‹ä»¶ï¼š
- fileStorage:importOptionsNeeded - éœ€è¦ç”¨æˆ·é€‰æ‹©å¯¼å…¥é€‰é¡¹
- fileStorage:importError - æ–‡ä»¶å­˜å‚¨å¯¼å…¥é”™è¯¯
- fileStorage:importProgress - å¯¼å…¥è¿›åº¦é€šçŸ¥
- fileStorage:importSuccess - å¯¼å…¥æˆåŠŸ
- fileStorage:exportStart - å¯¼å‡ºå¼€å§‹
- fileStorage:exportProgress - å¯¼å‡ºè¿›åº¦
- fileStorage:exportSuccess - å¯¼å‡ºæˆåŠŸ  
- fileStorage:exportError - å¯¼å‡ºé”™è¯¯
- fileStorage:exportCancelled - å¯¼å‡ºå–æ¶ˆ

ğŸ—„ï¸ æ•°æ®åº“ç›¸å…³äº‹ä»¶ï¼š
- database:importConfirmationNeeded - éœ€è¦ç”¨æˆ·ç¡®è®¤å¯¼å…¥
- database:importProgress - å¯¼å…¥è¿›åº¦é€šçŸ¥
- database:importStart - å¯¼å…¥å¼€å§‹
- database:importSuccess - å¯¼å…¥æˆåŠŸ
- database:importError - å¯¼å…¥é”™è¯¯
- database:exportStart - å¯¼å‡ºå¼€å§‹
- database:exportSuccess - å¯¼å‡ºæˆåŠŸ
- database:exportError - å¯¼å‡ºé”™è¯¯
- database:repairNeeded - éœ€è¦æ•°æ®åº“ä¿®å¤
- database:repairSuccess - ä¿®å¤æˆåŠŸ
- database:repairError - ä¿®å¤å¤±è´¥
- database:errorDialog - æ˜¾ç¤ºé”™è¯¯å¯¹è¯æ¡†

ğŸ’¡ æç¤ºè¯ç›¸å…³äº‹ä»¶ï¼š
- prompts:importSuccess - æç¤ºè¯å¯¼å…¥æˆåŠŸ
- prompts:importError - æç¤ºè¯å¯¼å…¥é”™è¯¯

ğŸª å­˜å‚¨ç›¸å…³äº‹ä»¶ï¼š
- storage:persistentGranted - æŒä¹…åŒ–å­˜å‚¨å·²æˆæƒ
- storage:persistentDenied - æŒä¹…åŒ–å­˜å‚¨è¢«æ‹’ç»
- storage:persistentUnsupported - ä¸æ”¯æŒæŒä¹…åŒ–å­˜å‚¨
- storage:persistentError - æŒä¹…åŒ–å­˜å‚¨é”™è¯¯
- storage:statsRefreshNeeded - éœ€è¦åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯

================================================================================
ğŸ“– UIå±‚å®ç°ç¤ºä¾‹
================================================================================

ä»¥ä¸‹æ˜¯æ¨èçš„UIå±‚å®ç°æ¨¡å¼ï¼š

// ğŸ¯ 1. åŸºç¡€é”™è¯¯é€šçŸ¥å¤„ç†
window.addEventListener('fileStorage:importError', (event) => {
    const { error, type } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(error.message, 'error');
    } else {
        // é™çº§åˆ°åŸç”Ÿå¯¹è¯æ¡†
        alert(error.message);
    }
});

// ğŸ¯ 2. ç”¨æˆ·ç¡®è®¤å¯¹è¯æ¡†
window.addEventListener('fileStorage:importOptionsNeeded', (event) => {
    const { resolve, messages } = event.detail;
    
    // ç°ä»£UIå®ç°ç¤ºä¾‹
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: 'å¯¼å…¥é€‰é¡¹',
            message: messages.overwrite,
            buttons: [
                { text: 'è¦†ç›–', style: 'primary', value: true },
                { text: 'ä¿ç•™', style: 'secondary', value: false }
            ]
        }).then(overwrite => {
            return showCustomDialog({
                title: 'å¤„ç†ç¼ºå¤±æ–‡ä»¶',
                message: messages.skipMissing,
                buttons: [
                    { text: 'è·³è¿‡', style: 'primary', value: true },
                    { text: 'å ä½ç¬¦', style: 'secondary', value: false }
                ]
            }).then(skipMissing => {
                resolve({ overwrite, skipMissing });
            });
        });
    } else {
        // é™çº§åˆ°åŸç”Ÿå¯¹è¯æ¡†
        const overwrite = confirm(messages.overwrite);
        const skipMissing = confirm(messages.skipMissing);
        resolve({ overwrite, skipMissing });
    }
});

// ğŸ¯ 3. è¿›åº¦é€šçŸ¥å¤„ç†
window.addEventListener('database:importProgress', (event) => {
    const { message, stage } = event.detail;
    
    if (typeof showProgressToast === 'function') {
        showProgressToast(message);
    } else if (typeof showToast === 'function') {
        showToast(message);
    }
});

// ğŸ¯ 4. æˆåŠŸé€šçŸ¥å¤„ç†
window.addEventListener('database:importSuccess', (event) => {
    const { message, autoReload, reloadDelay } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(message);
    }
    
    // è‡ªåŠ¨åˆ·æ–°å·²ç»åœ¨ä¸šåŠ¡é€»è¾‘ä¸­å¤„ç†ï¼ŒUIå±‚å¯ä»¥æ·»åŠ é¢å¤–çš„è§†è§‰åé¦ˆ
    if (autoReload &amp;&amp; typeof showCountdownNotification === 'function') {
        showCountdownNotification('é¡µé¢å°†è‡ªåŠ¨åˆ·æ–°', reloadDelay);
    }
});

// ğŸ¯ 5. æ•°æ®åº“ä¿®å¤ç¡®è®¤å¯¹è¯æ¡†
window.addEventListener('database:repairNeeded', (event) => {
    const { missingStores, resolve } = event.detail;
    
    const message = `å‘ç°æ•°æ®åº“ç»“æ„é—®é¢˜ï¼Œç¼ºå¤±ä»¥ä¸‹å­˜å‚¨ï¼š\n${missingStores.join(', ')}\n\næ˜¯å¦ç«‹å³ä¿®å¤ï¼Ÿ`;
    
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: 'æ•°æ®åº“ä¿®å¤',
            message: message,
            type: 'warning',
            buttons: [
                { text: 'ç«‹å³ä¿®å¤', style: 'primary', value: true },
                { text: 'ç¨åå¤„ç†', style: 'secondary', value: false }
            ]
        }).then(resolve);
    } else {
        const shouldRepair = confirm(message);
        resolve(shouldRepair);
    }
});

// ğŸ¯ 6. å¤æ‚ç»Ÿè®¡ä¿¡æ¯å±•ç¤º
window.addEventListener('fileStorage:importSuccess', (event) => {
    const { message, stats, detailedMessage } = event.detail;
    
    if (typeof showDetailedNotification === 'function') {
        showDetailedNotification({
            title: 'å¯¼å…¥å®Œæˆ',
            message: message,
            details: `æˆåŠŸï¼š${stats.imported}ï¼Œè·³è¿‡ï¼š${stats.skipped}ï¼Œå¤±è´¥ï¼š${stats.failed}`,
            type: 'success'
        });
    } else if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(detailedMessage);
    }
});

================================================================================
ğŸ”§ UIæ¡†æ¶é›†æˆæŒ‡å—
================================================================================

ğŸ¨ Vue.js é›†æˆç¤ºä¾‹ï¼š
// åœ¨Vueç»„ä»¶ä¸­
mounted() {
    // ç›‘å¬æ•°æ®åº“äº‹ä»¶
    window.addEventListener('database:importError', this.handleImportError);
    window.addEventListener('database:importSuccess', this.handleImportSuccess);
},
methods: {
    handleImportError(event) {
        this.$toast.error(event.detail.error.message);
    },
    handleImportSuccess(event) {
        this.$toast.success(event.detail.message);
        if (event.detail.autoReload) {
            this.showCountdown(event.detail.reloadDelay);
        }
    }
}

âš›ï¸ React é›†æˆç¤ºä¾‹ï¼š
// åœ¨Reactç»„ä»¶ä¸­
useEffect(() => {
    const handleImportError = (event) => {
        toast.error(event.detail.error.message);
    };
    
    window.addEventListener('database:importError', handleImportError);
    return () => window.removeEventListener('database:importError', handleImportError);
}, []);

ğŸ° Vanilla JS é›†æˆç¤ºä¾‹ï¼š
// åˆ›å»ºç»Ÿä¸€çš„äº‹ä»¶å¤„ç†ç®¡ç†å™¨
class UIEventManager {
    constructor() {
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // é”™è¯¯å¤„ç†
        ['database:importError', 'fileStorage:importError', 'prompts:importError']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleError.bind(this));
            });
            
        // æˆåŠŸå¤„ç†
        ['database:importSuccess', 'fileStorage:importSuccess', 'prompts:importSuccess']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleSuccess.bind(this));
            });
    }
    
    handleError(event) {
        const { error, type } = event.detail;
        this.showNotification(error.message, 'error');
    }
    
    handleSuccess(event) {
        const { message } = event.detail;
        this.showNotification(message, 'success');
    }
}

// å¯ç”¨äº‹ä»¶ç®¡ç†å™¨
document.addEventListener('DOMContentLoaded', () => {
    new UIEventManager();
});

================================================================================
ğŸ’¯ æœ€ä½³å®è·µ
================================================================================

1. âœ… é™çº§ç­–ç•¥ï¼šå§‹ç»ˆæä¾›åŸç”Ÿå¯¹è¯æ¡†ä½œä¸ºé™çº§æ–¹æ¡ˆ
2. âœ… é”™è¯¯åˆ†ç±»ï¼šä½¿ç”¨ detail.type åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
3. âœ… è¿›åº¦åé¦ˆï¼šé•¿æ—¶é—´æ“ä½œæä¾›è¿›åº¦é€šçŸ¥
4. âœ… ä¸€è‡´æ€§ï¼šæ‰€æœ‰UIäº¤äº’ä½¿ç”¨ç›¸åŒçš„äº‹ä»¶æ¨¡å¼
5. âœ… å¯è®¿é—®æ€§ï¼šç¡®ä¿äº‹ä»¶åŒ…å«è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ä¿¡æ¯
6. âœ… æ¸…ç†ï¼šç»„ä»¶é”€æ¯æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
7. âœ… æµ‹è¯•å‹å¥½ï¼šäº‹ä»¶å¯ä»¥è½»æ¾æ¨¡æ‹Ÿå’Œæµ‹è¯•

é€šè¿‡éµå¾ªè¿™äº›æ¨¡å¼ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªå®Œå…¨è§£è€¦ã€å¯æµ‹è¯•ã€å¯ç»´æŠ¤çš„åº”ç”¨æ¶æ„ï¼

================================================================================
*/
// export default UnifiedDBManager;
// export { unifiedDB };
</script>
    
    <!-- æ–‡ä»¶å’Œå›¾ç‰‡å¤„ç†æ¨¡å— -->
    <script>
/**
 * è¯¦ç»†é”™è¯¯ç±» - æä¾›é”™è¯¯ç±»å‹å’Œç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
 */
class DetailedError extends Error {
    constructor(code, message) {
        super(message);
        this.name = 'DetailedError';
        this.code = code;
    }
}

/**
 * å›¾ç‰‡å­˜å‚¨API - é«˜çº§æ¥å£
 * æä¾›ç®€å•æ˜“ç”¨çš„å›¾ç‰‡å­˜å‚¨å’Œè·å–æ¥å£ï¼Œå°è£…åº•å±‚çš„æ–‡ä»¶å­˜å‚¨ç®¡ç†å™¨
 */

class ImageStorageAPI {
    constructor() {
        this.fileManager = null;
        this.isInitialized = false;
        this.initPromise = null;
    }

    /**
     * åˆå§‹åŒ–å›¾ç‰‡å­˜å‚¨API
     */
    async init() {
        if (this.isInitialized) {
            return this.fileManager;
        }

        if (this.initPromise) {
            return this.initPromise;
        }

        this.initPromise = this._initInternal();
        return this.initPromise;
    }

    async _initInternal() {
        try {
            // ç¡®ä¿UnifiedDBManagerå·²åŠ è½½ï¼ˆé€šè¿‡FileStorageManagerå…¼å®¹æ€§æ˜ å°„ï¼‰
            if (!window.FileStorageManager) {
                throw new Error('UnifiedDBManageræœªåŠ è½½æˆ–FileStorageManageræ˜ å°„æœªè®¾ç½®');
            }

            this.fileManager = window.FileStorageManager;
            await this.fileManager.init();
            
            this.isInitialized = true;
            // å›¾ç‰‡å­˜å‚¨APIåˆå§‹åŒ–å®Œæˆ
            return this.fileManager;
        } catch (error) {
            console.error('å›¾ç‰‡å­˜å‚¨APIåˆå§‹åŒ–å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * å­˜å‚¨å¤´åƒå›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®ï¼ˆbase64å­—ç¬¦ä¸²ã€Fileå¯¹è±¡æˆ–Blobå¯¹è±¡ï¼‰
     * @param {string} entityType - å®ä½“ç±»å‹ï¼ˆ'user' æˆ– 'contact'ï¼‰
     * @param {string} entityId - å®ä½“IDï¼ˆç”¨æˆ·IDæˆ–è”ç³»äººIDï¼‰
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeAvatar(imageData, entityType, entityId) {
        await this.init();

        try {
            // éªŒè¯è¾“å…¥å‚æ•°
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
            }
            
            if (!entityType || !entityId) {
                throw new DetailedError('PARAM_MISSING', 'ç¼ºå°‘å¿…è¦çš„å‚æ•°');
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆå¦‚æœæ˜¯Fileæˆ–Blobå¯¹è±¡ï¼‰
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', 'æ–‡ä»¶å¤§å°è¶…è¿‡10MBé™åˆ¶');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                }
            }

            // å­˜å‚¨æ–‡ä»¶
            const result = await this.fileManager.storeFile(imageData, {
                type: 'avatar',
                entityType: entityType,
                entityId: entityId
            });

            // åˆ›å»ºå¼•ç”¨å…³ç³»
            await this.fileManager.createFileReference(
                result.fileId,
                `avatar_${entityType}`,
                entityId,
                {
                    originalType: entityType,
                    storedAt: new Date().toISOString()
                }
            );

            // å¤´åƒå­˜å‚¨æˆåŠŸ
            return result.fileId;

        } catch (error) {
            console.error(`å­˜å‚¨${entityType}å¤´åƒå¤±è´¥:`, error);
            console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', {
                errorName: error.name,
                errorCode: error.code,
                errorMessage: error.message,
                originalError: error.originalError,
                stackTrace: error.stack,
                entityType: entityType,
                entityId: entityId,
                fileType: imageData instanceof File ? imageData.type : 'unknown',
                fileSize: imageData instanceof File ? imageData.size : 'unknown'
            });
            
            // å¦‚æœæ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„DetailedErroræˆ–è€…å·²ç»æœ‰codeå±æ€§ï¼Œç›´æ¥æŠ›å‡º
            if (error instanceof DetailedError || error.name === 'DetailedError' || error.code) {
                throw error;
            }
            
            // å¤„ç†å…¶ä»–ç±»å‹çš„é”™è¯¯
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æ•°æ®åé‡è¯•');
            }
            
            if (error.name === 'InvalidStateError' || (error.message &amp;&amp; error.message.includes('database'))) {
                throw new DetailedError('DATABASE_ERROR', 'æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
            }
            
            if (error.message &amp;&amp; (error.message.includes('UnifiedDBManageræœªåŠ è½½') || error.message.includes('FileStorageManageræœªåŠ è½½'))) {
                throw new DetailedError('SYSTEM_ERROR', 'æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿæœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            
            if (error.message &amp;&amp; error.message.includes('è¡¨ä¸å­˜åœ¨')) {
                throw new DetailedError('DATABASE_SCHEMA_ERROR', 'æ•°æ®åº“è¡¨ç»“æ„ä¸å®Œæ•´ï¼Œè¯·åˆ·æ–°é¡µé¢é‡æ–°åˆå§‹åŒ–');
            }
            
            // é»˜è®¤é”™è¯¯ - æä¾›æ›´å¤šè°ƒè¯•ä¿¡æ¯
            const errorMsg = error.message || error.toString() || 'æœªçŸ¥é”™è¯¯';
            throw new DetailedError('UNKNOWN_ERROR', `å¤´åƒä¸Šä¼ å¤±è´¥: ${errorMsg}`);
        }
    }

    /**
     * è·å–å¤´åƒå›¾ç‰‡URL
     * @param {string} entityType - å®ä½“ç±»å‹ï¼ˆ'user' æˆ– 'contact'ï¼‰
     * @param {string} entityId - å®ä½“ID
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›ç©ºå­—ç¬¦ä¸²
     */
    async getAvatarURL(entityType, entityId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(`avatar_${entityType}`, entityId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error(`è·å–${entityType}å¤´åƒå¤±è´¥:`, error);
            return '';
        }
    }

    /**
     * å­˜å‚¨èƒŒæ™¯å›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®
     * @param {string} backgroundId - èƒŒæ™¯ID
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeBackground(imageData, backgroundId) {
        await this.init();

        try {
            // éªŒè¯è¾“å…¥å‚æ•°
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', 'æ²¡æœ‰é€‰æ‹©èƒŒæ™¯å›¾ç‰‡');
            }
            
            if (!backgroundId) {
                throw new DetailedError('PARAM_MISSING', 'èƒŒæ™¯IDä¸èƒ½ä¸ºç©º');
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œç±»å‹
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 15 * 1024 * 1024; // 15MBï¼ˆèƒŒæ™¯å›¾ç‰‡å¯ä»¥ç¨å¤§ï¼‰
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', 'èƒŒæ™¯å›¾ç‰‡å¤§å°è¶…è¿‡15MBé™åˆ¶');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ä½œä¸ºèƒŒæ™¯');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'background',
                backgroundId: backgroundId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'background',
                backgroundId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // èƒŒæ™¯å›¾ç‰‡å­˜å‚¨æˆåŠŸ
            return result.fileId;

        } catch (error) {
            console.error('å­˜å‚¨èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
            
            // å¦‚æœæ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„DetailedErrorï¼Œç›´æ¥æŠ›å‡º
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // å¤„ç†å…¶ä»–ç±»å‹çš„é”™è¯¯
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æ•°æ®åé‡è¯•');
            }
            
            if (error.name === 'InvalidStateError' || error.message &amp;&amp; error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', 'æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
            }
            
            if (error.message &amp;&amp; (error.message.includes('UnifiedDBManageræœªåŠ è½½') || error.message.includes('FileStorageManageræœªåŠ è½½'))) {
                throw new DetailedError('SYSTEM_ERROR', 'æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿæœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            
            // é»˜è®¤é”™è¯¯
            throw new DetailedError('UNKNOWN_ERROR', `èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    }

    /**
     * è·å–èƒŒæ™¯å›¾ç‰‡URL
     * @param {string} backgroundId - èƒŒæ™¯ID
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
     */
    async getBackgroundURL(backgroundId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('background', backgroundId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('è·å–èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
            return '';
        }
    }

    /**
     * å­˜å‚¨è¡¨æƒ…åŒ…å›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®
     * @param {string} emojiTag - è¡¨æƒ…æ ‡ç­¾
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeEmoji(imageData, emojiTag) {
        await this.init();

        try {
            // éªŒè¯è¾“å…¥å‚æ•°
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', 'æ²¡æœ‰é€‰æ‹©è¡¨æƒ…åŒ…å›¾ç‰‡');
            }
            
            if (!emojiTag) {
                throw new DetailedError('PARAM_MISSING', 'è¡¨æƒ…åŒ…æ ‡ç­¾ä¸èƒ½ä¸ºç©º');
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œç±»å‹
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
                const maxSize = 5 * 1024 * 1024; // 5MBï¼ˆè¡¨æƒ…åŒ…é€šå¸¸è¾ƒå°ï¼‰
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', 'è¡¨æƒ…åŒ…å¤§å°è¶…è¿‡5MBé™åˆ¶');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ä½œä¸ºè¡¨æƒ…åŒ…');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'emoji',
                tag: emojiTag
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'emoji',
                emojiTag,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // è®¾ç½®å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ® - è¡¨æƒ…åŒ…åˆ†ç±»
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'emoji',
                tags: [emojiTag],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`è¡¨æƒ…åŒ…å­˜å‚¨æˆåŠŸå¹¶è®¾ç½®åˆ†ç±»: ${emojiTag} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('å­˜å‚¨è¡¨æƒ…åŒ…å¤±è´¥:', error);
            
            // å¦‚æœæ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„DetailedErrorï¼Œç›´æ¥æŠ›å‡º
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // å¤„ç†å…¶ä»–ç±»å‹çš„é”™è¯¯
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æ•°æ®åé‡è¯•');
            }
            
            if (error.name === 'InvalidStateError' || error.message &amp;&amp; error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', 'æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
            }
            
            if (error.message &amp;&amp; (error.message.includes('UnifiedDBManageræœªåŠ è½½') || error.message.includes('FileStorageManageræœªåŠ è½½'))) {
                throw new DetailedError('SYSTEM_ERROR', 'æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿæœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            
            // é»˜è®¤é”™è¯¯
            throw new DetailedError('UNKNOWN_ERROR', `è¡¨æƒ…åŒ…ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    }

    /**
     * è·å–è¡¨æƒ…åŒ…å›¾ç‰‡URL
     * @param {string} emojiTag - è¡¨æƒ…æ ‡ç­¾
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
     */
    async getEmojiURL(emojiTag) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('emoji', emojiTag);
            if (!reference) {
                return '';
            }


            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('è·å–è¡¨æƒ…åŒ…å¤±è´¥:', error);
            return '';
        }
    }

    /**
     * å­˜å‚¨æœ‹å‹åœˆå›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeMomentImage(imageData, momentId) {
        await this.init();

        try {
            // è·å–æ–‡ä»¶å¤§å°ç”¨äºå…ƒæ•°æ®
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'moment',
                momentId: momentId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'moment_image',
                momentId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // è®¾ç½®æœ‹å‹åœˆå›¾ç‰‡åˆ†ç±»
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'moments',
                tags: ['æœ‹å‹åœˆ', momentId],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`æœ‹å‹åœˆå›¾ç‰‡å­˜å‚¨æˆåŠŸå¹¶è®¾ç½®åˆ†ç±»: ${momentId} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('å­˜å‚¨æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–æœ‹å‹åœˆå›¾ç‰‡URL
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
     */
    async getMomentImageURL(momentId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('moment_image', momentId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('è·å–æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            return '';
        }
    }

    /**
     * å­˜å‚¨æœ‹å‹åœˆå¤šå›¾ç‰‡
     * @param {Array} imageDataArray - å›¾ç‰‡æ•°æ®æ•°ç»„
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @returns {Promise<Array>} è¿”å›fileIdæ•°ç»„
     */
    async storeMomentImages(imageDataArray, momentId) {
        await this.init();

        try {
            const fileIds = [];

            for (let i = 0; i < imageDataArray.length; i++) {
                const imageData = imageDataArray[i];
                
                // è·å–æ–‡ä»¶å¤§å°
                let fileSize = 0;
                if (imageData instanceof File || imageData instanceof Blob) {
                    fileSize = imageData.size;
                }

                const result = await this.fileManager.storeFile(imageData, {
                    type: 'moment',
                    momentId: momentId,
                    imageIndex: i
                });

                await this.fileManager.createFileReference(
                    result.fileId,
                    'moment_image',
                    `${momentId}_${i}`, // ä½¿ç”¨ç´¢å¼•åŒºåˆ†å¤šå¼ å›¾ç‰‡
                    {
                        storedAt: new Date().toISOString(),
                        imageIndex: i,
                        momentId: momentId
                    }
                );

                // è®¾ç½®æœ‹å‹åœˆå›¾ç‰‡åˆ†ç±»
                await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                    category: 'moments',
                    tags: ['æœ‹å‹åœˆ', momentId, `å›¾ç‰‡${i + 1}`],
                    size: fileSize,
                    createdAt: new Date().toISOString()
                });

                fileIds.push(result.fileId);
            }

            console.log(`æœ‹å‹åœˆå¤šå›¾ç‰‡å­˜å‚¨æˆåŠŸå¹¶è®¾ç½®åˆ†ç±»: ${fileIds.length}å¼ å›¾ç‰‡`);
            return fileIds;

        } catch (error) {
            console.error('å­˜å‚¨æœ‹å‹åœˆå¤šå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–æœ‹å‹åœˆå¤šå›¾ç‰‡URLs
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @param {number} imageCount - å›¾ç‰‡æ•°é‡
     * @returns {Promise<Array>} è¿”å›å›¾ç‰‡URLæ•°ç»„
     */
    async getMomentImagesURLs(momentId, imageCount) {
        await this.init();

        try {
            const urls = [];
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                const reference = await this.fileManager.getFileReference('moment_image', referenceKey);
                if (reference) {
                    const url = await this.fileManager.createFileURL(reference.fileId);
                    urls.push(url);
                } else {
                    console.warn(`æœ‹å‹åœˆå›¾ç‰‡ä¸å­˜åœ¨: ${referenceKey}`);
                }
            }
            return urls;
        } catch (error) {
            console.error('è·å–æœ‹å‹åœˆå¤šå›¾ç‰‡å¤±è´¥:', error);
            return [];
        }
    }

    /**
     * åˆ é™¤æœ‹å‹åœˆæ‰€æœ‰å›¾ç‰‡
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @param {number} imageCount - å›¾ç‰‡æ•°é‡
     */
    async deleteMomentImages(momentId, imageCount) {
        await this.init();

        try {
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                await this.deleteImage('moment_image', referenceKey);
            }
            console.log(`æœ‹å‹åœˆå›¾ç‰‡åˆ é™¤æˆåŠŸ: ${momentId}`);
        } catch (error) {
            console.error('åˆ é™¤æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * åˆ é™¤å›¾ç‰‡
     * @param {string} referenceType - å¼•ç”¨ç±»å‹
     * @param {string} referenceKey - å¼•ç”¨é”®
     */
    async deleteImage(referenceType, referenceKey) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(referenceType, referenceKey);
            if (reference) {
                // åˆ é™¤æ–‡ä»¶
                await this.fileManager.deleteFile(reference.fileId);
                // åˆ é™¤å¼•ç”¨
                await this.fileManager.deleteFileReference(referenceType, referenceKey);
                console.log(`å›¾ç‰‡åˆ é™¤æˆåŠŸ: ${referenceType}/${referenceKey}`);
            }
        } catch (error) {
            console.error('åˆ é™¤å›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ‰¹é‡è¿ç§»base64æ•°æ®åˆ°Blobå­˜å‚¨
     * @param {string} sourceType - æºæ•°æ®ç±»å‹ï¼ˆ'avatars', 'backgrounds', 'emojis'ï¼‰
     * @param {Array} dataArray - è¦è¿ç§»çš„æ•°æ®æ•°ç»„
     * @param {Function} progressCallback - è¿›åº¦å›è°ƒå‡½æ•°
     */
    async migrateBulkData(sourceType, dataArray, progressCallback = null) {
        await this.init();

        const results = {
            success: 0,
            failed: 0,
            errors: []
        };

        for (let i = 0; i < dataArray.length; i++) {
            const item = dataArray[i];
            
            try {
                if (progressCallback) {
                    progressCallback({
                        current: i + 1,
                        total: dataArray.length,
                        item: item,
                        type: sourceType
                    });
                }

                let fileId = null;

                switch (sourceType) {
                    case 'avatars':
                        if (item.avatar &amp;&amp; item.avatar.startsWith('data:')) {
                            const entityType = item.type || 'contact'; // å‡è®¾é»˜è®¤ä¸ºcontact
                            fileId = await this.storeAvatar(item.avatar, entityType, item.id);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.avatar = '';
                            item.avatarFileId = fileId;
                        }
                        break;

                    case 'backgrounds':
                        if (item.data &amp;&amp; item.data.startsWith('data:')) {
                            fileId = await this.storeBackground(item.data, item.id);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'emojis':
                        if (item.data &amp;&amp; item.data.startsWith('data:')) {
                            fileId = await this.storeEmoji(item.data, item.tag);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'moments':
                        if (item.image &amp;&amp; item.image.startsWith('data:')) {
                            fileId = await this.storeMomentImage(item.image, item.id);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.image = '';
                            item.imageFileId = fileId;
                        }
                        break;
                }

                if (fileId) {
                    results.success++;
                } else {
                    // æ²¡æœ‰éœ€è¦è¿ç§»çš„æ•°æ®
                }

            } catch (error) {
                results.failed++;
                results.errors.push({
                    item: item,
                    error: error.message
                });
                console.error(`è¿ç§»æ•°æ®å¤±è´¥ (${sourceType}):`, error, item);
            }
        }

        return results;
    }

    /**
     * è·å–å­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
     */
    async getStorageStats() {
        await this.init();
        return await this.fileManager.getStorageStats();
    }

    /**
     * æ¸…ç†æœªä½¿ç”¨çš„æ–‡ä»¶
     */
    async cleanupUnusedFiles() {
        await this.init();
        return await this.fileManager.cleanupUnusedFiles();
    }

    /**
     * æ¸…ç†ä¸´æ—¶å¤´åƒå¼•ç”¨
     * æ¸…ç†æ‰€æœ‰ä»¥ 'temp_' å¼€å¤´çš„å¤´åƒå¼•ç”¨
     */
    async cleanupTempAvatarReferences() {
        await this.init();
        
        try {
            // è·å–æ‰€æœ‰å¤´åƒå¼•ç”¨
            const transaction = window.db.transaction(['fileReferences'], 'readwrite');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('avatar_contact');
            
            request.onsuccess = async () => {
                const references = request.result;
                const tempReferences = references.filter(ref => 
                    ref.referenceKey &amp;&amp; ref.referenceKey.startsWith('temp_')
                );
                
                console.log(`æ‰¾åˆ° ${tempReferences.length} ä¸ªä¸´æ—¶å¤´åƒå¼•ç”¨ï¼Œå¼€å§‹æ¸…ç†...`);
                
                for (const ref of tempReferences) {
                    try {
                        // åˆ é™¤æ–‡ä»¶å¼•ç”¨
                        await this.fileManager.deleteFileReference('avatar_contact', ref.referenceKey);
                        // å°è¯•åˆ é™¤å¯¹åº”çš„æ–‡ä»¶
                        if (ref.fileId) {
                            await this.fileManager.deleteFile(ref.fileId);
                        }
                        console.log(`æ¸…ç†ä¸´æ—¶å¼•ç”¨: ${ref.referenceId}`);
                    } catch (error) {
                        console.warn(`æ¸…ç†ä¸´æ—¶å¼•ç”¨å¤±è´¥: ${ref.referenceId}`, error);
                    }
                }
                
                console.log('ä¸´æ—¶å¤´åƒå¼•ç”¨æ¸…ç†å®Œæˆ');
            };
            
            request.onerror = () => {
                console.error('è·å–å¤´åƒå¼•ç”¨å¤±è´¥:', request.error);
            };
            
        } catch (error) {
            console.error('æ¸…ç†ä¸´æ—¶å¤´åƒå¼•ç”¨å¤±è´¥:', error);
        }
    }

    // === å›¾ç‰‡åˆ†ç±»ç®¡ç†æ–¹æ³• ===




    /**
     * æ‰‹åŠ¨è®¾ç½®å›¾ç‰‡åˆ†ç±»
     * @param {string} fileId - æ–‡ä»¶ID
     * @param {string} usageType - æ–°çš„ä½¿ç”¨ç±»å‹
     * @param {Object} metadata - é¢å¤–å…ƒæ•°æ®
     */
    async setImageClassification(fileId, usageType, metadata = {}) {
        await this.init();
        return await this.fileManager.setImageUsageMetadata(fileId, usageType, metadata);
    }




    /**
     * æ£€æŸ¥æ˜¯å¦éœ€è¦æ•°æ®è¿ç§»
     */
    async needsMigration() {
        try {
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ—§çš„base64æ•°æ®
            if (!window.db || !window.isIndexedDBReady) {
                return false;
            }

            const transaction = window.db.transaction(['contacts', 'emojiImages', 'backgrounds', 'userProfile', 'moments'], 'readonly');
            
            // æ£€æŸ¥contactsä¸­æ˜¯å¦æœ‰avatar base64æ•°æ®
            const contactsStore = transaction.objectStore('contacts');
            const contactsRequest = contactsStore.getAll();
            
            return new Promise((resolve) => {
                contactsRequest.onsuccess = () => {
                    const contacts = contactsRequest.result;
                    const hasBase64Avatars = contacts.some(contact => 
                        contact.avatar &amp;&amp; contact.avatar.startsWith('data:')
                    );
                    
                    resolve(hasBase64Avatars);
                };
                
                contactsRequest.onerror = () => {
                    resolve(false);
                };
            });

        } catch (error) {
            console.error('æ£€æŸ¥è¿ç§»éœ€æ±‚å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * å­˜å‚¨bannerå›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®ï¼ˆbase64å­—ç¬¦ä¸²ã€Fileå¯¹è±¡æˆ–Blobå¯¹è±¡ï¼‰
     * @param {string} bannerId - banneræ ‡è¯†ç¬¦
     * @returns {Promise<string>} æ–‡ä»¶ID
     */
    async storeBanner(imageData, bannerId) {
        await this.init();
        
        try {
            console.log('å¼€å§‹å­˜å‚¨bannerå›¾ç‰‡ï¼ŒbannerId:', bannerId);
            
            // å¤„ç†ä¸åŒç±»å‹çš„å›¾ç‰‡æ•°æ®
            let blob;
            if (imageData instanceof Blob) {
                blob = imageData;
                console.log('å¤„ç†Blobæ•°æ®ï¼Œå¤§å°:', blob.size);
            } else if (imageData instanceof File) {
                blob = imageData;
                console.log('å¤„ç†Fileæ•°æ®ï¼Œå¤§å°:', blob.size);
            } else if (typeof imageData === 'string' &amp;&amp; imageData.startsWith('data:image/')) {
                // å¤„ç†base64æ•°æ®
                blob = await this._base64ToBlob(imageData);
                console.log('å¤„ç†base64æ•°æ®ï¼Œè½¬æ¢åå¤§å°:', blob.size);
            } else {
                throw new Error('ä¸æ”¯æŒçš„å›¾ç‰‡æ•°æ®æ ¼å¼');
            }

            // å­˜å‚¨æ–‡ä»¶
            const fileResult = await this.fileManager.storeFile(blob, 'image/jpeg');
            console.log('æ–‡ä»¶å­˜å‚¨å®Œæˆï¼Œç»“æœ:', fileResult);
            
            const fileId = fileResult.fileId; // æå–å®é™…çš„æ–‡ä»¶IDå­—ç¬¦ä¸²
            console.log('æå–çš„æ–‡ä»¶IDå­—ç¬¦ä¸²:', fileId);
            
            // åˆ›å»ºå¼•ç”¨
            const referenceId = `banner_${bannerId}`;
            console.log('åˆ›å»ºæ–‡ä»¶å¼•ç”¨ï¼Œå¼•ç”¨ID:', referenceId, 'æ–‡ä»¶ID:', fileId);
            await this.fileManager.createFileReference(fileId, 'banner', bannerId);
            
            console.log(`Bannerå›¾ç‰‡å­˜å‚¨æˆåŠŸ: ${bannerId} -> ${fileId}`);
            return fileId;
            
        } catch (error) {
            console.error('å­˜å‚¨bannerå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–bannerå›¾ç‰‡URL
     * @param {string} bannerId - banneræ ‡è¯†ç¬¦
     * @returns {Promise<string|null>} å›¾ç‰‡URLï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›null
     */
    async getBannerURL(bannerId) {
        await this.init();
        
        try {
            console.log('æŸ¥æ‰¾bannerï¼ŒbannerId:', bannerId);
            const referenceResult = await this.fileManager.getFileReference('banner', bannerId);
            console.log('è·å–åˆ°çš„å¼•ç”¨ç»“æœ:', referenceResult);
            
            if (!referenceResult || !referenceResult.fileId) {
                console.log('æœªæ‰¾åˆ°banneræ–‡ä»¶å¼•ç”¨æˆ–æ–‡ä»¶ID');
                return null;
            }
            
            const fileId = referenceResult.fileId;
            console.log('æå–çš„æ–‡ä»¶ID:', fileId);
            const url = await this.fileManager.createFileURL(fileId);
            console.log('ç”Ÿæˆçš„banner URL:', url);
            return url;
            
        } catch (error) {
            console.error('è·å–bannerå›¾ç‰‡URLå¤±è´¥:', error);
            return null;
        }
    }

    /**
     * å°†base64è½¬æ¢ä¸ºBlob
     * @private
     */
    async _base64ToBlob(base64) {
        try {
            const [header, data] = base64.split(',');
            const mimeType = header.match(/data:(.+?);/)[1];
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('base64è½¬Blobå¤±è´¥:', error);
            throw new Error('base64æ•°æ®æ ¼å¼é”™è¯¯');
        }
    }
}

// === æ–‡ä»¶ä¸Šä¼ å¤„ç†å‡½æ•° ===

/**
 * é€šç”¨æ–‡ä»¶ä¸Šä¼ å‡½æ•°
 */
async function handleFileUpload(inputId, targetUrlInputId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);
    const targetUrlInput = document.getElementById(targetUrlInputId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    // ä½¿ç”¨ FileReader å°†å›¾ç‰‡è½¬ä¸º Base64
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
        targetUrlInput.value = reader.result;
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('å›¾ç‰‡å·²åŠ è½½');
    };
    reader.onerror = (error) => {
        console.error('æ–‡ä»¶è¯»å–å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'è¯»å–å¤±è´¥';
        if (typeof showToast === 'function') showToast(`è¯»å–å¤±è´¥: ${error.message}`);
    };
}

/**
 * å¤„ç†å¤´åƒä¸Šä¼ 
 */
async function handleAvatarUpload(inputId, entityType, entityId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    try {
        // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨å¤´åƒ
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI æœªåˆå§‹åŒ–');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeAvatar(file, entityType, entityId);
        
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('å¤´åƒå·²ä¿å­˜', 'success');
        
        // è¿”å›æ–‡ä»¶IDç”¨äºåç»­å¤„ç†
        return fileId;
    } catch (error) {
        console.error('å¤´åƒä¸Šä¼ å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ å¤±è´¥';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * å¤„ç†èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ 
 */
async function handleBackgroundUpload(inputId, contactId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    try {
        // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨èƒŒæ™¯å›¾ç‰‡
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI æœªåˆå§‹åŒ–');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeBackground(file, contactId);
        
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('èƒŒæ™¯å›¾ç‰‡å·²ä¿å­˜', 'success');
        
        // è¿”å›æ–‡ä»¶IDç”¨äºåç»­å¤„ç†
        return fileId;
    } catch (error) {
        console.error('èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ å¤±è´¥';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * å¤„ç†è¡¨æƒ…åŒ…ä¸Šä¼ 
 */
async function handleEmojiUpload(inputId, emojiTag, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    try {
        // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨è¡¨æƒ…åŒ…
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI æœªåˆå§‹åŒ–');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('è¡¨æƒ…åŒ…å·²ä¿å­˜', 'success');
        
        // è¿”å›æ–‡ä»¶IDç”¨äºåç»­å¤„ç†
        return fileId;
    } catch (error) {
        console.error('è¡¨æƒ…åŒ…ä¸Šä¼ å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ å¤±è´¥';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

// å…¨å±€å˜é‡å­˜å‚¨ä¸´æ—¶ä¸Šä¼ çš„è¡¨æƒ…åŒ…æ–‡ä»¶
let tempEmojiFile = null;

/**
 * å¤„ç†è¡¨æƒ…åŒ…æ–‡ä»¶ä¸Šä¼ 
 */
async function handleEmojiFileUpload(event) {
    try {
        const fileInput = document.getElementById('emojiUploadInput');
        const file = fileInput.files[0];
        
        if (!file) {
            if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
            return;
        }
        
        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
            return;
        }
        
        // ç®€å•å­˜å‚¨æ–‡ä»¶å¯¹è±¡ï¼Œç­‰å¾…ä¿å­˜æ—¶å¤„ç†
        tempEmojiFile = file;
        window.ImageUploadHandlers.tempEmojiFile = file;  // åŒæ­¥æ›´æ–°åˆ°æš´éœ²çš„å¯¹è±¡ä¸­
        
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = 'å›¾ç‰‡å·²é€‰æ‹©';
            statusElement.style.color = '#07c160';
        }
        
        // ç”Ÿæˆä¸´æ—¶URLç”¨äºé¢„è§ˆ
        const tempUrl = URL.createObjectURL(file);
        document.getElementById('emojiUrl').value = `temp:${tempUrl}`;
        
        if (typeof showToast === 'function') showToast('å›¾ç‰‡å·²é€‰æ‹©ï¼Œå¡«å†™æ„æ€åç‚¹å‡»æ·»åŠ ');
        
    } catch (error) {
        console.error('è¡¨æƒ…åŒ…æ–‡ä»¶é€‰æ‹©å¤±è´¥:', error);
        if (typeof showToast === 'function') showToast('æ–‡ä»¶é€‰æ‹©å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

/**
 * ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨è¡¨æƒ…åŒ…çš„è¾…åŠ©å‡½æ•°
 */
async function storeEmojiWithMeaning(file, emojiTag, statusElement) {
    try {
        if (statusElement) statusElement.textContent = 'æ­£åœ¨å­˜å‚¨...';
        
        // ç›´æ¥ä¼ é€’Fileå¯¹è±¡ç»™ImageStorageAPIï¼Œè®©å®ƒå¤„ç†æ•°æ®ç±»å‹è½¬æ¢
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (fileId) {
            document.getElementById('emojiUrl').value = `file:${fileId}`;
            
            if (statusElement) {
                statusElement.textContent = 'å­˜å‚¨æˆåŠŸ';
                statusElement.style.color = '#07c160';
            }
            
            return fileId;
        } else {
            throw new Error('å­˜å‚¨è¿”å›ç©ºçš„æ–‡ä»¶ID');
        }
    } catch (error) {
        console.error('è¡¨æƒ…åŒ…å­˜å‚¨å¤±è´¥:', error);
        if (statusElement) {
            statusElement.textContent = 'å­˜å‚¨å¤±è´¥';
            statusElement.style.color = '#ff3b30';
        }
        if (typeof showToast === 'function') showToast('å­˜å‚¨å¤±è´¥: ' + error.message);
        throw error;
    }
}

/**
 * ç‰¹å®šçš„ä¸Šä¼ å¤„ç†å‡½æ•° - è”ç³»äººå¤´åƒ
 */
async function handleContactAvatarUpload(event, editingContact) {
    try {
        const fileInput = document.getElementById('avatarUploadInput');
        const file = fileInput.files[0];
        const statusElement = document.getElementById('avatarUploadStatus');

        if (!file) {
            if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
            return;
        }

        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
            fileInput.value = '';
            return;
        }

        if (editingContact) {
            // ç¼–è¾‘æ¨¡å¼ï¼šç«‹å³ä¸Šä¼ å’Œä¿å­˜
            const contactId = editingContact.id;

            // å¦‚æœä¹‹å‰æœ‰å¤´åƒï¼Œå…ˆåˆ é™¤æ—§çš„æ–‡ä»¶å¼•ç”¨
            if (editingContact.avatarFileId) {
                try {
                    if (window.ImageStorageAPI) {
                        await window.ImageStorageAPI.deleteImage(`avatar_contact`, contactId);
                    }
                } catch (deleteError) {
                    console.warn('åˆ é™¤æ—§å¤´åƒå¤±è´¥ï¼Œç»§ç»­ä¸Šä¼ æ–°å¤´åƒ:', deleteError);
                }
            }

            const fileId = await handleAvatarUpload('avatarUploadInput', 'contact', contactId, 'avatarUploadStatus');

            if (fileId) {
                document.getElementById('contactAvatar').value = `file:${fileId}`;
                editingContact.avatarFileId = fileId;
                editingContact.avatar = '';

                // åŒæ­¥æ›´æ–°å½“å‰è”ç³»äººå¯¹è±¡
                if (window.currentContact &amp;&amp; window.currentContact.id === contactId) {
                    window.currentContact.avatarFileId = fileId;
                    window.currentContact.avatar = '';
                }

                // åˆ·æ–°UIæ˜¾ç¤º
                if (window.ImageDisplayHelper) {
                    window.ImageDisplayHelper.clearCacheByType(`avatar_contact_${contactId}`);
                }

                if (typeof renderContactList === 'function') {
                    try {
                        await renderContactList();
                    } catch (error) {
                        console.warn('åˆ·æ–°è”ç³»äººåˆ—è¡¨å¤±è´¥:', error);
                    }
                }
            }
        } else {
            // æ–°å»ºæ¨¡å¼ï¼šç±»ä¼¼emojiçš„ä¸´æ—¶å­˜å‚¨
            window.tempContactAvatarFile = file;

            // ç”Ÿæˆä¸´æ—¶URLç”¨äºé¢„è§ˆ
            const tempUrl = URL.createObjectURL(file);
            document.getElementById('contactAvatar').value = `temp:${tempUrl}`;

            if (statusElement) {
                statusElement.textContent = 'å¤´åƒå·²é€‰æ‹©';
                statusElement.style.color = '#07c160';
            }

            if (typeof showToast === 'function') showToast('å¤´åƒå·²é€‰æ‹©ï¼Œå¡«å†™å®Œä¿¡æ¯åç‚¹å‡»ç¡®å®š');
        }

    } catch (error) {
        console.error('è”ç³»äººå¤´åƒå¤„ç†å¤±è´¥:', error);
        const statusElement = document.getElementById('avatarUploadStatus');
        if (statusElement) {
            statusElement.textContent = 'å¤„ç†å¤±è´¥';
            statusElement.style.color = '#ff3b30';
        }
    }
}

/**
 * ç‰¹å®šçš„ä¸Šä¼ å¤„ç†å‡½æ•° - ç”¨æˆ·å¤´åƒ
 */
async function handleProfileAvatarUpload(event) {
    try {
        const fileId = await handleAvatarUpload('profileUploadInput', 'user', 'profile', 'profileUploadStatus');
        
        if (fileId) {
            // æ›´æ–°éšè—çš„URLè¾“å…¥æ¡†ä¸ºæ–‡ä»¶IDå¼•ç”¨
            document.getElementById('profileAvatarInput').value = `file:${fileId}`;
            
            // æ¸…ç†å¤´åƒç¼“å­˜
            if (window.ImageDisplayHelper) {
                window.ImageDisplayHelper.clearCacheByType('avatar_user_');
            }
            
            // è®¾ç½®æŒä¹…çŠ¶æ€æç¤º
            const statusElement = document.getElementById('profileUploadStatus');
            if (statusElement) {
                statusElement.textContent = 'å·²ä¸Šä¼ ';
                statusElement.style.color = '#07c160';
            }
            
            // ç«‹å³æ›´æ–°UI
            if (typeof updateUserProfileUI === 'function') {
                await updateUserProfileUI();
            }
        }
    } catch (error) {
        console.error('ä¸ªäººå¤´åƒä¸Šä¼ å¤±è´¥:', error);
    }
}

/**
 * ç‰¹å®šçš„ä¸Šä¼ å¤„ç†å‡½æ•° - èƒŒæ™¯å›¾ç‰‡
 */
async function handleBgUpload(event) {
    try {
        // ä»å…¨å±€å˜é‡è·å–currentContact
        const currentContact = window.currentContact;
        if (!currentContact) {
            if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©è”ç³»äºº');
            return;
        }
        
        const fileId = await handleBackgroundUpload('bgUploadInput', currentContact.id, 'bgUploadStatus');
        
        if (fileId) {
            // æ›´æ–°éšè—çš„URLè¾“å…¥æ¡†ä¸ºæ–‡ä»¶IDå¼•ç”¨
            document.getElementById('backgroundUrl').value = `file:${fileId}`;
        }
    } catch (error) {
        console.error('èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const imageStorageAPI = new ImageStorageAPI();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.ImageStorageAPI = imageStorageAPI;

// åˆ›å»ºå‘½åç©ºé—´å¹¶æš´éœ²ä¸Šä¼ å¤„ç†å‡½æ•°
window.ImageUploadHandlers = {
    handleFileUpload,
    handleAvatarUpload,
    handleBackgroundUpload,
    handleEmojiUpload,
    handleEmojiFileUpload,
    storeEmojiWithMeaning,
    handleContactAvatarUpload,
    handleProfileAvatarUpload,
    handleBgUpload,
    tempEmojiFile
};

// ä¸ºäº†å‘åå…¼å®¹ï¼Œä¿ç•™ä¸»è¦çš„å…¨å±€å¼•ç”¨
// TODO: Remove these global assignments once all code is updated to use ImageUploadHandlers.
window.handleContactAvatarUpload = handleContactAvatarUpload;
window.handleProfileAvatarUpload = handleProfileAvatarUpload;

// å›¾ç‰‡å­˜å‚¨APIå·²åŠ è½½
</script>
    <script>
/**
 * å›¾ç‰‡æ˜¾ç¤ºå¸®åŠ©å·¥å…·
 * æä¾›å‘åå…¼å®¹çš„å›¾ç‰‡URLè·å–åŠŸèƒ½ï¼Œæ”¯æŒæ–°çš„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿå’Œæ—§çš„base64æ ¼å¼
 */

class ImageDisplayHelper {
    constructor() {
        this.urlCache = new Map();
        this.imageAPI = null;
    }

    /**
     * åˆå§‹åŒ–
     */
    async init() {
        if (!this.imageAPI &amp;&amp; window.ImageStorageAPI) {
            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
        }
    }

    /**
     * è·å–å¤´åƒURLï¼ˆæ”¯æŒè”ç³»äººå’Œç”¨æˆ·ï¼‰
     * @param {Object} entity - è”ç³»äººæˆ–ç”¨æˆ·å¯¹è±¡
     * @param {string} entityType - 'contact' æˆ– 'user'
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getAvatarURL(entity, entityType = 'contact') {
        if (!entity) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (entity.avatarFileId &amp;&amp; this.imageAPI) {
                // ä¸ºç”¨æˆ·ç±»å‹ä½¿ç”¨å›ºå®šçš„idï¼Œå› ä¸ºç”¨æˆ·å¯¹è±¡é€šå¸¸æ²¡æœ‰idå­—æ®µ
                const entityId = entityType === 'user' ? 'profile' : entity.id;
                const cacheKey = `avatar_${entityType}_${entityId}`;
                
                // æ£€æŸ¥ç¼“å­˜ï¼Œä½†å¦‚æœæœ‰æ–°çš„avatarFileIdï¼Œå…ˆæ¸…ç†æ—§ç¼“å­˜
                if (this.urlCache.has(cacheKey)) {
                    const cachedUrl = this.urlCache.get(cacheKey);
                    // è·å–å½“å‰å®é™…çš„æ–‡ä»¶å¼•ç”¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
                    const currentReference = await this.imageAPI.getAvatarURL(entityType, entityId);
                    if (currentReference &amp;&amp; currentReference !== cachedUrl) {
                        // æ–‡ä»¶å¼•ç”¨å·²å˜åŒ–ï¼Œæ¸…ç†æ—§ç¼“å­˜
                        URL.revokeObjectURL(cachedUrl);
                        this.urlCache.delete(cacheKey);
                    } else if (cachedUrl) {
                        return cachedUrl;
                    }
                }
                
                const url = await this.imageAPI.getAvatarURL(entityType, entityId);
                if (url) {
                    this.urlCache.set(cacheKey, url);
                }
                return url;
            }
            
            // å›é€€åˆ°æ—§çš„base64æ ¼å¼
            if (entity.avatar &amp;&amp; entity.avatar.startsWith('data:')) {
                return entity.avatar;
            }
            
            return '';
            
        } catch (error) {
            console.warn(`è·å–${entityType}å¤´åƒå¤±è´¥:`, error);
            // å›é€€åˆ°æ—§æ ¼å¼
            return entity.avatar || '';
        }
    }

    /**
     * è·å–èƒŒæ™¯å›¾ç‰‡URL
     * @param {Object} background - èƒŒæ™¯å¯¹è±¡
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getBackgroundURL(background) {
        if (!background) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (background.fileId &amp;&amp; this.imageAPI) {
                const cacheKey = `background_${background.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getBackgroundURL(background.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // å›é€€åˆ°æ—§æ ¼å¼
            if (background.data &amp;&amp; background.data.startsWith('data:')) {
                return background.data;
            }
            
            return background.url || '';
            
        } catch (error) {
            console.warn('è·å–èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
            return background.data || background.url || '';
        }
    }

    /**
     * è·å–è¡¨æƒ…åŒ…URL
     * @param {Object} emoji - è¡¨æƒ…åŒ…å¯¹è±¡
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getEmojiURL(emoji) {
        if (!emoji) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (emoji.fileId &amp;&amp; this.imageAPI) {
                const cacheKey = `emoji_${emoji.tag}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getEmojiURL(emoji.tag);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // å›é€€åˆ°æ—§æ ¼å¼
            if (emoji.data &amp;&amp; emoji.data.startsWith('data:')) {
                return emoji.data;
            }
            
            return emoji.url || '';
            
        } catch (error) {
            console.warn('è·å–è¡¨æƒ…åŒ…å¤±è´¥:', error);
            return emoji.data || emoji.url || '';
        }
    }

    /**
     * è·å–æœ‹å‹åœˆå›¾ç‰‡URL
     * @param {Object} moment - æœ‹å‹åœˆåŠ¨æ€å¯¹è±¡
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getMomentImageURL(moment) {
        if (!moment) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (moment.imageFileId &amp;&amp; this.imageAPI) {
                const cacheKey = `moment_${moment.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getMomentImageURL(moment.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // å›é€€åˆ°æ—§æ ¼å¼
            if (moment.image &amp;&amp; moment.image.startsWith('data:')) {
                return moment.image;
            }
            
            return moment.imageUrl || '';
            
        } catch (error) {
            console.warn('è·å–æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            return moment.image || moment.imageUrl || '';
        }
    }

    /**
     * åˆ›å»ºå¤´åƒHTMLå…ƒç´ ï¼ˆå‘åå…¼å®¹ï¼‰
     * @param {Object} entity - è”ç³»äººæˆ–ç”¨æˆ·å¯¹è±¡  
     * @param {string} entityType - 'contact' æˆ– 'user'
     * @param {string} className - CSSç±»åï¼ˆå¯é€‰ï¼‰
     * @returns {Promise<string>} è¿”å›HTMLå­—ç¬¦ä¸²
     */
    async createAvatarHTML(entity, entityType = 'contact', className = '') {
        if (!entity) return '';
        
        const avatarURL = await this.getAvatarURL(entity, entityType);
        const classAttr = className ? ` class=&quot;${className}&quot;` : '';
        
        if (avatarURL) {
            return `<img src=&quot;${avatarURL}&quot;${classAttr}>`;
        } else {
            // ä½¿ç”¨é¦–å­—ç¬¦ä½œä¸ºé»˜è®¤å¤´åƒ
            const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? 'æˆ‘' : '?');
            return `<span${classAttr}>${firstChar}</span>`;
        }
    }

    /**
     * æ¸…ç†URLç¼“å­˜
     */
    clearCache() {
        this.urlCache.clear();
    }

    /**
     * æ¸…ç†ç‰¹å®šç±»å‹çš„ç¼“å­˜
     * @param {string} type - ç¼“å­˜ç±»å‹å‰ç¼€ï¼ˆå¦‚ 'avatar_', 'background_'ï¼‰
     */
    clearCacheByType(type) {
        for (const [key, url] of this.urlCache) {
            if (key.startsWith(type)) {
                // é‡Šæ”¾Blob URLä»¥é˜²æ­¢å†…å­˜æ³„æ¼
                if (url &amp;&amp; url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
                this.urlCache.delete(key);
            }
        }
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const imageDisplayHelper = new ImageDisplayHelper();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.ImageDisplayHelper = imageDisplayHelper;

// å›¾ç‰‡æ˜¾ç¤ºå¸®åŠ©å·¥å…·å·²åŠ è½½
</script>
    
    <link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;>
    <link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin>
    <link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;display=swap&quot; rel=&quot;stylesheet&quot;>
    <style>
        :root {
            --blur-value: 12px;
            --body-bg: #fdf2f8;
            --glass-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.2));
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-shadow: rgba(236, 72, 153, 0.25);
            --text-primary: #831843;
            --text-secondary: #be185d;
            --accent-color: #ec4899;
            --accent-gradient: linear-gradient(135deg, #fb7185, #ec4899);
            --char-bubble-bg: #ffffff;
            --char-bubble-text: #1f2937;
            --control-bg: rgba(255, 255, 255, 0.3);
            --control-bg-active: #ffffff;
            --list-hover-bg: rgba(255, 255, 255, 0.7);
        }
        body.theme-blue-purple {
            --body-bg: #37306B; --glass-bg: linear-gradient(135deg, rgba(173, 169, 217, 0.25), rgba(94, 91, 142, 0.1));
            --glass-border: rgba(255, 255, 255, 0.1); --glass-shadow: rgba(27, 24, 64, 0.4);
            --text-primary: #E0E7FF; --text-secondary: #C7D2FE; --accent-color: #818cf8;
            --accent-gradient: linear-gradient(135deg, #a5b4fc, #818cf8); --char-bubble-bg: rgba(255,255,255,0.1);
            --char-bubble-text: #E0E7FF; --control-bg: rgba(255, 255, 255, 0.1);
            --control-bg-active: rgba(255, 255, 255, 0.3); --list-hover-bg: rgba(255, 255, 255, 0.2);
        }
        body.theme-black-white {
            --body-bg: #111827; --glass-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            --glass-border: rgba(255, 255, 255, 0.15); --glass-shadow: rgba(0, 0, 0, 0.5);
            --text-primary: #f3f4f6; --text-secondary: #d1d5db; --accent-color: #f9fafb;
            --accent-gradient: linear-gradient(135deg, #9ca3af, #6b7280); --char-bubble-bg: rgba(255,255,255,0.1);
            --char-bubble-text: #f3f4f6; --control-bg: rgba(255, 255, 255, 0.1);
            --control-bg-active: rgba(255, 255, 255, 0.2); --list-hover-bg: rgba(255, 255, 255, 0.15);
        }
        html, body { height: 100%; overflow: hidden; font-family: 'Noto Sans SC', sans-serif; background-color: var(--body-bg); transition: background-color 0.5s ease; }
        #main-container { background-size: cover; background-position: center; height: 100%; width: 100%; position: relative; }
        #image-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-size: contain; background-position: center; touch-action: none; background-repeat: no-repeat; }
        .touch-zone { position: absolute; border: 2px dashed rgba(255, 255, 255, 0.7); background-color: rgba(29, 78, 216, 0.4); color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; user-select: none; text-shadow: 1px 1px 2px black; border-radius: 8px; box-sizing: border-box; transition: background-color 0.2s, border-color 0.2s; cursor: move; }
        .resize-handle, .rotate-handle, .delete-zone-btn { position: absolute; background-color: rgba(255, 255, 255, 0.8); border: 1px solid #333; border-radius: 50%; display: none; box-sizing: border-box; z-index: 10; }
        .resize-handle { width: 16px; height: 16px; right: -8px; bottom: -8px; cursor: se-resize; }
        .rotate-handle { width: 16px; height: 16px; left: 50%; top: -20px; transform: translateX(-50%); cursor: alias; }
        .rotate-handle::before { content: ''; position: absolute; width: 1px; height: 12px; background: #333; left: 50%; top: -12px; }
        .delete-zone-btn { width: 20px; height: 20px; right: -10px; top: -10px; cursor: pointer; display: none; align-items: center; justify-content: center; background-color: #ef4444; color: white; font-weight: bold; line-height: 18px; }
        #image-container.edit-mode .touch-zone { border-color: rgba(255, 255, 255, 0.7); cursor: move; }
        #image-container.edit-mode .touch-zone:hover { border-style: solid; }
        #image-container.edit-mode .resize-handle, #image-container.edit-mode .rotate-handle, #image-container.edit-mode .delete-zone-btn { display: flex; }
        #image-container.use-mode .touch-zone { background-color: transparent; border-color: transparent; color: transparent; text-shadow: none; cursor: pointer; z-index: 25; }
        .glassmorphism { background: var(--glass-bg); backdrop-filter: blur(var(--blur-value)); -webkit-backdrop-filter: blur(var(--blur-value)); border: 1px solid var(--glass-border); box-shadow: 0 8px 32px 0 var(--glass-shadow); transition: background 0.5s ease, border 0.5s ease, box-shadow 0.5s ease; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem; }
        .chat-bubble { max-width: 75%; padding: 0.5rem 0.75rem; border-radius: 1rem; word-break: break-word; }
        .chat-bubble-user { background: var(--accent-gradient); color: white; border-bottom-right-radius: 0.25rem; }
        .chat-bubble-char { background-color: var(--char-bubble-bg); color: var(--char-bubble-text); border: 1px solid var(--glass-border); }
        .theme-selector div { cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s; }
        .theme-selector div.selected { border-color: var(--accent-color); }
        .button-gradient { background: var(--accent-gradient); transition: filter 0.2s ease-in-out; }
        .button-gradient:hover { filter: brightness(1.1); }
        .segmented-control { display: flex; background-color: var(--control-bg); border-radius: 9px; padding: 3px; width: 100%; }
        .settings-tab { flex: 1; text-align: center; padding: 6px 4px; border-radius: 7px; font-weight: 500; cursor: pointer; color: var(--text-secondary); transition: background-color 0.3s, color 0.3s; border-bottom: none; }
        .settings-tab.active { background-color: var(--control-bg-active); color: var(--text-primary); box-shadow: 0 1px 4px rgba(0,0,0,0.1); }
        select { color: #1f2937; }
        select option { background-color: #ffffff; color: #111827; }
        #floating-pomodoro-display { position: absolute; top: 1rem; left: 1rem; z-index: 20; pointer-events: none; display: none; flex-direction: column; gap: 0.5rem; }
        .floating-timer-block { padding: 0.5rem 1rem; border-radius: 0.75rem; min-width: 200px; }
        .floating-timer-block .task-name { font-weight: bold; font-size: 0.875rem; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-shadow: 0 0 4px rgba(0,0,0,0.5); }
        .floating-timer-block .time { font-family: 'Noto Sans SC', sans-serif, monospace; font-size: 1.5rem; line-height: 2rem; color: var(--text-primary); text-shadow: 0 0 4px rgba(0,0,0,0.5); }
        #char-pomodoro-display, #user-pomodoro-display { text-shadow: 0 0 8px rgba(0, 0, 0, 0.3); }
        .diary-list-item { cursor: pointer; padding: 0.75rem 0.5rem; border-radius: 0.5rem; transition: background-color 0.2s; }
        .diary-list-item:hover { background-color: var(--list-hover-bg); }
        #diary-list-panel { transform: translateX(-100%); transition: transform 0.3s ease-in-out; box-shadow: 4px 0px 15px rgba(0,0,0,0.2); }
        #diary-modal.panel-open #diary-list-panel { transform: translateX(0); }
        #diary-panel-overlay { transition: opacity 0.3s ease-in-out; }
    </style>
    <!-- Analytics -->
    <script defer src=&quot;https://umami.whale-llt.top/script.js&quot; data-website-id=&quot;00c95749-7c0d-4333-9ec1-2ad2701799a3&quot;></script>
</head>
<body class=&quot;theme-pink-white&quot;>

    <audio id=&quot;tts-audio-player&quot; class=&quot;hidden&quot;></audio>

    <div id=&quot;main-container&quot;>
        <div id=&quot;image-container&quot; class=&quot;edit-mode&quot;>
            <div id=&quot;upload-prompt&quot; class=&quot;absolute inset-0 flex items-center justify-center text-gray-600 pointer-events-none text-center p-4&quot;>
                <p class=&quot;text-[var(--text-secondary)]&quot;>ç‚¹å‡»å³ä¸‹è§’è®¾å®šæŒ‰é’® (âš™ï¸)<br>å¼€å§‹é…ç½®</p>
            </div>
        </div>
    </div>
    
    <div id=&quot;floating-pomodoro-display&quot;>
        <div id=&quot;floating-char-timer&quot; class=&quot;glassmorphism floating-timer-block hidden&quot;>
            <p class=&quot;task-name&quot; id=&quot;floating-char-task-name&quot;>è§’è‰²çš„ä»»åŠ¡</p>
            <p class=&quot;time&quot; id=&quot;floating-char-time&quot;>25:00</p>
        </div>
        <div id=&quot;floating-user-timer&quot; class=&quot;glassmorphism floating-timer-block hidden&quot;>
            <p class=&quot;task-name&quot; id=&quot;floating-user-task-name&quot;>ä½ çš„ä»»åŠ¡</p>
            <p class=&quot;time&quot; id=&quot;floating-user-time&quot;>25:00</p>
        </div>
    </div>

    <div id=&quot;top-right-selectors&quot; class=&quot;absolute top-4 right-4 z-20 flex flex-col space-y-2 items-end&quot;>
        <select id=&quot;active-character-select&quot; class=&quot;glassmorphism w-48 px-3 py-2 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-[var(--accent-color)]&quot;></select>
    </div>

    <footer id=&quot;dialogue-box-container&quot; class=&quot;fixed left-0 right-0 p-4 z-20&quot; style=&quot;bottom: 60px;&quot;>
        <div id=&quot;dialogue-box&quot; class=&quot;glassmorphism w-full h-24 p-3 rounded-2xl overflow-y-auto&quot;>
            <p id=&quot;dialogue-text&quot; class=&quot;text-[var(--text-primary)]&quot;>è§’è‰²å°†ä¼šåœ¨è¿™é‡Œå›åº”...</p>
        </div>
    </footer>

    <div class=&quot;absolute bottom-28 right-4 z-30 flex flex-col items-center space-y-3&quot;>
        <button id=&quot;chat-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;><path fill-rule=&quot;evenodd&quot; d=&quot;M18 5v8a2 2 0 01-2 2h-5l-5 4v-4H4a2 2 0 01-2-2V5a2 2 0 012-2h12a2 2 0 012 2zM7 8H5v2h2V8zm2 0h2v2H9V8zm6 0h-2v2h2V8z&quot; clip-rule=&quot;evenodd&quot; /></svg></button>
        <button id=&quot;diary-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;><path d=&quot;M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z&quot; /></svg></button>
        <button id=&quot;pomodoro-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z&quot; /></svg></button>
        <div class=&quot;flex items-center glassmorphism p-2 rounded-full shadow-lg space-x-2&quot;>
            <label for=&quot;mode-toggle&quot; class=&quot;relative inline-flex items-center cursor-pointer&quot;>
                <input type=&quot;checkbox&quot; id=&quot;mode-toggle&quot; class=&quot;sr-only peer&quot; checked>
                <div class=&quot;w-11 h-6 bg-gray-400 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--accent-color)]&quot;></div>
            </label>
        </div>
        <button id=&quot;settings-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot; /><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot; /></svg></button>
    </div>

    <div id=&quot;settings-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div class=&quot;glassmorphism rounded-2xl p-4 w-full max-w-lg max-h-[90vh] overflow-y-auto relative flex flex-col&quot;>
            <div class=&quot;flex-shrink-0 mb-4&quot;>
                <nav class=&quot;segmented-control&quot;>
                    <button data-tab=&quot;scene-settings-tab&quot; class=&quot;settings-tab active&quot;>åœºæ™¯è®¾ç½®</button>
                    <button data-tab=&quot;touch-settings-tab&quot; class=&quot;settings-tab&quot;>äº’åŠ¨åŒºåŸŸ</button>
                    <button data-tab=&quot;theme-settings-tab&quot; class=&quot;settings-tab&quot;>ä¸»é¢˜ä¸è¯­éŸ³</button>
                </nav>
            </div>
            <div id=&quot;settings-content&quot; class=&quot;flex-grow overflow-y-auto pr-2&quot;></div>
            <button id=&quot;close-settings-modal-btn&quot; class=&quot;absolute top-4 right-4 text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-3xl&quot;>&amp;times;</button>
        </div>
    </div>
    
    <div id=&quot;chat-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div class=&quot;glassmorphism rounded-2xl w-full max-w-lg h-[90vh] flex flex-col p-4&quot;>
            <div class=&quot;flex-shrink-0 flex justify-between items-center border-b border-[var(--glass-border)] pb-2 mb-2&quot;>
                <h2 class=&quot;text-xl font-bold text-[var(--text-primary)]&quot;>èŠå¤©</h2>
                <div class=&quot;flex items-center space-x-4&quot;>
                    <button id=&quot;clear-chat-btn&quot; class=&quot;bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-sm&quot;>æ¸…é™¤è®°å½•</button>
                    <button id=&quot;close-chat-modal-btn&quot; class=&quot;text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-2xl&quot;>&amp;times;</button>
                </div>
            </div>
            <div id=&quot;chat-history&quot; class=&quot;flex-grow overflow-y-auto space-y-4 p-2&quot;></div>
            <div class=&quot;flex-shrink-0 mt-2 flex space-x-2&quot;>
                <input type=&quot;text&quot; id=&quot;chat-input&quot; class=&quot;flex-grow bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 focus:outline-none text-[var(--text-primary)] placeholder-[var(--text-secondary)]&quot; placeholder=&quot;è¾“å…¥æ¶ˆæ¯...&quot;>
                <button id=&quot;chat-send-btn&quot; class=&quot;button-gradient text-white px-4 py-2 rounded-lg&quot;>å‘é€</button>
            </div>
        </div>
    </div>
    
    <div id=&quot;diary-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div id=&quot;diary-main-content&quot; class=&quot;w-full max-w-2xl h-auto max-h-[90vh] flex flex-col glassmorphism rounded-2xl relative overflow-hidden&quot;>
             <div class=&quot;flex-shrink-0 flex items-center justify-between border-b border-[var(--glass-border)] p-4&quot;>
                 <button id=&quot;show-diary-panel-btn&quot; class=&quot;text-[var(--text-primary)] p-2 rounded-full hover:bg-black/10&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M4 6h16M4 12h16M4 18h16&quot; /></svg></button>
                 <h2 id=&quot;diary-title&quot; class=&quot;text-xl font-bold text-[var(--text-primary)] text-center flex-grow mx-4&quot;>è§’è‰²æ—¥è®°</h2>
                 <div class=&quot;flex items-center space-x-2&quot;>
                    <button id=&quot;generate-diary-btn&quot; class=&quot;text-[var(--text-primary)] p-2 rounded-full hover:bg-black/10&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M4 4v5h5M20 20v-5h-5M4 4l16 16&quot; /></svg></button>
                    <button id=&quot;close-diary-modal-btn&quot; class=&quot;text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-3xl&quot;>&amp;times;</button>
                 </div>
             </div>
             <div id=&quot;diary-content-wrapper&quot; class=&quot;flex-grow overflow-y-auto p-6&quot;>
                 <div id=&quot;diary-content&quot; class=&quot;text-[var(--text-primary)] whitespace-pre-wrap leading-relaxed&quot;>è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€ç¯‡æ—¥è®°æŸ¥çœ‹ï¼Œæˆ–ç”Ÿæˆä»Šæ—¥æ—¥è®°ã€‚</div>
             </div>
        </div>
        <div id=&quot;diary-panel-overlay&quot; class=&quot;hidden absolute inset-0 bg-black/30 z-10&quot;></div>
        <div id=&quot;diary-list-panel&quot; class=&quot;absolute top-0 left-0 h-full w-full max-w-xs glassmorphism p-4 z-20 flex flex-col space-y-4&quot;>
             <h3 class=&quot;text-xl font-bold text-[var(--text-primary)] border-b border-[var(--glass-border)] pb-2&quot;>æ—¥è®°åˆ—è¡¨</h3>
             <div id=&quot;diary-list&quot; class=&quot;flex-grow overflow-y-auto text-[var(--text-primary)] space-y-1&quot;></div>
        </div>
    </div>
    
    <div id=&quot;pomodoro-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div class=&quot;glassmorphism rounded-2xl w-full max-w-lg h-auto flex flex-col p-6 space-y-4&quot;>
            <div class=&quot;flex justify-between items-center border-b border-[var(--glass-border)] pb-3 mb-3&quot;>
                 <h2 class=&quot;text-2xl font-bold text-[var(--text-primary)]&quot;>ç•ªèŒ„é’Ÿ</h2>
                 <button id=&quot;close-pomodoro-modal-btn&quot; class=&quot;text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-3xl&quot;>&amp;times;</button>
            </div>
            <div class=&quot;p-4 rounded-lg border border-[var(--glass-border)] space-y-3&quot;>
                <h3 class=&quot;font-bold text-lg text-[var(--text-primary)]&quot;>è§’è‰²çš„ä»»åŠ¡</h3>
                <div class=&quot;text-center&quot;>
                    <p id=&quot;char-pomodoro-display&quot; class=&quot;text-5xl font-mono text-[var(--text-primary)]&quot;>25:00</p>
                    <p id=&quot;char-task-display&quot; class=&quot;text-sm text-[var(--text-secondary)] mt-1&quot;>æœªå¼€å§‹</p>
                </div>
                <div class=&quot;flex flex-col sm:flex-row gap-2&quot;>
                    <input type=&quot;text&quot; id=&quot;char-task-input&quot; class=&quot;flex-grow bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]&quot; placeholder=&quot;ä»»åŠ¡åç§° (ä¾‹å¦‚: çœ‹ä¹¦)&quot;>
                    <input type=&quot;number&quot; id=&quot;char-duration-input&quot; class=&quot;w-24 bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)]&quot; placeholder=&quot;åˆ†é’Ÿ&quot; value=&quot;25&quot;>
                    <button id=&quot;char-pomodoro-btn&quot; class=&quot;button-gradient text-white px-4 py-2 rounded-lg&quot;>å¼€å§‹</button>
                </div>
            </div>
            <div class=&quot;p-4 rounded-lg border border-[var(--glass-border)] space-y-3&quot;>
                <h3 class=&quot;font-bold text-lg text-[var(--text-primary)]&quot;>ä½ çš„ä»»åŠ¡</h3>
                <div class=&quot;text-center&quot;>
                    <p id=&quot;user-pomodoro-display&quot; class=&quot;text-5xl font-mono text-[var(--text-primary)]&quot;>25:00</p>
                    <p id=&quot;user-task-display&quot; class=&quot;text-sm text-[var(--text-secondary)] mt-1&quot;>æœªå¼€å§‹</p>
                </div>
                <div class=&quot;flex flex-col sm:flex-row gap-2&quot;>
                    <input type=&quot;text&quot; id=&quot;user-task-input&quot; class=&quot;flex-grow bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]&quot; placeholder=&quot;ä»»åŠ¡åç§° (ä¾‹å¦‚: å†™ä»£ç )&quot;>
                    <input type=&quot;number&quot; id=&quot;user-duration-input&quot; class=&quot;w-24 bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)]&quot; placeholder=&quot;åˆ†é’Ÿ&quot; value=&quot;25&quot;>
                    <button id=&quot;user-pomodoro-btn&quot; class=&quot;button-gradient text-white px-4 py-2 rounded-lg&quot;>å¼€å§‹</button>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // =========================================================================
    // æ•°æ®åº“è®¿é—®ç»Ÿä¸€ç®¡ç† - ä½¿ç”¨ä¸»åº”ç”¨çš„æ•°æ®åº“ç³»ç»Ÿ
    // =========================================================================
    
    // äº’åŠ¨ç•Œé¢æ•°æ®ç®¡ç†åŠ©æ‰‹
    const interactiveDataHelper = {
        // ç­‰å¾…ä¸»åº”ç”¨æ•°æ®åº“å‡†å¤‡å°±ç»ª
        // ğŸ”¥ ç®€åŒ–çš„æ•°æ®åº“åˆå§‹åŒ– - ä½¿ç”¨ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨
        async ensureReady() {
            if (this.isReady) {
                return;
            }

            console.log('ğŸ”¥ [interact.html] ä½¿ç”¨ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨ç­‰å¾…æ•°æ®åº“å°±ç»ª...');
            
            try {
                // ä½¿ç”¨ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨ç­‰å¾…æ•°æ®åº“å°±ç»ª
                await window.UnifiedDBManager.waitForReady(8000);
                
                console.log('ğŸ”¥ [interact.html] æ•°æ®åº“çŠ¶æ€ç¡®è®¤:', {
                    isReady: window.isIndexedDBReady,
                    dbExists: !!window.db,
                    dbVersion: window.db?.version
                });
                
                this.isReady = true;
                console.log('ğŸ”¥ [interact.html] äº’åŠ¨ç•Œé¢æ•°æ®åº“åŠ©æ‰‹å·²å°±ç»ª');
                
            } catch (error) {
                console.error('ğŸ”¥ [interact.html] æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
                alert('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                throw error;
            }
        },

        // è·å–å•ä¸ªè”ç³»äººæ•°æ®
        async getContact(contactName) {
            await this.ensureReady();
            return await window.ensureDBReady(async () => {
                const transaction = window.db.transaction(['contacts'], 'readonly');
                const store = transaction.objectStore('contacts');
                const contacts = await window.promisifyRequest(store.getAll(), 'è·å–è”ç³»äººåˆ—è¡¨');
                return contacts.find(c => c.name === contactName);
            }, `è·å–è”ç³»äºº ${contactName}`);
        },

        // è·å–æ‰€æœ‰è”ç³»äººæ•°æ®
        async getAllContacts() {
            await this.ensureReady();
            return await window.ensureDBReady(async () => {
                const transaction = window.db.transaction(['contacts'], 'readonly');
                const store = transaction.objectStore('contacts');
                return await window.promisifyRequest(store.getAll(), 'è·å–æ‰€æœ‰è”ç³»äºº');
            }, 'è·å–è”ç³»äººåˆ—è¡¨');
        },

        // æ›´æ–°è”ç³»äººæ•°æ®
        async updateContact(contactData) {
            await this.ensureReady();
            return await window.ensureDBReady(async () => {
                const transaction = window.db.transaction(['contacts'], 'readwrite');
                const store = transaction.objectStore('contacts');
                return await window.promisifyRequest(store.put(contactData), `æ›´æ–°è”ç³»äºº ${contactData.name}`);
            }, `ä¿å­˜è”ç³»äººæ•°æ® ${contactData.name}`);
        }
    };


    // --- æ¥æ”¶çˆ¶çª—å£æ•°æ® ---
    let parentAppSettings = null; 

    // --- æ•°æ®åŒæ­¥å¤„ç† ---
    async function handleBulkDataSync(data) {
        console.log('æ­£åœ¨å¤„ç†æ‰¹é‡åŒæ­¥æ•°æ®...', data);
        const { characters: receivedCharacters, userProfile: receivedUserProfile } = data;

        // è®¾ç½®ç”¨æˆ·äººè®¾
        currentUserPersona = { name: receivedUserProfile.name, text: receivedUserProfile.personality };
        
        console.log('æ•°æ®åŒæ­¥å®Œæˆï¼è§’è‰²æ•°æ®æ¥è‡ªä¸»åº”ç”¨contactsè¡¨ã€‚');
        
        // åˆ·æ–°è§’è‰²åˆ—è¡¨ï¼ˆæ•°æ®å·²ç»åœ¨ä¸»åº”ç”¨ä¸­åŒæ­¥ï¼‰
        await populateCharacterList(activeCharacterSelect);
        
        // å¦‚æœæœ‰è§’è‰²ï¼ŒåŠ è½½ç¬¬ä¸€ä¸ªè§’è‰²
        const chars = await getCharacters();
        const charNames = Object.keys(chars);
        if (charNames.length > 0 &amp;&amp; !currentCharacterName) {
            await loadCharacter(charNames[0]);
        }
    }

    // --- æ¶ˆæ¯ç›‘å¬ ---
    window.addEventListener('message', (event) => {
        const data = event.data;
        if (!data || !data.type) return;

        switch (data.type) {
            case 'BULK_DATA_SYNC':
                parentAppSettings = {
                    apiSettings: data.apiSettings,
                    userPersona: data.userProfile,
                    character: {}
                };
                console.log(&quot;å·²æ¥æ”¶å¹¶åº”ç”¨å…¨å±€è®¾ç½®: &quot;, parentAppSettings);

                handleBulkDataSync(data).then(async () => {
                    const chars = await getCharacters();
                    const syncedChars = Object.keys(chars);
                    if (syncedChars.length > 0 &amp;&amp; !currentCharacterName) {
                        await loadCharacter(syncedChars[0]);
                    }
                });
                break;
            default:
                console.warn('æ”¶åˆ°æœªçŸ¥çš„æ¶ˆæ¯ç±»å‹:', data.type);
                break;
        }
    });
    
    // --- DOM Elements ---
    const getUI = (id) => document.getElementById(id);
    const body = document.body;
    const imageContainer = getUI('image-container');
    const dialogueText = getUI('dialogue-text');
    const modeToggle = getUI('mode-toggle');
    const settingsBtn = getUI('settings-btn');
    const chatBtn = getUI('chat-btn');
    const diaryBtn = getUI('diary-btn');
    const settingsModal = getUI('settings-modal');
    const chatModal = getUI('chat-modal');
    const diaryModal = getUI('diary-modal');
    const closeSettingsModalBtn = getUI('close-settings-modal-btn');
    const closeChatModalBtn = getUI('close-chat-modal-btn');
    const closeDiaryModalBtn = getUI('close-diary-modal-btn');
    const uploadPrompt = getUI('upload-prompt');
    const chatHistoryEl = getUI('chat-history');
    const chatInput = getUI('chat-input');
    const chatSendBtn = getUI('chat-send-btn');
    const settingsContent = getUI('settings-content');
    const activeCharacterSelect = getUI('active-character-select');
    const topRightSelectors = getUI('top-right-selectors');
    const clearChatBtn = getUI('clear-chat-btn');
    const diaryTitle = getUI('diary-title');
    const generateDiaryBtn = getUI('generate-diary-btn');
    const diaryList = getUI('diary-list');
    const diaryContent = getUI('diary-content');
    const showDiaryPanelBtn = getUI('show-diary-panel-btn');
    const diaryListPanel = getUI('diary-list-panel');
    const diaryPanelOverlay = getUI('diary-panel-overlay');
    const diaryMainContent = getUI('diary-main-content');
    const pomodoroBtn = getUI('pomodoro-btn');
    const pomodoroModal = getUI('pomodoro-modal');
    const closePomodoroModalBtn = getUI('close-pomodoro-modal-btn');
    const charPomodoroDisplay = getUI('char-pomodoro-display');
    const charTaskDisplay = getUI('char-task-display');
    const charTaskInput = getUI('char-task-input');
    const charDurationInput = getUI('char-duration-input');
    const charPomodoroBtn = getUI('char-pomodoro-btn');
    const userPomodoroDisplay = getUI('user-pomodoro-display');
    const userTaskDisplay = getUI('user-task-display');
    const userTaskInput = getUI('user-task-input');
    const userDurationInput = getUI('user-duration-input');
    const userPomodoroBtn = getUI('user-pomodoro-btn');
    const floatingPomodoroDisplay = getUI('floating-pomodoro-display');
    const floatingCharTimer = getUI('floating-char-timer');
    const floatingUserTimer = getUI('floating-user-timer');
    const floatingCharTaskName = getUI('floating-char-task-name');
    const floatingCharTime = getUI('floating-char-time');
    const floatingUserTaskName = getUI('floating-user-task-name');
    const floatingUserTime = getUI('floating-user-time');
    const ttsAudioPlayer = getUI('tts-audio-player');

    // --- State Variables ---
    const DEFAULT_ZONES = [&quot;å¤´å‘&quot;, &quot;è€³æœµ&quot;, &quot;çœ¼ç›&quot;, &quot;è„¸é¢Š&quot;, &quot;é¼»å­&quot;, &quot;è„–å­&quot;, &quot;é”éª¨&quot;, &quot;èƒ¸å£&quot;, &quot;å°è…¹&quot;, &quot;å¤§è‡‚&quot;, &quot;å°è‡‚&quot;, &quot;èƒ¯éƒ¨&quot;, &quot;å¤§è…¿&quot;, &quot;å°è…¿&quot;, &quot;è„š&quot;];
    let currentZones = [...DEFAULT_ZONES];
    let touchHistory = [];
    let messageHistory = [];
    const HISTORY_LIMIT = 20; 
    const CONTEXT_LIMIT = 10;
    let currentBackgroundFileId = '';
    let currentUserPersona = { name: 'é»˜è®¤', text: 'ä¸€ä¸ªæ¸©æŸ”çš„æ¢ç´¢è€…' };
    let currentCharacterName = '';
    let currentCharacterPersonaText = '';
    let currentDiaryDate = '';
    let pomodoroState = {
        char: { timerId: null, endTime: 0, task: '', isRunning: false },
        user: { timerId: null, endTime: 0, task: '', isRunning: false }
    };

    // --- Templates for Settings Tabs ---
    const sceneSettingsHTML = `
        <div id=&quot;scene-settings-tab&quot; class=&quot;space-y-4&quot;>
            <div>
                <label class=&quot;block text-sm font-bold text-[var(--text-primary)] mb-2&quot;>å½“å‰è§’è‰²</label>
                <div class=&quot;p-3 bg-white/20 border border-gray-300/50 rounded-md&quot;>
                    <div class=&quot;text-[var(--text-primary)] font-bold&quot; id=&quot;character-name-display&quot;>è¯·å…ˆé€‰æ‹©æˆ–åŒæ­¥è§’è‰²</div>
                </div>
            </div>
            <div>
                <label for=&quot;image-upload&quot; class=&quot;block text-sm font-medium text-[var(--text-secondary)]&quot;>äº’åŠ¨èƒŒæ™¯å›¾</label>
                <input type=&quot;file&quot; id=&quot;image-upload&quot; accept=&quot;image/*&quot; class=&quot;mt-1 block w-full text-sm text-[var(--text-secondary)] file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-white/30 file:text-[var(--text-primary)] hover:file:bg-white/50&quot;>
                <p class=&quot;text-xs text-slate-500 mt-1&quot;>ä¸ºè¯¥è§’è‰²ä¸Šä¼ åœ¨äº’åŠ¨åœºæ™¯ä¸­ä½¿ç”¨çš„ä¸“å±å›¾ç‰‡ã€‚</p>
                <button id=&quot;save-char-btn&quot; class=&quot;mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full&quot;>ä¿å­˜åœºæ™¯è®¾ç½®</button>
            </div>
        </div>`;

    const touchSettingsHTML = `
        <div id=&quot;touch-settings-tab&quot; class=&quot;space-y-4 hidden&quot;>
            <div>
                <label for=&quot;custom-zone-name&quot; class=&quot;block text-sm font-medium text-[var(--text-secondary)]&quot;>æ·»åŠ è‡ªå®šä¹‰åŒºåŸŸ</label>
                <div class=&quot;flex space-x-2 mt-1&quot;>
                    <input type=&quot;text&quot; id=&quot;custom-zone-name&quot; class=&quot;flex-grow px-3 py-2 bg-white/30 border border-gray-300/50 rounded-md shadow-sm text-[var(--text-primary)] placeholder-[var(--text-secondary)] focus:outline-none focus:ring-2 focus:ring-[var(--accent-color)]&quot; placeholder=&quot;ä¾‹å¦‚ï¼šæ‰‹è…•&quot;>
                    <button id=&quot;add-zone-btn&quot; class=&quot;button-gradient text-white font-bold py-2 px-4 rounded-lg&quot;>æ·»åŠ </button>
                </div>
            </div>
            <button id=&quot;reset-zones-btn&quot; class=&quot;w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg mt-4&quot;>é‡ç½®æ‰€æœ‰è§¦å‘æ¡†</button>
        </div>`;

    const themeSettingsHTML = `
        <div id=&quot;theme-settings-tab&quot; class=&quot;space-y-4 hidden&quot;>
            <div>
                <label class=&quot;block text-sm font-medium text-[var(--text-secondary)] mb-2&quot;>ä¸»é¢˜é€‰æ‹©</label>
                <div class=&quot;theme-selector flex space-x-2&quot;>
                    <div data-theme=&quot;theme-pink-white&quot; class=&quot;selected w-10 h-10 rounded-full bg-gradient-to-br from-pink-200 to-pink-400&quot;></div>
                    <div data-theme=&quot;theme-blue-purple&quot; class=&quot;w-10 h-10 rounded-full bg-gradient-to-br from-indigo-300 to-purple-500&quot;></div>
                    <div data-theme=&quot;theme-black-white&quot; class=&quot;w-10 h-10 rounded-full bg-gradient-to-br from-gray-400 to-gray-800&quot;></div>
                </div>
            </div>
            <div class=&quot;flex items-center justify-between&quot;>
                <label for=&quot;tts-toggle&quot; class=&quot;text-sm font-medium text-[var(--text-secondary)]&quot;>è‡ªåŠ¨æ’­æ”¾è§’è‰²è¯­éŸ³</label>
                <label for=&quot;tts-toggle&quot; class=&quot;relative inline-flex items-center cursor-pointer&quot;>
                    <input type=&quot;checkbox&quot; id=&quot;tts-toggle&quot; class=&quot;sr-only peer&quot;>
                    <div class=&quot;w-11 h-6 bg-gray-400 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--accent-color)]&quot;></div>
                </label>
            </div>
            <div class=&quot;p-3 bg-yellow-50 border border-yellow-200 rounded-md text-yellow-800&quot;>
                <p class=&quot;text-sm&quot;>è¯­éŸ³æ’­æ”¾ä½¿ç”¨ä¸»åº”ç”¨è®¾ç½®çš„Minimax APIå’Œè§’è‰²çš„è¯­éŸ³IDã€‚</p>
            </div>
        </div>`;
    
    // --- Function Definitions ---
    const openModal = (modal) => modal.classList.remove('hidden');
    const closeModal = (modal) => {
        modal.classList.add('hidden');
        if (modal === diaryModal) closeDiaryPanel();
    };
    const addMessageToChatUI = (sender, text) => {
        const bubble = document.createElement('div');
        bubble.className = `w-full flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
        bubble.innerHTML = `<div class=&quot;chat-bubble ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-char'}&quot;>${text.replace(/\n/g, '<br>')}</div>`;
        chatHistoryEl.appendChild(bubble);
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
    };
    const applyTheme = (themeClass) => {
        body.className = themeClass;
        if (settingsModal.querySelector('.theme-selector')) {
            settingsModal.querySelectorAll('.theme-selector div').forEach(s => s.classList.remove('selected'));
            settingsModal.querySelector(`[data-theme=&quot;${themeClass}&quot;]`)?.classList.add('selected');
        }
    };
    const sendChatMessage = () => {
        const text = chatInput.value.trim();
        if (!text) return;
        addMessageToChatUI('user', text);
        addToHistory(messageHistory, { sender: 'user', text: text });
        chatInput.value = '';
        callAI({ type: 'chat', content: text });
    };

    function attachEventListeners() {
        settingsBtn.addEventListener('click', openSettings);
        chatBtn.addEventListener('click', () => openModal(chatModal));
        diaryBtn.addEventListener('click', openDiaryModal);
        closeSettingsModalBtn.addEventListener('click', () => closeModal(settingsModal));
        closeChatModalBtn.addEventListener('click', () => closeModal(chatModal));
        closeDiaryModalBtn.addEventListener('click', () => closeModal(diaryModal));
        pomodoroBtn.addEventListener('click', () => openModal(pomodoroModal));
        closePomodoroModalBtn.addEventListener('click', () => closeModal(pomodoroModal));
        clearChatBtn.addEventListener('click', clearChatHistory);
        chatSendBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendChatMessage(); });
        modeToggle.addEventListener('change', () => {
            imageContainer.classList.toggle('edit-mode', modeToggle.checked);
            imageContainer.classList.toggle('use-mode', !modeToggle.checked);
            topRightSelectors.style.display = modeToggle.checked ? 'flex' : 'none';
        });
        activeCharacterSelect.addEventListener('change', (e) => loadCharacter(e.target.value));
        generateDiaryBtn.addEventListener('click', generateDiary);
        showDiaryPanelBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            diaryModal.classList.add('panel-open');
            diaryPanelOverlay.classList.remove('hidden');
        });
        diaryPanelOverlay.addEventListener('click', closeDiaryPanel);
        diaryMainContent.addEventListener('click', (e) => {
            if (diaryModal.classList.contains('panel-open') &amp;&amp; !diaryListPanel.contains(e.target)) {
                closeDiaryPanel();
            }
        });
        charPomodoroBtn.addEventListener('click', () => {
            if (pomodoroState.char.isRunning) stopTimer('char', false); else startTimer('char');
        });
        userPomodoroBtn.addEventListener('click', () => {
            if (pomodoroState.user.isRunning) stopTimer('user', false); else startTimer('user');
        });
    }
    
    const openSettings = async () => {
        settingsContent.innerHTML = sceneSettingsHTML + touchSettingsHTML + themeSettingsHTML;
        
        settingsModal.querySelectorAll('.settings-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                settingsModal.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                settingsContent.querySelectorAll('#settings-content > div').forEach(c => c.classList.add('hidden'));
                getUI(tab.dataset.tab)?.classList.remove('hidden');
            });
        });
        
        getUI('image-upload').addEventListener('change', handleImageUpload);
        getUI('save-char-btn').addEventListener('click', saveCurrentCharacter);
        getUI('add-zone-btn').addEventListener('click', addCustomZone);
        getUI('reset-zones-btn').addEventListener('click', () => {
            currentZones = [...DEFAULT_ZONES];
            createAllZones();
        });
        settingsModal.querySelectorAll('.theme-selector div').forEach(selector => {
            selector.addEventListener('click', async () => {
                const theme = selector.dataset.theme;
                applyTheme(theme);
                await updateCharacterSetting({ theme: theme }, 'ä¿å­˜ä¸»é¢˜è®¾ç½®');
            });
        });
        getUI('tts-toggle').addEventListener('change', async () => {
            const ttsEnabled = getUI('tts-toggle').checked;
            await updateCharacterSetting({ ttsEnabled: ttsEnabled }, 'ä¿å­˜TTSè®¾ç½®');
        });
        
        getUI('character-name-display').textContent = currentCharacterName || &quot;æœªé€‰æ‹©è§’è‰²&quot;;
        const characters = await getCharacters();
        if (currentCharacterName &amp;&amp; characters[currentCharacterName]) {
            getUI('tts-toggle').checked = characters[currentCharacterName].ttsEnabled === true;
            applyTheme(characters[currentCharacterName].theme || 'theme-pink-white');
        }

        openModal(settingsModal);
    };

    // å®‰å…¨çš„ postMessage å‡½æ•°ï¼Œé€‚é…æœ¬åœ°æ–‡ä»¶ç¯å¢ƒ
    const safePostMessage = (data, targetWindow = window.parent) => {
        if (!targetWindow || targetWindow === window) return;

        try {
            // è·å–å½“å‰ç¯å¢ƒçš„ origin
            let targetOrigin = window.location.origin;

            // åœ¨æœ¬åœ°æ–‡ä»¶ç¯å¢ƒä¸‹ï¼Œorigin ä¸º &quot;null&quot;ï¼Œéœ€è¦ä½¿ç”¨ &quot;*&quot; è¿›è¡Œé€šä¿¡
            if (targetOrigin === &quot;null&quot; || window.location.protocol === &quot;file:&quot;) {
                targetOrigin = &quot;*&quot;;
            }

            targetWindow.postMessage(data, targetOrigin);
        } catch (error) {
            console.warn('postMessage å‘é€å¤±è´¥:', error);
            // ä½œä¸ºé™çº§æ–¹æ¡ˆï¼Œå°è¯•ä½¿ç”¨ &quot;*&quot; ä½œä¸º targetOrigin
            try {
                targetWindow.postMessage(data, &quot;*&quot;);
            } catch (fallbackError) {
                console.error('postMessage é™çº§æ–¹æ¡ˆä¹Ÿå¤±è´¥:', fallbackError);
            }
        }
    };

    const addToHistory = async (historyArray, item) => {
        historyArray.push(item);
        if (historyArray.length > HISTORY_LIMIT) historyArray.shift();
        if (historyArray === messageHistory) {
            await saveChatHistory();
        } else if (historyArray === touchHistory) {
            await saveTouchHistory();
        }
    };

    // é€šç”¨çš„è§’è‰²è®¾ç½®æ›´æ–°å‡½æ•°
    const updateCharacterSetting = async (updateData, errorContext = 'æ›´æ–°è§’è‰²è®¾ç½®') => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            if (contact) {
                // æ‰¹é‡æ›´æ–°å±æ€§
                Object.assign(contact, updateData);
                await interactiveDataHelper.updateContact(contact);
                
                // åŒæ­¥åˆ°ä¸»åº”ç”¨
                if (window.parent &amp;&amp; window.parent !== window) {
                    const syncData = {
                        type: 'UPDATE_CONTACT',
                        contactId: currentCharacterName,
                        updateData: updateData
                    };
                    safePostMessage(syncData);
                }
            }
        } catch (error) {
            console.error(`${errorContext}å¤±è´¥:`, error);
        }
    };

    const saveChatHistory = async () => {
        await updateCharacterSetting({ interactiveChatHistory: messageHistory }, 'ä¿å­˜èŠå¤©è®°å½•');
    };

    const saveTouchHistory = async () => {
        await updateCharacterSetting({ interactiveTouchHistory: touchHistory }, 'ä¿å­˜è§¦æ‘¸è®°å½•');
    };

    const loadChatHistory = async () => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            messageHistory = contact ? (contact.interactiveChatHistory || []) : [];
            chatHistoryEl.innerHTML = '';
            messageHistory.forEach(msg => addMessageToChatUI(msg.sender, msg.text));
        } catch (error) {
            console.error('åŠ è½½èŠå¤©è®°å½•å¤±è´¥:', error);
            messageHistory = [];
        }
    };

    const loadTouchHistory = async () => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            touchHistory = contact ? (contact.interactiveTouchHistory || []) : [];
        } catch (error) {
            console.error('åŠ è½½è§¦æ‘¸è®°å½•å¤±è´¥:', error);
            touchHistory = [];
        }
    };
    
    const clearChatHistory = async () => {
        if (!currentCharacterName) return alert('æ²¡æœ‰åŠ è½½ä»»ä½•è§’è‰²ã€‚');
        if (confirm(`ç¡®å®šè¦æ¸…é™¤è§’è‰²&quot;${currentCharacterName}&quot;çš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
            messageHistory = [];
            chatHistoryEl.innerHTML = '';
            await saveChatHistory(); 
            alert('èŠå¤©è®°å½•å·²æ¸…é™¤ã€‚');
        }
    };

    const getDiaryEntries = async () => {
        if (!currentCharacterName) return {};
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            return contact ? (contact.diaryEntries || {}) : {};
        } catch (error) {
            console.error('è·å–æ—¥è®°å¤±è´¥:', error);
            return {};
        }
    };

    const saveDiaryEntry = async (dateKey, content) => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            if (!contact) return;
            
            // æ›´æ–°æ—¥è®°è®°å½•
            contact.diaryEntries = contact.diaryEntries || {};
            contact.diaryEntries[dateKey] = content;
            
            // ä¿å­˜åˆ°æ•°æ®åº“
            await interactiveDataHelper.updateContact(contact);
        } catch (error) {
            console.error('ä¿å­˜æ—¥è®°å¤±è´¥:', error);
        }
    };
    
    const deleteDiaryEntry = async (dateKey) => {
        if (!currentCharacterName) return;
        if (confirm(`ç¡®å®šè¦åˆ é™¤ ${dateKey} çš„æ—¥è®°å—ï¼Ÿ`)) {
            try {
                const contact = await interactiveDataHelper.getContact(currentCharacterName);
                if (contact &amp;&amp; contact.diaryEntries &amp;&amp; contact.diaryEntries[dateKey]) {
                    delete contact.diaryEntries[dateKey];
                    await interactiveDataHelper.updateContact(contact);
                    await populateDiaryList();
                    if (currentDiaryDate === dateKey) {
                        const entries = await getDiaryEntries();
                        const dates = Object.keys(entries).sort((a, b) => new Date(b) - new Date(a));
                        await loadDiaryContent(dates.length > 0 ? dates[0] : null);
                    }
                }
            } catch (error) {
                console.error('åˆ é™¤æ—¥è®°å¤±è´¥:', error);
            }
        }
    };

    const clearCharacterForm = (silent = false) => {
        currentCharacterName = '';
        currentCharacterPersonaText = '';
        if(getUI('image-upload')) getUI('image-upload').value = null;
        currentBackgroundFileId = '';
        imageContainer.style.backgroundImage = 'none';
        uploadPrompt.style.display = 'flex';
        if(getUI('reset-zones-btn')) getUI('reset-zones-btn').click();
        activeCharacterSelect.selectedIndex = -1;
        messageHistory = [];
        touchHistory = [];
        chatHistoryEl.innerHTML = '';
        if (!silent) alert('å·²æ¸…ç©ºè§’è‰²è¡¨å•ï¼Œæ‚¨å¯ä»¥åˆ›å»ºæ–°è§’è‰²äº†ã€‚');
    };

    const getCharacters = async () => {
        try {
            const contacts = await interactiveDataHelper.getAllContacts();
            const charsMap = {};
            contacts.forEach(contact => {
                // åªè¿”å›ç§èŠç±»å‹çš„è”ç³»äººï¼ˆAIè§’è‰²ï¼‰
                if (contact.type === 'private') {
                    charsMap[contact.name] = {
                        name: contact.name,
                        personality: contact.personality,
                        voiceId: contact.voiceId || '',
                        backgroundFileId: contact.interactiveBackgroundFileId || '',
                        theme: contact.theme || 'theme-pink-white',
                        ttsEnabled: contact.ttsEnabled || false,
                        zones: contact.touchZones || [],
                        diaryEntries: contact.diaryEntries || {},
                        interactiveChatHistory: contact.interactiveChatHistory || [],
                        interactiveTouchHistory: contact.interactiveTouchHistory || []
                    };
                }
            });
            return charsMap;
        } catch (error) {
            console.error('è·å–è§’è‰²æ•°æ®å¤±è´¥:', error);
            return {};
        }
    };

    const populateCharacterList = async (selectElement) => {
        const characters = await getCharacters();
        const currentVal = selectElement.value;
        selectElement.innerHTML = '';
        const charNames = Object.keys(characters);
        if (charNames.length === 0) {
            selectElement.innerHTML = '<option>æ— å·²å­˜è§’è‰²</option>';
            selectElement.disabled = true;
        } else {
            charNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectElement.appendChild(option);
            });
            selectElement.disabled = false;
        }
        if (characters[currentVal]) selectElement.value = currentVal;
    };

    const getCurrentZoneData = () => Array.from(imageContainer.querySelectorAll('.touch-zone')).map(zoneEl => ({
        name: zoneEl.dataset.name,
        x: parseFloat(zoneEl.dataset.x) || 0, y: parseFloat(zoneEl.dataset.y) || 0,
        width: zoneEl.offsetWidth, height: zoneEl.offsetHeight,
        angle: parseFloat(zoneEl.dataset.angle) || 0,
    }));

    const saveCurrentCharacter = async () => {
        const name = currentCharacterName;
        if (!name) return alert('æ²¡æœ‰å½“å‰æ´»åŠ¨è§’è‰²ï¼Œæ— æ³•ä¿å­˜ï¼');
        
        try {
            // ä»ä¸»åº”ç”¨æ•°æ®åº“è·å–è”ç³»äººæ•°æ®
            const contact = await interactiveDataHelper.getContact(name);
            if (!contact) {
                return alert('è§’è‰²ä¸å­˜åœ¨ï¼Œè¯·å…ˆåœ¨ä¸»åº”ç”¨ä¸­åˆ›å»ºï¼');
            }
            
            // æ›´æ–°äº’åŠ¨ç›¸å…³å­—æ®µ
            contact.theme = body.className;
            contact.interactiveBackgroundFileId = currentBackgroundFileId;
            contact.touchZones = getCurrentZoneData();
            
            // è·å–å½“å‰çš„TTSè®¾ç½®çŠ¶æ€
            const ttsToggle = getUI('tts-toggle');
            if (ttsToggle) {
                contact.ttsEnabled = ttsToggle.checked;
            } else {
                contact.ttsEnabled = contact.ttsEnabled || false;
            }
            
            // ä¿å­˜åˆ°ä¸»åº”ç”¨æ•°æ®åº“
            await interactiveDataHelper.updateContact(contact);
            
            // å‘ä¸»åº”ç”¨å‘é€æ•°æ®æ›´æ–°é€šçŸ¥
            if (window.parent &amp;&amp; window.parent !== window) {
                const updateData = {
                    type: 'UPDATE_CONTACT',
                    contactId: name,
                    updateData: {
                        interactiveBackgroundFileId: contact.interactiveBackgroundFileId,
                        touchZones: contact.touchZones,
                        theme: contact.theme,
                        ttsEnabled: contact.ttsEnabled
                    }
                };
                safePostMessage(updateData);
                console.log('åœºæ™¯è®¾ç½®å·²åŒæ­¥åˆ°ä¸»åº”ç”¨:', updateData);
            }
            
            alert(`è§’è‰² &quot;${name}&quot; çš„åœºæ™¯è®¾ç½®å·²ä¿å­˜å¹¶åŒæ­¥ï¼`);
        } catch (error) {
            console.error('ä¿å­˜è§’è‰²æ•°æ®å¤±è´¥:', error);
            alert(`ä¿å­˜å¤±è´¥: ${error.message}`);
        }
    };

    const loadCharacter = async (name) => {
        const characters = await getCharacters();
        const charData = characters[name];
        if (!charData) return console.error(`Character &quot;${name}&quot; not found.`);
        
        currentCharacterName = name;
        currentCharacterPersonaText = charData.personality || '';
        applyTheme(charData.theme || 'theme-pink-white');
        
        if (parentAppSettings) {
            parentAppSettings.character = {
                name: charData.name,
                persona: charData.personality,
                voiceId: charData.voiceId || ''
            };
        }
        
        currentBackgroundFileId = charData.backgroundFileId;
        if (currentBackgroundFileId) {
            try {
                const backgroundUrl = await window.ImageStorageAPI.getBackgroundURL(currentCharacterName);
                if (backgroundUrl) {
                    imageContainer.style.backgroundImage = `url('${backgroundUrl}')`;
                    uploadPrompt.style.display = 'none';
                }
            } catch (error) {
                console.warn('åŠ è½½èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
                imageContainer.style.backgroundImage = 'none';
                uploadPrompt.style.display = 'flex';
            }
        } else {
            imageContainer.style.backgroundImage = 'none';
            uploadPrompt.style.display = 'flex';
        }

        imageContainer.querySelectorAll('.touch-zone').forEach(z => z.remove());
        if (charData.zones &amp;&amp; charData.zones.length > 0) {
            currentZones = charData.zones.map(z => z.name);
            charData.zones.forEach(zoneData => createSingleZone(zoneData, true));
        } else {
            currentZones = [...DEFAULT_ZONES];
            createAllZones();
        }
        
        if(activeCharacterSelect.value !== name) activeCharacterSelect.value = name;
        await loadChatHistory();
        await loadTouchHistory();
    };

    const createSingleZone = (zoneData, fromLoad = false) => {
        const containerRect = imageContainer.getBoundingClientRect();
        const zone = document.createElement('div');
        zone.className = 'touch-zone';
        zone.textContent = zoneData.name;
        zone.dataset.name = zoneData.name;
        
        const zoneWidth = fromLoad ? zoneData.width : 100;
        const zoneHeight = fromLoad ? zoneData.height : 50;
        zone.style.width = `${zoneWidth}px`;
        zone.style.height = `${zoneHeight}px`;

        if (fromLoad) {
            zone.dataset.x = zoneData.x;
            zone.dataset.y = zoneData.y;
            zone.dataset.angle = zoneData.angle;
        } else {
            zone.dataset.x = (containerRect.width / 2) - (zoneWidth / 2);
            zone.dataset.y = (containerRect.height / 2) - (zoneHeight / 2);
            zone.dataset.angle = 0;
        }
        zone.style.transform = `translate(${zone.dataset.x}px, ${zone.dataset.y}px) rotate(${zone.dataset.angle}deg)`;
        
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-zone-btn';
        deleteBtn.innerHTML = '&amp;times;';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentZones = currentZones.filter(z => z !== zone.dataset.name);
            zone.remove();
        });

        zone.appendChild(deleteBtn);
        zone.appendChild(document.createElement('div')).className = 'resize-handle';
        zone.appendChild(document.createElement('div')).className = 'rotate-handle';
        
        imageContainer.appendChild(zone);
    };

    const createAllZones = () => {
        imageContainer.querySelectorAll('.touch-zone').forEach(z => z.remove());
        currentZones.forEach(name => createSingleZone({name}));
    };
    
    const addCustomZone = () => {
        const name = getUI('custom-zone-name').value.trim();
        if (!name) return alert('è¯·è¾“å…¥åŒºåŸŸåç§°ï¼');
        if (currentZones.includes(name)) return alert('è¯¥åŒºåŸŸå·²å­˜åœ¨ï¼');
        currentZones.push(name);
        createSingleZone({name});
        getUI('custom-zone-name').value = '';
    };

    const handleImageUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        if (!currentCharacterName) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²ï¼');
            return;
        }

        try {
            // ç¡®ä¿ImageStorageAPIå·²åˆå§‹åŒ–
            await window.ImageStorageAPI.init();
            
            // å­˜å‚¨èƒŒæ™¯å›¾ç‰‡ï¼Œä½¿ç”¨è§’è‰²åä½œä¸ºbackgroundId
            const fileId = await window.ImageStorageAPI.storeBackground(file, currentCharacterName);
            
            // æ›´æ–°å½“å‰çŠ¶æ€
            currentBackgroundFileId = fileId;
            
            // è·å–å¹¶æ˜¾ç¤ºèƒŒæ™¯å›¾ç‰‡
            const backgroundUrl = await window.ImageStorageAPI.getBackgroundURL(currentCharacterName);
            if (backgroundUrl) {
                imageContainer.style.backgroundImage = `url('${backgroundUrl}')`;
                uploadPrompt.style.display = 'none';
            }
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            console.log('èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼ŒfileId:', fileId);
            
        } catch (error) {
            console.error('èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
            alert(`èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    };
    
    interact('.touch-zone').draggable({
        listeners: { move(event) {
            const target = event.target;
            const x = (parseFloat(target.dataset.x) || 0) + event.dx;
            const y = (parseFloat(target.dataset.y) || 0) + event.dy;
            target.style.transform = `translate(${x}px, ${y}px) rotate(${parseFloat(target.dataset.angle) || 0}deg)`;
            target.dataset.x = x;
            target.dataset.y = y;
        }},
        modifiers: [interact.modifiers.restrictRect({ restriction: 'parent' })],
        inertia: true
    }).resizable({
        edges: { left: true, right: true, bottom: true, top: true },
        listeners: { move(event) {
            const target = event.target;
            let x = (parseFloat(target.dataset.x) || 0);
            let y = (parseFloat(target.dataset.y) || 0);
            target.style.width = `${event.rect.width}px`;
            target.style.height = `${event.rect.height}px`;
            x += event.deltaRect.left;
            y += event.deltaRect.top;
            target.style.transform = `translate(${x}px, ${y}px) rotate(${parseFloat(target.dataset.angle) || 0}deg)`;
            target.dataset.x = x;
            target.dataset.y = y;
        }},
        modifiers: [interact.modifiers.restrictSize({ min: { width: 30, height: 20 } })],
    }).on('tap', (event) => {
        if (imageContainer.classList.contains('edit-mode') || event.target.classList.contains('delete-zone-btn')) return;
        callAI({ type: 'touch', content: event.currentTarget.dataset.name });
        event.preventDefault();
    });

    interact('.rotate-handle').draggable({
        onstart: (event) => {
            const box = event.target.parentElement;
            const rect = box.getBoundingClientRect();
            box.dataset.centerX = rect.left + rect.width / 2;
            box.dataset.centerY = rect.top + rect.height / 2;
        },
        onmove: (event) => {
            const box = event.target.parentElement;
            const angle = (Math.atan2(event.clientY - parseFloat(box.dataset.centerY), event.clientX - parseFloat(box.dataset.centerX)) * (180 / Math.PI)) + 90;
            box.style.transform = `translate(${parseFloat(box.dataset.x) || 0}px, ${parseFloat(box.dataset.y) || 0}px) rotate(${angle}deg)`;
            box.dataset.angle = angle;
        },
    });

    const formatTime = (seconds) => `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;

    const updateCountdown = (type) => {
        const state = pomodoroState[type];
        const remainingSeconds = Math.round((state.endTime - Date.now()) / 1000);
        const display = type === 'char' ? charPomodoroDisplay : userPomodoroDisplay;
        const floatingTimeDisplay = type === 'char' ? floatingCharTime : floatingUserTime;

        if (remainingSeconds < 0) {
            display.textContent = &quot;00:00&quot;;
            floatingTimeDisplay.textContent = &quot;00:00&quot;;
            stopTimer(type, true);
            return;
        }
        const formattedTime = formatTime(remainingSeconds);
        display.textContent = formattedTime;
        floatingTimeDisplay.textContent = formattedTime;
    };

    const sendEncouragement = async (type) => {
        if (!pomodoroState[type].isRunning) return;
        const prompt = `ä½ æ­£åœ¨è¿›è¡Œä¸€ä¸ªè§’è‰²æ‰®æ¼”ã€‚**ä½ çš„è§’è‰²äººè®¾æ˜¯ï¼š**\n${currentCharacterPersonaText.trim()}\n**ä¸ä½ äº’åŠ¨çš„ç”¨æˆ·äººè®¾æ˜¯ï¼š**\n${currentUserPersona.text}\n**å½“å‰æƒ…æ™¯ï¼š**\n${type === 'user' ? `ç”¨æˆ·æ­£åœ¨ä¸“å¿ƒè¿›è¡Œä»»åŠ¡ï¼šâ€œ${pomodoroState[type].task}â€ã€‚` : `ä½ æ­£åœ¨ä¸“å¿ƒè¿›è¡Œä»»åŠ¡ï¼šâ€œ${pomodoroState[type].task}â€ã€‚`}\n**ä½ çš„ä»»åŠ¡ï¼š**\næ—¶é—´å·²ç»è¿‡å»äº†ä¸€æ®µæ—¶é—´ï¼Œè¯·æ ¹æ®ä½ çš„è§’è‰²äººè®¾ï¼Œå¯¹ç”¨æˆ·è¯´ä¸€å¥ç®€çŸ­ã€è‡ªç„¶ã€ç¬¦åˆäººè®¾çš„é¼“åŠ±æˆ–å…³å¿ƒçš„è¯ï¼Œè®©ä»–/å¥¹èƒ½ç»§ç»­åšæŒä¸‹å»ã€‚`;
        try {
            const encouragementMessage = await makeApiCall(prompt);
            dialogueText.textContent = encouragementMessage;
            addToHistory(messageHistory, { sender: 'char', text: encouragementMessage });
            addMessageToChatUI('char', `(é¼“åŠ±) ${encouragementMessage}`);
        } catch (error) { console.error(&quot;Encouragement failed:&quot;, error.message); }
    };

    const startTimer = (type) => {
        const state = pomodoroState[type];
        const taskInput = type === 'char' ? charTaskInput : userTaskInput;
        const durationInput = type === 'char' ? charDurationInput : userDurationInput;
        const taskDisplay = type === 'char' ? charTaskDisplay : userTaskDisplay;
        const startBtn = type === 'char' ? charPomodoroBtn : userPomodoroBtn;
        const floatingTimerBlock = type === 'char' ? floatingCharTimer : floatingUserTimer;
        const floatingTaskName = type === 'char' ? floatingCharTaskName : floatingUserTaskName;

        const task = taskInput.value.trim();
        if (!task) return alert('è¯·ä¸ºä»»åŠ¡å‘½åï¼');
        const durationMinutes = parseInt(durationInput.value, 10);
        if (isNaN(durationMinutes) || durationMinutes <= 0) return alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰ï¼');

        stopTimer(type, false);
        state.isRunning = true;
        state.task = task;
        state.endTime = Date.now() + durationMinutes * 60 * 1000;
        state.timerId = setInterval(() => updateCountdown(type), 1000);
        state.encouragementId = setInterval(() => sendEncouragement(type), 7 * 60 * 1000); // 7 minutes
        taskDisplay.textContent = `è¿›è¡Œä¸­: ${task}`;
        startBtn.textContent = 'åœæ­¢';
        taskInput.disabled = true;
        durationInput.disabled = true;
        floatingTaskName.textContent = `${type === 'char' ? 'è§’è‰²' : 'ä½ '}: ${task}`;
        floatingTimerBlock.classList.remove('hidden');
        floatingPomodoroDisplay.style.display = 'flex';
        updateCountdown(type);
    };

    const stopTimer = (type, finished) => {
        const state = pomodoroState[type];
        if (!state.isRunning) return;
        clearInterval(state.timerId);
        clearInterval(state.encouragementId);

        const taskDisplay = type === 'char' ? charTaskDisplay : userTaskDisplay;
        const startBtn = type === 'char' ? charPomodoroBtn : userPomodoroBtn;
        const taskInput = type === 'char' ? charTaskInput : userTaskInput;
        const durationInput = type === 'char' ? charDurationInput : userDurationInput;
        const display = type === 'char' ? charPomodoroDisplay : userPomodoroDisplay;
        const floatingTimerBlock = type === 'char' ? floatingCharTimer : floatingUserTimer;
        
        const originalTask = state.task;
        state.isRunning = false; state.timerId = null; state.encouragementId = null; state.task = '';
        taskDisplay.textContent = 'æœªå¼€å§‹';
        startBtn.textContent = 'å¼€å§‹';
        taskInput.disabled = false;
        durationInput.disabled = false;
        display.textContent = formatTime(parseInt(durationInput.value, 10) * 60 || 25 * 60);
        floatingTimerBlock.classList.add('hidden');
        if (!pomodoroState.char.isRunning &amp;&amp; !pomodoroState.user.isRunning) {
            floatingPomodoroDisplay.style.display = 'none';
        }
        if (finished) {
            const prompt = `ä½ æ­£åœ¨è¿›è¡Œä¸€ä¸ªè§’è‰²æ‰®æ¼”ã€‚**ä½ çš„è§’è‰²äººè®¾æ˜¯ï¼š**\n${currentCharacterPersonaText.trim()}\n**ä¸ä½ äº’åŠ¨çš„ç”¨æˆ·äººè®¾æ˜¯ï¼š**\n${currentUserPersona.text}\n**å½“å‰æƒ…æ™¯ï¼š**\n${type === 'user' ? `ç”¨æˆ·åˆšåˆšå®Œæˆäº†ä»»åŠ¡ï¼šâ€œ${originalTask}â€ã€‚` : `ä½ åˆšåˆšå®Œæˆäº†ä»»åŠ¡ï¼šâ€œ${originalTask}â€ã€‚`}\n**ä½ çš„ä»»åŠ¡ï¼š**\nè¯·æ ¹æ®ä½ çš„è§’è‰²äººè®¾ï¼Œå¯¹æ­¤å‘è¡¨ä¸€å¥ç¥è´ºæˆ–è¯„è®ºã€‚`;
            callAI({type: 'system', content: prompt});
        }
    };
    
    const getTodayDateKey = () => new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });

    const loadDiaryContent = (dateKey) => {
        if (!dateKey) {
            currentDiaryDate = getTodayDateKey();
            diaryTitle.textContent = `è§’è‰²æ—¥è®° - ${currentDiaryDate}`;
            diaryContent.innerHTML = 'ä»Šå¤©è¿˜æ²¡æœ‰æ—¥è®°ã€‚ç‚¹å‡»å³ä¸Šè§’æŒ‰é’®ç”Ÿæˆä»Šæ—¥æ—¥è®°ã€‚';
            return;
        }
        currentDiaryDate = dateKey;
        diaryTitle.textContent = `è§’è‰²æ—¥è®° - ${dateKey}`;
        diaryContent.innerHTML = (getDiaryEntries()[dateKey] || 'æ— æ³•æ‰¾åˆ°è¯¥æ—¥è®°ã€‚').replace(/\n/g, '<br>');
    };
    
    const openDiaryModal = () => {
        populateDiaryList();
        const entries = getDiaryEntries();
        const dates = Object.keys(entries).sort((a, b) => new Date(b) - new Date(a));
        loadDiaryContent(dates.length > 0 ? dates[0] : null);
        diaryModal.classList.remove('panel-open');
        diaryPanelOverlay.classList.add('hidden');
        openModal(diaryModal);
    };
    
    const closeDiaryPanel = () => {
        diaryModal.classList.remove('panel-open');
        diaryPanelOverlay.classList.add('hidden');
    };

    const populateDiaryList = () => {
        const entries = getDiaryEntries();
        const dates = Object.keys(entries).sort((a, b) => new Date(b) - new Date(a));
        diaryList.innerHTML = '';
        if (dates.length === 0) return diaryList.innerHTML = '<p class=&quot;text-sm text-[var(--text-secondary)] p-2&quot;>æ²¡æœ‰å†å²æ—¥è®°ã€‚</p>';
        
        dates.forEach(date => {
            const item = document.createElement('div');
            item.className = 'diary-list-item flex justify-between items-center';
            const dateSpan = document.createElement('span');
            dateSpan.textContent = date;
            dateSpan.className = 'flex-grow';
            dateSpan.onclick = () => { loadDiaryContent(date); closeDiaryPanel(); };
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'text-red-400 hover:text-red-600 p-1 rounded-full';
            deleteBtn.innerHTML = `<svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;><path fill-rule=&quot;evenodd&quot; d=&quot;M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z&quot; clip-rule=&quot;evenodd&quot; /></svg>`;
            deleteBtn.onclick = (e) => { e.stopPropagation(); deleteDiaryEntry(date); };
            item.appendChild(dateSpan);
            item.appendChild(deleteBtn);
            diaryList.appendChild(item);
        });
    };

    const generateDiary = async () => {
        if (!currentCharacterName) return alert(&quot;è¯·å…ˆåŠ è½½ä¸€ä¸ªè§’è‰²ã€‚&quot;);
        const dateKey = getTodayDateKey();
        diaryContent.innerHTML = 'æ­£åœ¨ç”Ÿæˆæ—¥è®°...';
        const prompt = `ä½ æ­£åœ¨æ‰®æ¼”ä»¥ä¸‹è§’è‰²ï¼Œå¹¶éœ€è¦å†™ä¸€ç¯‡æ—¥è®°ã€‚**ä½ çš„è§’è‰²äººè®¾æ˜¯ï¼š**\n${currentCharacterPersonaText.trim()}\n**ä¸ä½ äº’åŠ¨çš„ç”¨æˆ·äººè®¾æ˜¯ï¼š**\n${currentUserPersona.text}\n**ä»Šå¤©æ—¥æœŸï¼š**\n${dateKey}\n**æœ€è¿‘å‘ç”Ÿçš„äº‹ï¼ˆä½œä¸ºä½ å†™æ—¥è®°çš„å‚è€ƒï¼‰ï¼š**\n- æˆ‘ä»Šå¤©åœ¨ç•ªèŒ„é’Ÿé‡Œåšäº†ï¼š${pomodoroState.char.task || 'æ²¡æœ‰ç‰¹åˆ«å®‰æ’ä»»åŠ¡'}\n- Taä»Šå¤©åœ¨ç•ªèŒ„é’Ÿé‡Œåšäº†ï¼š${pomodoroState.user.task || 'æ²¡æœ‰ç‰¹åˆ«å®‰æ’ä»»åŠ¡'}\n- æœ€è¿‘è¢«è§¦ç¢°çš„éƒ¨ä½: ${touchHistory.slice(-CONTEXT_LIMIT).join(', ') || 'æ— '}\n- æœ€è¿‘å¯¹è¯è®°å½•:\n${messageHistory.slice(-CONTEXT_LIMIT).map(m => `${m.sender === 'user' ? 'Ta' : 'æˆ‘'}è¯´: &quot;${m.text}&quot;`).join('\n') || 'æ— '}\n**ä½ çš„ä»»åŠ¡ï¼š**\nè¯·å®Œå…¨ä»£å…¥ä½ çš„è§’è‰²ï¼Œä»¥æ—¥è®°çš„å½¢å¼ï¼Œå†™ä¸‹ä½ å¯¹ä»Šå¤©ï¼ˆ${dateKey}ï¼‰çš„æ„Ÿå—å’Œæ€è€ƒã€‚æ—¥è®°çš„å¼€å¤´ä¸å¿…åŒ…å«æ—¥æœŸã€‚æ—¥è®°å†…å®¹è¦è‡ªç„¶ã€ç¬¦åˆäººè®¾ï¼Œå¹¶ä¸”è¦ä½“ç°å‡ºä½ å†…å¿ƒçš„æƒ³æ³•ã€‚è¯·ç›´æ¥è¾“å‡ºæ—¥è®°å†…å®¹ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ ‡é¢˜ã€‚`;
        try {
            const diaryText = await makeApiCall(prompt);
            await saveDiaryEntry(dateKey, diaryText);
            loadDiaryContent(dateKey);
            populateDiaryList();
            
            // å‘ä¸»åº”ç”¨åŒæ­¥æ—¥è®°æ•°æ®
            if (window.parent &amp;&amp; window.parent !== window) {
                const updateData = {
                    type: 'UPDATE_CONTACT',
                    contactId: currentCharacterName,
                    updateData: {
                        diaryEntries: { [dateKey]: diaryText }
                    }
                };
                safePostMessage(updateData);
                console.log('æ—¥è®°æ•°æ®å·²åŒæ­¥åˆ°ä¸»åº”ç”¨');
            }
        } catch (error) {
            diaryContent.innerHTML = `ç”Ÿæˆæ—¥è®°å¤±è´¥: ${error.message}`;
        }
    };

    const filterTextForTts = (text) => text ? text.replace(/\ï¼ˆ[^ï¼‰]*\ï¼‰/g, &quot;&quot;).replace(/\([^)]*\)/g, &quot;&quot;).trim() : &quot;&quot;;

    const playTtsAudio = async (text) => {
        if (!text) return;
        ttsAudioPlayer.pause();
        ttsAudioPlayer.src = '';
        if (!parentAppSettings) {
            return console.warn(&quot;TTS Aborted: Parent settings not received.&quot;);
        }
        const { minimaxGroupId, minimaxApiKey } = parentAppSettings.apiSettings;
        const { voiceId } = parentAppSettings.character;
        try {
            const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`;
            const requestBody = { &quot;voice_id&quot;: voiceId, &quot;text&quot;: text, &quot;model&quot;: &quot;speech-01&quot;, &quot;speed&quot;: 1.0, &quot;vol&quot;: 1.0, &quot;pitch&quot;: 0 };
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${minimaxApiKey}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) throw new Error(`è¯­éŸ³æœåŠ¡é”™è¯¯: ${response.status} - ${await response.text()}`);
            const audioBlob = await response.blob();
            ttsAudioPlayer.src = URL.createObjectURL(audioBlob);
            await ttsAudioPlayer.play();
        } catch (error) {
            console.error('TTS process failed:', error);
            dialogueText.textContent += ` (è¯­éŸ³åˆæˆå¤±è´¥)`;
        }
    };

    const callAI = async (interaction) => {
        if (interaction.type === 'touch') await addToHistory(touchHistory, interaction.content);
        const prompt = `ä½ æ­£åœ¨è¿›è¡Œä¸€ä¸ªè§’è‰²æ‰®æ¼”ã€‚**ä½ çš„è§’è‰²äººè®¾æ˜¯ï¼š**\n${currentCharacterPersonaText.trim()}\n**ä¸ä½ äº’åŠ¨çš„ç”¨æˆ·äººè®¾æ˜¯ï¼š**\n${currentUserPersona.text}\n**å½“å‰ä»»åŠ¡çŠ¶æ€:**\n- ä½ çš„ä»»åŠ¡: ${pomodoroState.char.isRunning ? `&quot;${pomodoroState.char.task}&quot;` : 'æ— '}\n- ç”¨æˆ·çš„ä»»åŠ¡: ${pomodoroState.user.isRunning ? `&quot;${pomodoroState.user.task}&quot;` : 'æ— '}\n**ä¸Šä¸‹æ–‡å‚è€ƒ:**\n- æœ€è¿‘çš„è§¦ç¢°å†å²: ${touchHistory.slice(-CONTEXT_LIMIT).join(', ') || 'æ— '}\n- æœ€è¿‘çš„å¯¹è¯å†å²:\n${messageHistory.slice(-CONTEXT_LIMIT).map(m => `${m.sender === 'user' ? 'ç”¨æˆ·' : 'ä½ '}è¯´: &quot;${m.text}&quot;`).join('\n') || 'æ— '}\n**${interaction.type === 'touch' ? `å½“å‰æƒ…æ™¯ï¼š**\nç”¨æˆ·è½»è½»åœ°è§¦ç¢°äº†ä½ çš„&quot;${interaction.content}&quot;éƒ¨ä½ã€‚` : `ç”¨æˆ·åˆšåˆšå¯¹ä½ è¯´äº†ï¼š**\n&quot;${interaction.content}&quot;`}\n**ä½ çš„ä»»åŠ¡ï¼š**\nè¯·å®Œå…¨ä»£å…¥ä½ çš„è§’è‰²ï¼Œåªä»¥è§’è‰²çš„å£å»å’Œèº«ä»½ï¼Œå¯¹è¿™ä¸ªåŠ¨ä½œæˆ–è¿™å¥è¯åšå‡ºè‡ªç„¶ã€ç¬¦åˆäººè®¾ä¸”ç»“åˆä¸Šä¸‹æ–‡çš„å›åº”ã€‚`;
        dialogueText.textContent = `æ­£åœ¨æ€è€ƒ...`;
        try {
            const reply = await makeApiCall(prompt);
            dialogueText.textContent = reply;
            await addToHistory(messageHistory, { sender: 'char', text: reply });
            if (interaction.type === 'chat') addMessageToChatUI('char', reply);
            
            const characters = await getCharacters(); // å¼‚æ­¥è·å–
            const ttsEnabled = currentCharacterName &amp;&amp; characters[currentCharacterName] ? characters[currentCharacterName].ttsEnabled : false;
            
            if (ttsEnabled) {
                await playTtsAudio(filterTextForTts(reply));
            }
        } catch (error) {
            const errorMessage = `è¯·æ±‚å¤±è´¥: ${error.message}`;
            dialogueText.textContent = errorMessage;
            if (interaction.type === 'chat') addMessageToChatUI('char', errorMessage);
        }
    };

    const makeApiCall = async (prompt) => {
        if (!parentAppSettings || !parentAppSettings.apiSettings) throw new Error('æœªä»ä¸»åº”ç”¨è·å–APIé…ç½®ã€‚');
        const { url: baseUrl, key, model: selectedModel } = parentAppSettings.apiSettings;
        if (!baseUrl || !key || !selectedModel) throw new Error('ä¸»åº”ç”¨ä¸­çš„APIé“¾æ¥ã€å¯†é’¥æˆ–æ¨¡å‹æœªé…ç½®ã€‚');
        if (!currentCharacterPersonaText.trim() || !currentUserPersona.text) throw new Error('è§’è‰²æˆ–ç”¨æˆ·äººè®¾æœªé…ç½®ã€‚');
        try {
            const messages = [{ role: &quot;user&quot;, content: prompt }];
            const response = await fetch(`${baseUrl.replace(/\/$/, &quot;&quot;)}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
                body: JSON.stringify({ model: selectedModel, messages: messages, temperature: 0.8, max_tokens: 1500 })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
            }
            const data = await response.json();
            if (!data.choices || !data.choices[0]?.message) throw new Error(&quot;APIè¿”å›æ•°æ®æ ¼å¼ä¸æ­£ç¡®ã€‚&quot;);
            return data.choices[0].message.content.trim();
        } catch (error) {
            console.error('AI call failed:', error);
            throw error;
        }
    };

    const initializeApp = async () => {
        try {
            // ç­‰å¾…ä¸»åº”ç”¨æ•°æ®åº“ç³»ç»Ÿå°±ç»ª
            await interactiveDataHelper.ensureReady();
            
            attachEventListeners();
            await populateCharacterList(activeCharacterSelect);
            
            // è·å–è§’è‰²åˆ—è¡¨ï¼Œå¦‚æœæœ‰è§’è‰²åˆ™åŠ è½½ç¬¬ä¸€ä¸ª
            const chars = await getCharacters();
            const charNames = Object.keys(chars);
            
            if (charNames.length > 0) {
                await loadCharacter(charNames[0]);
            }
            
            console.log('äº’åŠ¨ç•Œé¢åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('äº’åŠ¨ç•Œé¢åˆå§‹åŒ–å¤±è´¥:', error);
            alert('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        }
    };

    initializeApp();
});
</script>
</body>
</html>" style="width: 100%; height: calc(100vh - 60px); border: none;"></iframe>
            </div>
        </div>

        <div class="profile-page" id="profilePage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>â€¹</span>
                    <span>Whale-LLT</span>
                </div>
                <div class="chat-title">ä¸ªäººä¿¡æ¯</div>
                <div class="chat-header-spacer"></div>
            </div>
            
            <div class="profile-header">
                <div class="profile-avatar" id="userAvatar">æˆ‘</div>
                <div class="profile-name" id="userName">æˆ‘çš„æ˜µç§°</div>
                <div class="profile-id">idå·ï¼šAI_User_001</div>
            </div>
            
            <div class="profile-section">
                <div class="profile-item" onclick="showEditProfileModal()" data-umami-event="Edit Profile Open">
                    <div class="profile-item-label">ç¼–è¾‘ä¸ªäººä¿¡æ¯</div>
                    <div class="profile-item-arrow">â€º</div>
                </div>
                <div class="profile-item" onclick="showUserProfile()">
                    <div class="profile-item-label">æˆ‘çš„ä¸ªäººä¸»é¡µ</div>
                    <div class="profile-item-arrow">â€º</div>
                </div>
                <div class="profile-item" onclick="showPage('appearanceManagementPage')" data-umami-event="Appearance Management Open">
                    <div class="profile-item-label">å¤–è§‚ç®¡ç†</div>
                    <div class="profile-item-arrow">â€º</div>
                </div>
                <div class="profile-item" onclick="showPage('dataManagementPage')" data-umami-event="Data Management Open">
                    <div class="profile-item-label">æ•°æ®ç®¡ç†</div>
                    <div class="profile-item-arrow">â€º</div>
                </div>
                <div class="profile-item" onclick="showPage('memoryManagementPage')" data-umami-event="Memory Management Open">
                    <div class="profile-item-label">è®°å¿†ç®¡ç†</div>
                    <div class="profile-item-arrow">â€º</div>
                </div>
                <div class="profile-item" onclick="window.SystemUtils.showDebugLogPage()"
                data-umami-event="Debug Log Open">
                    <div class="profile-item-label">æŸ¥çœ‹è°ƒè¯•æ—¥å¿—</div>
                    <div class="profile-item-arrow">â€º</div>
                </div>
                
                <!-- ç‰ˆæœ¬å·æ˜¾ç¤º -->
                <div class="profile-version" id="profileVersion">
                    <span id="profileVersionText">-</span>
                </div>
            </div>
        </div>

        <div class="weibo-page" id="weiboPage">
            <div class="weibo-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="chat-title">è®ºå›</div>
                <div class="chat-more" onclick="showPostChoiceModal()">â•</div>
            </div>
            <div class="weibo-container" id="weiboContainer">
                <div class="weibo-scroll-content"></div>
            </div>
        </div>

        <div class="data-management-page" id="dataManagementPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="chat-title">æ•°æ®ç®¡ç†</div>
                <div class="chat-header-spacer"></div>
            </div>
            
            <div class="data-management-container">
                <!-- æ•°æ®ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="database-stats" style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 15px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0; font-size: 18px; font-weight: bold; color: #333;">æ•°æ®ç»Ÿè®¡</h3>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="persistentStatusIndicator" style="font-size: 13px; font-weight: bold;">
                                â³ æ£€æŸ¥ä¸­...
                            </div>
                            <button type="button" class="info-button" 
                                    onclick="StorageManager.showPersistentStorageInfo()" 
                                    title="ç‚¹å‡»æŸ¥çœ‹æŒä¹…åŒ–å­˜å‚¨è¯´æ˜">
                                ?
                            </button>
                        </div>
                    </div>
                    <div id="databaseStatsContent" style="font-size: 13px; color: #666;">
                        <div>æ­£åœ¨åŠ è½½ç»Ÿè®¡ä¿¡æ¯...</div>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap;">
                        <button type="button" class="refresh-stats-btn" onclick="refreshDatabaseStats()" 
                                style="padding: 5px 10px; font-size: 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            åˆ·æ–°ç»Ÿè®¡
                        </button>
                        <button type="button" class="request-persistent-btn" 
                                onclick="StorageManager.requestPersistentStorageAndRefresh()" 
                                title="ç”³è¯·å°†æ•°æ®åº“è®¾ä¸ºæŒä¹…åŒ–å­˜å‚¨ï¼Œé˜²æ­¢è¢«æµè§ˆå™¨æ¸…ç†">
                            ğŸ’¾ ç”³è¯·æŒä¹…åŒ–æ•°æ®åº“
                        </button>
                        <button type="button" class="optimize-db-btn" onclick="optimizeEmojiDatabase()" 
                                style="padding: 5px 10px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;" title="å°†Base64è¡¨æƒ…è½¬æ¢ä¸ºæ ‡ç­¾æ ¼å¼ï¼Œå‡å°æ•°æ®åº“ä½“ç§¯">
                            ğŸš€ æ•°æ®åº“ä¼˜åŒ–
                        </button>
                        <button type="button" class="clear-localStorage-btn" onclick="showClearLocalStorageConfirmation()" 
                                style="padding: 5px 10px; font-size: 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;" title="æ¸…ç©ºæµè§ˆå™¨æœ¬åœ°å­˜å‚¨ï¼Œè°¨æ…æ“ä½œ">
                            ğŸ—‘ï¸ æ¸…ç©ºLocalStorage
                        </button>
                    </div>
                </div>

                
                <!-- å¯¼å…¥å¯¼å‡ºæ“ä½œ -->
                <div class="import-export-actions" style="margin: 15px;">
                    <!-- å¯¼å…¥è¯´æ˜ -->
                    <div class="import-warning" style="margin-top: 10px; padding: 10px; background: #f8d7da; border-radius: 4px; border: 1px solid #f5c6cb;">
                        <div style="font-size: 13px; color: #721c24; margin-bottom: 5px;">
                            <strong>âš ï¸ é‡è¦æé†’</strong>
                        </div>
                        <div style="font-size: 12px; color: #721c24;">
                            å¯¼å…¥æ•°æ®å°†å®Œå…¨è¦†ç›–ç°æœ‰çš„æ‰€æœ‰æ•°æ®ï¼è¯·ç¡®ä¿å·²å¤‡ä»½é‡è¦ä¿¡æ¯ï¼ï¼
                        </div>
                    </div>
                    <!-- æ•°æ®åº“å¯¼å…¥å¯¼å‡º -->
                    <div style="margin-bottom: 15px; padding: 15px; background: #e8f5e8; border: 1px solid #4caf50; border-radius: 4px;">
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #2e7d32;">
                            ğŸ’¾ æ•°æ®åº“å®Œæ•´å¤‡ä»½
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button type="button" class="form-submit" onclick="exportDatabase()" data-umami-event="Export Database"
                                    style="flex: 1; background-color: #28a745;">
                                ğŸ“¤ å¯¼å‡ºæ•°æ®åº“
                            </button>
                            <button type="button" class="form-submit" onclick="triggerFileSelect()" data-umami-event="Import Database"
                                    style="flex: 1; background-color: #dc3545;">
                                ğŸ“¥ å¯¼å…¥æ•°æ®åº“
                            </button>
                        </div>
                    </div>

                    <!-- æ–‡ä»¶å­˜å‚¨å¯¼å…¥å¯¼å‡º -->
                    <div style="margin-bottom: 15px; padding: 15px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 4px;">
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #ef6c00;">
                            ğŸ–¼ï¸ æ–‡ä»¶å­˜å‚¨è¿ç§»ï¼ˆå›¾ç‰‡ã€è¡¨æƒ…åŒ…ã€èƒŒæ™¯ï¼‰
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button type="button" class="form-submit" onclick="exportFileStorage()" data-umami-event="Export Media Files"
                                    style="flex: 1; background-color: #ff9800;">
                                ğŸ“¤ å¯¼å‡ºæ–‡ä»¶
                            </button>
                            <button type="button" class="form-submit" onclick="triggerFileStorageImport()" data-umami-event="Import Media Files"
                                    style="flex: 1; background-color: #f57c00;">
                                ğŸ“¥ å¯¼å…¥æ–‡ä»¶
                            </button>
                        </div>
                        <div style="font-size: 12px; color: #bf360c; margin-bottom: 10px;">
                            å¯¼å‡ºä¸ºZIPæ ¼å¼ï¼Œä¿æŒåŸå§‹æ–‡ä»¶æ ¼å¼ï¼ˆjpg/png/gifç­‰ï¼‰ï¼Œåœ¨æ–°ç¯å¢ƒä¸­å¯¼å…¥æ—¶ä¼šè‡ªåŠ¨åŒ¹é…å¯¹åº”é¡¹ç›®
                        </div>
                        
                        <!-- æ–‡ä»¶å­˜å‚¨å¯¼å‡ºé€‰é¡¹ -->
                        <div id="fileExportOptions" style="display: none; margin-top: 10px; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px;">
                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 8px; color: #333;">é€‰æ‹©è¦å¯¼å‡ºçš„æ–‡ä»¶ç±»å‹ï¼š</div>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                                <input type="checkbox" id="exportAvatars" checked style="margin-right: 5px;">
                                å¤´åƒå›¾ç‰‡ï¼ˆè”ç³»äººå’Œç”¨æˆ·å¤´åƒï¼‰
                            </label>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                                <input type="checkbox" id="exportBackgrounds" checked style="margin-right: 5px;">
                                èŠå¤©èƒŒæ™¯å›¾ç‰‡
                            </label>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                                <input type="checkbox" id="exportEmojis" checked style="margin-right: 5px;">
                                è¡¨æƒ…åŒ…å›¾ç‰‡
                            </label>
                            <label style="display: block; margin-bottom: 10px; font-size: 12px;">
                                <input type="checkbox" id="exportMoments" checked style="margin-right: 5px;">
                                æœ‹å‹åœˆå›¾ç‰‡
                            </label>
                            <div style="display: flex; gap: 10px;">
                                <button type="button" class="form-submit" onclick="confirmFileExport()" data-umami-event="Confirm File Export"
                                        style="flex: 1; background-color: #4caf50; font-size: 12px; padding: 6px;">
                                    âœ… ç¡®è®¤å¯¼å‡º
                                </button>
                                <button type="button" class="form-submit" onclick="cancelFileExport()" data-umami-event="Cancel File Export"
                                        style="flex: 1; background-color: #f44336; font-size: 12px; padding: 6px;">
                                    âŒ å–æ¶ˆ
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- å…¶ä»–åŠŸèƒ½ -->
                    <div style="margin-bottom: 15px;">
                        <button type="button" class="form-submit" id="shareDataBtn" onclick="handleShareData()" data-umami-event="Transfer Data" 
                                style="width: 100%; background-color: #007bff;">
                            ğŸ”— æ•°æ®ä¼ è¾“
                        </button>
                    </div>

                    <!-- äº‘åŒæ­¥åŠŸèƒ½ -->
                    <div style="margin-bottom: 15px; padding: 15px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px;">
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #1565c0;">
                            ğŸŒ äº‘ç«¯æ•°æ®åŒæ­¥
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button type="button" class="form-submit" onclick="uploadDataToCloud()" 
                                    style="flex: 1; background-color: #4caf50;">
                                â˜ï¸ ä¸Šä¼ åˆ°äº‘ç«¯
                            </button>
                            <button type="button" class="form-submit" onclick="downloadDataFromCloud()" 
                                    style="flex: 1; background-color: #2196f3;">
                                â¬‡ï¸ ä»äº‘ç«¯ä¸‹è½½
                            </button>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <input type="text" id="syncKeyInput" placeholder="è¾“å…¥åŒæ­¥æ ‡è¯†ç¬¦" 
                                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        </div>
                        
                        <div id="syncStatus" style="font-size: 12px; color: #666; text-align: center;"></div>
                    </div>
                    
                    
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileSelect(event)">
                    <input type="file" id="fileStorageImportInput" accept=".zip,.json" style="display: none;" onchange="handleFileStorageImport(event)">
                </div>

                <!-- æ•°æ®ä¼˜åŒ–åŠŸèƒ½ -->
                <div class="data-optimization-section" style="margin: 15px;">
                    <!-- å›¾ç‰‡å­˜å‚¨ä¼˜åŒ–éƒ¨åˆ† -->
                    <div class="context-control" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f9f9f9;">
                        <div class="context-header">
                            <div class="context-title" style="color: #333; font-weight: bold;">ğŸ“ å›¾ç‰‡å­˜å‚¨ä¼˜åŒ–</div>
                            <div class="context-value" id="migrationStatusText">æ£€æŸ¥ä¸­...</div>
                        </div>
                        <div class="context-info" style="margin-top: 10px; font-size: 13px; color: #666;">
                            å°†ç°æœ‰çš„base64å›¾ç‰‡æ•°æ®è½¬æ¢ä¸ºé«˜æ•ˆçš„æ–‡ä»¶å­˜å‚¨æ ¼å¼ï¼Œå¯æ˜¾è‘—å‡å°‘å­˜å‚¨ç©ºé—´å ç”¨å¹¶æå‡æ€§èƒ½ã€‚
                        </div>
                        
                        <!-- è¿ç§»çŠ¶æ€æ˜¾ç¤º -->
                        <div id="migrationStatusDetails" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; color: #666;">
                            <div>æ­£åœ¨æ£€æŸ¥å›¾ç‰‡æ•°æ®çŠ¶æ€...</div>
                        </div>

                        <!-- è¿ç§»æŒ‰é’®ç»„ -->
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="form-submit" onclick="checkImageMigrationStatus()" style="flex: 1; font-size: 12px;">
                                ğŸ” æ£€æŸ¥çŠ¶æ€
                            </button>
                            <button type="button" class="form-submit" id="startMigrationBtn" onclick="startImageMigration()" 
                                    style="flex: 2; font-size: 12px; background-color: #ff9500;" disabled>
                                ğŸš€ å¼€å§‹ä¼˜åŒ–
                            </button>
                        </div>

                        <!-- è¿ç§»è¿›åº¦æ˜¾ç¤º -->
                        <div id="migrationProgress" style="margin-top: 10px; display: none;">
                            <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden; height: 8px; margin-bottom: 5px;">
                                <div id="migrationProgressBar" style="background: #07c160; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="migrationProgressText" style="font-size: 11px; color: #666;">å‡†å¤‡å¼€å§‹...</div>
                        </div>
                    </div>

                    <!-- èŠå¤©è®°å½•è¡¨æƒ…åŒ…ä¼˜åŒ–éƒ¨åˆ† -->
                    <div class="context-control" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f0f8ff;">
                        <div class="context-header">
                            <div class="context-title" style="color: #333; font-weight: bold;">ğŸ’¬ èŠå¤©è®°å½•è¡¨æƒ…ä¼˜åŒ–</div>
                            <div class="context-value" id="chatEmojiMigrationStatusText">æ£€æŸ¥ä¸­...</div>
                        </div>
                        <div class="context-info" style="margin-top: 10px; font-size: 13px; color: #666;">
                            ä¼˜åŒ–èŠå¤©è®°å½•ä¸­çš„è¡¨æƒ…åŒ…å­˜å‚¨æ ¼å¼ï¼Œå°†base64æ ¼å¼è½¬æ¢ä¸ºé«˜æ•ˆçš„æ–‡ä»¶å­˜å‚¨ï¼ŒåŒæ—¶ä¿æŒAPIå…¼å®¹æ€§ã€‚
                        </div>
                        
                        <!-- è¿ç§»çŠ¶æ€æ˜¾ç¤º -->
                        <div id="chatEmojiMigrationStatusDetails" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; color: #666;">
                            <div>æ­£åœ¨æ£€æŸ¥èŠå¤©è®°å½•ä¸­çš„è¡¨æƒ…åŒ…çŠ¶æ€...</div>
                        </div>

                        <!-- è¿ç§»æŒ‰é’®ç»„ -->
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="form-submit" onclick="checkChatEmojiMigrationStatus()" style="flex: 1; font-size: 12px;">
                                ğŸ” æ£€æŸ¥çŠ¶æ€
                            </button>
                            <button type="button" class="form-submit" id="startChatEmojiMigrationBtn" onclick="startChatEmojiMigration()" 
                                    style="flex: 2; font-size: 12px; background-color: #1890ff;" disabled>
                                ğŸ’¬ å¼€å§‹ä¼˜åŒ–
                            </button>
                        </div>

                        <!-- è¿ç§»è¿›åº¦æ˜¾ç¤º -->
                        <div id="chatEmojiMigrationProgress" style="margin-top: 10px; display: none;">
                            <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden; height: 8px; margin-bottom: 5px;">
                                <div id="chatEmojiMigrationProgressBar" style="background: #1890ff; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="chatEmojiMigrationProgressText" style="font-size: 11px; color: #666;">å‡†å¤‡å¼€å§‹...</div>
                        </div>
                    </div>

                    <!-- Unsplash -->
                    <div class="context-control" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f5f8ff;">
                        <div class="context-header">
                            <div class="context-title" style="color: #333; font-weight: bold;">ğŸ¨ æ–‡å­—é…å›¾</div>
                            <div class="context-value" id="imageKeywordStatusText">
                                <span id="imageKeywordStatus"></span>
                            </div>
                        </div>
                        <div class="context-info" style="margin-top: 10px; font-size: 13px; color: #666;">
                            ä½¿ç”¨ Unsplash API ä¸ºè®ºå›æˆ–æœ‹å‹åœˆé…å›¾
                        </div>
                        
                        <!-- é…ç½®çŠ¶æ€æ˜¾ç¤º -->
                        <div id="imageKeywordConfigStatus" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; color: #666;">
                            <div>æ­£åœ¨æ£€æŸ¥é…ç½®çŠ¶æ€...</div>
                        </div>

                        <!-- æ§åˆ¶æŒ‰é’® -->
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="form-submit" onclick="checkImageKeywordStatus()" style="flex: 1; font-size: 12px;">
                                ğŸ” æ£€æŸ¥çŠ¶æ€
                            </button>
                            <button type="button" class="form-submit" onclick="openImageKeywordSettings()" style="flex: 1; font-size: 12px; background-color: #28a745;">
                                âš™ï¸ é…ç½®è®¾ç½®
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="debug-log-page" id="debugLogPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="chat-title">è°ƒè¯•æ—¥å¿—</div>
                <div class="header-actions">
                    <button class="header-btn" onclick="window.SystemUtils.clearDebugLogs()">æ¸…ç©º</button>
                    <button class="header-btn" onclick="window.SystemUtils.copyDebugLogs()">å¤åˆ¶</button>
                </div>
            </div>
            
            <div class="debug-log-container">
                <div class="debug-log-info">
                    <div class="debug-log-stats">
                        æ€»è®¡ <span id="logCount">0</span> æ¡æ—¥å¿—
                    </div>
                    <div class="debug-log-hint">
                        æ˜¾ç¤ºæµè§ˆå™¨æ§åˆ¶å°çš„å®æ—¶æ—¥å¿—ï¼ŒåŒ…æ‹¬é”™è¯¯ã€è­¦å‘Šå’Œè°ƒè¯•ä¿¡æ¯
                    </div>
                </div>
                
                <div class="debug-log-content" id="debugLogContent">
                    <div class="debug-log-empty">
                        æš‚æ— æ—¥å¿—è®°å½•
                    </div>
                </div>
            </div>
        </div>

        <!-- å¤–è§‚ç®¡ç†é¡µé¢ -->
        <div class="appearance-management-page" id="appearanceManagementPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>â€¹</span>
                </div>
                <div class="chat-title">å¤–è§‚ç®¡ç†</div>
            </div>
            
            <div class="appearance-content">
                <!-- æš—é»‘æ¨¡å¼é€‰æ‹© -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">ä¸»é¢˜æ¨¡å¼</h3>
                    <p class="appearance-section-desc">é€‰æ‹©ä½ å–œæ¬¢çš„ä¸»é¢˜æ¨¡å¼ï¼Œæ”¯æŒè·Ÿéšç³»ç»Ÿè®¾ç½®</p>
                    
                    <div class="theme-mode-grid">
                        <div class="theme-mode-option active" data-theme="system" onclick="window.UIManager.switchTheme('system')">
                            <div class="theme-mode-icon">ğŸ”„</div>
                            <div class="theme-mode-content">
                                <div class="theme-mode-name">è·Ÿéšç³»ç»Ÿ</div>
                                <div class="theme-mode-desc">è‡ªåŠ¨è·Ÿéšç³»ç»Ÿæš—è‰²æ¨¡å¼</div>
                            </div>
                        </div>
                        <div class="theme-mode-option" data-theme="light" onclick="window.UIManager.switchTheme('light')">
                            <div class="theme-mode-icon">â˜€ï¸</div>
                            <div class="theme-mode-content">
                                <div class="theme-mode-name">äº®è‰²æ¨¡å¼</div>
                                <div class="theme-mode-desc">å§‹ç»ˆä½¿ç”¨äº®è‰²ä¸»é¢˜</div>
                            </div>
                        </div>
                        <div class="theme-mode-option" data-theme="dark" onclick="window.UIManager.switchTheme('dark')">
                            <div class="theme-mode-icon">ğŸŒ™</div>
                            <div class="theme-mode-content">
                                <div class="theme-mode-name">æš—é»‘æ¨¡å¼</div>
                                <div class="theme-mode-desc">å§‹ç»ˆä½¿ç”¨æš—è‰²ä¸»é¢˜</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ä¸»é¢˜è‰²é€‰æ‹© -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">ä¸»é¢˜è‰²å½©</h3>
                    <p class="appearance-section-desc">é€‰æ‹©ä½ å–œæ¬¢çš„ä¸»é¢˜è‰²ï¼Œä¸ªæ€§åŒ–ä½ çš„åº”ç”¨ç•Œé¢</p>
                    
                    <div class="theme-color-grid">
                        <!-- é»˜è®¤ç»¿è‰² -->
                        <div class="theme-color-option active" data-color="#07c160" data-name="é²œç»¿">
                            <div class="theme-color-preview" style="background-color: #07c160;"></div>
                            <div class="theme-color-name">é²œç»¿</div>
                        </div>
                        <!-- è“è‰² -->
                        <div class="theme-color-option" data-color="#1890ff" data-name="å¤©ç©ºè“">
                            <div class="theme-color-preview" style="background-color: #1890ff;"></div>
                            <div class="theme-color-name">å¤©ç©ºè“</div>
                        </div>
                        <!-- ç´«è‰² -->
                        <div class="theme-color-option" data-color="#722ed1" data-name="æ·±ç´«">
                            <div class="theme-color-preview" style="background-color: #722ed1;"></div>
                            <div class="theme-color-name">æ·±ç´«</div>
                        </div>
                        <!-- çº¢è‰² -->
                        <div class="theme-color-option" data-color="#f5222d" data-name="ç«çº¢">
                            <div class="theme-color-preview" style="background-color: #f5222d;"></div>
                            <div class="theme-color-name">ç«çº¢</div>
                        </div>
                        <!-- æ©™è‰² -->
                        <div class="theme-color-option" data-color="#fa8c16" data-name="æ©™">
                            <div class="theme-color-preview" style="background-color: #fa8c16;"></div>
                            <div class="theme-color-name">æ©™</div>
                        </div>
                        <!-- é’è‰² -->
                        <div class="theme-color-option" data-color="#13c2c2" data-name="æ¸…æ–°é’">
                            <div class="theme-color-preview" style="background-color: #13c2c2;"></div>
                            <div class="theme-color-name">æ¸…æ–°é’</div>
                        </div>
                        <!-- ç²‰è‰² -->
                        <div class="theme-color-option" data-color="#eb2f96" data-name="äº®ç²‰">
                            <div class="theme-color-preview" style="background-color: #eb2f96;"></div>
                            <div class="theme-color-name">äº®ç²‰</div>
                        </div>
                        <!-- æ·±è“ -->
                        <div class="theme-color-option" data-color="#2f54eb" data-name="æµ·è“">
                            <div class="theme-color-preview" style="background-color: #2f54eb;"></div>
                            <div class="theme-color-name">æµ·è“</div>
                        </div>
                    </div>
                    
                    <!-- è‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨ -->
                    <div class="custom-color-section">
                        <label for="customColorPicker" class="custom-color-label">è‡ªå®šä¹‰é¢œè‰²</label>
                        <p class="custom-color-desc">ç‚¹å‡»é¢œè‰²åœ†åœˆé€‰æ‹©ï¼Œæˆ–ç›´æ¥è¾“å…¥åå…­è¿›åˆ¶é¢œè‰²ä»£ç </p>
                        
                        <div class="custom-color-preview-row">
                            <div class="custom-color-preview-container">
                                <div class="custom-color-preview-circle" id="customColorPreview" style="background-color: #07c160;">
                                    <input type="color" id="customColorPicker" class="custom-color-picker-hidden" value="#07c160">
                                </div>
                                <span class="custom-color-preview-label">é¢„è§ˆ</span>
                            </div>
                            
                            <div class="custom-color-input-container">
                                <input type="text" id="customColorText" class="custom-color-text" placeholder="#07c160" maxlength="7">
                                <button type="button" class="apply-custom-color-btn" onclick="applyCustomColor()">åº”ç”¨</button>
                            </div>
                        </div>
                        
                        <div class="color-input-tips">
                            <small>ğŸ’¡ æç¤ºï¼šæ”¯æŒæ ¼å¼å¦‚ #FF0000ã€#ff0000 ç­‰å…­ä½åå…­è¿›åˆ¶é¢œè‰²ä»£ç </small>
                        </div>
                    </div>
                </div>
                
                <!-- æ¸å˜ä¸»é¢˜è®¾ç½® -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">æ¸å˜ä¸»é¢˜</h3>
                    <p class="appearance-section-desc">å¼€å¯æ¸å˜æ•ˆæœï¼Œè®©ç•Œé¢æ›´å…·è§†è§‰å±‚æ¬¡æ„Ÿ</p>
                    
                    <div class="gradient-toggle-container">
                        <label class="gradient-toggle-label">
                            <input type="checkbox" id="gradientToggle" class="gradient-toggle-input">
                            <span class="gradient-toggle-slider"></span>
                            å¯ç”¨æ¸å˜ä¸»é¢˜
                        </label>
                    </div>
                    
                    <div class="gradient-settings" id="gradientSettings" style="display: none;">
                        <div class="gradient-color-row">
                            <div class="gradient-color-group">
                                <label class="gradient-color-label">ä¸»è‰²</label>
                                <div class="gradient-color-picker-container">
                                    <div class="gradient-color-preview" id="gradientPrimaryPreview" style="background-color: #07c160;">
                                        <input type="color" id="gradientPrimaryPicker" class="gradient-color-picker-hidden" value="#07c160">
                                    </div>
                                    <input type="text" id="gradientPrimaryText" class="gradient-color-text" placeholder="#07c160" maxlength="7" value="#07c160">
                                </div>
                            </div>
                            
                            <div class="gradient-color-group">
                                <label class="gradient-color-label">å‰¯è‰²</label>
                                <div class="gradient-color-picker-container">
                                    <div class="gradient-color-preview" id="gradientSecondaryPreview" style="background-color: #1890ff;">
                                        <input type="color" id="gradientSecondaryPicker" class="gradient-color-picker-hidden" value="#1890ff">
                                    </div>
                                    <input type="text" id="gradientSecondaryText" class="gradient-color-text" placeholder="#1890ff" maxlength="7" value="#1890ff">
                                </div>
                            </div>
                        </div>
                        
                        <div class="gradient-preview-container">
                            <label class="gradient-preview-label">æ•ˆæœé¢„è§ˆ</label>
                            <div class="gradient-preview-demo" id="gradientPreviewDemo">
                                <div class="gradient-preview-text">æ¸å˜æ•ˆæœé¢„è§ˆ</div>
                            </div>
                        </div>
                        
                        <div class="gradient-direction-container">
                            <label class="gradient-direction-label">æ¸å˜æ–¹å‘</label>
                            <div class="gradient-direction-options">
                                <label class="gradient-direction-option">
                                    <input type="radio" name="gradientDirection" value="to right" checked>
                                    <span class="gradient-direction-text">â†’ æ°´å¹³</span>
                                </label>
                                <label class="gradient-direction-option">
                                    <input type="radio" name="gradientDirection" value="to bottom">
                                    <span class="gradient-direction-text">â†“ å‚ç›´</span>
                                </label>
                                <label class="gradient-direction-option">
                                    <input type="radio" name="gradientDirection" value="135deg">
                                    <span class="gradient-direction-text">â†˜ å¯¹è§’</span>
                                </label>
                            </div>
                        </div>
                        
                        <button type="button" class="apply-gradient-btn" onclick="applyGradientThemeFromUI()">åº”ç”¨æ¸å˜ä¸»é¢˜</button>
                    </div>
                </div>
                
                <!-- èŠå¤©æ°”æ³¡è®¾è®¡å™¨ -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">èŠå¤©æ°”æ³¡è®¾è®¡</h3>
                    <p class="appearance-section-desc">è®¾è®¡ä¸ªæ€§åŒ–çš„èŠå¤©æ°”æ³¡æ ·å¼ï¼Œæ·»åŠ è´´å›¾è£…é¥°</p>
                    <div class="bubble-designer-option">
                        <button type="button" class="bubble-designer-btn" onclick="openBubbleDesigner()">
                            <div class="bubble-designer-icon">ğŸ’¬</div>
                            <div class="bubble-designer-info">
                                <div class="bubble-designer-title">æ°”æ³¡æ ·å¼è®¾è®¡å™¨</div>
                                <div class="bubble-designer-desc">è‡ªå®šä¹‰æ°”æ³¡é¢œè‰²ã€è¾¹æ¡†ã€è´´å›¾è£…é¥°ç­‰</div>
                            </div>
                            <div class="bubble-designer-arrow">â€º</div>
                        </button>
                    </div>
                </div>
                
                <!-- é¢„ç•™æ›´å¤šå¤–è§‚è®¾ç½® -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">æ›´å¤šè®¾ç½®</h3>
                    <p class="appearance-section-desc">æ•¬è¯·æœŸå¾…æ›´å¤šä¸ªæ€§åŒ–é€‰é¡¹</p>
                    <div class="coming-soon">
                        <div class="coming-soon-icon">ğŸ¨</div>
                        <div class="coming-soon-text">æ›´å¤šå¤–è§‚é€‰é¡¹å³å°†æ¨å‡º</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="memory-management-page" id="memoryManagementPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="chat-title">è®°å¿†ç®¡ç†</div>
                <div class="header-actions">
                    <button class="header-btn" onclick="showAddMemoryModal()">æ·»åŠ </button>
                </div>
            </div>
            
            <div class="memory-management-container">
                <div class="memory-tabs">
                    <button class="memory-tab active" onclick="switchMemoryTab('global')">å…¨å±€è®°å¿†</button>
                    <button class="memory-tab" onclick="switchMemoryTab('character')">è§’è‰²è®°å¿†</button>
                </div>
                
                <div class="memory-content">
                    <div class="memory-section" id="globalMemorySection">
                        <div class="memory-list" id="globalMemoryList">
                            <div class="memory-empty">æš‚æ— å…¨å±€è®°å¿†</div>
                        </div>
                    </div>
                    
                    <div class="memory-section hidden" id="characterMemorySection">
                        <div class="character-selector">
                            <select id="characterSelector" onchange="loadCharacterMemories()">
                                <option value="">é€‰æ‹©è§’è‰²...</option>
                            </select>
                        </div>
                        <div class="memory-list" id="characterMemoryList">
                            <div class="memory-empty">è¯·å…ˆé€‰æ‹©è§’è‰²</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä¸ªäººä¸»é¡µé¡µé¢ -->
        <div class="user-profile-page" id="userProfilePage">
            <div class="user-profile-header">
                <div class="back-btn" onclick="goBackFromUserProfile()">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="user-profile-actions">
                    <span class="header-icon">â‹¯</span>
                </div>
            </div>
            
            <div class="user-profile-content">
                <div class="user-profile-banner" id="userProfileBanner" onclick="openBannerUploadModal()" style="cursor: pointer;" data-umami-event="Banner Click">
                    <div class="banner-upload-hint" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255,255,255,0.7); font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s;">
                        ç‚¹å‡»æ›´æ¢èƒŒæ™¯å›¾ç‰‡
                    </div>
                    <div class="user-profile-avatar-container" onclick="event.stopPropagation()">
                        <div class="user-profile-name" id="userProfileName">æˆ‘çš„æ˜µç§°</div>
                        <div class="user-profile-avatar" id="userProfileAvatar">æˆ‘</div>
                    </div>
                </div>
                
                <!-- æœ‹å‹åœˆç€‘å¸ƒæµ -->
                <div class="user-profile-moments" id="userProfileMoments">
                    <div class="user-profile-moments-empty">
                        <div class="moments-empty-icon">ğŸ“</div>
                        <div class="moments-empty-text">è¿˜æ²¡æœ‰æœ‹å‹åœˆåŠ¨æ€</div>
                    </div>
                    <div class="user-profile-moments-list" id="userProfileMomentsList"></div>
                </div>
            </div>
        </div>

        <!-- APIé…ç½®ç®¡ç†é¡µé¢ -->
        <div class="page" id="apiConfigManagementPage" style="display: none;">
            <div class="page-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="page-title">APIé…ç½®ç®¡ç†</div>
                <div class="page-actions">
                    <button class="header-btn" onclick="showNewApiConfigForm()">æ·»åŠ </button>
                </div>
            </div>
            <div class="page-content">
                <div class="config-list" id="apiConfigList">
                    <div class="config-list-empty">
                        <div class="empty-icon">âš™ï¸</div>
                        <div class="empty-text">æš‚æ— APIé…ç½®</div>
                        <button class="empty-action-btn" onclick="showNewApiConfigForm()">æ·»åŠ ç¬¬ä¸€ä¸ªé…ç½®</button>
                    </div>
                </div>
                
                <!-- é…ç½®è¡¨å• -->
                <div class="config-form" id="apiConfigForm" style="display: none;">
                    <div class="config-form-header">
                        <h3 id="configFormTitle">æ–°å¢APIé…ç½®</h3>
                        <button class="close-form-btn" onclick="closeApiConfigForm()">âœ•</button>
                    </div>
                    
                    <form onsubmit="saveApiConfigInPage(event)" id="apiConfigPageForm">
                        <div class="form-group">
                            <label class="form-label">é…ç½®åç§°</label>
                            <input type="text" class="form-input" id="pageConfigName" required placeholder="ç»™è¿™ä¸ªé…ç½®èµ·ä¸ªåå­—">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">API URL</label>
                            <input type="url" class="form-input" id="pageApiUrl" required placeholder="ä¾‹å¦‚: https://api.openai.com/v1">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">API Key</label>
                            <div class="api-key-row">
                                <input type="password" class="form-input api-key-input" id="pageApiKey" required>
                                <div class="timeout-group">
                                    <label class="timeout-label">è¶…æ—¶</label>
                                    <input type="number" class="timeout-input" id="pageApiTimeout" min="5" max="300" value="60" placeholder="60">
                                    <span class="timeout-unit">ç§’</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <button type="button" class="form-submit" onclick="testApiConnectionInPage(event)" style="background-color: #17a2b8; margin-bottom: 10px;">æµ‹è¯•è¿æ¥</button>
                        </div>
                        
                        <div class="form-actions">
                            <button type="button" class="form-button secondary" onclick="closeApiConfigForm()">å–æ¶ˆ</button>
                            <button type="submit" class="form-button primary">ä¿å­˜é…ç½®</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- æ–°çš„å…¨å±è®¾ç½®é¡µé¢ -->
        <div class="contact-settings-page" id="contactSettingsPage">
            <div class="chat-header">
                <div class="back-btn" onclick="closeContactSettingsPage()">
                    <span>â€¹</span>
                    <span>è¿”å›</span>
                </div>
                <div class="chat-title" id="contactSettingsTitle">è”ç³»äººè®¾ç½®</div>
                <div class="chat-header-spacer"></div>
            </div>
            
            <div class="contact-settings-content">
                <!-- è§’è‰²ä¿¡æ¯è®¾ç½®åŒº -->
                <div class="settings-section">
                    <div class="settings-section-title">è§’è‰²ä¿¡æ¯</div>
                    <div class="settings-item" onclick="showEditContactModal()" data-umami-event="Edit Contact Open">
                        <div class="settings-item-icon">âœï¸</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">ç¼–è¾‘äººè®¾</div>
                            <div class="settings-item-desc">ä¿®æ”¹è§’è‰²åç§°ã€å¤´åƒã€æ€§æ ¼æè¿°ç­‰</div>
                        </div>
                        <div class="settings-item-arrow">â€º</div>
                    </div>
                </div>

                <!-- èŠå¤©è®¾ç½®åŒº -->
                <div class="settings-section">
                    <div class="settings-section-title">èŠå¤©è®¾ç½®</div>
                    <div class="settings-item" onclick="showBackgroundModal()" data-umami-event="Background Settings Open">
                        <div class="settings-item-icon">ğŸ¨</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">è®¾ç½®èƒŒæ™¯</div>
                            <div class="settings-item-desc">æ›´æ¢èŠå¤©èƒŒæ™¯å›¾ç‰‡</div>
                        </div>
                        <div class="settings-item-arrow">â€º</div>
                    </div>
                </div>

                <!-- æ•°æ®ç®¡ç†åŒº -->
                <div class="settings-section">
                    <div class="settings-section-title">æ•°æ®ç®¡ç†</div>
                    <div class="settings-item" onclick="clearMessages()" data-umami-event="Clear Messages">
                        <div class="settings-item-icon">ğŸ—‘ï¸</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">æ¸…ç©ºèŠå¤©</div>
                            <div class="settings-item-desc">åˆ é™¤æ‰€æœ‰èŠå¤©è®°å½•ï¼Œæ­¤æ“ä½œä¸å¯æ’¤é”€</div>
                        </div>
                        <div class="settings-item-arrow">â€º</div>
                    </div>
                    <div class="settings-item danger-item" onclick="deleteCurrentContact()" data-umami-event="Delete Contact">
                        <div class="settings-item-icon">âš ï¸</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">åˆ é™¤è”ç³»äºº</div>
                            <div class="settings-item-desc">æ°¸ä¹…åˆ é™¤æ­¤è”ç³»äººåŠæ‰€æœ‰æ•°æ®</div>
                        </div>
                        <div class="settings-item-arrow">â€º</div>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <div class="bottom-nav">
        <div class="nav-item active" onclick="showPage('contactListPage')" data-umami-event="Nav Chat">
            <div class="nav-icon">ğŸ’¬</div>
            <div class="nav-text">èŠå¤©</div>
        </div>
        <div class="nav-item" onclick="showPage('weiboPage')" data-umami-event="Nav Forum">
            <div class="nav-icon">
                <svg t="1721063385731" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10099" width="24" height="24"><path d="M822.4 438.4c-3.2-16-16-28.8-32-32-12.8-3.2-25.6-3.2-38.4-3.2-108.8 0-204.8 48-275.2 128-22.4 25.6-41.6 51.2-57.6 80-96-44.8-192-115.2-265.6-204.8-19.2-25.6-48-35.2-76.8-22.4-28.8 12.8-44.8 44.8-35.2 73.6 3.2 9.6 9.6 19.2 16 28.8 48 64 108.8 118.4 179.2 163.2-83.2 16-156.8 64-211.2 131.2-19.2 25.6-16 64 9.6 83.2 25.6 19.2 64 16 83.2-9.6 44.8-54.4 105.6-92.8 172.8-112-6.4 35.2-9.6 70.4-9.6 105.6 0 163.2 102.4 304 249.6 358.4 19.2 6.4 38.4 0 51.2-16 12.8-16 12.8-38.4 0-54.4-115.2-124.8-115.2-300.8 0-425.6 64-70.4 144-112 233.6-121.6 16 0 32-3.2 44.8-9.6 16-9.6 22.4-25.6 19.2-41.6z" fill="#999999" p-id="10100"></path></svg>
            </div>
            <div class="nav-text">è®ºå›</div>
        </div>
        <div class="nav-item" onclick="showPage('momentsPage')" data-umami-event="Nav Discover">
            <div class="nav-icon">ğŸ”</div>
            <div class="nav-text">å‘ç°</div>
        </div>
        <div class="nav-item" onclick="showPage('interactivePage')" data-umami-event="Nav Interactive">
            <div class="nav-icon">ğŸ®</div>
            <div class="nav-text">äº’åŠ¨</div>
        </div>
        <div class="nav-item" onclick="showPage('profilePage')" data-umami-event="Nav Profile">
            <div class="nav-icon">ğŸ‘¤</div>
            <div class="nav-text">æˆ‘</div>
        </div>
    </div>

    <div class="modal" id="generatePostModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ç”Ÿæˆè®ºå›å¸–å­</div>
                <div class="modal-close" onclick="closeModal('generatePostModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleGeneratePost(event)">
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹©è§’è‰²</label>
                        <select class="form-input" id="postGenCharacterSelect" onchange="handleCharacterChange()" required>
                            <option value="">è¯·é€‰æ‹©...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">å…³ç³»ç±»å‹</label>
                        <select class="form-input" id="postGenRelations" onchange="handleRelationChange()" required>
                            <option value="">è¯·é€‰æ‹©...</option>
                            <option value="CP">CP</option>
                            <option value="CB">CB</option>
                            <option value="å¥½å‹">å¥½å‹</option>
                            <option value="å®¿æ•Œ">å®¿æ•Œ</option>
                            <option value="custom">è‡ªå®šä¹‰</option>
                        </select>
                    </div>
                    <div class="form-group" style="display: none;">
                        <label class="form-label">è‡ªå®šä¹‰å…³ç³»</label>
                        <input type="text" class="form-input" id="postGenCustomRelation" placeholder="è¯·æè¿°ä½ ä»¬çš„å…³ç³»">
                    </div>
                    <div class="form-group">
                        <label class="form-label">è¯é¢˜</label>
                        <input type="text" class="form-input" id="postGenHashtag" placeholder="ä¾‹å¦‚ï¼šABã€BAã€A & Bã€ABçš„æ—¥è®° ç­‰" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">ç”Ÿæˆæ•°é‡</label>
                        <input type="number" class="form-input" id="postGenCount" value="1" min="1" max="5" required>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Generate Forum Post">å¼€å§‹ç”Ÿæˆ</button>
                </form>
            </div>
        </div>
    </div>

    <!-- æœ‹å‹åœˆå‘å¸ƒæ–¹å¼é€‰æ‹©æ¨¡æ€æ¡† -->
    <div class="modal" id="momentChoiceModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">å‘å¸ƒæœ‹å‹åœˆ</div>
                <div class="modal-close" onclick="closeModal('momentChoiceModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <div class="post-choice-container">
                    <div class="choice-option" onclick="selectMomentType('manual')">
                        <div class="choice-icon">âœï¸</div>
                        <div class="choice-title">è‡ªå·±å‘æœ‹å‹åœˆ</div>
                        <div class="choice-description">æ‰‹åŠ¨è¾“å…¥æœ‹å‹åœˆå†…å®¹ï¼Œç³»ç»Ÿä¼šç”Ÿæˆè¯„è®º</div>
                    </div>
                    <div class="choice-option" onclick="selectMomentType('generate')">
                        <div class="choice-icon">âœ¨</div>
                        <div class="choice-title">ç”Ÿæˆæœ‹å‹åœˆ</div>
                        <div class="choice-description">AIæ ¹æ®èŠå¤©è®°å½•è‡ªåŠ¨ç”Ÿæˆæœ‹å‹åœˆå’Œè¯„è®º</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ‰‹åŠ¨å‘æœ‹å‹åœˆæ¨¡æ€æ¡† -->
    <div class="modal" id="manualMomentModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">å‘å¸ƒæœ‹å‹åœˆ</div>
                <div class="modal-close" onclick="closeModal('manualMomentModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleManualMoment(event)">
                    <div class="form-group">
                        <label class="form-label">å‘å¸ƒäºº</label>
                        <input type="text" class="form-input" id="manualMomentAuthor" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æœ‹å‹åœˆå†…å®¹</label>
                        <textarea class="form-input" id="manualMomentContent" placeholder="è¾“å…¥ä½ çš„æœ‹å‹åœˆå†…å®¹..." rows="4" required></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label">ä½ç½®ï¼ˆå¯é€‰ï¼‰</label>
                        <input type="text" class="form-input" id="manualMomentLocation" placeholder="è¾“å…¥ä½ç½®ä¿¡æ¯...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ä¸Šä¼ å›¾ç‰‡ï¼ˆæœ€å¤š9å¼ ï¼‰</label>
                        <input type="file" id="momentImagesInput" accept="image/*" multiple style="margin-bottom: 10px;" onchange="handleMomentImagesUpload(event)">
                        <div class="moment-images-preview" id="momentImagesPreview"></div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Manual Moment Submit">å‘å¸ƒå¹¶ç”Ÿæˆè¯„è®º</button>
                </form>
            </div>
        </div>
    </div>

    <!-- AIç”Ÿæˆæœ‹å‹åœˆæ¨¡æ€æ¡† -->
    <div class="modal" id="generateMomentModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ç”Ÿæˆæœ‹å‹åœˆ</div>
                <div class="modal-close" onclick="closeModal('generateMomentModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleGenerateMoment(event)">
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹©è§’è‰²</label>
                        <select class="form-input" id="momentGenCharacterSelect" required>
                            <option value="">è¯·é€‰æ‹©...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æœ‹å‹åœˆä¸»é¢˜</label>
                        <input type="text" class="form-input" id="momentGenTopic" placeholder="ä¾‹å¦‚ï¼šæ—¥å¸¸ç”Ÿæ´»ã€å·¥ä½œæ„Ÿæ‚Ÿã€ç¾é£Ÿåˆ†äº«ç­‰ï¼ˆå¯é€‰ï¼‰">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ä½ç½®ï¼ˆå¯é€‰ï¼‰</label>
                        <input type="text" class="form-input" id="momentGenLocation" placeholder="è¾“å…¥ä½ç½®ä¿¡æ¯ï¼Œç•™ç©ºåˆ™AIè‡ªåŠ¨ç”Ÿæˆ">
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Generate Moment Submit">ç”Ÿæˆæœ‹å‹åœˆ</button>
                </form>
            </div>
        </div>
    </div>

    <!-- ç¼–è¾‘ä½ç½®æ¨¡æ€æ¡† -->
    <div class="modal" id="editLocationModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ä¿®æ”¹ä½ç½®</div>
                <div class="modal-close" onclick="closeModal('editLocationModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleEditLocation(event)">
                    <div class="form-group">
                        <label class="form-label">ä½ç½®ä¿¡æ¯</label>
                        <input type="text" class="form-input" id="editLocationInput" placeholder="è¾“å…¥ä½ç½®ä¿¡æ¯ï¼Œç•™ç©ºåˆ™ä¸æ˜¾ç¤ºä½ç½®">
                        <input type="hidden" id="editLocationMomentId">
                    </div>
                    <button type="submit" class="form-submit">ä¿å­˜</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="addContactModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="contactModalTitle">æ·»åŠ è§’è‰²</div>
                <div class="modal-close" onclick="closeModal('addContactModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="saveContact(event)">
                    <div class="form-group">
                        <label class="form-label">è§’è‰²åç§°</label>
                        <input type="text" class="form-input" id="contactName" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">å¤´åƒï¼ˆå¯é€‰ï¼‰</label>
                        <input type="url" class="form-input" id="contactAvatar" placeholder="å¯ç›´æ¥ç²˜è´´URLæˆ–ä¸Šä¼ æœ¬åœ°å›¾ç‰‡">
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="avatarUploadInput" accept="image/*" style="flex: 1;" onchange="handleContactAvatarUpload(event, window.editingContact)">
                            <span id="avatarUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">äººè®¾æè¿°</label>
                        <textarea class="form-textarea" id="contactPersonality" required placeholder="æè¿°AIçš„æ€§æ ¼ã€èƒŒæ™¯ã€è¯´è¯é£æ ¼ç­‰"></textarea>
                    </div>
                    
                    <!-- ã€ä¿®æ”¹ç‚¹ 2ã€‘: æ›´æ–°è”ç³»äººè®¾ç½®ä¸­çš„è¯­éŸ³IDæç¤º -->
                    <div class="form-group">
                        <label class="form-label">Minimax è¯­éŸ³IDï¼ˆå¯é€‰ï¼‰</label>
                        <input type="text" class="form-input" id="contactVoiceId" placeholder="å¯é€‰ - å¡«å†™åè§’è‰²ä¼šæ‹¥æœ‰è¯­éŸ³èƒ½åŠ›">
                        <div class="context-info" style="margin-top: 4px;">
                            åœ¨ <a href="https://www.minimaxi.com/voice-clone" target="_blank" rel="noopener noreferrer">Minimaxå®˜ç½‘</a> å…‹éš†æˆ–åˆ›å»ºå£°éŸ³ï¼
                        </div>
                    </div>
                    
                    <div class="prompt-section">
                        <div class="prompt-header">
                            <div class="prompt-title">è‡ªå®šä¹‰æç¤ºè¯ï¼ˆå¯é€‰ï¼‰</div>
                            <div class="prompt-actions">
                                <button type="button" class="prompt-btn" onclick="document.getElementById('promptFile').click()">å¯¼å…¥JSON</button>
                                <input type="file" id="promptFile" class="file-input" accept=".json" onchange="importPrompts(event)">
                            </div>
                        </div>
                        <div class="form-group">
                            <textarea class="form-textarea" id="customPrompts" placeholder="è¾“å…¥è‡ªå®šä¹‰æç¤ºè¯ï¼Œæˆ–å¯¼å…¥JSONæ–‡ä»¶"></textarea>
                        </div>
                    </div>
                    
                    <button type="submit" class="form-submit">ç¡®å®š</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="createGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">åˆ›å»ºç¾¤èŠ</div>
                <div class="modal-close" onclick="closeModal('createGroupModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="createGroup(event)">
                    <div class="form-group">
                        <label class="form-label">ç¾¤èŠåç§°</label>
                        <input type="text" class="form-input" id="groupName" required>
                    </div>
                    
                    <div class="create-group-section">
                        <label class="form-label">é€‰æ‹©ç¾¤æˆå‘˜</label>
                        <div class="group-member-list" id="groupMemberList"></div>
                    </div>
                    
                    <button type="submit" class="form-submit">åˆ›å»ºç¾¤èŠ</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="editProfileModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ç¼–è¾‘ä¸ªäººä¿¡æ¯</div>
                <div class="modal-close" onclick="closeModal('editProfileModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="saveProfile(event)">
                    <div class="form-group">
                        <label class="form-label">æ˜µç§°</label>
                        <input type="text" class="form-input" id="profileNameInput" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">å¤´åƒï¼ˆå¯é€‰ï¼‰</label>
                        <input type="url" class="form-input" id="profileAvatarInput" placeholder="å¯ç›´æ¥ç²˜è´´URLæˆ–ä¸Šä¼ æœ¬åœ°å›¾ç‰‡">
                         <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="profileUploadInput" accept="image/*" style="flex: 1;" onchange="handleProfileAvatarUpload(event)">
                            <span id="profileUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æˆ‘çš„äººè®¾æè¿°</label>
                        <textarea class="form-textarea" id="profilePersonality" placeholder="æè¿°ä½ çš„æ€§æ ¼ã€èƒŒæ™¯ã€è¯´è¯é£æ ¼ç­‰ï¼Œè®©AIæ›´å¥½åœ°ä¸ä½ äº’åŠ¨"></textarea>
                    </div>
                    <button type="submit" class="form-submit">ä¿å­˜</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="apiSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">APIé…ç½®ç®¡ç†</div>
                <div class="modal-close" onclick="closeModal('apiSettingsModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <!-- é…ç½®é€‰æ‹©å’Œç®¡ç†åŒºåŸŸ -->
                <div class="config-management-section">
                    <div class="config-selector-row">
                        <div class="config-selector-group">
                            <label class="form-label">å½“å‰é…ç½®</label>
                            <select class="form-input" id="configSelector" onchange="handleConfigSwitch(this.value)">
                                <option value="">åŠ è½½ä¸­...</option>
                            </select>
                        </div>
                        <div class="config-actions">
                            <button type="button" class="config-action-btn" onclick="showNewConfigForm()" title="æ–°å¢é…ç½®">â•</button>
                            <button type="button" class="config-action-btn config-delete-btn" onclick="deleteCurrentConfig()" title="åˆ é™¤é…ç½®" id="deleteBtn">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                </div>
                
                <!-- APIé…ç½®è¡¨å• -->
                <form onsubmit="saveApiConfig(event)" id="apiConfigForm">
                    <div class="form-group">
                        <label class="form-label">é…ç½®åç§°</label>
                        <input type="text" class="form-input" id="configName" required placeholder="ç»™è¿™ä¸ªé…ç½®èµ·ä¸ªåå­—">
                    </div>
                    
                    <div class="config-section">
                        <div class="config-section-title">APIé…ç½®</div>
                        <div class="form-group">
                            <label class="form-label">API URL</label>
                            <input type="url" class="form-input" id="apiUrl" required placeholder="ä¾‹å¦‚: https://api.openai.com/v1">
                        </div>
                        <div class="form-group main-api-key-group">
                            <label class="form-label">API Key (ä¸»Key)</label>
                            <div class="compact-key-row main-key-row">
                                <input type="password" class="form-input api-key-input compact-key-input" id="apiKey" required oninput="updateMainKeyStats(this); handleApiKeyInput(this, event)" placeholder="è¾“å…¥ä¸»API Key">
                                <div class="timeout-group">
                                    <input type="number" class="timeout-input" id="apiTimeout" min="5" max="300" value="60" placeholder="60" title="è¶…æ—¶(ç§’)">
                                    <span class="timeout-unit">s</span>
                                </div>
                                <button type="button" class="key-status-btn main-key-status" data-status="enabled" data-enabled="true" onclick="toggleMainKeyStatus(this)" title="ä¸»Key(å·²å¯ç”¨)">ğŸŸ¢</button>
                                <div class="key-stats-compact">
                                    <div class="key-masked-compact" id="mainKeyMask">æœªè®¾ç½®</div>
                                    <div class="stats-compact">
                                        <span id="mainKeyCalls">0æ¬¡</span>/<span id="mainKeySuccess">0%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <button type="button" class="form-submit" onclick="addProviderRow()" style="background-color: #28a745; margin-bottom: 10px; font-size: 14px; padding: 8px 16px;">
                                â• æ·»åŠ API Key
                            </button>
                            <div class="context-info" style="margin-top: -5px; font-size: 12px; color: #666;">
                                å¯ä»¥æ·»åŠ å¤šä¸ªAPI Keyï¼Œæ‰‹åŠ¨é€‰æ‹©å¯ç”¨çš„Key
                            </div>
                        </div>
                        
                        <button type="button" class="form-submit" onclick="enhancedTestApiConnection()" style="margin-bottom: 10px;" data-umami-event="Test API Connection">æµ‹è¯•è¿æ¥</button>
                    </div>
                    
                    <button type="submit" class="form-submit" data-umami-event="Save API Config">ä¿å­˜APIé…ç½® <small>(ç¬¬1æ­¥)</small></button>
                    <div class="form-step-hint" id="configSaveHint">
                        âœ… APIé…ç½®å·²ä¿å­˜ï¼æ¥ä¸‹æ¥ï¼š<strong>â‘ é€‰æ‹©é…ç½® â‘¡é€‰æ‹©æ¨¡å‹ â‘¢æ»‘åˆ°æœ€åç‚¹å‡»"å®Œæˆè®¾ç½®"</strong>
                    </div>
                </form>
                
                <!-- æ¨¡å‹å’ŒåŠŸèƒ½é…ç½® -->
                <form onsubmit="saveAppSettings(event)" id="appSettingsForm" style="margin-top: 20px;">
                    <div class="config-section">
                        <div class="config-section-title">åº”ç”¨è®¾ç½®</div>
                        
                        <div class="context-control">
                            <div class="context-header">
                                <div class="context-title">ä¸Šä¸‹æ–‡é•¿åº¦</div>
                                <div class="context-value" id="contextValue">10æ¡</div>
                            </div>
                            <input 
                                type="range" 
                                class="context-slider" 
                                id="contextSlider" 
                                min="1" 
                                max="50" 
                                value="10"
                                oninput="updateContextValue(this.value)"
                            >
                            <div class="context-info">
                                æ§åˆ¶AIå¯è§çš„å†å²æ¶ˆæ¯æ•°é‡ï¼Œè¾ƒé•¿çš„ä¸Šä¸‹æ–‡æœ‰åŠ©äºä¿æŒå¯¹è¯è¿è´¯æ€§ï¼Œä½†å¯èƒ½ä¼šå¢åŠ APIæˆæœ¬ã€‚
                            </div>
                        </div>
                        
                        <div class="config-section">
                            <div class="config-section-title">æ¨¡å‹é€‰æ‹©</div>
                            <div class="form-step-reminder" id="modelSelectionReminder">
                                ğŸ’¡ <strong>æ“ä½œæµç¨‹ï¼š</strong>â‘ ä¿å­˜ä¸Šæ–¹APIé…ç½® â†’ â‘¡é€‰æ‹©APIé…ç½® â†’ â‘¢é€‰æ‹©æ¨¡å‹ â†’ â‘£æ»‘åˆ°æœ€åç‚¹å‡»"å®Œæˆè®¾ç½®"
                            </div>
                        
                        <div class="form-group">
                            <label class="form-label">ä¸»è¦æ¨¡å‹</label>
                            <div class="model-selection-row">
                                <select class="form-input model-config-select" id="primaryConfigSelect" onchange="loadModelsForConfig('primaryConfigSelect', 'primaryModelSelect')">
                                    <option value="">é€‰æ‹©APIé…ç½®</option>
                                </select>
                                <select class="form-input model-select" id="primaryModelSelect" onchange="saveModelSelection('primary')">
                                    <option value="">è¯·å…ˆå®Œæˆç¬¬1æ­¥ä¿å­˜APIé…ç½®</option>
                                </select>
                            </div>
                            <div class="context-info" style="margin-top: 4px;">ç”Ÿæˆå¯¹è¯ã€ç”Ÿæˆå¸–å­ç­‰ä½¿ç”¨çš„æ¨¡å‹ã€‚å»ºè®®é€‰æ‹©è´¨é‡é«˜çš„æ¨¡å‹ã€‚</div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">æ¬¡è¦æ¨¡å‹</label>
                            <div class="model-selection-row">
                                <select class="form-input model-config-select" id="secondaryConfigSelect" onchange="loadModelsForConfig('secondaryConfigSelect', 'secondaryModelSelect')">
                                    <option value="">é€‰æ‹©APIé…ç½®</option>
                                    <option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>
                                </select>
                                <select class="form-input model-select" id="secondaryModelSelect" onchange="saveModelSelection('secondary')">
                                    <option value="">è¯·å…ˆå®Œæˆç¬¬1æ­¥ä¿å­˜APIé…ç½®</option>
                                    <option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>
                                </select>
                            </div>
                            <div class="context-info" style="margin-top: 4px;">ç”¨äºæ€»ç»“ã€å¡«å†™è®°å¿†è¡¨æ ¼ç­‰ï¼Œå»ºè®®é€‰æ‹©ä¾¿å®œçš„æ¨¡å‹ï¼Œä»¥èŠ‚çº¦æˆæœ¬ã€‚è‹¥ä¸ä»‹æ„æˆæœ¬ï¼Œå¯é€‰æ‹©ä¸ä¸»è¦æ¨¡å‹ä¿æŒä¸€è‡´ã€‚</div>
                        </div>
                        </div>
                    
                    <div class="config-section">
                        <div class="config-section-title">æ‰©å±•åŠŸèƒ½</div>
                        <div class="form-group">
                            <label for="minimaxGroupId" class="form-label">Minimax Group ID</label>
                            <input type="text" id="minimaxGroupId" class="form-input" placeholder="è¾“å…¥ä½ çš„ Minimax Group ID...">
                        </div>
                        <div class="form-group">
                            <label for="minimaxApiKey" class="form-label">Minimax API Key (for TTS)</label>
                            <input type="password" id="minimaxApiKey" class="form-input" placeholder="è¾“å…¥ä½ çš„ Minimax API Key...">
                            <div class="context-info" style="margin-top: 4px;">
                                ç”¨äºè¯­éŸ³å…‹éš†åŠŸèƒ½ã€‚åœ¨ <a href="https://www.minimaxi.com/" target="_blank" rel="noopener noreferrer">Minimaxå®˜ç½‘</a> è·å–å‡­è¯ã€‚
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="unsplashApiKey" class="form-label">Unsplash API Keyï¼ˆå¯é€‰ï¼‰</label>
                            <input type="password" id="unsplashApiKey" class="form-input" placeholder="è¾“å…¥ä½ çš„ Unsplash Access Key...">
                            <div class="context-info" style="margin-top: 4px;">
                                ç”¨äºä¸ºè®ºå›å¸–å­å’Œæœ‹å‹åœˆè‡ªåŠ¨é…å›¾ã€‚åœ¨ <a href="https://unsplash.com/developers" target="_blank" rel="noopener noreferrer">Unsplash Developers</a> è·å–API Keyã€‚
                            </div>
                        </div>
                        </div>
                    </div>

                    <div class="final-step-hint">
                        ğŸ¯ <strong>æœ€åä¸€æ­¥ï¼š</strong>ç¡®è®¤å·²é€‰æ‹©é…ç½®å’Œæ¨¡å‹åï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å®Œæˆè®¾ç½®ï¼
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Save App Settings">å®Œæˆè®¾ç½® <small>(ç¬¬2æ­¥)</small></button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="backgroundModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">è®¾ç½®èŠå¤©èƒŒæ™¯</div>
                <div class="modal-close" onclick="closeModal('backgroundModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="setBackground(event)">
                    <div class="form-group">
                        <label class="form-label">èƒŒæ™¯å›¾ç‰‡</label>
                        <input type="url" class="form-input" id="backgroundUrl" placeholder="å¯ç›´æ¥ç²˜è´´URLæˆ–ä¸Šä¼ æœ¬åœ°å›¾ç‰‡">
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="bgUploadInput" accept="image/*" style="flex: 1;" onchange="window.ImageUploadHandlers.handleBgUpload(event)">
                            <span id="bgUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Contact Background Save">ç¡®å®š</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="addEmojiModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">æ·»åŠ è¡¨æƒ…åŒ…</div>
                <div class="modal-close" onclick="closeModal('addEmojiModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="addEmoji(event)">
                    <div class="form-group">
                        <label class="form-label">è¡¨æƒ…å›¾ç‰‡</label>
                        <input type="url" class="form-input" id="emojiUrl" placeholder="å¯ç›´æ¥ç²˜è´´URLæˆ–ä¸Šä¼ æœ¬åœ°å›¾ç‰‡" required>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="emojiUploadInput" accept="image/*" style="flex: 1;" onchange="window.ImageUploadHandlers.handleEmojiFileUpload(event)">
                            <span id="emojiUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">è¡¨æƒ…å«ä¹‰ï¼ˆç”¨äºAIç†è§£å’Œè°ƒç”¨ï¼‰</label>
                        <input type="text" class="form-input" id="emojiMeaning" required placeholder="ä¾‹å¦‚ï¼šå¼€å¿ƒã€å¤§ç¬‘ã€å“­æ³£ç­‰">
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Sticker Save">æ·»åŠ </button>
                </form>
            </div>
        </div>
    </div>
    
    <div class="modal" id="redPacketModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">å‘çº¢åŒ…</div>
                <div class="modal-close" onclick="closeModal('redPacketModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="sendRedPacket(event)">
                    <div class="form-group">
                        <label class="form-label">é‡‘é¢</label>
                        <input type="number" class="form-input" id="redPacketAmount" step="0.01" required placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ç•™è¨€ï¼ˆå¯é€‰ï¼‰</label>
                        <input type="text" class="form-input" id="redPacketMessage" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼">
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Redpacket Send">å¡é’±è¿›çº¢åŒ…</button>
                </form>
            </div>
        </div>
    </div>

    <div id="musicModal" class="music-modal">
        <div class="music-modal-content">
            <span class="close-btn" id="closeMusicModal">&times;</span>
            <h2>ğŸµ éŸ³ä¹æ’­æ”¾å™¨</h2>
            
            <div id="currentSongInfo" style="display: none;">
                <h3>æ­£åœ¨æ’­æ”¾: <span id="currentSongName"></span></h3>
                <div class="player-controls">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="time-display">
                        <span id="currentTime">0:00</span>
                        <span id="totalTime">0:00</span>
                    </div>
                    <div style="text-align: center; margin-top: 10px;">
                        <button class="form-submit" onclick="togglePlay()">
                            <span id="playPauseBtn">â–¶ï¸ æ’­æ”¾</span>
                        </button>
                        <button class="form-submit" style="background-color: #888;" onclick="stopMusic()">â¹ï¸ åœæ­¢</button>
                    </div>
                </div>
            </div>

            <h3>æˆ‘çš„æ­Œå•</h3>
            <div class="playlist-container" id="playlistContainer">
                <p style="text-align: center; color: #999;">æš‚æ— æ­Œæ›²</p>
            </div>

            <h3>æ·»åŠ æ–°æ­Œæ›²</h3>
            <div id="addSongForm">
                <div class="form-group">
                    <label class="form-label">æ­Œæ›²åç§° (å¯é€‰):</label>
                    <input type="text" class="form-input" id="songName" placeholder="ç•™ç©ºåˆ™ä½¿ç”¨æ–‡ä»¶å">
                </div>
                <div class="form-group">
                    <label class="form-label">é€‰æ‹©éŸ³ä¹æ–‡ä»¶:</label>
                    <input type="file" class="form-input" id="musicFileUpload" accept="audio/*,.mp3,.m4a,.wav,.flac">
                </div>
                <div class="form-group">
                    <label class="form-label">LRCæ­Œè¯æ–‡ä»¶ (å¯é€‰):</label>
                    <input type="file" class="form-input" id="lrcFile" accept=".lrc">
                    <small style="color: #666;">è¯·é€‰æ‹©.lrcæ ¼å¼çš„æ­Œè¯æ–‡ä»¶</small>
                </div>
                <button class="form-submit" onclick="saveSong()">ä¿å­˜æ­Œæ›²</button>
            </div>

            <div style="margin-top: 20px;">
                <label>
                    <input type="checkbox" id="showLyrics" onchange="toggleLyricsDisplay()">
                    æ˜¾ç¤ºæµ®åŠ¨æ­Œè¯
                </label>
            </div>
        </div>
    </div>

    <div id="floatingLyrics" class="floating-lyrics" style="display: none;">
        <span id="currentLyric">ç­‰å¾…æ­Œè¯...</span>
    </div>

    <div class="toast" id="toast"></div>
    
    <div class="top-notification" id="topNotification"></div>

    <!-- Update Announcement Modal -->
    <div class="modal" id="updateModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">æ›´æ–°å…¬å‘Š</div>
            </div>
            <div class="modal-body" id="updateModalBody">
                <!-- Content will be injected by JS to handle markdown -->
            </div>
            <div class="modal-footer">
                 <button class="form-submit" id="updateModalCloseBtn">æˆ‘çŸ¥é“äº†</button>
            </div>
        </div>
    </div>

    <!-- Post Choice Modal -->
    <div class="modal" id="postChoiceModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">åˆ›å»ºè®ºå›å¸–å­</div>
                <div class="modal-close" onclick="closeModal('postChoiceModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <div class="post-choice-container">
                    <div class="choice-option" onclick="selectPostType('manual')">
                        <div class="choice-icon">âœï¸</div>
                        <div class="choice-title">è‡ªå·±å‘å¸–å­</div>
                        <div class="choice-description">æ‰‹åŠ¨è¾“å…¥å¸–å­å†…å®¹ï¼Œç³»ç»Ÿä¼šç”Ÿæˆè¯„è®º</div>
                    </div>
                    <div class="choice-option" onclick="selectPostType('generate')">
                        <div class="choice-icon">âœ¨</div>
                        <div class="choice-title">ç”Ÿæˆå¸–å­</div>
                        <div class="choice-description">AIæ ¹æ®èŠå¤©è®°å½•è‡ªåŠ¨ç”Ÿæˆå¸–å­å’Œè¯„è®º</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Manual Post Modal -->
    <div class="modal" id="manualPostModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">å‘å¸ƒå¸–å­</div>
                <div class="modal-close" onclick="closeModal('manualPostModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleManualPost(event)">
                    <div class="form-group">
                        <label class="form-label">å‘å¸–äºº</label>
                        <input type="text" class="form-input" id="manualPostAuthor" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">è¯é¢˜æ ‡ç­¾</label>
                        <input type="text" class="form-input" id="manualPostTag" value="ç¢ç¢å¿µ" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">å¸–å­å†…å®¹</label>
                        <textarea class="form-input" id="manualPostContent" placeholder="è¾“å…¥ä½ çš„å¸–å­å†…å®¹..." rows="4" required></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label">å›¾ç‰‡æè¿°</label>
                        <textarea class="form-input" id="manualPostImageDesc" placeholder="æè¿°é…å›¾å†…å®¹ï¼ˆå¯é€‰ï¼‰..." rows="2"></textarea>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Manual Forum Post Submit">å‘å¸ƒå¹¶ç”Ÿæˆè¯„è®º</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Memory Modal -->
    <div class="modal" id="addMemoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">æ·»åŠ è®°å¿†</div>
                <div class="modal-close" onclick="closeModal('addMemoryModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleAddMemory(event)">
                    <div class="form-group" id="memoryTypeGroup">
                        <label class="form-label">è®°å¿†ç±»å‹</label>
                        <select class="form-input" id="memoryType" onchange="handleMemoryTypeChange()">
                            <option value="global">å…¨å±€è®°å¿†</option>
                            <option value="character">è§’è‰²è®°å¿†</option>
                        </select>
                    </div>
                    <div class="form-group hidden" id="characterSelectGroup">
                        <label class="form-label">é€‰æ‹©è§’è‰²</label>
                        <select class="form-input" id="memoryCharacterSelect">
                            <option value="">é€‰æ‹©è§’è‰²...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">è®°å¿†å†…å®¹</label>
                        <textarea class="form-input" id="memoryContent" placeholder="å¡«å†™ä½ æƒ³è®©AIè®°ä½çš„å†…å®¹ï¼Œä¸€è¡Œä¸ºä¸€æ¡æ–°è®°å¿†" rows="6" required></textarea>
                        <div class="form-hint">æ¯è¡Œä¸ºä¸€æ¡è®°å¿†ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ ¼å¼åŒ–ã€‚</div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Memory Add Confirm">æ·»åŠ è®°å¿†</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Edit Memory Modal -->
    <div class="modal" id="editMemoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ç¼–è¾‘è®°å¿†</div>
                <div class="modal-close" onclick="closeModal('editMemoryModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleEditMemory(event)">
                    <div class="form-group">
                        <label class="form-label">è®°å¿†å†…å®¹</label>
                        <textarea class="form-input" id="editMemoryContent" placeholder="è¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š&#10;- ç¬¬ä¸€æ¡è®°å¿†&#10;- ç¬¬äºŒæ¡è®°å¿†&#10;- ç¬¬ä¸‰æ¡è®°å¿†" rows="6" required></textarea>
                        <div class="form-hint">åªæ”¯æŒ "- è®°å¿†å†…å®¹" æ ¼å¼ï¼Œä¸€è¡Œä¸€æ¡è®°å¿†ã€‚å…¶ä»–æ ¼å¼ä¼šè¢«è‡ªåŠ¨å¿½ç•¥ã€‚</div>
                    </div>
                    <button type="submit" class="form-submit">ä¿å­˜ä¿®æ”¹</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Edit Single Memory Item Modal -->
    <div class="modal" id="editSingleMemoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ç¼–è¾‘è®°å¿†é¡¹</div>
                <div class="modal-close" onclick="closeModal('editSingleMemoryModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleEditSingleMemory(event)">
                    <div class="form-group">
                        <label class="form-label">è®°å¿†å†…å®¹</label>
                        <textarea class="form-input" id="editSingleMemoryContent" placeholder="å¡«å†™ä½ æƒ³è®©AIè®°ä½çš„å†…å®¹" rows="4" required></textarea>
                        <div class="form-hint">ç¼–è¾‘å•æ¡è®°å¿†çš„å†…å®¹ã€‚</div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Memory Edit Save">ä¿å­˜ä¿®æ”¹</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Bannerä¸Šä¼ æ¨¡æ€æ¡† -->
    <div class="modal" id="bannerUploadModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">æ›´æ¢èƒŒæ™¯å›¾ç‰‡</div>
                <div class="modal-close" onclick="closeModal('bannerUploadModal')">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <div class="banner-upload-container">
                    <div class="banner-upload-area" id="bannerUploadArea" onclick="triggerBannerFileInput()">
                        <div class="banner-upload-icon">ğŸ“·</div>
                        <div class="banner-upload-text">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡</div>
                        <div class="banner-upload-hint">æ”¯æŒ JPGã€PNG æ ¼å¼ï¼Œæ¨èæ¨ªå›¾</div>
                    </div>
                    <input type="file" id="bannerFileInput" accept="image/jpeg,image/jpg,image/png" style="display: none;" onchange="handleBannerFileSelect(event)">
                </div>
                
                <!-- é¢„è§ˆå’Œè£å‰ªåŒºåŸŸ -->
                <div class="banner-preview-container" id="bannerPreviewContainer" style="display: none;">
                    <div class="banner-preview-title">é¢„è§ˆæ•ˆæœ</div>
                    <div class="banner-preview-wrapper">
                        <canvas id="bannerPreviewCanvas" width="400" height="160"></canvas>
                    </div>
                    <div class="banner-crop-controls">
                        <label>å‚ç›´ä½ç½®è°ƒæ•´ï¼š</label>
                        <input type="range" id="bannerCropSlider" min="0" max="100" value="50" oninput="updateBannerPreview()">
                    </div>
                    <div class="banner-upload-buttons">
                        <button class="btn-secondary" onclick="resetBannerUpload()">é‡æ–°é€‰æ‹©</button>
                        <button class="btn-primary" onclick="saveBannerImage()" data-umami-event="Banner Upload Save">åº”ç”¨èƒŒæ™¯</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä¸ƒå¤•èŠ‚AIç©ºå›å¤é‡è¯•æ¨¡æ€æ¡† -->
    <div class="modal" id="qixiRetryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ğŸŒŸ è¯·æ±‚å¤±è´¥</div>
                <div class="modal-close" onclick="closeModal('qixiRetryModal')">âœ•</div>
            </div>
            <div class="modal-body">
                <div class="qixi-retry-content">
                    <div class="qixi-retry-icon">â¤ï¸â€ğŸ©¹</div>
                    <div class="qixi-retry-message">
                        <p><strong>æ“ä½œå¤±è´¥</strong></p>
                        <p>æ˜¯å¦è¦é‡æ–°å°è¯•ï¼Ÿ</p>
                    </div>
                </div>
                <div class="qixi-retry-buttons">
                    <button type="button" class="form-button qixi-retry-btn" onclick="handleQixiRetry()">
                        é‡æ–°å°è¯•
                    </button>
                    <button type="button" class="form-button qixi-cancel-btn" onclick="closeModal('qixiRetryModal')">
                        å–æ¶ˆ
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- æ¸…ç©ºlocalStorageç¡®è®¤å¯¹è¯æ¡† -->
    <div class="modal" id="clearLocalStorageModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">âš ï¸ å±é™©æ“ä½œç¡®è®¤</div>
                <div class="modal-close" onclick="closeModal('clearLocalStorageModal')">âœ•</div>
            </div>
            <div class="modal-body">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">ğŸ—‘ï¸</div>
                    <div style="margin-bottom: 20px;">
                        <p style="font-size: 16px; font-weight: bold; color: #dc3545; margin-bottom: 10px;">
                            ä½ å³å°†æ¸…ç©ºæ‰€æœ‰localStorageï¼
                        </p>
                        <p style="font-size: 14px; color: #666; margin-bottom: 8px;">
                            è¿™å¯èƒ½ä¼šå¯¼è‡´æ„å¤–çš„é€»è¾‘è§¦å‘
                        </p>
                        <p style="font-size: 14px; color: #dc3545; font-weight: 600;">
                            é™¤éä½ çŸ¥é“ä½ åœ¨åšä»€ä¹ˆï¼Œå¦åˆ™ä¸è¦ç¡®è®¤ï¼
                        </p>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button data-umami-event="Confirm Clear localStorage" type="button" class="form-button" onclick="executeLocalStorageClear()" 
                                style="flex: 1; background: #dc3545; color: white; border: none; padding: 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                            ç¡®è®¤
                        </button>
                        <button type="button" class="form-button" onclick="closeModal('clearLocalStorageModal')" 
                                style="flex: 1; background: #6c757d; color: white; border: none; padding: 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- APIæ¨¡å‹åŠ è½½ç­‰å¾…æç¤ºæ¡† -->
    <div class="modal" id="apiLoadingModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">æ­£åœ¨åŠ è½½æ¨¡å‹ä¿¡æ¯</div>
                <div class="modal-close" onclick="cancelApiLoading()">å–æ¶ˆ</div>
            </div>
            <div class="modal-body">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">â³</div>
                    <div style="margin-bottom: 20px;">
                        <p style="font-size: 16px; margin-bottom: 10px;">
                            æ­£åœ¨è·å–æ¨¡å‹åˆ—è¡¨...
                        </p>
                        <p style="font-size: 14px; margin-bottom: 6px;">
                            æ­¤è¿‡ç¨‹å–å†³äºæ‚¨çš„ç½‘é€Ÿå’Œå­˜å‚¨é…ç½®çš„æ•°é‡ã€‚è‹¥ç­‰å¾…æ—¶é—´è¿‡é•¿ï¼Œå»ºè®®æ›´æ¢ç½‘ç»œé‡è¯•ã€‚
                        </p>
                        <p style="font-size: 24px; font-weight: bold; color: var(--theme-primary);" id="loadingCountdown">
                            0s
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/marked@4.3.0/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- ğŸ”¥ ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨ - æ›¿ä»£æ‰€æœ‰æ•°æ®åº“ç›¸å…³æ¨¡å— -->
    <script>
/**
 * ğŸ”¥ ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨ - ç»ˆæç®€åŒ–ç‰ˆ
 * 
 * è®¾è®¡ç›®æ ‡ï¼š
 * 1. å•ä¸€è´£ä»»ï¼šæ‰€æœ‰æ•°æ®åº“æ“ä½œçš„å”¯ä¸€å…¥å£
 * 2. çŠ¶æ€åŒæ­¥ï¼šè‡ªåŠ¨å¤„ç†è·¨é¡µé¢çŠ¶æ€åŒæ­¥
 * 3. ç®€å•å¯é ï¼šå•ä¸€åˆå§‹åŒ–æ–¹æ³•ï¼Œè‡ªåŠ¨é”™è¯¯æ¢å¤
 * 4. åŠŸèƒ½å®Œæ•´ï¼šæ•´åˆæ‰€æœ‰ç°æœ‰æ•°æ®åº“åŠŸèƒ½
 * 5. å‘åå…¼å®¹ï¼šä¿æŒç°æœ‰APIæ¥å£ä¸å˜
 * 
 * âš ï¸ ARCHITECTURAL DEBT WARNING:
 * This file currently mixes database operations with UI concerns (DOM manipulation,
 * alerts, confirm dialogs, toast notifications). This violates separation of concerns
 * and harms maintainability and testability.
 * 
 * TODO - Future Refactoring Plan:
 * 1. Create DatabaseUIManager class for all UI interactions
 * 2. Keep UnifiedDBManager focused only on pure database operations
 * 3. Move StorageManager, DatabaseManager UI functions to separate UI layer
 * 4. Use event system or callbacks for UI notifications instead of direct coupling
 * 5. Make functions pure and testable by removing side effects
 */

class UnifiedDBManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.version = 14; // ç‰ˆæœ¬å‡çº§åˆ°14ï¼Œæ”¯æŒå›¾ç‰‡åˆ†ç±»åŠŸèƒ½
        this.db = null;
        this.isReady = false;
        this.initPromise = null;
        this.urlCache = new Map(); // æ–‡ä»¶URLç¼“å­˜
        
        // å®šä¹‰ä¸å‚ä¸æ‰‹åŠ¨å¯¼å…¥å¯¼å‡ºçš„å­˜å‚¨ï¼ˆå›¾ç‰‡ç­‰å¤§æ•°æ®ï¼‰ - ä¸åŸå§‹dataMigrator.jså®Œå…¨ä¸€è‡´
        this.excludedFromManualExport = ['emojiImages', 'fileStorage', 'imageUsageMetadata'];
        
        // æ–‡ä»¶ç±»å‹æ˜ å°„
        this.mimeTypes = {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg', 
            'png': 'image/png',
            'gif': 'image/gif',
            'webp': 'image/webp',
            'bmp': 'image/bmp',
            'svg': 'image/svg+xml'
        };

        // å›¾ç‰‡ä½¿ç”¨ç±»å‹æšä¸¾
        this.imageUsageTypes = {
            PERMANENT: 'permanent',     // æŒç»­ä½¿ç”¨çš„è¡¨æƒ…åŒ…
            TEMPORARY: 'temporary',     // ä¸´æ—¶æ€§å›¾ç‰‡ï¼ˆæœ‹å‹åœˆç­‰ï¼‰
            RECENT: 'recent',          // æœ€è¿‘ä½¿ç”¨
            ARCHIVE: 'archive'         // å½’æ¡£ï¼ˆä¸å¸¸ç”¨ï¼‰
        };

        // å®šä¹‰å®Œæ•´çš„æ•°æ®åº“æ¨¡å¼ - ä¸åŸå§‹dataMigrator.jså®Œå…¨ä¸€è‡´
        this.stores = {
            songs: { keyPath: 'id', autoIncrement: true },
            contacts: { keyPath: 'id' },
            apiSettings: { keyPath: 'id' },
            emojis: { keyPath: 'id' },
            emojiImages: { keyPath: 'tag' }, // å­˜å‚¨è¡¨æƒ…å›¾ç‰‡çš„base64æ•°æ®ï¼ˆå°†é€æ­¥è¿ç§»åˆ°fileStorageï¼‰
            backgrounds: { keyPath: 'id' },
            userProfile: { keyPath: 'id' },
            moments: { keyPath: 'id' },
            weiboPosts: { keyPath: 'id', autoIncrement: true },
            hashtagCache: { keyPath: 'id' },
            characterMemories: { keyPath: 'contactId' },
            conversationCounters: { keyPath: 'id' },
            globalMemory: { keyPath: 'id' },
            memoryProcessedIndex: { keyPath: 'contactId' },
            fileStorage: { keyPath: 'fileId' }, // æ–°å¢ï¼šå­˜å‚¨åŸå§‹æ–‡ä»¶Blobæ•°æ®
            fileReferences: { keyPath: 'referenceId' }, // æ–°å¢ï¼šå­˜å‚¨æ–‡ä»¶å¼•ç”¨å…³ç³»
            themeConfig: { keyPath: 'type' }, // æ–°å¢ï¼šå­˜å‚¨ä¸»é¢˜é…ç½®ï¼ˆé¢œè‰²ã€æ¸å˜ç­‰ï¼‰
            imageUsageMetadata: { keyPath: 'fileId' } // æ–°å¢ï¼šå›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®è¡¨
        };
        
        console.log('ğŸ”¥ [UnifiedDB] ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨å·²åˆ›å»º');
    }

    /**
     * åˆå§‹åŒ–æ•°æ®åº“ - å”¯ä¸€å…¥å£æ–¹æ³•
     */
    async init() {
        // å¦‚æœå·²ç»åˆå§‹åŒ–è¿‡ï¼Œç›´æ¥è¿”å›
        if (this.isReady && this.db) {
            console.log('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å·²åˆå§‹åŒ–ï¼Œç›´æ¥è¿”å›');
            this.syncToGlobal();
            return this.db;
        }

        // å¦‚æœæ­£åœ¨åˆå§‹åŒ–ï¼Œç­‰å¾…ç°æœ‰åˆå§‹åŒ–å®Œæˆ
        if (this.initPromise) {
            console.log('ğŸ”¥ [UnifiedDB] æ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œç­‰å¾…å®Œæˆ...');
            return await this.initPromise;
        }

        // å¼€å§‹æ–°çš„åˆå§‹åŒ–æµç¨‹
        console.log('ğŸ”¥ [UnifiedDB] å¼€å§‹æ•°æ®åº“åˆå§‹åŒ–...');
        this.initPromise = this._performInit();
        
        try {
            const result = await this.initPromise;
            this.initPromise = null;
            return result;
        } catch (error) {
            this.initPromise = null;
            throw error;
        }
    }

    /**
     * æ‰§è¡Œå®é™…çš„åˆå§‹åŒ–å·¥ä½œ
     */
    async _performInit() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => {
                const error = new Error(`æ•°æ®åº“æ‰“å¼€å¤±è´¥: ${request.error?.message}`);
                console.error('ğŸ”¥ [UnifiedDB]', error);
                reject(error);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                this.isReady = true;
                
                console.log(`ğŸ”¥ [UnifiedDB] åˆå§‹åŒ–æˆåŠŸï¼Œç‰ˆæœ¬: ${this.db.version}`);
                console.log(`ğŸ”¥ [UnifiedDB] å¯ç”¨å­˜å‚¨:`, Array.from(this.db.objectStoreNames));
                
                // åŒæ­¥åˆ°å…¨å±€çŠ¶æ€
                this.syncToGlobal();
                
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                console.log('ğŸ”¥ [UnifiedDB] æ•°æ®åº“éœ€è¦å‡çº§...');
                const db = event.target.result;
                this._createStores(db, event.oldVersion);
            };
        });
    }

    /**
     * åˆ›å»ºæ‰€æœ‰å¿…è¦çš„å¯¹è±¡å­˜å‚¨ - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsé€»è¾‘
     */
    _createStores(db, oldVersion) {
        console.log(`ğŸ”¥ [UnifiedDB] æ•°æ®åº“å‡çº§: ç‰ˆæœ¬${oldVersion} -> ç‰ˆæœ¬${this.version}`);
        
        try {
            // å¤„ç†åºŸå¼ƒå­˜å‚¨çš„åˆ é™¤ - ä¸åŸå§‹é€»è¾‘å®Œå…¨ä¸€è‡´
            if (this.version >= 12) {
                // ç‰ˆæœ¬12åŠä»¥ä¸Šç§»é™¤äº†bubbleDesignerStickers
                if (db.objectStoreNames.contains('bubbleDesignerStickers')) {
                    db.deleteObjectStore('bubbleDesignerStickers');
                    console.log('ğŸ”¥ [UnifiedDB] åˆ é™¤åºŸå¼ƒçš„ bubbleDesignerStickers å­˜å‚¨');
                }
            }
            
            // åˆ›å»ºæ‰€æœ‰å¯¹è±¡å­˜å‚¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            Object.entries(this.stores).forEach(([storeName, config]) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    try {
                        const store = db.createObjectStore(storeName, config);
                        console.log(`ğŸ”¥ [UnifiedDB] åˆ›å»º ${storeName} å­˜å‚¨æˆåŠŸ`);
                        
                        // ä¸ºç‰¹å®šå­˜å‚¨æ·»åŠ ç´¢å¼•
                        if (storeName === 'fileReferences') {
                            // ä¸ºæ–‡ä»¶å¼•ç”¨è¡¨æ·»åŠ categoryç´¢å¼•ï¼Œæ–¹ä¾¿æŒ‰ç±»å‹æŸ¥è¯¢
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('fileId', 'fileId', { unique: false });
                            console.log('ğŸ”¥ [UnifiedDB] ä¸º fileReferences æ·»åŠ ç´¢å¼•');
                        }
                        
                        if (storeName === 'imageUsageMetadata') {
                            // ä¸ºå›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®è¡¨æ·»åŠ ç®€åŒ–çš„ç´¢å¼•
                            store.createIndex('usageType', 'usageType', { unique: false });
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('createdAt', 'createdAt', { unique: false });
                            console.log('ğŸ”¥ [UnifiedDB] ä¸º imageUsageMetadata æ·»åŠ ç´¢å¼•');
                        }
                        
                    } catch (storeError) {
                        console.error(`ğŸ”¥ [UnifiedDB] åˆ›å»ºå­˜å‚¨ ${storeName} å¤±è´¥:`, storeError);
                        throw storeError;
                    }
                }
            });
            
            console.log('ğŸ”¥ [UnifiedDB] æ•°æ®åº“ç»“æ„å‡çº§å®Œæˆ');
            
        } catch (upgradeError) {
            console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å‡çº§è¿‡ç¨‹ä¸­å‡ºé”™:', upgradeError);
            throw upgradeError;
        }
    }

    /**
     * åŒæ­¥çŠ¶æ€åˆ°å…¨å±€å¯¹è±¡ - ç®€åŒ–çš„è·¨é¡µé¢é€šä¿¡
     */
    syncToGlobal() {
        if (typeof window !== 'undefined') {
            // è®¾ç½®å…¨å±€æ•°æ®åº“çŠ¶æ€
            window.db = this.db;
            window.isIndexedDBReady = this.isReady;
            // ç§»é™¤æ··ä¹±çš„å®ä¾‹èµ‹å€¼ - ç»Ÿä¸€ä½¿ç”¨ window.unifiedDB ä½œä¸ºå®ä¾‹å¼•ç”¨
            
            // ğŸ”¥ ç®€åŒ–çš„è·¨é¡µé¢é€šçŸ¥ï¼šåªä½¿ç”¨localStorageäº‹ä»¶
            try {
                // å†™å…¥çŠ¶æ€ä¿¡æ¯
                const dbStatus = {
                    isReady: true,
                    version: this.db.version,
                    timestamp: Date.now(),
                    page: window.location.pathname
                };
                localStorage.setItem('dbStatus', JSON.stringify(dbStatus));
                
                // è§¦å‘è·¨é¡µé¢äº‹ä»¶
                localStorage.setItem('dbSyncTrigger', Date.now().toString());
                localStorage.removeItem('dbSyncTrigger');
                
                console.log('ğŸ”¥ [UnifiedDB] å·²åŒæ­¥çŠ¶æ€åˆ°å…¨å±€å¹¶è§¦å‘è·¨é¡µé¢äº‹ä»¶');
            } catch (e) {
                console.warn('ğŸ”¥ [UnifiedDB] localStorage åŒæ­¥å¤±è´¥:', e);
            }
        }
    }

    /**
     * ç­‰å¾…æ•°æ®åº“å°±ç»ª
     */
    static async waitForReady(timeout = 8000) {
        console.log('ğŸ”¥ [UnifiedDB] å¼€å§‹ç­‰å¾…æ•°æ®åº“å°±ç»ª...');
        
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            let resolved = false;
            let timeoutId = null;

            // ç›‘å¬localStorageäº‹ä»¶
            const storageListener = (event) => {
                if (event.key === 'dbSyncTrigger' && !resolved) {
                    console.log('ğŸ”¥ [UnifiedDB] æ”¶åˆ°è·¨é¡µé¢åŒæ­¥äº‹ä»¶');
                    setTimeout(checkReady, 50);
                }
            };

            // æ¸…ç†å‡½æ•° - ç¡®ä¿åœ¨æ‰€æœ‰é€€å‡ºè·¯å¾„ä¸­éƒ½è°ƒç”¨
            const cleanup = () => {
                window.removeEventListener('storage', storageListener);
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
            };

            // æˆåŠŸè§£æå‡½æ•°
            const resolveWithCleanup = (result) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    resolve(result);
                }
            };

            // å¤±è´¥æ‹’ç»å‡½æ•°
            const rejectWithCleanup = (error) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    reject(error);
                }
            };

            const checkReady = () => {
                if (resolved) return;

                // æ£€æŸ¥å…¨å±€çŠ¶æ€
                if (window.isIndexedDBReady && window.db && window.db.version >= 14) {
                    console.log('ğŸ”¥ [UnifiedDB] æ£€æµ‹åˆ°æ•°æ®åº“å·²å°±ç»ª');
                    resolveWithCleanup(window.db);
                    return;
                }

                // æ£€æŸ¥localStorageçŠ¶æ€  
                try {
                    const dbStatus = JSON.parse(localStorage.getItem('dbStatus') || '{}');
                    if (dbStatus.isReady && dbStatus.version >= 14) {
                        console.log('ğŸ”¥ [UnifiedDB] ä»localStorageæ£€æµ‹åˆ°æ•°æ®åº“çŠ¶æ€ï¼Œå°è¯•å»ºç«‹è¿æ¥...');
                        
                        // å°è¯•ä¸ºå½“å‰é¡µé¢å»ºç«‹æ•°æ®åº“è¿æ¥
                        if (window.unifiedDB) {
                            window.unifiedDB.init().then(db => {
                                resolveWithCleanup(db);
                            }).catch(err => {
                                console.warn('ğŸ”¥ [UnifiedDB] è¿æ¥å»ºç«‹å¤±è´¥:', err);
                                rejectWithCleanup(err);
                            });
                        }
                        // ç§»é™¤äº†ä¸å¯è¾¾çš„ getInstance é€»è¾‘ - window.unifiedDB æ£€æŸ¥å·²ç»å¤„ç†äº†æ‰€æœ‰æƒ…å†µ
                    }
                } catch (e) {
                    console.warn('ğŸ”¥ [UnifiedDB] localStorageè¯»å–å¤±è´¥:', e);
                }

                // è¶…æ—¶æ£€æŸ¥
                if (Date.now() - startTime > timeout) {
                    rejectWithCleanup(new Error(`ç­‰å¾…æ•°æ®åº“å°±ç»ªè¶…æ—¶ (${timeout}ms)`));
                    return;
                }

                // ç»§ç»­æ£€æŸ¥
                setTimeout(checkReady, 100);
            };

            // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
            window.addEventListener('storage', storageListener);
            
            // è®¾ç½®è¶…æ—¶
            timeoutId = setTimeout(() => {
                rejectWithCleanup(new Error(`ç­‰å¾…æ•°æ®åº“å°±ç»ªè¶…æ—¶ (${timeout}ms)`));
            }, timeout);

            // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
            checkReady();
        });
    }

    /**
     * è·å–å…¨å±€å®ä¾‹ - æ­£ç¡®çš„å•ä¾‹æ¨¡å¼å®ç°
     */
    static getInstance() {
        if (!window.unifiedDB) {
            window.unifiedDB = new UnifiedDBManager();
        }
        return window.unifiedDB;
    }

    /**
     * æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å°±ç»ª
     */
    static isReady() {
        return window.isIndexedDBReady && window.db && window.db.version >= 14;
    }

    // ============================================
    // æ•°æ®åº“æ“ä½œæ–¹æ³• - ç»Ÿä¸€API
    // ============================================

    /**
     * é€šç”¨æ•°æ®åº“æ“ä½œå°è£…
     */
    async _dbOperation(storeName, mode, operation, description) {
        if (!this.db) {
            await this.init();
        }

        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], mode);
                const store = transaction.objectStore(storeName);

                transaction.onerror = (event) => {
                    console.error(`ğŸ”¥ [UnifiedDB] Transaction failed for ${description}:`, event.target.error);
                    reject(event.target.error);
                };

                const result = operation(store);

                if (mode === 'readwrite') {
                    // For write operations, the transaction's completion is the source of truth.
                    let operationResult;
                    const resultPromise = Promise.resolve(result);
                    
                    resultPromise.then(res => {
                        operationResult = res;
                    }).catch(reject); // Propagate errors from the inner promise.

                    transaction.oncomplete = () => {
                        resolve(operationResult);
                    };
                } else { // readonly
                    if (result && typeof result.then === 'function') {
                        result.then(resolve).catch(reject);
                    } else if (result && result.onsuccess !== undefined) {
                        result.onsuccess = () => resolve(result.result);
                        result.onerror = (event) => reject(event.target.error);
                    } else {
                        resolve(result);
                    }
                }
            } catch (error) {
                console.error(`ğŸ”¥ [UnifiedDB] ${description || 'æ•°æ®åº“æ“ä½œ'}å¤±è´¥:`, error);
                reject(error);
            }
        });
    }

    /**
     * è·å–æ•°æ®
     */
    async get(storeName, key) {
        return this._dbOperation(storeName, 'readonly', store => store.get(key), `è·å–æ•°æ® ${storeName}:${key}`);
    }

    /**
     * è·å–æ‰€æœ‰æ•°æ®
     */
    async getAll(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.getAll(), `è·å–æ‰€æœ‰æ•°æ® ${storeName}`);
    }

    /**
     * ä¿å­˜æ•°æ®
     */
    async put(storeName, data) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.put(data);
            // Return a promise that resolves when the put operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `ä¿å­˜æ•°æ®åˆ° ${storeName}`);
    }

    /**
     * åˆ é™¤æ•°æ®
     */
    async delete(storeName, key) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.delete(key);
            // Return a promise that resolves when the delete operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `åˆ é™¤æ•°æ® ${storeName}:${key}`);
    }

    /**
     * è®¡æ•°æ•°æ®
     */
    async count(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.count(), `è®¡æ•° ${storeName}`);
    }

    /**
     * å¯¼å‡ºæ•´ä¸ªæ•°æ®åº“ - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsæ ¼å¼
     */
    async exportDatabase(options = {}) {
        try {
            if (!this.db) {
                await this.init();
            }

            const { stores = null, includeMetadata = true } = options;
            const exportData = {};
            
            // æ·»åŠ å…ƒæ•°æ®
            if (includeMetadata) {
                exportData._metadata = await this.getDatabaseInfo();
            }

            // ç¡®å®šè¦å¯¼å‡ºçš„å­˜å‚¨
            const storesToExport = stores || Array.from(this.db.objectStoreNames);
            
            // å¯¼å‡ºæ¯ä¸ªå¯¹è±¡å­˜å‚¨çš„æ•°æ®
            for (const storeName of storesToExport) {
                if (this.db.objectStoreNames.contains(storeName)) {
                    exportData[storeName] = await this.exportStore(storeName);
                }
            }

            return exportData;
            
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å¯¼å‡ºå¤±è´¥:', error);
            throw new Error(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¯¼å‡ºå•ä¸ªå¯¹è±¡å­˜å‚¨
     */
    async exportStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                let result = request.result;
                
                // ä¸ºä¿æŠ¤ç”¨æˆ·éšç§ï¼Œåœ¨å¯¼å‡ºæ—¶ç§»é™¤APIå¯†é’¥
                if (storeName === 'apiSettings') {
                    result = result.map(item => {
                        const sanitized = { ...item };
                        // æ¸…ç†æ•æ„Ÿä¿¡æ¯
                        if (sanitized.apiKey) delete sanitized.apiKey;
                        if (sanitized.password) delete sanitized.password;
                        return sanitized;
                    });
                }
                
                resolve(result);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * è·å–æ•°æ®åº“ç‰ˆæœ¬ä¿¡æ¯
     */
    async getDatabaseInfo() {
        if (!this.db) {
            await this.init();
        }
        
        return {
            name: this.db.name,
            version: this.db.version,  // è¿™é‡Œä½¿ç”¨å®é™…æ•°æ®åº“ç‰ˆæœ¬ï¼Œä¸æ˜¯ç›®æ ‡ç‰ˆæœ¬
            stores: Array.from(this.db.objectStoreNames),
            exportTime: new Date().toISOString()
        };
    }

    /**
     * å¯¼å…¥æ•°æ®åº“æ•°æ® - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsé€»è¾‘
     */
    async importDatabase(importData, options = {}) {
        try {
            const { 
                overwrite = false, 
                validateVersion = true,
                stores = null,
                enableMigration = true
            } = options;

            if (!this.db) {
                await this.init();
            }

            // éªŒè¯æ•°æ®æ ¼å¼
            if (!importData || typeof importData !== 'object') {
                throw new Error('å¯¼å…¥æ•°æ®æ ¼å¼æ— æ•ˆ');
            }

            // ç‰ˆæœ¬æ£€æŸ¥å’Œè¿ç§»å¤„ç†
            let migratedData = importData;
            if (importData._metadata && importData._metadata.version !== this.version) {
                if (enableMigration && importData._metadata.version < this.version) {
                    console.log(`ğŸ”¥ [UnifiedDB] æ£€æµ‹åˆ°ç‰ˆæœ¬ ${importData._metadata.version}ï¼Œå¼€å§‹è¿ç§»åˆ°ç‰ˆæœ¬ ${this.version}`);
                    migratedData = await this.migrateData(importData);
                } else if (validateVersion) {
                    throw new Error(`æ•°æ®åº“ç‰ˆæœ¬ä¸åŒ¹é…ã€‚å½“å‰ç‰ˆæœ¬: ${this.version}, å¯¼å…¥ç‰ˆæœ¬: ${importData._metadata.version}`);
                }
            }

            // ç¡®å®šè¦å¯¼å…¥çš„å­˜å‚¨
            const storesToImport = stores || Object.keys(migratedData).filter(key => key !== '_metadata');
            
            // æ¸…ç©ºç°æœ‰æ•°æ®ï¼ˆå¦‚æœé€‰æ‹©è¦†ç›–ï¼‰
            if (overwrite) {
                for (const storeName of storesToImport) {
                    if (this.db.objectStoreNames.contains(storeName)) {
                        await this.clearStore(storeName);
                    }
                }
            }

            // å¯¼å…¥æ•°æ®
            const importResults = {};
            for (const storeName of storesToImport) {
                if (this.db.objectStoreNames.contains(storeName) && migratedData[storeName]) {
                    const result = await this.importStore(storeName, migratedData[storeName], overwrite);
                    importResults[storeName] = result;
                }
            }

            return { success: true, importedStores: storesToImport, results: importResults, migrated: migratedData !== importData };
            
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“å¯¼å…¥å¤±è´¥:', error);
            throw new Error(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¯¼å…¥å•ä¸ªå­˜å‚¨çš„æ•°æ®
     */
    async importStore(storeName, data, overwrite = false) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            let addedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;

            // æ‰¹é‡å¯¼å…¥æ•°æ®
            data.forEach(item => {
                const request = overwrite ? store.put(item) : store.add(item);
                
                request.onsuccess = () => {
                    addedCount++;
                };
                
                request.onerror = () => {
                    if (request.error.name === 'ConstraintError') {
                        skippedCount++;
                    } else {
                        errorCount++;
                    }
                };
            });

            transaction.oncomplete = () => {
                resolve({
                    total: data.length,
                    added: addedCount,
                    skipped: skippedCount,
                    errors: errorCount
                });
            };

            transaction.onerror = () => reject(transaction.error);
        });
    }

    /**
     * æ¸…ç©ºæŒ‡å®šå­˜å‚¨çš„æ‰€æœ‰æ•°æ®
     */
    async clearStore(storeName) {
        if (!this.db) {
            await this.init();
        }
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                
                const store = transaction.objectStore(storeName);
                store.clear();
            } catch (error) {
                console.error(`ğŸ”¥ [UnifiedDB] æ¸…ç©ºå­˜å‚¨ ${storeName} å¤±è´¥:`, error);
                reject(error);
            }
        });
    }

    /**
     * æ•°æ®è¿ç§»å‡½æ•° - å®Œå…¨éµå¾ªåŸå§‹dataMigrator.jsé€»è¾‘
     */
    async migrateData(importData) {
        const { _metadata } = importData;
        const fromVersion = _metadata ? _metadata.version : 1;
        const toVersion = this.version;
        
        console.log(`ğŸ”¥ [UnifiedDB] å¼€å§‹æ•°æ®è¿ç§»ï¼šä»ç‰ˆæœ¬ ${fromVersion} åˆ°ç‰ˆæœ¬ ${toVersion}`);
        
        // åˆ›å»ºè¿ç§»åçš„æ•°æ®å‰¯æœ¬
        const migratedData = JSON.parse(JSON.stringify(importData));
        
        // æ›´æ–°å…ƒæ•°æ®ç‰ˆæœ¬
        migratedData._metadata.version = toVersion;
        migratedData._metadata.migrationTime = new Date().toISOString();
        migratedData._metadata.originalVersion = fromVersion;
        
        // æ ¹æ®ç‰ˆæœ¬å·®å¼‚è¿›è¡Œè¿ç§»
        if (fromVersion <= 4 && toVersion >= 5) {
            // ç‰ˆæœ¬4åˆ°5çš„è¿ç§»ï¼šæ·»åŠ ç¼ºå¤±çš„å­˜å‚¨
            this.migrateFrom4To5(migratedData);
        }
        
        if (fromVersion <= 5 && toVersion >= 6) {
            // ç‰ˆæœ¬5åˆ°6çš„è¿ç§»ï¼ˆå¦‚æœæœ‰éœ€è¦çš„è¯ï¼‰
            this.migrateFrom5To6(migratedData);
        }
        
        if (fromVersion <= 6 && toVersion >= 7) {
            // ç‰ˆæœ¬6åˆ°7çš„è¿ç§»ï¼ˆå¦‚æœæœ‰éœ€è¦çš„è¯ï¼‰
            this.migrateFrom6To7(migratedData);
        }
        
        if (fromVersion <= 7 && toVersion >= 8) {
            // ç‰ˆæœ¬7åˆ°8çš„è¿ç§»ï¼šæ·»åŠ æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
            this.migrateFrom7To8(migratedData);
        }
        
        if (fromVersion <= 8 && toVersion >= 9) {
            // ç‰ˆæœ¬8åˆ°9çš„è¿ç§»ï¼šå®Œå–„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
            this.migrateFrom8To9(migratedData);
        }
        
        if (fromVersion <= 9 && toVersion >= 10) {
            // ç‰ˆæœ¬9åˆ°10çš„è¿ç§»ï¼šæ·»åŠ ä¸»é¢˜é…ç½®ç³»ç»Ÿ
            this.migrateFrom9To10(migratedData);
        }
        
        if (fromVersion <= 10 && toVersion >= 11) {
            // ç‰ˆæœ¬10åˆ°11çš„è¿ç§»ï¼šæ·»åŠ æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“
            this.migrateFrom10To11(migratedData);
        }
        
        if (fromVersion <= 11 && toVersion >= 12) {
            // ç‰ˆæœ¬11åˆ°12çš„è¿ç§»ï¼šç§»é™¤æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“
            this.migrateFrom11To12(migratedData);
        }
        
        if (fromVersion <= 12 && toVersion >= 13) {
            // ç‰ˆæœ¬12åˆ°13çš„è¿ç§»ï¼šä¼˜åŒ–æ•°æ®ç»“æ„
            this.migrateFrom12To13(migratedData);
        }
        
        if (fromVersion <= 13 && toVersion >= 14) {
            // ç‰ˆæœ¬13åˆ°14çš„è¿ç§»ï¼šæ·»åŠ å›¾ç‰‡åˆ†ç±»åŠŸèƒ½
            await this.migrateFrom13To14(migratedData);
        }
        
        console.log(`ğŸ”¥ [UnifiedDB] æ•°æ®è¿ç§»å®Œæˆï¼šç‰ˆæœ¬ ${fromVersion} -> ${toVersion}`);
        return migratedData;
    }

    // è¿ç§»æ–¹æ³•å ä½ç¬¦ - éœ€è¦æ—¶å¯ä»¥å®ç°å…·ä½“é€»è¾‘
    migrateFrom4To5(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 4->5 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ ç¼ºå¤±çš„å­˜å‚¨åˆå§‹åŒ–
        if (!data.characterMemories) data.characterMemories = [];
        if (!data.globalMemory) data.globalMemory = [];
    }

    migrateFrom5To6(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 5->6 ç‰ˆæœ¬è¿ç§»');
        // å¯ä»¥æ·»åŠ å…·ä½“è¿ç§»é€»è¾‘
    }

    migrateFrom6To7(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 6->7 ç‰ˆæœ¬è¿ç§»');
        // å¯ä»¥æ·»åŠ å…·ä½“è¿ç§»é€»è¾‘
    }

    migrateFrom7To8(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 7->8 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
        if (!data.fileStorage) data.fileStorage = [];
        if (!data.fileReferences) data.fileReferences = [];
    }

    migrateFrom8To9(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 8->9 ç‰ˆæœ¬è¿ç§»');
        // å®Œå–„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
    }

    migrateFrom9To10(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 9->10 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ ä¸»é¢˜é…ç½®ç³»ç»Ÿ
        if (!data.themeConfig) data.themeConfig = [];
    }

    migrateFrom10To11(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 10->11 ç‰ˆæœ¬è¿ç§»');
        // æ·»åŠ æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“ï¼ˆå·²åœ¨v12ä¸­ç§»é™¤ï¼‰
    }

    migrateFrom11To12(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 11->12 ç‰ˆæœ¬è¿ç§»');
        // ç§»é™¤æ°”æ³¡è®¾è®¡å™¨è´´å›¾åº“
        if (data.bubbleDesignerStickers) {
            delete data.bubbleDesignerStickers;
        }
    }

    migrateFrom12To13(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 12->13 ç‰ˆæœ¬è¿ç§»');
        // ä¼˜åŒ–æ•°æ®ç»“æ„
    }

    /**
     * ç‰ˆæœ¬13åˆ°14çš„è¿ç§»ï¼šæ·»åŠ å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®è¡¨
     * @param {Object} data - æ•°æ®
     */
    async migrateFrom13To14(data) {
        console.log('ğŸ”¥ [UnifiedDB] æ‰§è¡Œ 13->14 ç‰ˆæœ¬è¿ç§»ï¼šæ·»åŠ å›¾ç‰‡åˆ†ç±»åŠŸèƒ½');
        // imageUsageMetadata è¡¨ä¼šåœ¨ _createStores ä¸­è‡ªåŠ¨åˆ›å»º
        
        try {
            // ä¸ºç°æœ‰çš„è¡¨æƒ…åŒ…åˆ›å»ºç®€åŒ–çš„ metadataï¼ˆä¸åŒºåˆ† temp/permanentï¼‰
            if (data.emojis && Array.isArray(data.emojis)) {
                console.log('ğŸ”¥ [UnifiedDB] ä¸ºç°æœ‰è¡¨æƒ…åŒ…åˆ›å»ºå›¾åº“å…ƒæ•°æ®');
                for (const emoji of data.emojis) {
                    if (emoji.id && emoji.tag) {
                        // æŸ¥æ‰¾å¯¹åº”çš„æ–‡ä»¶è®°å½•
                        const fileReferences = data.fileReferences || [];
                        const emojiFile = fileReferences.find(ref => 
                            ref.referenceType === 'emoji' && ref.referenceKey === emoji.tag
                        );
                        
                        if (emojiFile && emojiFile.fileId) {
                            await this.setImageUsageMetadata(emojiFile.fileId, 'general', {
                                category: 'emoji',
                                tags: [emoji.tag],
                                createdAt: emoji.createdAt || new Date().toISOString(),
                                fileName: emoji.tag
                            });
                        }
                    }
                }
            }
            
            // ä¸ºç°æœ‰çš„æœ‹å‹åœˆå›¾ç‰‡åˆ›å»ºç®€åŒ–çš„ metadata
            if (data.moments && Array.isArray(data.moments)) {
                console.log('ğŸ”¥ [UnifiedDB] ä¸ºç°æœ‰æœ‹å‹åœˆå›¾ç‰‡åˆ›å»ºå›¾åº“å…ƒæ•°æ®');
                for (const moment of data.moments) {
                    if (moment.imageFileIds && Array.isArray(moment.imageFileIds)) {
                        for (let i = 0; i < moment.imageFileIds.length; i++) {
                            const fileId = moment.imageFileIds[i];
                            await this.setImageUsageMetadata(fileId, 'general', {
                                category: 'moments',
                                tags: ['æœ‹å‹åœˆ', moment.authorName || 'æœªçŸ¥'],
                                createdAt: moment.timestamp || new Date().toISOString(),
                                fileName: `moment_${moment.id}_${i + 1}.jpg`
                            });
                        }
                    }
                }
            }
            
            console.log('ğŸ”¥ [UnifiedDB] å†å²å›¾ç‰‡å…ƒæ•°æ®è¿ç§»å®Œæˆ');
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] è¿ç§»å†å²å›¾ç‰‡å…ƒæ•°æ®å¤±è´¥:', error);
            // è¿ç§»å¤±è´¥ä¸å½±å“æ•´ä½“å‡çº§
        }
    }

    // ============================================
    // æ–‡ä»¶å­˜å‚¨åŠŸèƒ½
    // ============================================

    /**
     * ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶ID
     */
    generateFileId() {
        return 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * ä»base64å­—ç¬¦ä¸²ä¸­æå–MIMEç±»å‹
     */
    getMimeTypeFromBase64(base64String) {
        const match = base64String.match(/^data:([^;]+);base64,/);
        return match ? match[1] : 'image/jpeg';
    }

    /**
     * å°†base64å­—ç¬¦ä¸²è½¬æ¢ä¸ºBlob
     */
    base64ToBlob(base64String) {
        try {
            const mimeType = this.getMimeTypeFromBase64(base64String);
            const base64Data = base64String.split(',')[1];
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('ğŸ”¥ [UnifiedDB] base64è½¬æ¢Blobå¤±è´¥:', error);
            return null;
        }
    }

    /**
     * å­˜å‚¨æ–‡ä»¶åˆ°æ•°æ®åº“
     */
    async storeFile(fileData, metadata = {}) {
        let blob;
        
        if (typeof fileData === 'string' && fileData.startsWith('data:')) {
            // base64å­—ç¬¦ä¸²
            blob = this.base64ToBlob(fileData);
            if (!blob) {
                throw new Error('æ— æ³•è½¬æ¢base64æ•°æ®');
            }
        } else if (fileData instanceof File || fileData instanceof Blob) {
            // Fileæˆ–Blobå¯¹è±¡
            blob = fileData;
        } else {
            throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ•°æ®ç±»å‹: ${typeof fileData}`);
        }

        const fileId = this.generateFileId();
        const fileRecord = {
            fileId: fileId,
            blob: blob,
            type: blob.type,
            size: blob.size,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileStorage', fileRecord);
        
        console.log('ğŸ”¥ [UnifiedDB] æ–‡ä»¶å­˜å‚¨æˆåŠŸï¼ŒID:', fileId);
        return {
            fileId: fileId,
            type: blob.type,
            size: blob.size
        };
    }

    /**
     * è·å–æ–‡ä»¶
     */
    async getFile(fileId) {
        const result = await this.get('fileStorage', fileId);
        if (!result) {
            throw new Error(`æ–‡ä»¶ä¸å­˜åœ¨: ${fileId}`);
        }
        return result;
    }

    /**
     * åˆ›å»ºæ–‡ä»¶çš„ä¸´æ—¶URL
     */
    async createFileURL(fileId) {
        try {
            // æ£€æŸ¥ç¼“å­˜
            if (this.urlCache.has(fileId)) {
                return this.urlCache.get(fileId);
            }

            const fileRecord = await this.getFile(fileId);
            
            // æ›´å®½æ¾çš„blobæ£€æŸ¥ - å…¼å®¹IndexedDBåºåˆ—åŒ–çš„blob
            if (!fileRecord.blob) {
                throw new Error(`æ–‡ä»¶è®°å½•ä¸­ç¼ºå°‘blobæ•°æ®: ${fileId}`);
            }
            
            let blob = fileRecord.blob;
            
            // å¦‚æœä¸æ˜¯æ ‡å‡†Blobå®ä¾‹ï¼Œå°è¯•é‡æ–°æ„é€ 
            if (!(blob instanceof Blob)) {
                try {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç±»ä¼¼Blobçš„å¯¹è±¡
                    if (blob.size !== undefined && blob.type !== undefined) {
                        // å¦‚æœæœ‰sizeå’Œtypeå±æ€§ï¼Œå¯èƒ½æ˜¯åºåˆ—åŒ–çš„Blobï¼Œå°è¯•é‡æ–°æ„é€ 
                        console.log(`ğŸ”¥ [UnifiedDB] æ£€æµ‹åˆ°éæ ‡å‡†Blobå¯¹è±¡ï¼Œå°è¯•é‡æ–°æ„é€ : ${fileId}`);
                        
                        // å¦‚æœblobæœ‰streamæ–¹æ³•ï¼Œè¯´æ˜å®ƒä»ç„¶æ˜¯æœ‰æ•ˆçš„Blob-likeå¯¹è±¡
                        if (typeof blob.stream === 'function' || typeof blob.arrayBuffer === 'function') {
                            // ç›´æ¥ä½¿ç”¨ï¼Œå¯èƒ½æ˜¯æµè§ˆå™¨å†…éƒ¨çš„Blobè¡¨ç¤º
                            console.log(`ğŸ”¥ [UnifiedDB] ä½¿ç”¨ç±»Blobå¯¹è±¡åˆ›å»ºURL: ${fileId}`);
                        } else {
                            throw new Error('Blobå¯¹è±¡ç¼ºå°‘å¿…è¦çš„æ–¹æ³•');
                        }
                    } else {
                        throw new Error('æ— æ•ˆçš„blobæ•°æ®ç»“æ„');
                    }
                } catch (reconstructError) {
                    throw new Error(`æ— æ³•å¤„ç†blobæ•°æ®: ${reconstructError.message}`);
                }
            }
            
            const url = URL.createObjectURL(blob);
            
            // ç¼“å­˜URL
            this.urlCache.set(fileId, url);
            
            return url;
        } catch (error) {
            console.error(`ğŸ”¥ [UnifiedDB] åˆ›å»ºæ–‡ä»¶URLå¤±è´¥ (${fileId}):`, error);
            return '';
        }
    }

    /**
     * æ¸…ç†æ–‡ä»¶URLç¼“å­˜
     */
    revokeFileURL(fileId) {
        if (this.urlCache.has(fileId)) {
            const url = this.urlCache.get(fileId);
            URL.revokeObjectURL(url);
            this.urlCache.delete(fileId);
        }
    }

    // === å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®ç®¡ç†æ–¹æ³• ===

    /**
     * åˆ›å»ºæˆ–æ›´æ–°å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®
     * @param {string} fileId - æ–‡ä»¶ID
     * @param {string} usageType - ä½¿ç”¨ç±»å‹ (permanent/temporary/recent/archive)
     * @param {Object} metadata - é¢å¤–å…ƒæ•°æ®
     */
    async setImageUsageMetadata(fileId, usageType, metadata = {}) {
        const usageData = {
            fileId: fileId,
            usageType: usageType,
            createdAt: metadata.createdAt || new Date().toISOString(),
            category: metadata.category || 'general', // emoji, moment, chat, avatar, background
            tags: metadata.tags || [],
            size: metadata.size || 0,
            fileName: metadata.fileName || null
        };

        await this.put('imageUsageMetadata', usageData);
        console.log(`ğŸ”¥ [UnifiedDB] è®¾ç½®å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®: ${fileId} -> ${usageType}`);
        return usageData;
    }


    /**
     * è·å–å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ®
     * @param {string} fileId - æ–‡ä»¶ID
     */
    async getImageUsageMetadata(fileId) {
        return await this.get('imageUsageMetadata', fileId);
    }

    /**
     * æ ¹æ®ä½¿ç”¨ç±»å‹æŸ¥è¯¢å›¾ç‰‡
     * @param {string} usageType - ä½¿ç”¨ç±»å‹
     * @param {number} limit - é™åˆ¶æ•°é‡
     */
    async getImagesByUsageType(usageType, limit = 100) {
        return await this._dbOperation('imageUsageMetadata', 'readonly', (store) => {
            const index = store.index('usageType');
            const request = index.getAll(usageType);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const results = request.result.slice(0, limit);
                    resolve(results);
                };
                request.onerror = () => reject(request.error);
            });
        }, `æŸ¥è¯¢${usageType}ç±»å‹å›¾ç‰‡`);
    }

    /**
     * æ¸…ç†è¿‡æœŸçš„ä¸´æ—¶å›¾ç‰‡
     * @param {string[]} fileIds - è¦åˆ é™¤çš„æ–‡ä»¶IDæ•°ç»„
     */
    async cleanupSelectedImages(fileIds) {
        if (!Array.isArray(fileIds) || fileIds.length === 0) {
            return { deletedCount: 0, errors: [] };
        }

        try {
            let deletedCount = 0;
            const errors = [];

            for (const fileId of fileIds) {
                try {
                    // åˆ é™¤æ–‡ä»¶
                    await this.deleteFile(fileId);
                    // åˆ é™¤å…ƒæ•°æ®
                    await this.delete('imageUsageMetadata', fileId);
                    // åˆ é™¤ç›¸å…³å¼•ç”¨
                    await this.cleanupFileReferences(fileId);
                    deletedCount++;
                    console.log(`ğŸ”¥ [UnifiedDB] å·²åˆ é™¤å›¾ç‰‡: ${fileId}`);
                } catch (error) {
                    console.warn(`åˆ é™¤å›¾ç‰‡å¤±è´¥: ${fileId}`, error);
                    errors.push({ fileId, error: error.message });
                }
            }

            console.log(`ğŸ”¥ [UnifiedDB] æ‰‹åŠ¨æ¸…ç†å›¾ç‰‡å®Œæˆ: ${deletedCount}/${fileIds.length}`);
            return { deletedCount, totalRequested: fileIds.length, errors };
        } catch (error) {
            console.error('æ‰¹é‡åˆ é™¤å›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ¸…ç†æŒ‡å®šæ–‡ä»¶çš„æ‰€æœ‰å¼•ç”¨
     * @param {string} fileId - æ–‡ä»¶ID
     */
    async cleanupFileReferences(fileId) {
        return await this._dbOperation('fileReferences', 'readwrite', (store) => {
            return new Promise((resolve, reject) => {
                try {
                    const index = store.index('fileId');
                    const request = index.openCursor(IDBKeyRange.only(fileId));
                    let deletedCount = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            deletedCount++;
                            cursor.continue();
                        } else {
                            // æ‰€æœ‰åŒ¹é…çš„è®°å½•éƒ½å·²å¤„ç†å®Œæˆ
                            console.log(`ğŸ”¥ [UnifiedDB] æ¸…ç†æ–‡ä»¶å¼•ç”¨: ${fileId} (${deletedCount}ä¸ªå¼•ç”¨)`);
                            resolve(deletedCount);
                        }
                    };

                    request.onerror = (event) => {
                        console.warn('æ¸…ç†æ–‡ä»¶å¼•ç”¨å¤±è´¥:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.warn('æ¸…ç†æ–‡ä»¶å¼•ç”¨å¤±è´¥:', error);
                    reject(error);
                }
            });
        }, `æ¸…ç†æ–‡ä»¶å¼•ç”¨: ${fileId}`);
    }

    /**
     * è·å–å›¾ç‰‡ä½¿ç”¨ç»Ÿè®¡
     */
    async getImageUsageStats() {
        try {
            const allMetadata = await this.getAll('imageUsageMetadata');
            const stats = {
                total: allMetadata.length,
                byType: {},
                byCategory: {},
                totalSize: 0
            };

            allMetadata.forEach(meta => {
                // æŒ‰ç±»å‹ç»Ÿè®¡
                stats.byType[meta.usageType] = (stats.byType[meta.usageType] || 0) + 1;
                
                // æŒ‰åˆ†ç±»ç»Ÿè®¡
                stats.byCategory[meta.category] = (stats.byCategory[meta.category] || 0) + 1;
                
                // æ€»å¤§å°
                stats.totalSize += meta.size || 0;
            });

            return stats;
        } catch (error) {
            console.error('è·å–å›¾ç‰‡ä½¿ç”¨ç»Ÿè®¡å¤±è´¥:', error);
            return null;
        }
    }

    /**
     * åˆ é™¤æ–‡ä»¶
     */
    async deleteFile(fileId) {
        await this.delete('fileStorage', fileId);
        this.revokeFileURL(fileId);
        console.log(`ğŸ”¥ [UnifiedDB] æ–‡ä»¶åˆ é™¤æˆåŠŸ: ${fileId}`);
    }

    /**
     * åˆ›å»ºæ–‡ä»¶å¼•ç”¨å…³ç³»
     */
    async createFileReference(fileId, referenceType, referenceKey, metadata = {}) {
        const referenceId = `${referenceType}_${referenceKey}`;
        const reference = {
            referenceId: referenceId,
            fileId: fileId,
            category: referenceType,
            referenceKey: referenceKey,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileReferences', reference);
        console.log('ğŸ”¥ [UnifiedDB] æ–‡ä»¶å¼•ç”¨å­˜å‚¨æˆåŠŸ:', reference);
        return reference;
    }

    /**
     * è·å–æ–‡ä»¶å¼•ç”¨
     */
    async getFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        return await this.get('fileReferences', referenceId);
    }

    /**
     * åˆ é™¤æ–‡ä»¶å¼•ç”¨
     */
    async deleteFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        await this.delete('fileReferences', referenceId);
        console.log(`ğŸ”¥ [UnifiedDB] æ–‡ä»¶å¼•ç”¨åˆ é™¤æˆåŠŸ: ${referenceId}`);
    }

    // ============================================
    // å‘åå…¼å®¹çš„è¾…åŠ©æ–¹æ³•å’Œé”™è¯¯å¤„ç†
    // ============================================

    /**
     * å…¼å®¹æ—§çš„promisifyRequestæ–¹æ³•
     */
    promisifyRequest(request, description = '') {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => {
                console.error(`ğŸ”¥ [UnifiedDB] ${description}å¤±è´¥:`, request.error);
                reject(request.error);
            };
        });
    }

    /**
     * å…¼å®¹æ—§çš„ensureDBReadyæ–¹æ³•
     */
    async ensureDBReady(operation, description = '') {
        if (!this.isReady) {
            await this.init();
        }
        
        try {
            return await operation();
        } catch (error) {
            console.error(`ğŸ”¥ [UnifiedDB] ${description}å¤±è´¥:`, error);
            throw error;
        }
    }

    /**
     * é‡è¯•æœºåˆ¶ - å‘åå…¼å®¹
     */
    async retryWithBackoff(operation, context, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                lastError = error;
                console.warn(`ğŸ”¥ [UnifiedDB] ${context} - å°è¯• ${attempt}/${maxRetries} å¤±è´¥:`, error);
                
                if (attempt < maxRetries) {
                    // æŒ‡æ•°é€€é¿å»¶è¿Ÿ
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.error(`ğŸ”¥ [UnifiedDB] ${context} - æ‰€æœ‰é‡è¯•å¤±è´¥`);
                    throw lastError;
                }
            }
        }
        
        throw lastError;
    }
}

// ============================================
// å…¨å±€å¯¼å‡ºå’Œå…¼å®¹æ€§è®¾ç½® - ç«‹å³æ‰§è¡Œ
// ============================================

/**
 * æ˜¾ç¤ºæ•°æ®åº“é”™è¯¯å¯¹è¯æ¡† - å‘åå…¼å®¹
 */
function showDatabaseErrorDialog(error, isRetrying = false) {
    const title = isRetrying ? 'æ•°æ®åº“é‡è¯•ä¸­...' : 'æ•°æ®åº“è¿æ¥å¤±è´¥';
    const message = isRetrying 
        ? `æ•°æ®åº“è¿æ¥å¼‚å¸¸ï¼Œæ­£åœ¨è‡ªåŠ¨é‡è¯•...\n\né”™è¯¯ä¿¡æ¯: ${error.message}`
        : `æ•°æ®åº“è¿æ¥å¤±è´¥ã€‚\n\né”™è¯¯ä¿¡æ¯: ${error.message}\n\nå»ºè®®:\n1. åˆ·æ–°é¡µé¢é‡è¯•\n2. æ¸…é™¤æµè§ˆå™¨ç¼“å­˜\n3. æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒIndexedDB`;
    
    console.error('ğŸ”¥ [UnifiedDB] æ•°æ®åº“é”™è¯¯:', error);
    
    // Event-driven error dialog - replace direct alert() with custom event
    window.dispatchEvent(new CustomEvent('database:errorDialog', {
        detail: {
            title: title,
            message: message,
            error: error,
            isRetrying: isRetrying,
            suggestions: isRetrying ? [] : [
                'åˆ·æ–°é¡µé¢é‡è¯•',
                'æ¸…é™¤æµè§ˆå™¨ç¼“å­˜', 
                'æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒIndexedDB'
            ]
        }
    }));
}

/**
 * é‡è¯•æ‰§è¡Œå‡½æ•° - å‘åå…¼å®¹
 */
async function executeWithRetry(operation, context = 'æ•°æ®åº“æ“ä½œ') {
    if (window.unifiedDB && typeof window.unifiedDB.retryWithBackoff === 'function') {
        return await window.unifiedDB.retryWithBackoff(operation, context);
    }
    
    // ç®€å•é‡è¯•é€»è¾‘ä½œä¸ºåå¤‡
    try {
        return await operation();
    } catch (error) {
        console.error(`ğŸ”¥ [UnifiedDB] ${context} å¤±è´¥:`, error);
        throw error;
    }
}

// ğŸ”¥ ç«‹å³å¯¼å‡ºè¿™äº›å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œç¡®ä¿å…¶ä»–è„šæœ¬å¯ä»¥ä½¿ç”¨
if (typeof window !== 'undefined') {
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
}

// è·å–å…¨å±€å•ä¾‹å®ä¾‹
const unifiedDB = UnifiedDBManager.getInstance();

// åˆ›å»ºå‘½åç©ºé—´ä»¥å‡å°‘å…¨å±€æ±¡æŸ“
const AppDB = {
    // æ ¸å¿ƒç®¡ç†å™¨
    UnifiedDBManager: UnifiedDBManager,
    unifiedDB: unifiedDB,
    
    // å·¥å…·å‡½æ•°
    executeWithRetry: executeWithRetry,
    showDatabaseErrorDialog: showDatabaseErrorDialog,
    promisifyRequest: (request, description) => unifiedDB.promisifyRequest(request, description),
    ensureDBReady: (operation, description) => unifiedDB.ensureDBReady(operation, description),
    initUnifiedDB: () => unifiedDB.init(),
    
    // ç®¡ç†å™¨å¯¹è±¡ï¼ˆå°†åœ¨ä¸‹é¢å®šä¹‰ï¼‰
    StorageManager: null,
    DatabaseManager: null,
    
    // å¯¼å…¥å¯¼å‡ºå‡½æ•°ï¼ˆå°†åœ¨ä¸‹é¢å®šä¹‰ï¼‰
    exportDatabase: null,
    exportFileStorage: null,
    importDatabase: null,
    performImport: null,
    
    // æ–‡ä»¶å¤„ç†å‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼‰
    performFileStorageImport: null,
    importPrompts: null,
    
    // UIå‡½æ•°ç°åœ¨ç”±UIManagerå¤„ç†
    // handleFileSelect, handleFileStorageImport, confirmFileExport, cancelFileExport, refreshDatabaseStats
    // triggerFileSelect, triggerFileStorageImport
    
    // æ–‡ä»¶å­˜å‚¨ç®¡ç†å™¨åˆ«å
    FileStorageManager: unifiedDB
};

// å¯¼å‡ºåˆ°windowå¯¹è±¡
if (typeof window !== 'undefined') {
    window.AppDB = AppDB;
    
    // å‘åå…¼å®¹ï¼šä¿ç•™å…³é”®çš„ç›´æ¥windowå¯¼å‡º
    window.UnifiedDBManager = UnifiedDBManager;
    window.unifiedDB = unifiedDB;
    window.promisifyRequest = AppDB.promisifyRequest;
    window.ensureDBReady = AppDB.ensureDBReady;
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
    window.initUnifiedDB = AppDB.initUnifiedDB;
    
    // ğŸ”¥ å®Œæ•´çš„ StorageManager å¯¹è±¡
    AppDB.StorageManager = {
        /**
         * ç”³è¯·æŒä¹…åŒ–å­˜å‚¨ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼Œä¸æ¶‰åŠUIï¼‰
         */
        async requestPersistentStorage() {
            try {
                console.log('[StorageManager] ç”³è¯·æŒä¹…åŒ–å­˜å‚¨...');
                
                if (!navigator.storage || !navigator.storage.persist) {
                    const result = { success: false, error: 'æµè§ˆå™¨ä¸æ”¯æŒæŒä¹…åŒ–å­˜å‚¨åŠŸèƒ½' };
                    window.dispatchEvent(new CustomEvent('storage:persistentUnsupported', { detail: result }));
                    return result;
                }

                // ç”³è¯·æŒä¹…åŒ–å­˜å‚¨
                const granted = await navigator.storage.persist();
                const estimate = await navigator.storage.estimate();
                
                const result = {
                    success: true,
                    granted: granted,
                    estimate: estimate,
                    message: granted ? 'æŒä¹…åŒ–å­˜å‚¨ç”³è¯·æˆåŠŸ' : 'æŒä¹…åŒ–å­˜å‚¨ç”³è¯·è¢«æ‹’ç»'
                };

                // å‘å‡ºäº‹ä»¶é€šçŸ¥UIå±‚
                const eventType = granted ? 'storage:persistentGranted' : 'storage:persistentDenied';
                window.dispatchEvent(new CustomEvent(eventType, { detail: result }));
                
                console.log(`[StorageManager] æŒä¹…åŒ–å­˜å‚¨ç”³è¯·${granted ? 'æˆåŠŸ' : 'è¢«æ‹’ç»'}`);
                
                // é€šçŸ¥éœ€è¦åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯
                window.dispatchEvent(new CustomEvent('storage:statsRefreshNeeded'));
                
                return result;

            } catch (error) {
                console.error('[StorageManager] ç”³è¯·æŒä¹…åŒ–å­˜å‚¨å¤±è´¥:', error);
                const result = { success: false, error: error.message };
                window.dispatchEvent(new CustomEvent('storage:persistentError', { detail: result }));
                return result;
            }
        },

        /**
         * æ£€æŸ¥æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€
         */
        async checkPersistentStorageStatus() {
            try {
                if (!navigator.storage || !navigator.storage.persisted) {
                    return false;
                }
                return await navigator.storage.persisted();
            } catch (error) {
                console.error('[StorageManager] æ£€æŸ¥æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€å¤±è´¥:', error);
                return false;
            }
        },

        /**
         * è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
         */
        async getStorageUsage() {
            try {
                if (!navigator.storage || !navigator.storage.estimate) {
                    return null;
                }
                return await navigator.storage.estimate();
            } catch (error) {
                console.error('[StorageManager] è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥:', error);
                return null;
            }
        },

        /**
         * æ£€æŸ¥IndexedDBæ˜¯å¦ä¸ºæŒä¹…åŒ–å­˜å‚¨
         */
        async checkPersistentStorage() {
            try {
                if ('storage' in navigator && 'persisted' in navigator.storage) {
                    const isPersistent = await navigator.storage.persisted();
                    const estimate = await navigator.storage.estimate();
                    
                    return {
                        success: true,
                        isPersistent: isPersistent,
                        estimate: estimate
                    };
                } else {
                    return {
                        success: false,
                        error: 'æµè§ˆå™¨ä¸æ”¯æŒStorage API',
                        isPersistent: false
                    };
                }
            } catch (error) {
                console.error('æ£€æŸ¥æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€å¤±è´¥:', error);
                return {
                    success: false,
                    error: error.message,
                    isPersistent: false
                };
            }
        },

        // åˆ é™¤é‡å¤æ–¹æ³• - requestPersistentStorage() å·²åœ¨ä¸Šé¢å®šä¹‰
    };

    // å‘åå…¼å®¹ï¼šä¿ç•™ StorageManager çš„ç›´æ¥ window è®¿é—®
    window.StorageManager = AppDB.StorageManager;

    // ğŸ”¥ å®Œæ•´çš„ DatabaseManager å¯¹è±¡
    AppDB.DatabaseManager = {
        init: () => unifiedDB.init(),
        
        /**
         * æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€å¹¶æä¾›ä¿®å¤é€‰é¡¹
         */
        async checkAndOfferRepair() {
            try {
                console.log('[DatabaseManager] å¼€å§‹æ•°æ®åº“å¥åº·æ£€æŸ¥...');
                
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    console.warn('[DatabaseManager] æ•°æ®åº“æœªå°±ç»ªï¼Œè·³è¿‡å¥åº·æ£€æŸ¥');
                    return { success: false, error: 'æ•°æ®åº“æœªå°±ç»ª' };
                }

                // æ£€æŸ¥æ‰€æœ‰é¢„æœŸçš„å­˜å‚¨æ˜¯å¦å­˜åœ¨
                const expectedStores = [
                    'contacts', 'apiSettings', 'emojis', 'backgrounds', 
                    'userProfile', 'moments', 'weiboPosts', 'hashtagCache',
                    'characterMemories', 'globalMemory', 'conversationCounters', 
                    'memoryProcessedIndex', 'themeConfig'
                ];

                const db = window.unifiedDB.db;
                const missingStores = expectedStores.filter(storeName => 
                    !db.objectStoreNames.contains(storeName)
                );

                if (missingStores.length > 0) {
                    console.warn('[DatabaseManager] å‘ç°ç¼ºå¤±çš„å­˜å‚¨:', missingStores);
                    
                    // å‘å‡ºäº‹ä»¶ï¼Œè®©UIå±‚å†³å®šæ˜¯å¦ä¿®å¤
                    const repairResult = await new Promise((resolve) => {
                        const eventData = { missingStores, resolve };
                        window.dispatchEvent(new CustomEvent('database:repairNeeded', { detail: eventData }));
                    });
                    
                    if (repairResult) {
                        return await this.repairDatabase(missingStores);
                    }
                    
                    return { success: false, message: 'ç”¨æˆ·å–æ¶ˆä¿®å¤', missingStores };
                } else {
                    console.log('[DatabaseManager] æ•°æ®åº“ç»“æ„å®Œæ•´');
                    return { success: true, message: 'æ•°æ®åº“ç»“æ„å®Œæ•´' };
                }

                return { success: true, message: 'å¥åº·æ£€æŸ¥å®Œæˆ' };

            } catch (error) {
                console.error('[DatabaseManager] å¥åº·æ£€æŸ¥å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * ä¿®å¤æ•°æ®åº“ç»“æ„
         */
        async repairDatabase(missingStores) {
            try {
                console.log('[DatabaseManager] å¼€å§‹ä¿®å¤æ•°æ®åº“...');
                
                // å…³é—­ç°æœ‰è¿æ¥
                if (window.unifiedDB && window.unifiedDB.db) {
                    window.unifiedDB.db.close();
                }

                // é‡æ–°åˆå§‹åŒ–æ•°æ®åº“ä»¥åˆ›å»ºç¼ºå¤±çš„å­˜å‚¨
                await window.unifiedDB.init();
                
                // å‘å‡ºä¿®å¤æˆåŠŸäº‹ä»¶
                window.dispatchEvent(new CustomEvent('database:repairSuccess', {
                    detail: { message: 'æ•°æ®åº“ä¿®å¤å®Œæˆ' }
                }));

                return { success: true, message: 'æ•°æ®åº“ä¿®å¤å®Œæˆ' };

            } catch (error) {
                console.error('[DatabaseManager] æ•°æ®åº“ä¿®å¤å¤±è´¥:', error);
                
                // å‘å‡ºä¿®å¤å¤±è´¥äº‹ä»¶
                window.dispatchEvent(new CustomEvent('database:repairError', {
                    detail: { error: error.message }
                }));

                return { success: false, error: error.message };
            }
        },

        /**
         * è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
         */
        async getStats() {
            try {
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    return { success: false, error: 'æ•°æ®åº“æœªå°±ç»ª' };
                }

                const db = window.unifiedDB.db;
                const stats = {};

                // éå†æ‰€æœ‰å¯¹è±¡å­˜å‚¨è·å–è®°å½•æ•°
                const storeNames = Array.from(db.objectStoreNames);
                
                for (const storeName of storeNames) {
                    try {
                        const count = await window.unifiedDB.count(storeName);
                        stats[storeName] = count;
                    } catch (error) {
                        console.warn(`[DatabaseManager] è·å–å­˜å‚¨ ${storeName} ç»Ÿè®¡å¤±è´¥:`, error);
                        stats[storeName] = 0;
                    }
                }

                return { success: true, stats };

            } catch (error) {
                console.error('[DatabaseManager] è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * é‡ç½®åº”ç”¨çŠ¶æ€ - æ¸…ç©ºå†…å­˜ä¸­çš„å…¨å±€å˜é‡
         * åœ¨æ•°æ®åº“å¯¼å…¥åä½¿ç”¨ï¼Œç¡®ä¿åº”ç”¨çŠ¶æ€ä¸æ•°æ®åº“åŒæ­¥
         */
        resetApplicationState() {
            // è”ç³»äººç›¸å…³
            if (typeof window.contacts !== 'undefined') {
                window.contacts = [];
            }
            if (typeof window.currentContact !== 'undefined') {
                window.currentContact = null;
            }
            
            // è¡¨æƒ…ç›¸å…³
            if (typeof window.emojis !== 'undefined') {
                window.emojis = [];
            }
            
            // èƒŒæ™¯ç›¸å…³
            if (typeof window.backgrounds !== 'undefined') {
                window.backgrounds = {};
            }
            
            // ç”¨æˆ·èµ„æ–™
            if (typeof window.userProfile !== 'undefined') {
                window.userProfile = { name: 'æˆ‘çš„æ˜µç§°', avatar: '', personality: '' };
            }
            
            // åŠ¨æ€ç›¸å…³
            if (typeof window.moments !== 'undefined') {
                window.moments = [];
            }
            if (typeof window.weiboPosts !== 'undefined') {
                window.weiboPosts = [];
            }
            
            console.log('[DatabaseManager] åº”ç”¨çŠ¶æ€å·²é‡ç½®');
        },

        /**
         * å¯¼å‡ºå¹¶ä¸‹è½½æ•°æ®åº“
         */
        async exportAndDownload() {
            try {
                console.log('[DatabaseManager] å¼€å§‹å¯¼å‡ºæ•°æ®åº“...');
                
                const exportData = await window.unifiedDB.exportDatabase();
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `freeapp_backup_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                return { success: true, message: 'æ•°æ®åº“å¯¼å‡ºæˆåŠŸ' };

            } catch (error) {
                console.error('[DatabaseManager] å¯¼å‡ºæ•°æ®åº“å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * ä»æ–‡ä»¶å¯¼å…¥æ•°æ®åº“
         */
        async importFromFile(file, overwrite = false) {
            try {
                console.log('[DatabaseManager] å¼€å§‹å¯¼å…¥æ•°æ®åº“...');
                
                const text = await this.readFileAsText(file);
                const importData = JSON.parse(text);
                
                const result = await window.unifiedDB.importDatabase(importData, { overwrite });
                
                return { 
                    success: true, 
                    message: 'æ•°æ®åº“å¯¼å…¥æˆåŠŸ',
                    result: result
                };

            } catch (error) {
                console.error('[DatabaseManager] å¯¼å…¥æ•°æ®åº“å¤±è´¥:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * è¯»å–æ–‡ä»¶å†…å®¹ä¸ºæ–‡æœ¬
         */
        readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                reader.readAsText(file);
            });
        }
    };

    // å‘åå…¼å®¹ï¼šä¿ç•™ DatabaseManager çš„ç›´æ¥ window è®¿é—®
    window.DatabaseManager = AppDB.DatabaseManager;

    // ğŸ”¥ æ•°æ®åº“ç»Ÿè®¡åˆ·æ–°å‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIåˆ†ç¦»ï¼‰
    AppDB.refreshDatabaseStats = async function() {
        try {
            // å‘å‡ºåˆ·æ–°å¼€å§‹äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:statsRefreshStart'));
            
            const [result, persistentResult] = await Promise.all([
                window.DatabaseManager.getStats(),
                window.StorageManager.checkPersistentStorage()
            ]);
            
            if (result.success) {
                // å‘å‡ºæˆåŠŸäº‹ä»¶ï¼Œè®©UIå±‚å¤„ç†æ˜¾ç¤º
                window.dispatchEvent(new CustomEvent('database:statsRefreshSuccess', {
                    detail: { result, persistentResult }
                }));
                return { success: true, result, persistentResult };
            } else {
                // å‘å‡ºé”™è¯¯äº‹ä»¶
                window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                    detail: { error: result.error }
                }));
                return { success: false, error: result.error };
            }
            
        } catch (error) {
            console.error('åˆ·æ–°æ•°æ®åº“ç»Ÿè®¡å¤±è´¥:', error);
            // å‘å‡ºé”™è¯¯äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                detail: { error: error.message }
            }));
            return { success: false, error: error.message };
        }
    };

    // å‘åå…¼å®¹ï¼šrefreshDatabaseStats ç°åœ¨é€šè¿‡ UIManager å¤„ç†
    // window.refreshDatabaseStats is now assigned in uiManager.js

    // ğŸ”¥ æ•°æ®åº“å¯¼å‡ºå‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼‰
    AppDB.exportDatabase = async function() {
        try {
            // å‘å‡ºå¯¼å‡ºå¼€å§‹äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:exportStart'));
            
            const result = await window.DatabaseManager.exportAndDownload();
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:exportSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:exportError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('å¯¼å‡ºå‡ºé”™:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:exportError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // ğŸ”¥ æ–‡ä»¶å­˜å‚¨å¯¼å‡ºå‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼Œé…ç½®é€šè¿‡äº‹ä»¶è·å–
    AppDB.exportFileStorage = async function() {
        try {
            // é€šè¿‡äº‹ä»¶è¯·æ±‚å¯¼å‡ºé…ç½®
            const config = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:exportConfigNeeded', {
                    detail: { resolve }
                }));
            });

            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportStart', {
                detail: { config }
            }));

            const exporter = new FileStorageExporter();
            const result = await exporter.downloadFileStorageAsZip(config);

            if (result.success) {
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:exportSuccess', {
                    detail: { 
                        message: 'æ–‡ä»¶å­˜å‚¨å¯¼å‡ºæˆåŠŸï¼',
                        result: result
                    }
                }));
            } else {
                throw new Error(result.error || 'å¯¼å‡ºå¤±è´¥');
            }

        } catch (error) {
            console.error('æ–‡ä»¶å­˜å‚¨å¯¼å‡ºå¤±è´¥:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
        }
    };

    // ğŸ”¥ å¤„ç†æ–‡ä»¶é€‰æ‹©å‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œç§»è‡³UIManager
    AppDB.handleFileSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: 'æœªé€‰æ‹©æ–‡ä»¶' };
        }
        
        console.log('é€‰æ‹©çš„æ–‡ä»¶:', file.name, file.type, file.size);
        
        try {
            const result = await window.importDatabase(file);
            
            // å‘å‡ºæ–‡ä»¶å¤„ç†å®Œæˆäº‹ä»¶ï¼Œè®©UIå±‚å¤„ç†æ¸…ç©ºæ“ä½œ
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('å¯¼å…¥è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('database:importError', {
                detail: {
                    error: error,
                    type: 'import_operation'
                }
            }));
            
            // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // ğŸ”¥ å¤„ç†æ–‡ä»¶å­˜å‚¨é€‰æ‹©å‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œé€šè¿‡äº‹ä»¶å¤„ç†
    AppDB.handleFileStorageSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: 'æœªé€‰æ‹©æ–‡ä»¶' };
        }
        
        console.log('é€‰æ‹©çš„æ–‡ä»¶å­˜å‚¨æ–‡ä»¶:', file.name, file.type, file.size);
        
        try {
            // è¯·æ±‚UIæä¾›å¯¼å…¥é€‰é¡¹
            const options = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:importOptionsNeeded', {
                    detail: { resolve }
                }));
            });
            
            // è°ƒç”¨ä¸šåŠ¡é€»è¾‘æ‰§è¡Œå¯¼å…¥
            const result = await window.performFileStorageImport(file, options);
            
            // å‘å‡ºæ–‡ä»¶å¤„ç†å®Œæˆäº‹ä»¶ï¼Œè®©UIå±‚å¤„ç†æ¸…ç©ºæ“ä½œ
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('æ–‡ä»¶å­˜å‚¨å¯¼å…¥è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:importError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
            
            // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // ğŸ”¥ æ•°æ®åº“å¯¼å…¥å‡½æ•°ï¼ˆçº¯ä¸šåŠ¡é€»è¾‘ï¼‰
    AppDB.importDatabase = async function(file) {
        if (!file) {
            return { success: false, error: 'æœªæä¾›æ–‡ä»¶' };
        }
        
        try {
            // è¯·æ±‚UIç¡®è®¤
            const confirmed = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('database:importConfirmationNeeded', { 
                    detail: { file, resolve } 
                }));
            });
            
            if (!confirmed) {
                console.log('ç”¨æˆ·å–æ¶ˆå¯¼å…¥');
                return { success: false, message: 'ç”¨æˆ·å–æ¶ˆå¯¼å…¥' };
            }
            
            // å‘å‡ºå¯¼å…¥å¼€å§‹äº‹ä»¶
            window.dispatchEvent(new CustomEvent('database:importStart', { 
                detail: { fileName: file.name } 
            }));
            
            // ğŸ¯ ç¡®ä¿performImportå‡½æ•°å·²å°±ç»ª
            if (!window.performImport || typeof window.performImport !== 'function') {
                console.log('â³ [Import] performImportæœªå°±ç»ªï¼Œç­‰å¾…åˆå§‹åŒ–...');
                await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        console.warn('âš ï¸ [Import] performImportç­‰å¾…è¶…æ—¶ï¼Œå°è¯•ç»§ç»­');
                        resolve();
                    }, 3000);

                    const checkReady = () => {
                        if (window.performImport && typeof window.performImport === 'function') {
                            clearTimeout(timeout);
                            console.log('âœ… [Import] performImportå·²å°±ç»ª');
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }

            const overwrite = true;
            const result = await window.performImport(file, overwrite);

            // ğŸ” å®½å®¹çš„ç»“æœæ£€æŸ¥ - å…è®¸undefinedè¿”å›ï¼Œé€šå¸¸åˆ·æ–°åä¼šæ­£å¸¸
            if (result === undefined) {
                console.warn('âš ï¸ [Import] performImportè¿”å›undefinedï¼Œè¿™é€šå¸¸åœ¨åˆ·æ–°åä¼šè‡ªè¡Œä¿®å¤');
                return {
                    success: false,
                    error: 'å¯¼å…¥åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•',
                    needsRefresh: true
                };
            }
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:importSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:importError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('å¯¼å…¥å¤±è´¥:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:importError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // ğŸ”¥ æ‰§è¡Œå¯¼å…¥å‡½æ•° - é‡æ„ä¸ºäº‹ä»¶é©±åŠ¨æ¶æ„
    AppDB.performImport = async function(file, overwrite) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('database:importProgress', {
                detail: { message: 'æ­£åœ¨å¯¼å…¥æ•°æ®åº“...', stage: 'starting' }
            }));
            
            if (!window.DatabaseManager) {
                console.error('window.DatabaseManager ä¸å­˜åœ¨ï¼');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('æ•°æ®åº“ç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•'),
                        type: 'initialization_error',
                        critical: true
                    }
                }));
                return;
            }
            
            if (!window.DatabaseManager.importFromFile) {
                console.error('importFromFile æ–¹æ³•ä¸å­˜åœ¨ï¼');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('å¯¼å…¥åŠŸèƒ½ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ä»£ç '),
                        type: 'function_missing',
                        critical: true
                    }
                }));
                return;
            }
            
            const result = await window.DatabaseManager.importFromFile(file, overwrite);
            
            if (result.success) {
                // åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯
                if (typeof window.refreshDatabaseStats === 'function') {
                    window.refreshDatabaseStats();
                }
                
                // é‡ç½®åº”ç”¨çŠ¶æ€ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
                window.DatabaseManager.resetApplicationState();
                
                // Event-driven success notification with reload intent
                window.dispatchEvent(new CustomEvent('database:importSuccess', {
                    detail: { 
                        message: 'æ•°æ®åº“å¯¼å…¥æˆåŠŸï¼é¡µé¢å°†åœ¨3ç§’åè‡ªåŠ¨åˆ·æ–°...',
                        result: result,
                        autoReload: true,
                        reloadDelay: 3000
                    }
                }));
                
                // å»¶è¿Ÿåˆ·æ–°é¡µé¢ä»¥ç¡®ä¿ç”¨æˆ·çœ‹åˆ°æˆåŠŸæ¶ˆæ¯
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
                
            } else {
                throw new Error(result.error || 'å¯¼å…¥å¤±è´¥');
            }
            
        } catch (error) {
            console.error('å¯¼å…¥å¤±è´¥:', error.message);
            throw error; // é‡æ–°æŠ›å‡ºä»¥ä¾¿ä¸Šå±‚å¤„ç†
        }
    };

    // ğŸ”¥ æ‰§è¡Œæ–‡ä»¶å­˜å‚¨å¯¼å…¥å‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ˆUIäº¤äº’å·²ç§»è‡³UIManagerï¼‰
    AppDB.performFileStorageImport = async function(file, options) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:importProgress', {
                detail: { message: 'æ­£åœ¨å¯¼å…¥æ–‡ä»¶å­˜å‚¨...', stage: 'starting' }
            }));

            const importer = new FileStorageImporter();
            const response = await importer.importFromZipFile(file, options);

            if (response.success) {
                // æ˜ å°„è¿”å›ç»“æœæ ¼å¼ä»¥ä¿æŒå…¼å®¹æ€§
                const result = {
                    imported: response.results.created,
                    skipped: response.results.skipped,
                    failed: response.results.failed,
                    matched: response.results.matched,
                    processed: response.results.processed,
                    totalFiles: response.results.totalFiles
                };

                const detailedMessage = `æ–‡ä»¶å­˜å‚¨å¯¼å…¥æˆåŠŸï¼\n\nå¯¼å…¥ç»Ÿè®¡ï¼š\nâ€¢ æˆåŠŸå¯¼å…¥ ${result.imported} ä¸ªæ–‡ä»¶\nâ€¢ è·³è¿‡ ${result.skipped} ä¸ªæ–‡ä»¶\nâ€¢ å¤±è´¥ ${result.failed} ä¸ªæ–‡ä»¶`;
                
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:importSuccess', {
                    detail: { 
                        message: 'æ–‡ä»¶å­˜å‚¨å¯¼å…¥æˆåŠŸï¼',
                        detailedMessage: detailedMessage,
                        stats: {
                            imported: result.imported,
                            skipped: result.skipped,
                            failed: result.failed
                        },
                        result: result
                    }
                }));
                
                // åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯
                if (typeof window.refreshDatabaseStats === 'function') {
                    setTimeout(() => {
                        window.refreshDatabaseStats();
                    }, 1000);
                }

            } else {
                throw new Error(response.error || 'å¯¼å…¥å¤±è´¥');
            }

        } catch (error) {
            console.error('æ–‡ä»¶å­˜å‚¨å¯¼å…¥å¤±è´¥:', error);
            throw error; // é‡æ–°æŠ›å‡ºä»¥ä¾¿ä¸Šå±‚å¤„ç†
        }
    };

    // ğŸ”¥ ç¡®è®¤æ–‡ä»¶å¯¼å‡ºå‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œç§»è‡³UIManager
    AppDB.confirmFileExport = async function() {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportProgress', {
                detail: { message: 'æ­£åœ¨å¯¼å‡ºæ–‡ä»¶å­˜å‚¨...', stage: 'confirming' }
            }));

            // å‘å‡ºéšè—é€‰é¡¹é¢æ¿äº‹ä»¶
            window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));

            const result = await window.exportFileStorage();
            return result;

        } catch (error) {
            console.error('ç¡®è®¤æ–‡ä»¶å¯¼å‡ºå¤±è´¥:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'confirmation_error'
                }
            }));
            return { success: false, error: error.message };
        }
    };

    // ğŸ”¥ å–æ¶ˆæ–‡ä»¶å¯¼å‡ºå‡½æ•° - çº¯ä¸šåŠ¡é€»è¾‘ï¼ŒUIæ“ä½œç§»è‡³UIManager
    AppDB.cancelFileExport = function() {
        // å‘å‡ºéšè—é€‰é¡¹é¢æ¿äº‹ä»¶
        window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));
        
        // Event-driven cancellation notification
        window.dispatchEvent(new CustomEvent('fileStorage:exportCancelled', {
            detail: { message: 'ç”¨æˆ·å–æ¶ˆäº†æ–‡ä»¶å¯¼å‡º' }
        }));
        
        return { success: true, message: 'ç”¨æˆ·å–æ¶ˆäº†æ–‡ä»¶å¯¼å‡º' };
    };

    // ğŸ”¥ å¯¼å…¥æç¤ºè¯å‡½æ•° - é‡æ„ä¸ºäº‹ä»¶é©±åŠ¨æ¶æ„
    AppDB.importPrompts = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                const prompts = JSON.parse(content);
                
                if (Array.isArray(prompts)) {
                    localStorage.setItem('customPrompts', JSON.stringify(prompts));
                    // Event-driven success notification
                    window.dispatchEvent(new CustomEvent('prompts:importSuccess', {
                        detail: { 
                            message: `æˆåŠŸå¯¼å…¥ ${prompts.length} ä¸ªæç¤ºè¯`,
                            count: prompts.length,
                            prompts: prompts
                        }
                    }));
                } else {
                    throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œåº”ä¸ºæç¤ºè¯æ•°ç»„');
                }
            } catch (error) {
                console.error('å¯¼å…¥æç¤ºè¯å¤±è´¥:', error);
                // Event-driven error notification
                window.dispatchEvent(new CustomEvent('prompts:importError', {
                    detail: {
                        error: error,
                        type: 'format_error'
                    }
                }));
            }
        };
        reader.readAsText(file);
        
        // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
        event.target.value = '';
    };
    
    // å‘åå…¼å®¹ï¼šä¿ç•™æ‰€æœ‰å‡½æ•°çš„ç›´æ¥ window è®¿é—®
    window.exportDatabase = AppDB.exportDatabase;
    window.exportFileStorage = AppDB.exportFileStorage;
    // Pure database operations that remain in UnifiedDBManager
    window.importDatabase = AppDB.importDatabase;
    window.performImport = AppDB.performImport;
    window.performFileStorageImport = AppDB.performFileStorageImport;
    window.importPrompts = AppDB.importPrompts;
    
    // UI-related functions are now handled by UIManager
    // window.triggerFileSelect, window.triggerFileStorageImport, etc. are assigned in uiManager.js
    
    window.FileStorageManager = unifiedDB; // ç›´æ¥æ˜ å°„åˆ°ç»Ÿä¸€ç®¡ç†å™¨
    
    console.log('ğŸ”¥ [UnifiedDB] ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨å·²å…¨å±€å¯¼å‡ºï¼ŒåŒ…å«æ‰€æœ‰æ•°æ®åº“ç›¸å…³åŠŸèƒ½');

    // ğŸ¯ é€šçŸ¥æ‰€æœ‰ä¾èµ–å‡½æ•°å·²å°±ç»ª - è§£å†³å•æ–‡ä»¶æ„å»ºæ—¶åºé—®é¢˜
    setTimeout(() => {
        window.dispatchEvent(new CustomEvent('unifieddb:ready', {
            detail: {
                timestamp: Date.now(),
                message: 'æ‰€æœ‰å¯¼å…¥å¯¼å‡ºåŠŸèƒ½å·²å°±ç»ª',
                functions: ['performImport', 'importDatabase', 'exportDatabase', 'performFileStorageImport']
            }
        }));
        console.log('âœ… [UnifiedDB] å°±ç»ªäº‹ä»¶å·²å‘é€ï¼Œå¯¼å…¥åŠŸèƒ½å¯ç”¨');
    }, 0);
}

// ğŸ”¥ Module export removed for browser compatibility
// ES Moduleå¯¼å‡º (removed for standard script loading)

/*
================================================================================
ğŸ“š EVENT-DRIVEN UI ARCHITECTURE DOCUMENTATION
================================================================================

æœ¬æ–‡æ¡£è¯´æ˜äº†é‡æ„åçš„äº‹ä»¶é©±åŠ¨UIæ¶æ„ã€‚æ‰€æœ‰UIäº¤äº’ç°åœ¨é€šè¿‡è‡ªå®šä¹‰äº‹ä»¶è¿›è¡Œï¼Œ
å®ç°äº†ä¸šåŠ¡é€»è¾‘ä¸UIå±‚çš„å®Œå…¨åˆ†ç¦»ã€‚

ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿ï¼š
- âœ… çº¯ä¸šåŠ¡é€»è¾‘ï¼Œå¯å•å…ƒæµ‹è¯•
- âœ… çµæ´»çš„UIå®ç°ï¼ˆå¯ç”¨ä»»ä½•æ¡†æ¶ï¼‰  
- âœ… ä¸€è‡´çš„é”™è¯¯å¤„ç†æ¨¡å¼
- âœ… æ›´å¥½çš„ç”¨æˆ·ä½“éªŒï¼ˆéé˜»å¡äº¤äº’ï¼‰

ğŸ“‹ äº‹ä»¶ç±»å‹æ±‡æ€»ï¼š

ğŸ—‚ï¸ æ–‡ä»¶å­˜å‚¨ç›¸å…³äº‹ä»¶ï¼š
- fileStorage:importOptionsNeeded - éœ€è¦ç”¨æˆ·é€‰æ‹©å¯¼å…¥é€‰é¡¹
- fileStorage:importError - æ–‡ä»¶å­˜å‚¨å¯¼å…¥é”™è¯¯
- fileStorage:importProgress - å¯¼å…¥è¿›åº¦é€šçŸ¥
- fileStorage:importSuccess - å¯¼å…¥æˆåŠŸ
- fileStorage:exportStart - å¯¼å‡ºå¼€å§‹
- fileStorage:exportProgress - å¯¼å‡ºè¿›åº¦
- fileStorage:exportSuccess - å¯¼å‡ºæˆåŠŸ  
- fileStorage:exportError - å¯¼å‡ºé”™è¯¯
- fileStorage:exportCancelled - å¯¼å‡ºå–æ¶ˆ

ğŸ—„ï¸ æ•°æ®åº“ç›¸å…³äº‹ä»¶ï¼š
- database:importConfirmationNeeded - éœ€è¦ç”¨æˆ·ç¡®è®¤å¯¼å…¥
- database:importProgress - å¯¼å…¥è¿›åº¦é€šçŸ¥
- database:importStart - å¯¼å…¥å¼€å§‹
- database:importSuccess - å¯¼å…¥æˆåŠŸ
- database:importError - å¯¼å…¥é”™è¯¯
- database:exportStart - å¯¼å‡ºå¼€å§‹
- database:exportSuccess - å¯¼å‡ºæˆåŠŸ
- database:exportError - å¯¼å‡ºé”™è¯¯
- database:repairNeeded - éœ€è¦æ•°æ®åº“ä¿®å¤
- database:repairSuccess - ä¿®å¤æˆåŠŸ
- database:repairError - ä¿®å¤å¤±è´¥
- database:errorDialog - æ˜¾ç¤ºé”™è¯¯å¯¹è¯æ¡†

ğŸ’¡ æç¤ºè¯ç›¸å…³äº‹ä»¶ï¼š
- prompts:importSuccess - æç¤ºè¯å¯¼å…¥æˆåŠŸ
- prompts:importError - æç¤ºè¯å¯¼å…¥é”™è¯¯

ğŸª å­˜å‚¨ç›¸å…³äº‹ä»¶ï¼š
- storage:persistentGranted - æŒä¹…åŒ–å­˜å‚¨å·²æˆæƒ
- storage:persistentDenied - æŒä¹…åŒ–å­˜å‚¨è¢«æ‹’ç»
- storage:persistentUnsupported - ä¸æ”¯æŒæŒä¹…åŒ–å­˜å‚¨
- storage:persistentError - æŒä¹…åŒ–å­˜å‚¨é”™è¯¯
- storage:statsRefreshNeeded - éœ€è¦åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯

================================================================================
ğŸ“– UIå±‚å®ç°ç¤ºä¾‹
================================================================================

ä»¥ä¸‹æ˜¯æ¨èçš„UIå±‚å®ç°æ¨¡å¼ï¼š

// ğŸ¯ 1. åŸºç¡€é”™è¯¯é€šçŸ¥å¤„ç†
window.addEventListener('fileStorage:importError', (event) => {
    const { error, type } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(error.message, 'error');
    } else {
        // é™çº§åˆ°åŸç”Ÿå¯¹è¯æ¡†
        alert(error.message);
    }
});

// ğŸ¯ 2. ç”¨æˆ·ç¡®è®¤å¯¹è¯æ¡†
window.addEventListener('fileStorage:importOptionsNeeded', (event) => {
    const { resolve, messages } = event.detail;
    
    // ç°ä»£UIå®ç°ç¤ºä¾‹
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: 'å¯¼å…¥é€‰é¡¹',
            message: messages.overwrite,
            buttons: [
                { text: 'è¦†ç›–', style: 'primary', value: true },
                { text: 'ä¿ç•™', style: 'secondary', value: false }
            ]
        }).then(overwrite => {
            return showCustomDialog({
                title: 'å¤„ç†ç¼ºå¤±æ–‡ä»¶',
                message: messages.skipMissing,
                buttons: [
                    { text: 'è·³è¿‡', style: 'primary', value: true },
                    { text: 'å ä½ç¬¦', style: 'secondary', value: false }
                ]
            }).then(skipMissing => {
                resolve({ overwrite, skipMissing });
            });
        });
    } else {
        // é™çº§åˆ°åŸç”Ÿå¯¹è¯æ¡†
        const overwrite = confirm(messages.overwrite);
        const skipMissing = confirm(messages.skipMissing);
        resolve({ overwrite, skipMissing });
    }
});

// ğŸ¯ 3. è¿›åº¦é€šçŸ¥å¤„ç†
window.addEventListener('database:importProgress', (event) => {
    const { message, stage } = event.detail;
    
    if (typeof showProgressToast === 'function') {
        showProgressToast(message);
    } else if (typeof showToast === 'function') {
        showToast(message);
    }
});

// ğŸ¯ 4. æˆåŠŸé€šçŸ¥å¤„ç†
window.addEventListener('database:importSuccess', (event) => {
    const { message, autoReload, reloadDelay } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(message);
    }
    
    // è‡ªåŠ¨åˆ·æ–°å·²ç»åœ¨ä¸šåŠ¡é€»è¾‘ä¸­å¤„ç†ï¼ŒUIå±‚å¯ä»¥æ·»åŠ é¢å¤–çš„è§†è§‰åé¦ˆ
    if (autoReload && typeof showCountdownNotification === 'function') {
        showCountdownNotification('é¡µé¢å°†è‡ªåŠ¨åˆ·æ–°', reloadDelay);
    }
});

// ğŸ¯ 5. æ•°æ®åº“ä¿®å¤ç¡®è®¤å¯¹è¯æ¡†
window.addEventListener('database:repairNeeded', (event) => {
    const { missingStores, resolve } = event.detail;
    
    const message = `å‘ç°æ•°æ®åº“ç»“æ„é—®é¢˜ï¼Œç¼ºå¤±ä»¥ä¸‹å­˜å‚¨ï¼š\n${missingStores.join(', ')}\n\næ˜¯å¦ç«‹å³ä¿®å¤ï¼Ÿ`;
    
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: 'æ•°æ®åº“ä¿®å¤',
            message: message,
            type: 'warning',
            buttons: [
                { text: 'ç«‹å³ä¿®å¤', style: 'primary', value: true },
                { text: 'ç¨åå¤„ç†', style: 'secondary', value: false }
            ]
        }).then(resolve);
    } else {
        const shouldRepair = confirm(message);
        resolve(shouldRepair);
    }
});

// ğŸ¯ 6. å¤æ‚ç»Ÿè®¡ä¿¡æ¯å±•ç¤º
window.addEventListener('fileStorage:importSuccess', (event) => {
    const { message, stats, detailedMessage } = event.detail;
    
    if (typeof showDetailedNotification === 'function') {
        showDetailedNotification({
            title: 'å¯¼å…¥å®Œæˆ',
            message: message,
            details: `æˆåŠŸï¼š${stats.imported}ï¼Œè·³è¿‡ï¼š${stats.skipped}ï¼Œå¤±è´¥ï¼š${stats.failed}`,
            type: 'success'
        });
    } else if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(detailedMessage);
    }
});

================================================================================
ğŸ”§ UIæ¡†æ¶é›†æˆæŒ‡å—
================================================================================

ğŸ¨ Vue.js é›†æˆç¤ºä¾‹ï¼š
// åœ¨Vueç»„ä»¶ä¸­
mounted() {
    // ç›‘å¬æ•°æ®åº“äº‹ä»¶
    window.addEventListener('database:importError', this.handleImportError);
    window.addEventListener('database:importSuccess', this.handleImportSuccess);
},
methods: {
    handleImportError(event) {
        this.$toast.error(event.detail.error.message);
    },
    handleImportSuccess(event) {
        this.$toast.success(event.detail.message);
        if (event.detail.autoReload) {
            this.showCountdown(event.detail.reloadDelay);
        }
    }
}

âš›ï¸ React é›†æˆç¤ºä¾‹ï¼š
// åœ¨Reactç»„ä»¶ä¸­
useEffect(() => {
    const handleImportError = (event) => {
        toast.error(event.detail.error.message);
    };
    
    window.addEventListener('database:importError', handleImportError);
    return () => window.removeEventListener('database:importError', handleImportError);
}, []);

ğŸ° Vanilla JS é›†æˆç¤ºä¾‹ï¼š
// åˆ›å»ºç»Ÿä¸€çš„äº‹ä»¶å¤„ç†ç®¡ç†å™¨
class UIEventManager {
    constructor() {
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // é”™è¯¯å¤„ç†
        ['database:importError', 'fileStorage:importError', 'prompts:importError']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleError.bind(this));
            });
            
        // æˆåŠŸå¤„ç†
        ['database:importSuccess', 'fileStorage:importSuccess', 'prompts:importSuccess']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleSuccess.bind(this));
            });
    }
    
    handleError(event) {
        const { error, type } = event.detail;
        this.showNotification(error.message, 'error');
    }
    
    handleSuccess(event) {
        const { message } = event.detail;
        this.showNotification(message, 'success');
    }
}

// å¯ç”¨äº‹ä»¶ç®¡ç†å™¨
document.addEventListener('DOMContentLoaded', () => {
    new UIEventManager();
});

================================================================================
ğŸ’¯ æœ€ä½³å®è·µ
================================================================================

1. âœ… é™çº§ç­–ç•¥ï¼šå§‹ç»ˆæä¾›åŸç”Ÿå¯¹è¯æ¡†ä½œä¸ºé™çº§æ–¹æ¡ˆ
2. âœ… é”™è¯¯åˆ†ç±»ï¼šä½¿ç”¨ detail.type åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
3. âœ… è¿›åº¦åé¦ˆï¼šé•¿æ—¶é—´æ“ä½œæä¾›è¿›åº¦é€šçŸ¥
4. âœ… ä¸€è‡´æ€§ï¼šæ‰€æœ‰UIäº¤äº’ä½¿ç”¨ç›¸åŒçš„äº‹ä»¶æ¨¡å¼
5. âœ… å¯è®¿é—®æ€§ï¼šç¡®ä¿äº‹ä»¶åŒ…å«è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ä¿¡æ¯
6. âœ… æ¸…ç†ï¼šç»„ä»¶é”€æ¯æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
7. âœ… æµ‹è¯•å‹å¥½ï¼šäº‹ä»¶å¯ä»¥è½»æ¾æ¨¡æ‹Ÿå’Œæµ‹è¯•

é€šè¿‡éµå¾ªè¿™äº›æ¨¡å¼ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªå®Œå…¨è§£è€¦ã€å¯æµ‹è¯•ã€å¯ç»´æŠ¤çš„åº”ç”¨æ¶æ„ï¼

================================================================================
*/
// export default UnifiedDBManager;
// export { unifiedDB };
</script>
    
    <!-- åº”ç”¨æ ¸å¿ƒæ¨¡å— -->
    <script>
/**
 * UIç®¡ç†å™¨ - ç»Ÿä¸€çš„UIæ§åˆ¶ç³»ç»Ÿ
 * åŒ…å«è§†å£ç®¡ç†ã€ä¸»é¢˜ç®¡ç†ã€è¾“å…¥å¤„ç†ã€æµè§ˆå™¨å…¼å®¹æ€§ç­‰åŠŸèƒ½
 */

// === è§†å£ç®¡ç†ç³»ç»Ÿ ===
class ViewportManager {
    constructor() {
        this.init();
    }

    init() {
        // è®¾ç½®CSSè‡ªå®šä¹‰å±æ€§
        this.updateViewportProperties();

        // ç›‘å¬è§†å£å˜åŒ–
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                this.handleKeyboardToggle();
            });
        }

        // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                this.updateViewportProperties();
            }, 100);
        });

        // åˆå§‹è®¾ç½®
        this.setInitialStyles();
    }

    updateViewportProperties() {
        const root = document.documentElement;
        
        // è·å–çœŸå®çš„è§†å£å°ºå¯¸
        // é”®ç›˜å¼¹å‡ºæ—¶ä¸è°ƒæ•´viewport heightï¼Œé¿å…å‡ºç°ç™½è‰²åŒºåŸŸ
        const viewportHeight = window.innerHeight; // ä½¿ç”¨å›ºå®šçš„window.innerHeight
        const viewportWidth = window.visualViewport ? window.visualViewport.width : window.innerWidth;
        
        // è®¡ç®—safe area
        const safeAreaTop = this.getSafeAreaTop();
        const safeAreaBottom = this.getSafeAreaBottom();
        const safeAreaLeft = this.getSafeAreaLeft();
        const safeAreaRight = this.getSafeAreaRight();

        // è®¾ç½®CSSè‡ªå®šä¹‰å±æ€§
        root.style.setProperty('--viewport-height', `${viewportHeight}px`);
        root.style.setProperty('--viewport-width', `${viewportWidth}px`);
        root.style.setProperty('--safe-area-top', `${safeAreaTop}px`);
        root.style.setProperty('--safe-area-bottom', `${safeAreaBottom}px`);
        root.style.setProperty('--safe-area-left', `${safeAreaLeft}px`);
        root.style.setProperty('--safe-area-right', `${safeAreaRight}px`);

        // è®¡ç®—headeré«˜åº¦
        const headerHeight = 44; // åŸºç¡€headeré«˜åº¦
        const totalHeaderHeight = headerHeight + safeAreaTop;
        root.style.setProperty('--header-height', `${totalHeaderHeight}px`);

        // è®¡ç®—åº•éƒ¨å¯¼èˆªæ é«˜åº¦
        const navHeight = 50; // åŸºç¡€å¯¼èˆªæ é«˜åº¦
        const totalNavHeight = navHeight + safeAreaBottom;
        root.style.setProperty('--nav-height', `${totalNavHeight}px`);

        // è®¡ç®—å¯ç”¨å†…å®¹åŒºåŸŸé«˜åº¦
        const contentHeight = viewportHeight - totalHeaderHeight - totalNavHeight;
        root.style.setProperty('--content-height', `${contentHeight}px`);

        // èŠå¤©é¡µé¢ç‰¹æ®Šå¤„ç†ï¼ˆæ— å¯¼èˆªæ ï¼‰
        const chatContentHeight = viewportHeight - totalHeaderHeight;
        root.style.setProperty('--chat-content-height', `${chatContentHeight}px`);
    }

    /**
     * å¤„ç†é”®ç›˜å¼¹å‡º/æ”¶èµ·æ—¶çš„å¸ƒå±€è°ƒæ•´
     * ä½¿ç”¨transformå’Œscrollæ¥é€‚åº”é”®ç›˜ï¼Œè€Œä¸æ˜¯æ”¹å˜å®¹å™¨é«˜åº¦
     * ä¼˜åŒ–ç‰ˆæœ¬ï¼šå¢åŠ é˜²æŠ–å’ŒçŠ¶æ€æ£€æŸ¥
     */
    handleKeyboardToggle() {
        if (!window.visualViewport) return;
        
        // é˜²æŠ–æœºåˆ¶ï¼Œé¿å…é¢‘ç¹è§¦å‘
        if (this.keyboardToggleTimeout) {
            clearTimeout(this.keyboardToggleTimeout);
        }
        
        this.keyboardToggleTimeout = setTimeout(() => {
            const visualHeight = window.visualViewport.height;
            const windowHeight = window.innerHeight;
            const heightDiff = windowHeight - visualHeight;
            
            // é”®ç›˜é«˜åº¦é˜ˆå€¼ï¼Œè¶…è¿‡150pxè®¤ä¸ºæ˜¯é”®ç›˜å¼¹å‡ºï¼ˆæé«˜é˜ˆå€¼é¿å…è¯¯åˆ¤ï¼‰
            const keyboardThreshold = 150;
            const isKeyboardVisible = heightDiff > keyboardThreshold;
            
            const root = document.documentElement;
            const currentState = root.getAttribute('data-keyboard-visible') === 'true';
            
            // åªæœ‰çŠ¶æ€çœŸæ­£å˜åŒ–æ—¶æ‰æ‰§è¡Œæ“ä½œ
            if (isKeyboardVisible !== currentState) {
                if (isKeyboardVisible) {
                    // é”®ç›˜å¼¹å‡ºæ—¶ï¼Œè®¾ç½®ä¸€ä¸ªCSSå˜é‡æ¥æ ‡è¯†çŠ¶æ€
                    root.style.setProperty('--keyboard-height', `${heightDiff}px`);
                    root.setAttribute('data-keyboard-visible', 'true');
                    
                    // å»¶è¿Ÿæ‰§è¡Œæ»šåŠ¨ï¼Œç¡®ä¿é”®ç›˜å®Œå…¨å¼¹å‡º
                    setTimeout(() => {
                        this.scrollToActiveInput();
                    }, 50);
                } else {
                    // é”®ç›˜æ”¶èµ·æ—¶ï¼Œæ¸…é™¤çŠ¶æ€
                    root.style.removeProperty('--keyboard-height');
                    root.removeAttribute('data-keyboard-visible');
                }
            }
            
            this.keyboardToggleTimeout = null;
        }, 100); // 100msé˜²æŠ–
    }

    /**
     * å°†å½“å‰èšç„¦çš„è¾“å…¥æ¡†æ»šåŠ¨åˆ°å¯è§åŒºåŸŸ
     * ä¼˜åŒ–ç‰ˆæœ¬ï¼šé¿å…è¿‡åº¦æ»šåŠ¨å’Œé‡å¤è°ƒç”¨
     */
    scrollToActiveInput() {
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
            // é˜²æŠ–æœºåˆ¶ï¼Œé¿å…é‡å¤è°ƒç”¨
            if (this.scrollTimeout) {
                clearTimeout(this.scrollTimeout);
            }
            
            this.scrollTimeout = setTimeout(() => {
                // æ£€æŸ¥å…ƒç´ æ˜¯å¦å·²ç»åœ¨å¯è§†åŒºåŸŸå†…
                const rect = activeElement.getBoundingClientRect();
                const windowHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                const keyboardHeight = windowHeight - (window.visualViewport ? window.visualViewport.height : windowHeight);
                const availableHeight = windowHeight - keyboardHeight;
                
                // åªæœ‰å½“è¾“å…¥æ¡†ä¸åœ¨å¯è§†åŒºåŸŸæˆ–è¢«é”®ç›˜é®æŒ¡æ—¶æ‰æ»šåŠ¨
                const isVisible = rect.top >= 0 && rect.bottom <= availableHeight;
                const isPartiallyHidden = rect.bottom > availableHeight * 0.7; // å¦‚æœè¾“å…¥æ¡†åº•éƒ¨è¶…è¿‡å¯ç”¨é«˜åº¦çš„70%ï¼Œè®¤ä¸ºéœ€è¦è°ƒæ•´
                
                if (!isVisible || isPartiallyHidden) {
                    activeElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest', // æ”¹ä¸ºnearestï¼Œé¿å…è¿‡åº¦æ»šåŠ¨
                        inline: 'nearest'
                    });
                }
                
                this.scrollTimeout = null;
            }, 350); // ç¨å¾®å»¶é•¿ç­‰å¾…æ—¶é—´ï¼Œç¡®ä¿é”®ç›˜åŠ¨ç”»å®Œæˆ
        }
    }

    getSafeAreaTop() {
        // ä½¿ç”¨CSS env()è·å–safe areaï¼Œå¦‚æœä¸æ”¯æŒåˆ™è¿”å›é»˜è®¤å€¼
        const testEl = document.createElement('div');
        testEl.style.paddingTop = 'env(safe-area-inset-top)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaTop = parseInt(computedStyle.paddingTop) || 0;
        document.body.removeChild(testEl);
        return safeAreaTop;
    }

    getSafeAreaBottom() {
        const testEl = document.createElement('div');
        testEl.style.paddingBottom = 'env(safe-area-inset-bottom)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaBottom = parseInt(computedStyle.paddingBottom) || 0;
        document.body.removeChild(testEl);
        return safeAreaBottom;
    }

    getSafeAreaLeft() {
        const testEl = document.createElement('div');
        testEl.style.paddingLeft = 'env(safe-area-inset-left)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaLeft = parseInt(computedStyle.paddingLeft) || 0;
        document.body.removeChild(testEl);
        return safeAreaLeft;
    }

    getSafeAreaRight() {
        const testEl = document.createElement('div');
        testEl.style.paddingRight = 'env(safe-area-inset-right)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaRight = parseInt(computedStyle.paddingRight) || 0;
        document.body.removeChild(testEl);
        return safeAreaRight;
    }

    setInitialStyles() {
        // ç¡®ä¿bodyä½¿ç”¨å®Œæ•´è§†å£
        document.body.style.height = '100vh';
        document.body.style.height = 'var(--viewport-height, 100vh)';
    }
}

// === ä¸»é¢˜ç®¡ç†ç³»ç»Ÿ ===
class ThemeManager {
    constructor() {
        this.THEME_KEY = 'whale-llt-theme';
        this.themes = {
            system: 'system-theme',
            light: '',
            dark: 'dark-mode'
        };
        this.currentTheme = this.getStoredTheme();
        this.mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    }

    getStoredTheme() {
        return localStorage.getItem(this.THEME_KEY) || 'system';
    }

    setTheme(theme) {
        if (!this.themes.hasOwnProperty(theme)) {
            console.warn('æœªçŸ¥ä¸»é¢˜:', theme);
            return;
        }

        this.currentTheme = theme;
        localStorage.setItem(this.THEME_KEY, theme);
        this.applyTheme();
        this.updateThemeUI();
    }

    applyTheme() {
        const body = document.body;
        
        // ç§»é™¤æ‰€æœ‰ä¸»é¢˜ç±»
        Object.values(this.themes).forEach(className => {
            if (className) body.classList.remove(className);
        });

        // åº”ç”¨å½“å‰ä¸»é¢˜ç±»
        const themeClass = this.themes[this.currentTheme];
        if (themeClass) {
            body.classList.add(themeClass);
        }
    }

    updateThemeUI() {
        // æ›´æ–°ä¸»é¢˜åˆ‡æ¢æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
        const buttons = document.querySelectorAll('[data-theme]');
        buttons.forEach(btn => {
            if (btn.dataset.theme === this.currentTheme) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        console.log('ä¸»é¢˜UIå·²æ›´æ–°ï¼Œå½“å‰ä¸»é¢˜:', this.currentTheme);
    }

    init() {
        // ç«‹å³åº”ç”¨ä¸»é¢˜ï¼Œé¿å…é—ªçƒ
        this.applyTheme();
        
        // åˆå§‹åŒ–UIçŠ¶æ€
        this.updateThemeUI();
        
        // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
        this.mediaQuery.addEventListener('change', () => {
            if (this.currentTheme === 'system') {
                this.applyTheme();
            }
        });

        console.log('ä¸»é¢˜ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œå½“å‰ä¸»é¢˜:', this.currentTheme);
    }

    getCurrentTheme() {
        return this.currentTheme;
    }
}

// === æ•°æ®åº“ç›¸å…³UIç®¡ç†ç³»ç»Ÿ ===

class UIManager {
    constructor() {
        this.eventListeners = new Map();
        this.initializeEventListeners();
    }

    /**
     * åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
     */
    initializeEventListeners() {
        // ç›‘å¬æ•°æ®åº“äº‹ä»¶
        window.addEventListener('database:exportStart', () => {
            this.showMessage('æ­£åœ¨å¯¼å‡ºæ•°æ®åº“...', 'info');
        });

        window.addEventListener('database:exportSuccess', () => {
            this.showMessage('æ•°æ®åº“å¯¼å‡ºæˆåŠŸï¼', 'success');
        });

        window.addEventListener('database:exportError', (event) => {
            this.showMessage(`å¯¼å‡ºå¤±è´¥: ${event.detail.error}`, 'error');
        });

        window.addEventListener('database:importStart', () => {
            this.showMessage('æ­£åœ¨å¯¼å…¥æ•°æ®åº“...', 'info');
        });

        window.addEventListener('database:importSuccess', () => {
            this.showMessage('æ•°æ®åº“å¯¼å…¥æˆåŠŸï¼é¡µé¢å°†åœ¨3ç§’åè‡ªåŠ¨åˆ·æ–°...', 'success');
            setTimeout(() => window.location.reload(), 3000);
        });

        window.addEventListener('database:importError', (event) => {
            this.showMessage(`å¯¼å…¥å¤±è´¥: ${event.detail.error}`, 'error');
        });

        window.addEventListener('database:importConfirmationNeeded', async (event) => {
            const { file, resolve } = event.detail;
            const confirmed = await this.confirmDatabaseImport();
            resolve(confirmed);
        });

        window.addEventListener('database:repairNeeded', async (event) => {
            const { missingStores, resolve } = event.detail;
            const shouldRepair = await this.confirmDatabaseRepair(missingStores);
            resolve(shouldRepair);
        });

        window.addEventListener('database:repairSuccess', (event) => {
            this.showMessage(event.detail.message, 'success');
        });

        window.addEventListener('database:repairError', (event) => {
            this.showMessage(`æ•°æ®åº“ä¿®å¤å¤±è´¥: ${event.detail.error}`, 'error');
        });

        // ç›‘å¬å­˜å‚¨ç®¡ç†äº‹ä»¶
        window.addEventListener('storage:persistentGranted', (event) => {
            this.showMessage('æŒä¹…åŒ–å­˜å‚¨ç”³è¯·æˆåŠŸï¼æ•°æ®åº“å°†å—åˆ°æ›´å¥½ä¿æŠ¤', 'success');
            this.updatePersistentStatusIndicator(event.detail);
        });

        window.addEventListener('storage:persistentDenied', (event) => {
            this.showMessage('æŒä¹…åŒ–å­˜å‚¨ç”³è¯·è¢«æ‹’ç»ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®', 'warning');
            this.updatePersistentStatusIndicator(event.detail);
        });

        window.addEventListener('storage:persistentUnsupported', () => {
            this.showMessage('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæŒä¹…åŒ–å­˜å‚¨åŠŸèƒ½', 'warning');
        });

        window.addEventListener('storage:persistentError', (event) => {
            this.showMessage(`ç”³è¯·æŒä¹…åŒ–å­˜å‚¨å¤±è´¥: ${event.detail.error}`, 'error');
        });

        window.addEventListener('storage:statsRefreshNeeded', async () => {
            // è§¦å‘ç»Ÿè®¡ä¿¡æ¯åˆ·æ–°
            if (typeof window.refreshDatabaseStats === 'function') {
                await window.refreshDatabaseStats();
            }
        });

        // ç›‘å¬æ•°æ®åº“ç»Ÿè®¡åˆ·æ–°äº‹ä»¶
        window.addEventListener('database:statsRefreshStart', () => {
            this.updateRefreshButtonState(true);
        });

        window.addEventListener('database:statsRefreshSuccess', (event) => {
            const { result, persistentResult } = event.detail;
            this.updatePersistentStatusIndicator(persistentResult);
            this.updateDatabaseStats(result, persistentResult);
            this.updateRefreshButtonState(false);
        });

        window.addEventListener('database:statsRefreshError', (event) => {
            const { error } = event.detail;
            const statsContent = document.getElementById('databaseStatsContent');
            if (statsContent) {
                statsContent.innerHTML = `<div class="error">è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: ${error}</div>`;
            }
            this.updateRefreshButtonState(false);
        });

        // ç›‘å¬æ–‡ä»¶å¤„ç†å®Œæˆäº‹ä»¶ï¼Œæ¸…ç©ºæ–‡ä»¶è¾“å…¥
        window.addEventListener('database:fileProcessed', (event) => {
            const { inputId } = event.detail;
            if (inputId) {
                this.clearFileInput(inputId);
            }
        });

        // ç›‘å¬æ–‡ä»¶å­˜å‚¨å¯¼å‡ºé€‰é¡¹é¢æ¿æ“ä½œäº‹ä»¶
        window.addEventListener('fileStorage:hideExportOptions', () => {
            this.hideFileExportOptions();
        });

        // ç›‘å¬æ–‡ä»¶å­˜å‚¨å¯¼å…¥é€‰é¡¹è¯·æ±‚äº‹ä»¶
        window.addEventListener('fileStorage:importOptionsNeeded', async (event) => {
            const { resolve, messages } = event.detail;
            const options = await this.getFileStorageImportOptions(messages);
            resolve(options);
        });

        // ç›‘å¬æ–‡ä»¶å­˜å‚¨æ–‡ä»¶å¤„ç†å®Œæˆäº‹ä»¶ï¼Œæ¸…ç©ºæ–‡ä»¶è¾“å…¥
        window.addEventListener('fileStorage:fileProcessed', (event) => {
            const { inputId } = event.detail;
            if (inputId) {
                this.clearFileInput(inputId);
            }
        });

        // ç›‘å¬æ–‡ä»¶å­˜å‚¨å¯¼å‡ºé…ç½®è¯·æ±‚äº‹ä»¶
        window.addEventListener('fileStorage:exportConfigNeeded', (event) => {
            const { resolve } = event.detail;
            const config = this.getFileExportConfig();
            resolve(config);
        });
    }

    /**
     * æ˜¾ç¤ºæ¶ˆæ¯ç»™ç”¨æˆ·
     */
    showMessage(message, type = 'info') {
        if (typeof showToast === 'function') {
            showToast(message, type);
        } else {
            // é™çº§åˆ°åŸç”Ÿ alert
            alert(message);
        }
    }

    /**
     * æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
     */
    async showConfirmDialog(message, title = 'ç¡®è®¤') {
        return confirm(message);
    }

    /**
     * æ˜¾ç¤ºæ•°æ®åº“å¯¼å…¥ç¡®è®¤æµç¨‹
     */
    async confirmDatabaseImport() {
        const firstConfirmMessage = 'å¯¼å…¥æ•°æ®åº“å°†å®Œå…¨è¦†ç›–ç°æœ‰æ•°æ®ï¼\n\nè¿™å°†åˆ é™¤ï¼š\nâ€¢ æ‰€æœ‰èŠå¤©è®°å½•å’Œè”ç³»äºº\nâ€¢ ç”¨æˆ·èµ„æ–™å’Œè®¾ç½®\nâ€¢ æœ‹å‹åœˆåŠ¨æ€å’Œè®ºå›å¸–å­\nâ€¢ éŸ³ä¹åº“å’Œè¡¨æƒ…åŒ…\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ';
        
        if (!await this.showConfirmDialog(firstConfirmMessage)) {
            return false;
        }
        
        const secondConfirmMessage = 'è¿™æ˜¯æœ€åç¡®è®¤ï¼\n\nå¯¼å…¥æ“ä½œä¸å¯æ’¤é”€ï¼Œæ‰€æœ‰ç°æœ‰æ•°æ®å°†è¢«æ°¸ä¹…åˆ é™¤ã€‚\n\næ‚¨çœŸçš„ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ';
        
        return await this.showConfirmDialog(secondConfirmMessage);
    }

    /**
     * æ˜¾ç¤ºæ•°æ®åº“ä¿®å¤ç¡®è®¤
     */
    async confirmDatabaseRepair(missingStores) {
        const message = `æ£€æµ‹åˆ°æ•°æ®åº“ç»“æ„ä¸å®Œæ•´ï¼Œç¼ºå¤±ä»¥ä¸‹å­˜å‚¨:\n${missingStores.join(', ')}\n\næ˜¯å¦å°è¯•ä¿®å¤ï¼Ÿ`;
        return await this.showConfirmDialog(message, 'æ•°æ®åº“ä¿®å¤');
    }

    /**
     * æ˜¾ç¤ºæ–‡ä»¶å­˜å‚¨å¯¼å…¥é€‰é¡¹
     */
    async getFileStorageImportOptions(messages = null) {
        const overwriteMessage = messages?.overwrite || 
            'æ–‡ä»¶å­˜å‚¨å¯¼å…¥é€‰é¡¹ï¼š\n\nç‚¹å‡»"ç¡®å®š"è¦†ç›–ç°æœ‰æ–‡ä»¶\nç‚¹å‡»"å–æ¶ˆ"ä¿ç•™ç°æœ‰æ–‡ä»¶ï¼ˆä»…å¯¼å…¥æ–°æ–‡ä»¶ï¼‰\n\næ³¨æ„ï¼šè¦†ç›–æ¨¡å¼å°†åˆ é™¤æ‰€æœ‰ç°æœ‰çš„å¤´åƒã€èƒŒæ™¯ã€è¡¨æƒ…ç­‰æ–‡ä»¶ï¼';
        const overwrite = await this.showConfirmDialog(overwriteMessage);
        
        const missingMessage = messages?.skipMissing || 
            'å¯¹äºç¼ºå¤±çš„æ–‡ä»¶å¼•ç”¨ï¼š\n\nç‚¹å‡»"ç¡®å®š"è·³è¿‡ç¼ºå¤±çš„æ–‡ä»¶\nç‚¹å‡»"å–æ¶ˆ"å°è¯•åˆ›å»ºå ä½ç¬¦\n\nå»ºè®®é€‰æ‹©"ç¡®å®š"è·³è¿‡ç¼ºå¤±æ–‡ä»¶';
        const skipMissing = await this.showConfirmDialog(missingMessage);
        
        return { overwrite, skipMissing };
    }

    /**
     * è·å–æ–‡ä»¶å¯¼å‡ºé…ç½®
     */
    getFileExportConfig() {
        return {
            includeAvatars: this.getCheckboxValue('exportAvatars', true),
            includeBackgrounds: this.getCheckboxValue('exportBackgrounds', true),
            includeEmojis: this.getCheckboxValue('exportEmojis', true),
            includeMomentImages: this.getCheckboxValue('exportMomentImages', true),
            includeWeiboImages: this.getCheckboxValue('exportWeiboImages', true),
            includeUserBanner: this.getCheckboxValue('exportUserBanner', true)
        };
    }

    /**
     * è·å–å¤é€‰æ¡†å€¼çš„è¾…åŠ©æ–¹æ³•
     */
    getCheckboxValue(id, defaultValue = false) {
        const element = document.getElementById(id);
        return element ? element.checked : defaultValue;
    }

    /**
     * è§¦å‘æ–‡ä»¶é€‰æ‹©
     */
    triggerFileSelect(inputId = 'importFileInput') {
        const fileInput = document.getElementById(inputId);
        if (fileInput) {
            fileInput.click();
        } else {
            this.showMessage(`æœªæ‰¾åˆ°æ–‡ä»¶è¾“å…¥å…ƒç´ ï¼š${inputId}`, 'error');
        }
    }

    /**
     * æ˜¾ç¤º/éšè—æ¨¡æ€æ¡†
     */
    showModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }
    }

    hideModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.add('hidden');
            document.body.style.overflow = '';
        }
    }

    /**
     * æ˜¾ç¤ºæŒä¹…åŒ–å­˜å‚¨ä¿¡æ¯æ¨¡æ€æ¡†
     */
    showPersistentStorageInfo() {
        this.showModal('persistentStorageInfoModal');
    }

    /**
     * éšè—æŒä¹…åŒ–å­˜å‚¨ä¿¡æ¯æ¨¡æ€æ¡†
     */
    hidePersistentStorageInfo() {
        this.hideModal('persistentStorageInfoModal');
    }

    /**
     * æ›´æ–°æŒä¹…åŒ–çŠ¶æ€æŒ‡ç¤ºå™¨
     */
    updatePersistentStatusIndicator(persistentResult) {
        const persistentIndicator = document.getElementById('persistentStatusIndicator');
        if (!persistentIndicator) return;

        let status = 'unknown';
        let content = 'â“çŠ¶æ€æœªçŸ¥';
        
        if (persistentResult.success) {
            if (persistentResult.isPersistent) {
                status = 'persistent';
                content = 'ğŸ‰ğŸŸ¢æ•°æ®å·²æŒä¹…å­˜å‚¨';
            } else {
                status = 'not-persistent';
                content = 'â¤ï¸â€ğŸ©¹ğŸŸ¡æ•°æ®æœªæŒä¹…å­˜å‚¨';
            }
        }
        
        persistentIndicator.dataset.status = status;
        persistentIndicator.innerHTML = content;
    }

    /**
     * æ›´æ–°æ•°æ®åº“ç»Ÿè®¡æ˜¾ç¤º
     */
    updateDatabaseStats(result, persistentResult) {
        const statsContent = document.getElementById('databaseStatsContent');
        if (!statsContent) return;

        if (result.success) {
            const stats = result.stats;
            let statsHtml = '';
            
            const storeLabels = {
                'contacts': 'è”ç³»äºº/ç¾¤èŠ',
                'songs': 'éŸ³ä¹æ–‡ä»¶', 
                'apiSettings': 'APIè®¾ç½®',
                'emojis': 'è¡¨æƒ…åŒ…',
                'emojiImages': 'è¡¨æƒ…å›¾ç‰‡',
                'backgrounds': 'èŠå¤©èƒŒæ™¯',
                'userProfile': 'ç”¨æˆ·èµ„æ–™',
                'moments': 'æœ‹å‹åœˆ',
                'weiboPosts': 'è®ºå›å¸–å­',
                'hashtagCache': 'è¯é¢˜ç¼“å­˜',
                'characterMemories': 'è§’è‰²è®°å¿†',
                'globalMemory': 'å…¨å±€è®°å¿†',
                'conversationCounters': 'å¯¹è¯è®¡æ•°å™¨',
                'memoryProcessedIndex': 'è®°å¿†å¤„ç†ç´¢å¼•',
                'fileStorage': 'æ–‡ä»¶å­˜å‚¨',
                'fileReferences': 'æ–‡ä»¶å¼•ç”¨',
                'themeConfig': 'ä¸»é¢˜é…ç½®'
            };
            
            for (const [storeName, count] of Object.entries(stats)) {
                const displayName = storeLabels[storeName] || storeName;
                statsHtml += `<div class="stat-item">
                    <span class="stat-name">${displayName}</span>
                    <span class="stat-count">${count} æ¡è®°å½•</span>
                </div>`;
            }
            
            // æ·»åŠ æŒä¹…åŒ–å­˜å‚¨çŠ¶æ€ä¿¡æ¯
            if (persistentResult && persistentResult.success && persistentResult.estimate) {
                const estimate = persistentResult.estimate;
                const usedMB = estimate.usage ? (estimate.usage / 1024 / 1024).toFixed(2) : 'æœªçŸ¥';
                const quotaMB = estimate.quota ? (estimate.quota / 1024 / 1024).toFixed(2) : 'æœªçŸ¥';
                
                statsHtml += `
                <div class="storage-info">
                    <div class="stat-item">
                        <span class="stat-name">å­˜å‚¨ä½¿ç”¨é‡</span>
                        <span class="stat-count">${usedMB} MB</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-name">å­˜å‚¨é…é¢</span>
                        <span class="stat-count">${quotaMB} MB</span>
                    </div>
                </div>`;
            }
            
            statsContent.innerHTML = statsHtml;
            
        } else {
            statsContent.innerHTML = `<div class="error">è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: ${result.error}</div>`;
        }
    }

    /**
     * æ›´æ–°åˆ·æ–°æŒ‰é’®çŠ¶æ€
     */
    updateRefreshButtonState(isLoading, buttonSelector = '.refresh-stats-btn') {
        const refreshBtn = document.querySelector(buttonSelector);
        if (refreshBtn) {
            refreshBtn.textContent = isLoading ? 'åˆ·æ–°ä¸­...' : 'åˆ·æ–°ç»Ÿè®¡';
            refreshBtn.disabled = isLoading;
        }
    }

    /**
     * æ˜¾ç¤º/éšè—æ–‡ä»¶å¯¼å‡ºé€‰é¡¹é¢æ¿
     */
    showFileExportOptions() {
        const optionsPanel = document.getElementById('fileExportOptions');
        if (optionsPanel) {
            optionsPanel.style.display = 'block';
        }
    }

    hideFileExportOptions() {
        const optionsPanel = document.getElementById('fileExportOptions');
        if (optionsPanel) {
            optionsPanel.style.display = 'none';
        }
    }

    /**
     * éªŒè¯æ–‡ä»¶ç±»å‹
     */
    validateFileType(file, expectedExtensions = ['.zip']) {
        const fileName = file.name.toLowerCase();
        const isValid = expectedExtensions.some(ext => fileName.endsWith(ext));
        
        if (!isValid) {
            const expectedTypes = expectedExtensions.join(', ');
            this.showMessage(`è¯·é€‰æ‹© ${expectedTypes} æ ¼å¼çš„æ–‡ä»¶`, 'error');
        }
        
        return isValid;
    }

    /**
     * æ¸…ç©ºæ–‡ä»¶è¾“å…¥
     */
    clearFileInput(inputId) {
        const input = document.getElementById(inputId);
        if (input) {
            input.value = '';
        }
    }

    /**
     * è§¦å‘æ–‡ä»¶é€‰æ‹© - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    triggerFileSelect(inputId = 'importFileInput') {
        const fileInput = document.getElementById(inputId);
        if (fileInput) {
            fileInput.click();
        } else {
            this.showMessage(`æœªæ‰¾åˆ°æ–‡ä»¶è¾“å…¥å…ƒç´ ï¼š${inputId}`, 'error');
        }
    }

    /**
     * è§¦å‘æ–‡ä»¶å­˜å‚¨å¯¼å…¥ - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    triggerFileStorageImport(inputId = 'fileStorageImportInput') {
        const fileInput = document.getElementById(inputId);
        if (fileInput) {
            fileInput.click();
        } else {
            this.showMessage(`æœªæ‰¾åˆ°æ–‡ä»¶å­˜å‚¨å¯¼å…¥è¾“å…¥å…ƒç´ ï¼š${inputId}`, 'error');
        }
    }

    /**
     * åˆ·æ–°æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯ - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    async refreshDatabaseStats() {
        // This will trigger the events that the UIManager is listening to.
        await window.AppDB.refreshDatabaseStats();
    }

    /**
     * å¤„ç†æ–‡ä»¶é€‰æ‹© - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    async handleFileSelect(event) {
        // Call the business logic function which will dispatch events for UI updates.
        await window.AppDB.handleFileSelect(event);
    }

    /**
     * ç¡®è®¤æ–‡ä»¶å¯¼å‡º - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    async confirmFileExport() {
        await window.AppDB.confirmFileExport();
    }

    /**
     * å–æ¶ˆæ–‡ä»¶å¯¼å‡º - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    cancelFileExport() {
        window.AppDB.cancelFileExport();
    }

    /**
     * å¤„ç†æ–‡ä»¶å­˜å‚¨é€‰æ‹© - ä»UnifiedDBManager.jsç§»åŠ¨è¿‡æ¥çš„UIé€»è¾‘
     */
    async handleFileStorageSelect(event) {
        // Call the business logic function which will dispatch events for UI updates.
        await window.AppDB.handleFileStorageSelect(event);
    }
}

// === è¾“å…¥å¤„ç†å’Œæµè§ˆå™¨å…¼å®¹æ€§ç³»ç»Ÿ ===

// æµè§ˆå™¨å…¼å®¹æ€§æ£€æµ‹
function checkBrowserCompatibility() {
    // æ£€æµ‹æµè§ˆå™¨æ˜¯å¦æ”¯æŒ :has() é€‰æ‹©å™¨
    let supportsHas = false;
    
    try {
        // å°è¯•åˆ›å»ºä¸€ä¸ªä½¿ç”¨ :has() çš„CSSè§„åˆ™æ¥æµ‹è¯•æ”¯æŒæ€§
        const testRule = document.createElement('style');
        testRule.textContent = 'body:has(div) { color: inherit; }';
        document.head.appendChild(testRule);
        
        // æ£€æŸ¥è§„åˆ™æ˜¯å¦è¢«æ­£ç¡®è§£æ
        supportsHas = testRule.sheet && testRule.sheet.cssRules.length > 0;
        
        // æ¸…ç†æµ‹è¯•å…ƒç´ 
        document.head.removeChild(testRule);
    } catch (e) {
        // å¦‚æœå‡ºç°é”™è¯¯ï¼Œè¯´æ˜ä¸æ”¯æŒ
        supportsHas = false;
    }
    
    // å¦‚æœä¸æ”¯æŒ :has()ï¼Œä¸ºbodyæ·»åŠ æ ‡è¯†ç±»ä»¥å¯ç”¨JavaScriptå¤‡ç”¨æ–¹æ¡ˆ
    if (!supportsHas) {
        document.body.classList.add('no-has-support');
        console.log('æ£€æµ‹åˆ°æµè§ˆå™¨ä¸æ”¯æŒ :has() é€‰æ‹©å™¨ï¼Œå·²å¯ç”¨JavaScriptå¤‡ç”¨æ–¹æ¡ˆ');
    } else {
        console.log('æµè§ˆå™¨æ”¯æŒ :has() é€‰æ‹©å™¨');
    }
    
    // å°†æ”¯æŒçŠ¶æ€å­˜å‚¨ä¸ºå…¨å±€å˜é‡ï¼Œä¾›å…¶ä»–å‡½æ•°ä½¿ç”¨
    window.browserSupportsHas = supportsHas;
}

// å®‰å…¨èšç„¦å·¥å…·å‡½æ•°
function safeFocus(element, options = {}) {
    if (!element || typeof element.focus !== 'function') return;
    
    const {
        preventScroll = false,
        delay = 0,
        smooth = true
    } = options;
    
    // é˜²æŠ–æœºåˆ¶ï¼šå¦‚æœelementå·²ç»æ˜¯activeElementï¼Œé¿å…é‡å¤æ“ä½œ
    if (document.activeElement === element) return;
    
    const focusAction = () => {
        try {
            // å¦‚æœå…ƒç´ ä¸åœ¨å¯è§†åŒºåŸŸï¼Œå…ˆèšç„¦ä½†é˜»æ­¢æ»šåŠ¨
            element.focus({ preventScroll: true });
            
            // å¦‚æœéœ€è¦æ»šåŠ¨åˆ°å¯è§†åŒºåŸŸï¼Œä½¿ç”¨viewportManagerçš„æ–¹æ³•
            if (!preventScroll && window.UIManager && window.UIManager.viewportManager) {
                // å»¶è¿Ÿä¸€ä¸‹ï¼Œè®©focusäº‹ä»¶å…ˆå®Œæˆ
                setTimeout(() => {
                    window.UIManager.viewportManager.scrollToActiveInput();
                }, 50);
            }
        } catch (error) {
            console.warn('Focus operation failed:', error);
        }
    };
    
    if (delay > 0) {
        setTimeout(focusAction, delay);
    } else {
        focusAction();
    }
}

// å±è”½é•¿æŒ‰é€‰æ‹©å’Œä¸Šä¸‹æ–‡èœå•ç³»ç»Ÿ
function initializeLongPressBlocking() {
    // å±è”½ä¸Šä¸‹æ–‡èœå•ï¼ˆå³é”®èœå•å’Œé•¿æŒ‰èœå•ï¼‰
    document.addEventListener('contextmenu', function(e) {
        // å…è®¸è¾“å…¥æ¡†çš„ä¸Šä¸‹æ–‡èœå•
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
    }, { passive: false });

    // å±è”½é€‰æ‹©å¼€å§‹äº‹ä»¶
    document.addEventListener('selectstart', function(e) {
        // å…è®¸è¾“å…¥æ¡†çš„é€‰æ‹©
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
    }, { passive: false });

    // å±è”½æ‹–æ‹½å¼€å§‹äº‹ä»¶ï¼ˆæŸäº›æƒ…å†µä¸‹é•¿æŒ‰ä¼šè§¦å‘ï¼‰
    document.addEventListener('dragstart', function(e) {
        // å…è®¸è¾“å…¥æ¡†å†…å®¹çš„æ‹–æ‹½
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
    }, { passive: false });

    // iOS Safari ç‰¹æ®Šå¤„ç†ï¼šå±è”½é•¿æŒ‰é«˜äº®
    let longPressTimer = null;
    let touchStartTime = 0;
    let touchTarget = null;
    
    document.addEventListener('touchstart', function(e) {
        // è¾“å…¥æ¡†å…è®¸æ­£å¸¸è¡Œä¸º
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        
        touchTarget = e.target;
        touchStartTime = Date.now();
        longPressTimer = setTimeout(() => {
            // åªæœ‰å½“å‰æ´»è·ƒå…ƒç´ ä¸æ˜¯è¾“å…¥æ¡†æ—¶æ‰blur
            if (document.activeElement && 
                document.activeElement.tagName !== 'INPUT' && 
                document.activeElement.tagName !== 'TEXTAREA' && 
                document.activeElement.contentEditable !== 'true') {
                document.activeElement.blur();
            }
            // åªæ¸…é™¤éè¾“å…¥æ¡†çš„é€‰æ‹©
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                
                if (element && 
                    element.tagName !== 'INPUT' && 
                    element.tagName !== 'TEXTAREA' && 
                    element.contentEditable !== 'true' &&
                    !element.closest('input, textarea, [contenteditable="true"]')) {
                    selection.removeAllRanges();
                }
            }
        }, 500); // 500ms åç®—ä½œé•¿æŒ‰
    }, { passive: true });

    document.addEventListener('touchend', function(e) {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        touchTarget = null;
    }, { passive: true });

    document.addEventListener('touchmove', function(e) {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, { passive: true });

    // é¢å¤–ä¿æŠ¤ï¼šæ¸…é™¤ä»»ä½•æ„å¤–çš„é€‰æ‹©ï¼ˆä½†ä¸å¹²æ‰°æ­£åœ¨äº¤äº’çš„è¾“å…¥æ¡†ï¼‰
    setInterval(() => {
        // å¦‚æœå½“å‰æœ‰è¾“å…¥æ¡†èšç„¦ï¼Œè·³è¿‡æ¸…ç†
        if (document.activeElement && (
            document.activeElement.tagName === 'INPUT' || 
            document.activeElement.tagName === 'TEXTAREA' || 
            document.activeElement.contentEditable === 'true')) {
            return;
        }
        
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const container = range.commonAncestorContainer;
            const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
            
            // å¦‚æœé€‰æ‹©çš„ä¸æ˜¯è¾“å…¥æ¡†å†…å®¹ï¼Œå°±æ¸…é™¤é€‰æ‹©
            if (element && 
                element.tagName !== 'INPUT' && 
                element.tagName !== 'TEXTAREA' && 
                element.contentEditable !== 'true' &&
                !element.closest('input, textarea, [contenteditable="true"]')) {
                selection.removeAllRanges();
            }
        }
    }, 200); // é™ä½é¢‘ç‡ï¼Œå‡å°‘å¯¹æ€§èƒ½çš„å½±å“
}

// ä¸»é¢˜åˆ‡æ¢å‡½æ•°ï¼ˆå…¨å±€å‡½æ•°ï¼‰
function switchTheme(theme) {
    window.UIManager.themeManager.setTheme(theme);
    
    // æä¾›ç”¨æˆ·åé¦ˆ
    const themeNames = {
        system: 'è·Ÿéšç³»ç»Ÿ',
        light: 'äº®è‰²æ¨¡å¼', 
        dark: 'æš—é»‘æ¨¡å¼'
    };
    
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ toastæç¤ºï¼Œä½†ç°åœ¨å…ˆä¸æ·»åŠ ä»¥å…å¹²æ‰°ç”¨æˆ·
    console.log(`å·²åˆ‡æ¢åˆ°${themeNames[theme]}ä¸»é¢˜`);
}

// è·å–å½“å‰ä¸»é¢˜ï¼ˆå…¨å±€å‡½æ•°ï¼‰
function getCurrentTheme() {
    return window.UIManager.themeManager.getCurrentTheme();
}

// åˆ›å»ºå…¨å±€UIç®¡ç†å™¨å®ä¾‹
const uiManager = new UIManager();

// å¯¼å‡ºåˆ°windowå¯¹è±¡ä»¥ä¾¿å…¶ä»–æ¨¡å—ä½¿ç”¨
if (typeof window !== 'undefined') {
    // åˆ›å»ºç»Ÿä¸€çš„UIç®¡ç†å™¨å‘½åç©ºé—´
    window.UIManager = {
        // ç®¡ç†å™¨å®ä¾‹
        viewportManager: new ViewportManager(),
        themeManager: new ThemeManager(),
        
        // å·¥å…·å‡½æ•°
        safeFocus,
        switchTheme,
        getCurrentTheme,
        checkBrowserCompatibility,
        initializeLongPressBlocking
    };
    
    // æ•°æ®åº“ç›¸å…³UIç®¡ç†å™¨å®ä¾‹
    window.uiManager = uiManager;
    
    // ä¸ºäº†å‘åå…¼å®¹ï¼Œä¿ç•™ä¸€äº›å…³é”®çš„å…¨å±€å¼•ç”¨
    window.viewportManager = window.UIManager.viewportManager;
    window.themeManager = window.UIManager.themeManager;
    window.switchTheme = switchTheme;
    window.getCurrentTheme = getCurrentTheme;
    
    // æ•°æ®åº“UIåŠŸèƒ½çš„å…¨å±€å¼•ç”¨ï¼ˆå‘åå…¼å®¹ï¼‰
    window.refreshDatabaseStats = () => uiManager.refreshDatabaseStats();
    window.handleFileSelect = (event) => uiManager.handleFileSelect(event);
    window.confirmFileExport = () => uiManager.confirmFileExport();
    window.cancelFileExport = () => uiManager.cancelFileExport();
    window.handleFileStorageImport = (event) => uiManager.handleFileStorageSelect(event);
    
    // æ–‡ä»¶è§¦å‘å‡½æ•°
    window.triggerFileSelect = () => uiManager.triggerFileSelect();
    window.triggerFileStorageImport = () => uiManager.triggerFileStorageImport();
    
    // è‡ªåŠ¨åˆå§‹åŒ–
    window.UIManager.themeManager.init();
    window.UIManager.checkBrowserCompatibility();
    
    // åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–é•¿æŒ‰å±è”½
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.UIManager.initializeLongPressBlocking);
    } else {
        window.UIManager.initializeLongPressBlocking();
    }
    
    console.log('ğŸ¨ [UIManager] ViewportManagerå·²æ¢å¤ï¼Œè´Ÿè´£å¤„ç†ç§»åŠ¨ç«¯è§†å£ç®¡ç†å’Œé”®ç›˜å¼¹å‡ºé€‚é…');
    console.log('ğŸ¨ [UIManager] UIç®¡ç†å™¨å·²åˆ›å»ºï¼Œè´Ÿè´£å¤„ç†æ‰€æœ‰ç”¨æˆ·ç•Œé¢äº¤äº’');
}

// ES Moduleå¯¼å‡ºï¼ˆå¦‚æœæ”¯æŒï¼‰
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { UIManager, uiManager };
}
</script>
    <script>
class APIService {
    constructor() {
        this.maxRetries = 3;
        this.baseDelay = 1000;
    }

    /**
     * ä»AIè¿”å›çš„æ–‡æœ¬ä¸­æå–å®Œæ•´çš„JSONå¯¹è±¡ã€‚
     * è‡ªåŠ¨æ¸…ç†markdownä»£ç å—æ ‡è®°å’Œå…¶ä»–å¹²æ‰°æ–‡æœ¬ã€‚
     * @param {string} text - AIè¿”å›çš„åŸå§‹æ–‡æœ¬ã€‚
     * @returns {string} æå–å‡ºçš„çº¯JSONå­—ç¬¦ä¸²ã€‚
     */
    extractJSON(text) {
        if (!text || typeof text !== 'string') {
            throw new Error('æ— æ•ˆçš„æ–‡æœ¬å†…å®¹');
        }

        // 1. ä¼˜å…ˆæå– markdown ä»£ç å—ä¸­çš„ JSON
        const codeBlockMatch = text.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/i);
        if (codeBlockMatch) {
            return codeBlockMatch[1].trim();
        }

        // 2. å°è¯•ä»é¦–ä¸ª{åˆ°æœ€åä¸€ä¸ª}æˆªå–
        const firstBrace = text.indexOf('{');
        const lastBrace = text.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            const possibleJson = text.substring(firstBrace, lastBrace + 1);
            // éªŒè¯è¿™æ˜¯å¦æ˜¯æœ‰æ•ˆçš„JSON
            try {
                JSON.parse(possibleJson);
                return possibleJson;
            } catch (_) {
                // å¦‚æœè§£æå¤±è´¥ï¼Œç»§ç»­å°è¯•å…œåº•æ–¹æ¡ˆ
            }
        }
        
        // 3. å…œåº•è¿”å›åŸå§‹æ–‡æœ¬ï¼Œè®©è°ƒç”¨è€…å¤„ç†
        return text.trim();
    }

    /**
     * é€šç”¨çš„OpenAIå…¼å®¹APIè°ƒç”¨å‡½æ•°ã€‚
     * @param {string} apiUrl - APIåœ°å€ã€‚
     * @param {string} apiKey - APIå¯†é’¥ã€‚
     * @param {string} model - æ¨¡å‹åç§°ã€‚
     * @param {Array} messages - æ¶ˆæ¯æ•°ç»„ã€‚
     * @param {Object} options - é¢å¤–é€‰é¡¹ (å¦‚ temperature, top_p ç­‰)ã€‚
     * @param {number} timeout - è¶…æ—¶æ—¶é—´(æ¯«ç§’)ï¼Œé»˜è®¤60ç§’ã€‚
     * @returns {Promise<Object>} è¿”å›APIå“åº”çš„JSONå¯¹è±¡ã€‚
     */
    async callOpenAIAPI(apiUrl, apiKey, model, messages, options = {}, timeout = 60000) {
        console.log(`[APIè°ƒç”¨] callOpenAIAPIè¢«è°ƒç”¨:`, {
            apiUrl: apiUrl.substring(0, 30) + '...',
            apiKey: apiKey ? apiKey.substring(0, 10) + '...' : 'null',
            model,
            messagesCount: messages.length
        });

        // è‡ªåŠ¨è®¾ç½® deepseek æ¨¡å‹çš„ max_tokens ä¸º 8100
        if (model && model.toLowerCase().includes('deepseek')) {
            options = { ...options, max_tokens: 8100 };
            console.log(`[APIè°ƒç”¨] æ£€æµ‹åˆ° deepseek æ¨¡å‹ï¼Œè‡ªåŠ¨è®¾ç½® max_tokens ä¸º 8100`);
        }

        const payload = { model, messages, ...options, stream: false };

        let success = false;
        let shouldRecord = true;
        let resultData = null;

        try {
            for (let i = 0; i < this.maxRetries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);

                    const response = await fetch(apiUrl + '/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`,
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        if (response.status === 504) {
                            const errorBody = await response.text();
                            console.error('ERROR: APIç½‘å…³è¶…æ—¶ (504) - å®Œæ•´è¿”å›:', errorBody);
                            throw new Error('è¯·æ±‚è¶…æ—¶(504): æ¨¡å‹å“åº”æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¨åé‡è¯•');
                        }
                        const errorBody = await response.text().catch(() => `[æ— æ³•è§£æçš„é”™è¯¯å“åº”]`);
                        console.error('ERROR: APIè¯·æ±‚å¤±è´¥ - å®Œæ•´è¿”å›:', errorBody);
                        throw new Error(`API Error (${response.status}): ${errorBody || response.statusText}`);
                    }

                    const responseText = await response.text();
                    console.log('APIåŸå§‹å“åº”:', responseText);

                    try {
                        const data = JSON.parse(responseText);
                        console.log('APIè§£æä¸ºJSONæˆåŠŸ:', JSON.stringify(data, null, 2));

                        if (data.usage && data.usage.completion_tokens === 0) {
                            console.error('ERROR: APIè¿”å›ç©ºå›å¤ (completion_tokens=0) - å®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
                            throw new Error('APIé”™è¯¯ï¼šAPIå“åº”ï¼Œä½†AIç©ºå›å¤äº†ã€‚å¯èƒ½æ˜¯æ¨¡å‹é—®é¢˜ã€è¢«æˆªæ–­æˆ–APIæä¾›å•†é—®é¢˜ã€‚è¯·ç¨åé‡è¯•ã€‚');
                        }

                        success = true;
                        resultData = data;
                        break; // æˆåŠŸï¼Œè·³å‡ºé‡è¯•å¾ªç¯
                    } catch (parseError) {
                        console.log('JSONè§£æå¤±è´¥ï¼Œä½œä¸ºçº¯æ–‡æœ¬å¤„ç†:', parseError.message);
                        if (!responseText || responseText.trim() === '') {
                            throw new Error('APIè¿”å›ç©ºå“åº”');
                        }
                        // å°†åŸå§‹æ–‡æœ¬åŒ…è£…æˆæ ‡å‡†OpenAIæ ¼å¼
                        success = true;
                        resultData = {
                            choices: [{
                                message: { content: responseText.trim(), role: 'assistant' },
                                finish_reason: 'stop'
                            }],
                            usage: {
                                completion_tokens: responseText.length,
                                prompt_tokens: 0,
                                total_tokens: responseText.length
                            }
                        };
                        break; // æˆåŠŸï¼Œè·³å‡ºé‡è¯•å¾ªç¯
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('è¯·æ±‚è¶…æ—¶: æ¨¡å‹å“åº”æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¨åé‡è¯•');
                    }
                    if (i < this.maxRetries - 1) {
                        const delay = this.baseDelay * Math.pow(2, i);
                        console.log(`ç¬¬ ${i + 1} æ¬¡å°è¯•å¤±è´¥ï¼Œå°†åœ¨ ${delay}ms åé‡è¯•...`);
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        throw error; // æ‰€æœ‰é‡è¯•å‡å¤±è´¥ï¼ŒæŠ›å‡ºæœ€åä¸€æ¬¡çš„é”™è¯¯
                    }
                }
            }
        } catch (error) {
            // è®°å½•å¤±è´¥çš„APIè°ƒç”¨
            if (shouldRecord && window.apiConfigManager) {
                try {
                    console.log(`[APIç»Ÿè®¡] APIè°ƒç”¨å¤±è´¥ï¼Œè®°å½•å¤±è´¥ç»Ÿè®¡: ${error.message}`);
                    const configId = window.apiConfigManager.activeConfigId || 'unknown';
                    const config = window.apiConfigManager.activeConfigId
                        ? await window.apiConfigManager.getConfigById(window.apiConfigManager.activeConfigId)
                        : null;
                    if (config) {
                        let keyIndex = -1;
                        if (config.apiKeys && config.apiKeys.length > 0) {
                            keyIndex = config.apiKeys.findIndex(k => k.key === apiKey && k.enabled);
                        }
                        if (keyIndex === -1 && config.key === apiKey) keyIndex = 0;
                        if (keyIndex !== -1) {
                            window.apiConfigManager.recordCall(configId, keyIndex, apiKey, false);
                        }
                    }
                } catch (recordError) {
                    console.warn('è®°å½•APIè°ƒç”¨å¤±è´¥ç»Ÿè®¡å¤±è´¥:', recordError);
                }
            }
            throw error; // é‡æ–°æŠ›å‡ºåŸå§‹é”™è¯¯
        }

        // è®°å½•æˆåŠŸçš„APIè°ƒç”¨
        if (success && shouldRecord && window.apiConfigManager) {
            try {
                console.log(`[APIç»Ÿè®¡] APIè°ƒç”¨æˆåŠŸï¼Œè®°å½•æˆåŠŸç»Ÿè®¡ã€‚`);
                const configId = window.apiConfigManager.activeConfigId || 'unknown';
                const config = window.apiConfigManager.activeConfigId
                    ? await window.apiConfigManager.getConfigById(window.apiConfigManager.activeConfigId)
                    : null;
                if (config) {
                    let keyIndex = -1;
                    if (config.apiKeys && config.apiKeys.length > 0) {
                        keyIndex = config.apiKeys.findIndex(k => k.key === apiKey && k.enabled);
                    }
                    if (keyIndex === -1 && config.key === apiKey) keyIndex = 0;
                    if (keyIndex !== -1) {
                        window.apiConfigManager.recordCall(configId, keyIndex, apiKey, true);
                    }
                }
            } catch (err) {
                console.warn('è®°å½•APIè°ƒç”¨æˆåŠŸç»Ÿè®¡å¤±è´¥:', err);
            }
        }

        if (success) {
            return resultData;
        }
        
        // å¦‚æœå¾ªç¯ç»“æŸéƒ½æ²¡æœ‰æˆåŠŸï¼Œåˆ™æŠ›å‡ºé€šç”¨é”™è¯¯
        throw new Error('APIè°ƒç”¨æœ€ç»ˆå¤±è´¥');
    }

    /**
     * æµ‹è¯•APIè¿æ¥ã€‚
     * @param {string} apiUrl - APIåœ°å€ã€‚
     * @param {string} apiKey - APIå¯†é’¥ã€‚
     * @returns {Promise<Object>} è¿æ¥æµ‹è¯•ç»“æœã€‚
     */
    async testConnection(apiUrl, apiKey) {
        try {
            const response = await fetch(apiUrl + '/models', {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36'
                }
            });
            if (!response.ok) {
                const errorBody = await response.text();
                console.error('ERROR: APIæµ‹è¯•è¿æ¥å¤±è´¥ - å®Œæ•´è¿”å›:', errorBody);
                throw new Error(`API Error: ${errorBody}`);
            }
            const data = await response.json();
            console.log('APIæµ‹è¯•è¿æ¥å®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            return data;
        } catch (error) {
            throw new Error(`è¿æ¥å¤±è´¥: ${error.message}`);
        }
    }
}

// UMD é£æ ¼å¯¼å‡º + å…¨å±€å®ä¾‹
if (typeof module !== 'undefined' && module.exports) {
    module.exports = APIService;
}
if (typeof window !== 'undefined') {
    window.APIService = APIService;
    if (!window.apiService) {
        window.apiService = new APIService();
    }
}
</script>
    <script>
/**
 * Color Utilities
 * é¢œè‰²å¤„ç†ç›¸å…³çš„å®ç”¨å·¥å…·å‡½æ•°
 */

/**
 * éªŒè¯åå…­è¿›åˆ¶é¢œè‰²æ ¼å¼æ˜¯å¦æœ‰æ•ˆ
 * @param {string} color - åå…­è¿›åˆ¶é¢œè‰²å€¼ (å¦‚: #FF0000)
 * @returns {boolean} æ˜¯å¦ä¸ºæœ‰æ•ˆçš„åå…­è¿›åˆ¶é¢œè‰²
 */
function isValidHexColor(color) {
    return /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºRGBAæ ¼å¼
 * @param {string} hex - åå…­è¿›åˆ¶é¢œè‰²å€¼ (å¦‚: #FF0000)  
 * @param {number} alpha - é€æ˜åº¦ (0-1)
 * @returns {string} RGBAé¢œè‰²å­—ç¬¦ä¸² (å¦‚: rgba(255, 0, 0, 0.5))
 */
function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * åŠ æ·±é¢œè‰² - é€šè¿‡ç™¾åˆ†æ¯”é™ä½RGBå€¼
 * @param {string} hex - åå…­è¿›åˆ¶é¢œè‰²å€¼ (å¦‚: #FF0000)
 * @param {number} percent - åŠ æ·±çš„ç™¾åˆ†æ¯” (0-1ï¼Œ0.2è¡¨ç¤ºåŠ æ·±20%)
 * @returns {string} åŠ æ·±åçš„åå…­è¿›åˆ¶é¢œè‰²å€¼
 */
function darkenColor(hex, percent) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    const newR = Math.round(r * (1 - percent));
    const newG = Math.round(g * (1 - percent));
    const newB = Math.round(b * (1 - percent));
    
    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
}

/**
 * éªŒè¯é¢œè‰²è¾“å…¥æ¡†å¹¶æ›´æ–°æŒ‰é’®çŠ¶æ€
 * @param {HTMLInputElement} input - é¢œè‰²è¾“å…¥æ¡†å…ƒç´ 
 * @param {HTMLButtonElement} button - å…³è”çš„æŒ‰é’®å…ƒç´ 
 */
function validateColorInput(input, button) {
    const isValid = isValidHexColor(input.value);
    button.disabled = !isValid;
    
    if (isValid) {
        input.classList.remove('invalid');
    } else {
        input.classList.add('invalid');
    }
}

/**
 * åº”ç”¨å•è‰²ä¸»é¢˜åˆ°é¡µé¢
 * @param {string} color - ä¸»é¢˜è‰²çš„åå…­è¿›åˆ¶å€¼
 */
function applyThemeColor(color) {
    // ç¦ç”¨æ¸å˜æ¨¡å¼
    document.body.classList.remove('gradient-mode');
    
    // è®¡ç®—è¾…åŠ©é¢œè‰²
    const lightColor = hexToRgba(color, 0.1);
    const hoverColor = darkenColor(color, 0.1);
    
    // è®¡ç®—æ¬¡è¦è‰²çš„äº¤äº’çŠ¶æ€ï¼ˆç”¨äºæ¨¡æ€æ¡†ã€ä¿¡æ¯æŒ‰é’®ç­‰UIå…ƒç´ ï¼‰
    const secondaryColor = '#1890ff'; // å›ºå®šçš„æ¬¡è¦è‰²
    const secondaryHover = darkenColor(secondaryColor, 0.15);
    const secondaryActive = darkenColor(secondaryColor, 0.25);
    
    // æ›´æ–°CSSå˜é‡
    document.documentElement.style.setProperty('--theme-primary', color);
    document.documentElement.style.setProperty('--theme-primary-light', lightColor);
    document.documentElement.style.setProperty('--theme-primary-hover', hoverColor);
    document.documentElement.style.setProperty('--theme-secondary-hover', secondaryHover);
    document.documentElement.style.setProperty('--theme-secondary-active', secondaryActive);
    document.documentElement.style.setProperty('--use-gradient', '0');
    
    // æ›´æ–°metaæ ‡ç­¾ä¸­çš„ä¸»é¢˜è‰²ï¼ˆå½±å“ç³»ç»ŸçŠ¶æ€æ ï¼‰
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
        metaThemeColor.setAttribute('content', color);
    }
    
    // æ›´æ–°manifestç›¸å…³çš„metaæ ‡ç­¾
    const tileMeta = document.querySelector('meta[name="msapplication-TileColor"]');
    if (tileMeta) {
        tileMeta.setAttribute('content', color);
    }
    
    console.log('ä¸»é¢˜è‰²å·²åº”ç”¨:', color);
}

/**
 * åº”ç”¨æ¸å˜ä¸»é¢˜åˆ°é¡µé¢
 * @param {string} primaryColor - ä¸»è‰²çš„åå…­è¿›åˆ¶å€¼
 * @param {string} secondaryColor - æ¬¡è¦è‰²çš„åå…­è¿›åˆ¶å€¼
 * @param {string} direction - æ¸å˜æ–¹å‘ (å¦‚: 'to right', 'to bottom')
 */
function applyGradientTheme(primaryColor, secondaryColor, direction) {
    // å¯ç”¨æ¸å˜æ¨¡å¼
    document.body.classList.add('gradient-mode');
    
    // è®¡ç®—è¾…åŠ©é¢œè‰²
    const lightColor = hexToRgba(primaryColor, 0.1);
    const hoverColor = darkenColor(primaryColor, 0.1);
    
    // åœ¨æ¸å˜æ¨¡å¼ä¸‹ï¼Œä½¿ç”¨æ¸å˜çš„æ¬¡è¦è‰²ä½œä¸ºUIå…ƒç´ çš„æ¬¡è¦è‰²
    const secondaryHover = darkenColor(secondaryColor, 0.15);
    const secondaryActive = darkenColor(secondaryColor, 0.25);
    
    // æ›´æ–°CSSå˜é‡
    document.documentElement.style.setProperty('--theme-primary', primaryColor);
    document.documentElement.style.setProperty('--theme-secondary', secondaryColor);
    document.documentElement.style.setProperty('--theme-primary-light', lightColor);
    document.documentElement.style.setProperty('--theme-primary-hover', hoverColor);
    document.documentElement.style.setProperty('--theme-secondary-hover', secondaryHover);
    document.documentElement.style.setProperty('--theme-secondary-active', secondaryActive);
    document.documentElement.style.setProperty('--theme-gradient-direction', direction);
    document.documentElement.style.setProperty('--theme-gradient', `linear-gradient(${direction}, ${primaryColor}, ${secondaryColor})`);
    document.documentElement.style.setProperty('--use-gradient', '1');
    
    // æ›´æ–°metaæ ‡ç­¾ä¸­çš„ä¸»é¢˜è‰²ï¼ˆä½¿ç”¨ä¸»è‰²ï¼‰
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
        metaThemeColor.setAttribute('content', primaryColor);
    }
    
    // æ›´æ–°manifestç›¸å…³çš„metaæ ‡ç­¾
    const tileMeta = document.querySelector('meta[name="msapplication-TileColor"]');
    if (tileMeta) {
        tileMeta.setAttribute('content', primaryColor);
    }
    
    console.log('æ¸å˜ä¸»é¢˜å·²åº”ç”¨:', { primaryColor, secondaryColor, direction });
}

// å…¼å®¹æ€§ï¼šå°†å‡½æ•°åˆ†ç»„æš´éœ²åˆ°å…¨å±€windowå¯¹è±¡
if (typeof window !== 'undefined') {
    window.ColorUtils = {
        isValidHexColor,
        hexToRgba,
        darkenColor,
        validateColorInput,
        applyThemeColor,
        applyGradientTheme
    };
    
    // å‘åå…¼å®¹ï¼šä¿ç•™ç›´æ¥æŒ‚è½½çš„å‡½æ•°ï¼ˆé€æ­¥åºŸå¼ƒï¼‰
    window.isValidHexColor = isValidHexColor;
    window.hexToRgba = hexToRgba;
    window.darkenColor = darkenColor;
    window.validateColorInput = validateColorInput;
    window.applyThemeColor = applyThemeColor;
    window.applyGradientTheme = applyGradientTheme;
}
</script>
    <script>
/**
 * UI Utilities
 * é€šç”¨UIäº¤äº’ç›¸å…³çš„å®ç”¨å·¥å…·å‡½æ•°
 */

/**
 * æ˜¾ç¤ºToastæ¶ˆæ¯é€šçŸ¥
 * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯å†…å®¹
 * @param {string} type - æ¶ˆæ¯ç±»å‹: 'info', 'success', 'warning', 'error'
 * @param {number} duration - æ˜¾ç¤ºæŒç»­æ—¶é—´(æ¯«ç§’)ï¼Œé»˜è®¤3ç§’
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    if (!toast) {
        console.warn('Toastå…ƒç´ ä¸å­˜åœ¨');
        return;
    }
    
    toast.textContent = message;
    
    // ç§»é™¤ä¹‹å‰çš„ç±»å‹ç±»
    toast.classList.remove('toast-error', 'toast-success', 'toast-warning', 'toast-info');
    
    // æ·»åŠ æ–°çš„ç±»å‹ç±»
    switch(type) {
        case 'error':
            toast.classList.add('toast-error');
            duration = Math.max(duration, 4000); // é”™è¯¯æ¶ˆæ¯æ˜¾ç¤ºæ—¶é—´ç¨é•¿
            break;
        case 'success':
            toast.classList.add('toast-success');
            break;
        case 'warning':
            toast.classList.add('toast-warning');
            break;
        default:
            toast.classList.add('toast-info');
            break;
    }
    
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), duration);
}

/**
 * æ˜¾ç¤ºæ¨¡æ€æ¡†
 * @param {string} modalId - æ¨¡æ€æ¡†çš„DOMå…ƒç´ ID
 */
function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error('æ¨¡æ€æ¡†ä¸å­˜åœ¨:', modalId);
        return;
    }
    modal.style.display = 'block';
    
    // ç‰¹å®šæ¨¡æ€æ¡†çš„åˆå§‹åŒ–é€»è¾‘
    if (modalId === 'apiSettingsModal') {
        const contextSlider = document.getElementById('contextSlider');
        const contextValue = document.getElementById('contextValue');
        if (contextSlider && contextValue) {
            // ä½¿ç”¨æ–°çš„APIè·å–ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é‡ï¼Œè€Œä¸æ˜¯ç›´æ¥è®¿é—®å…¨å±€å˜é‡
            initializeContextSlider(contextSlider, contextValue);
        }
    }
}

/**
 * å…³é—­æ¨¡æ€æ¡†å¹¶æ‰§è¡Œç›¸å…³æ¸…ç†å·¥ä½œ
 * @param {string} modalId - æ¨¡æ€æ¡†çš„DOMå…ƒç´ ID
 */
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error('è¦å…³é—­çš„æ¨¡æ€æ¡†ä¸å­˜åœ¨:', modalId);
        return;
    }
    modal.style.display = 'none';
    
    // ç‰¹å®šæ¨¡æ€æ¡†çš„æ¸…ç†é€»è¾‘
    if (modalId === 'addContactModal') {
        // é‡ç½®ç¼–è¾‘çŠ¶æ€
        if (window.editingContact !== undefined) {
            window.editingContact = null;
        }
        
        // é‡ç½®è¡¨å•
        const elements = {
            'contactModalTitle': 'æ·»åŠ AIåŠ©æ‰‹',
            'contactName': '',
            'contactAvatar': '',
            'contactPersonality': '',
            'customPrompts': '',
            'contactVoiceId': ''
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
                    element.value = value;
                } else {
                    element.textContent = value;
                }
            }
        });
    } else if (modalId === 'addEmojiModal') {
        // æ¸…ç†è¡¨æƒ…åŒ…ä¸Šä¼ çš„ä¸´æ—¶æ•°æ®
        cleanupEmojiUploadData();
    }
}

/**
 * æ¸…ç†è¡¨æƒ…åŒ…ä¸Šä¼ ä¸´æ—¶æ•°æ®çš„è¾…åŠ©å‡½æ•°
 */
function cleanupEmojiUploadData() {
    try {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if (window.ImageUploadHandlers && window.ImageUploadHandlers.tempEmojiFile) {
            window.ImageUploadHandlers.tempEmojiFile = null;
        }
        
        // æ¸…ç†ä¸´æ—¶URL
        const emojiUrlInput = document.getElementById('emojiUrl');
        if (emojiUrlInput && emojiUrlInput.value.startsWith('temp:')) {
            const tempUrl = emojiUrlInput.value.substring(5);
            URL.revokeObjectURL(tempUrl);
            emojiUrlInput.value = '';
        }
        
        // æ¸…ç†æ–‡ä»¶è¾“å…¥
        const fileInput = document.getElementById('emojiUploadInput');
        if (fileInput) {
            fileInput.value = '';
        }
        
        // æ¸…ç†çŠ¶æ€æç¤º
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = '';
            statusElement.style.color = '';
        }
        
        // æ¸…ç†æ„æ€è¾“å…¥æ¡†
        const meaningInput = document.getElementById('emojiMeaning');
        if (meaningInput) {
            meaningInput.value = '';
        }
        
        console.log('è¡¨æƒ…åŒ…ä¸Šä¼ ä¸´æ—¶æ•°æ®å·²æ¸…ç†');
    } catch (error) {
        console.warn('æ¸…ç†è¡¨æƒ…åŒ…ä¸´æ—¶æ•°æ®æ—¶å‡ºé”™:', error);
    }
}

/**
 * æ˜¾ç¤ºé¡¶éƒ¨é€šçŸ¥æ¶ˆæ¯ï¼ˆçŸ­æš‚æ˜¾ç¤ºï¼‰
 * @param {string} message - è¦æ˜¾ç¤ºçš„é€šçŸ¥æ¶ˆæ¯
 */
function showTopNotification(message) {
    const notification = document.getElementById('topNotification');
    if (!notification) {
        console.warn('TopNotificationå…ƒç´ ä¸å­˜åœ¨');
        return;
    }
    notification.textContent = message;
    notification.classList.add('show');
    setTimeout(() => notification.classList.remove('show'), 1500);
}

/**
 * æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
 * @param {string} title - å¯¹è¯æ¡†æ ‡é¢˜
 * @param {string} message - å¯¹è¯æ¡†æ¶ˆæ¯å†…å®¹
 * @param {Function} onConfirm - ç¡®è®¤æŒ‰é’®çš„å›è°ƒå‡½æ•°
 */
function showConfirmDialog(title, message, onConfirm) {
    const dialogId = 'customConfirmDialog';
    let dialog = document.getElementById(dialogId);
    if (!dialog) {
        dialog = document.createElement('div');
        dialog.id = dialogId;
        dialog.className = 'modal'; // å¤ç”¨modalçš„æ ·å¼
        dialog.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="confirmDialogTitle"></div>
                    <div class="modal-close" onclick="closeModal('${dialogId}')">å–æ¶ˆ</div>
                </div>
                <div class="modal-body">
                    <p id="confirmDialogMessage" style="text-align: center; margin-bottom: 20px;"></p>
                    <div style="display: flex; justify-content: space-around; gap: 10px;">
                        <button class="form-submit" style="background-color: #ccc; flex: 1;" onclick="closeModal('${dialogId}')">å–æ¶ˆ</button>
                        <button class="form-submit delete-button" style="flex: 1;" id="confirmActionButton">ç¡®å®š</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(dialog);
    }

    document.getElementById('confirmDialogTitle').textContent = title;
    document.getElementById('confirmDialogMessage').textContent = message;
    
    const confirmBtn = document.getElementById('confirmActionButton');
    confirmBtn.onclick = () => {
        onConfirm();
        closeModal(dialogId);
    };

    showModal(dialogId);
}

/**
 * æ˜¾ç¤ºä¸Šä¼ é”™è¯¯çš„ä¸“ç”¨å¤„ç†å‡½æ•°
 * @param {Error|Object} error - é”™è¯¯å¯¹è±¡ï¼Œå¯èƒ½åŒ…å«DetailedErrorç»“æ„
 */
function showUploadError(error) {
    if (error && error.name === 'DetailedError') {
        // æ ¹æ®é”™è¯¯ä»£ç æ˜¾ç¤ºä¸åŒç±»å‹çš„toast
        switch(error.code) {
            case 'FILE_MISSING':
            case 'PARAM_MISSING':
                showToast(error.message, 'warning');
                break;
            case 'FILE_TOO_LARGE':
            case 'INVALID_FILE_TYPE':
                showToast(error.message, 'error');
                break;
            case 'STORAGE_FULL':
                showToast(error.message, 'error', 5000); // å­˜å‚¨æ»¡æ˜¾ç¤ºæ›´ä¹…
                break;
            case 'DATABASE_ERROR':
                showToast(error.message, 'error');
                break;
            case 'SYSTEM_ERROR':
                showToast(error.message, 'warning');
                break;
            default:
                showToast(error.message, 'error');
                break;
        }
    } else {
        showToast(`ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
    }
}

/**
 * å¤„ç†APIé”™è¯¯çš„ä¸“ç”¨å‡½æ•°ï¼ŒåŒ…å«è¯¦ç»†çš„é”™è¯¯è®°å½•å’Œé‡è¯•åŠŸèƒ½
 * @param {string|Error} prefixOrError - é”™è¯¯å‰ç¼€å­—ç¬¦ä¸²æˆ–é”™è¯¯å¯¹è±¡
 * @param {Error} error - é”™è¯¯å¯¹è±¡ï¼ˆå½“ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å‰ç¼€æ—¶ï¼‰
 */
function showApiError(prefixOrError, error) {
    let errorMessage;
    let prefix = '';
    
    // æ”¯æŒå•å‚æ•°å’ŒåŒå‚æ•°è°ƒç”¨
    if (typeof prefixOrError === 'string' && error) {
        // åŒå‚æ•°è°ƒç”¨ï¼šshowApiError('å‰ç¼€', error)
        prefix = prefixOrError + ': ';
        errorMessage = error.message || 'æœªçŸ¥é”™è¯¯';
    } else {
        // å•å‚æ•°è°ƒç”¨ï¼šshowApiError(error)
        errorMessage = prefixOrError.message || 'æœªçŸ¥é”™è¯¯';
    }
    
    // è®°å½•ERRORçº§åˆ«çš„æ—¥å¿—ï¼ŒåŒ…å«å®Œæ•´çš„é”™è¯¯ä¿¡æ¯
    console.error('ERROR: APIè°ƒç”¨å¤±è´¥è¯¦æƒ…:', {
        errorMessage: errorMessage,
        error: error,
        apiResponse: error?.response || error?.apiResponse || error?.data || null,
        timestamp: new Date().toISOString(),
        networkStatus: navigator.onLine ? 'online' : 'offline',
        pageUrl: window.location.href
    });
    
    // è°ƒç”¨ç‰¹æ®Šçš„é‡è¯•æ¨¡æ€æ¡†å¤„ç†
    if (typeof window.showQixiRetryModal === 'function') {
        window.showQixiRetryModal(prefixOrError, error, errorMessage, prefix);
    } else {
        // åå¤‡æ–¹æ¡ˆï¼šæ˜¾ç¤ºæ™®é€šé”™è¯¯æç¤º
        showToast(prefix + errorMessage, 'error', 4000);
    }
}

/**
 * åˆå§‹åŒ–ä¸Šä¸‹æ–‡æ»‘å—çš„å€¼ï¼Œä½¿ç”¨ç°ä»£APIè€Œéå…¨å±€å˜é‡
 * @param {HTMLElement} contextSlider - ä¸Šä¸‹æ–‡æ»‘å—å…ƒç´ 
 * @param {HTMLElement} contextValue - ä¸Šä¸‹æ–‡å€¼æ˜¾ç¤ºå…ƒç´ 
 */
async function initializeContextSlider(contextSlider, contextValue) {
    try {
        // ä½¿ç”¨æ–°çš„APIè·å–å½“å‰é…ç½®ï¼Œè€Œä¸æ˜¯ä¾èµ–å…¨å±€ window.apiSettings
        if (window.apiConfigManager) {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const contextCount = connection.contextMessageCount || 10;
            contextSlider.value = contextCount;
            contextValue.textContent = contextCount + 'æ¡';
        } else {
            // é™çº§å¤„ç†ï¼šå¦‚æœæ–°APIä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å€¼
            console.warn('apiConfigManager ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é‡');
            contextSlider.value = 10;
            contextValue.textContent = '10æ¡';
        }
    } catch (error) {
        console.error('åˆå§‹åŒ–ä¸Šä¸‹æ–‡æ»‘å—å¤±è´¥:', error);
        // é”™è¯¯æƒ…å†µä¸‹ä½¿ç”¨é»˜è®¤å€¼
        contextSlider.value = 10;
        contextValue.textContent = '10æ¡';
    }
}

// å…¼å®¹æ€§ï¼šå°†å‡½æ•°åˆ†ç»„æš´éœ²åˆ°å…¨å±€windowå¯¹è±¡
if (typeof window !== 'undefined') {
    window.UIUtils = {
        showToast,
        showModal,
        closeModal,
        showTopNotification,
        showConfirmDialog,
        showUploadError,
        showApiError,
        initializeContextSlider
    };
    
    // å‘åå…¼å®¹ï¼šä¿ç•™ç›´æ¥æŒ‚è½½çš„å‡½æ•°ï¼ˆé€æ­¥åºŸå¼ƒï¼‰
    window.showToast = showToast;
    window.showModal = showModal;
    window.closeModal = closeModal;
    window.showTopNotification = showTopNotification;
    window.showConfirmDialog = showConfirmDialog;
    window.showUploadError = showUploadError;
    window.showApiError = showApiError;
    window.initializeContextSlider = initializeContextSlider;
}
</script>
    <script>
/**
 * Formatting Utilities
 * æ•°æ®æ ¼å¼åŒ–ç›¸å…³çš„å®ç”¨å·¥å…·å‡½æ•°
 */

/**
 * HTMLå­—ç¬¦è½¬ä¹‰ï¼Œé˜²æ­¢XSSæ”»å‡»
 * @param {string} text - éœ€è¦è½¬ä¹‰çš„æ–‡æœ¬
 * @returns {string} è½¬ä¹‰åçš„å®‰å…¨HTMLæ–‡æœ¬
 */
function escapeHtml(text) {
    if (!text) return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

/**
 * æ ¼å¼åŒ–éŸ³ä¹æ’­æ”¾æ—¶é—´ (ç§’ -> MM:SSæ ¼å¼)
 * @param {number} seconds - ç§’æ•°
 * @returns {string} æ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸² (å¦‚: "3:45")
 */
function formatMusicTime(seconds) {
    if (!seconds || seconds < 0) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * æ ¼å¼åŒ–æ—¶é—´æˆ³ä¸ºç›¸å¯¹æ—¶é—´æ˜¾ç¤º (ç»Ÿä¸€ç‰ˆæœ¬)
 * @param {string|number|Date} timestamp - æ—¶é—´æˆ³
 * @param {Object} options - æ ¼å¼åŒ–é€‰é¡¹
 * @param {boolean} options.precise - æ˜¯å¦ä½¿ç”¨ç²¾ç¡®çš„"åˆšåˆš"åˆ¤æ–­ (é»˜è®¤true)
 * @returns {string} æ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸²
 */
function formatTime(timestamp, options = {}) {
    if (!timestamp) return '';
    
    const { precise = true } = options;
    const now = new Date();
    const postTime = new Date(timestamp);
    const diffInSeconds = (now - postTime) / 1000;
    const diffInMinutes = diffInSeconds / 60;
    const diffInHours = diffInMinutes / 60;

    // ä½¿ç”¨æ—¥æœŸè¾¹ç•Œè€Œé24å°æ—¶è®¡ç®—å¤©æ•°å·®å¼‚
    const startOfNow = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfPostTime = new Date(postTime.getFullYear(), postTime.getMonth(), postTime.getDate());
    const diffInDays = (startOfNow - startOfPostTime) / (1000 * 60 * 60 * 24);

    if (diffInDays < 1) { // ä»Šå¤©
        if (precise && diffInMinutes < 1) return "åˆšåˆš";
        if (diffInHours < 1) {
            const minutes = Math.max(1, Math.floor(diffInMinutes));
            return `${minutes}åˆ†é’Ÿå‰`;
        }
        return `${Math.floor(diffInHours)}å°æ—¶å‰`;
    } else if (diffInDays < 2) { // æ˜¨å¤©
        return "1å¤©å‰";
    } else { // 2å¤©å‰åŠä»¥ä¸Š
        const isThisYear = now.getFullYear() === postTime.getFullYear();
        const month = (postTime.getMonth() + 1).toString().padStart(2, '0');
        const day = postTime.getDate().toString().padStart(2, '0');
        
        if (isThisYear) {
            const hours = postTime.getHours().toString().padStart(2, '0');
            const minutes = postTime.getMinutes().toString().padStart(2, '0');
            return `${month}-${day} ${hours}:${minutes}`;
        } else {
            return `${postTime.getFullYear()}-${month}-${day}`;
        }
    }
}

/**
 * æ ¼å¼åŒ–æ—¶é—´æˆ³ä¸ºç›¸å¯¹æ—¶é—´æ˜¾ç¤º (å…¼å®¹æ—§ç‰ˆæœ¬ - æ— "åˆšåˆš"åˆ¤æ–­)
 * @param {string|number|Date} timestamp - æ—¶é—´æˆ³
 * @returns {string} æ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸²
 */
function formatTimeLegacy(timestamp) {
    return formatTime(timestamp, { precise: false });
}

/**
 * æ ¼å¼åŒ–è”ç³»äººåˆ—è¡¨æ—¶é—´æ˜¾ç¤º (é’ˆå¯¹èŠå¤©åˆ—è¡¨ä¼˜åŒ–)
 * @param {string} dateString - æ—¶é—´å­—ç¬¦ä¸²
 * @returns {string} æ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸²
 */
function formatContactListTime(dateString) {
    // å¤„ç†ç©ºå€¼æˆ–æ— æ•ˆè¾“å…¥
    if (!dateString) return '';
    
    // å¦‚æœå·²ç»æ˜¯æ ¼å¼åŒ–åçš„æ—¶é—´ï¼Œç›´æ¥è¿”å›
    if (typeof dateString === 'string' && (
        dateString === 'åˆšåˆš' || 
        dateString.includes('åˆ†é’Ÿå‰') || 
        dateString.includes('å°æ—¶å‰') ||
        dateString.includes('æ˜ŸæœŸ') ||
        dateString.includes('æ˜¨å¤©') ||
        dateString.includes('å‰å¤©') ||
        (dateString.includes(':') && !dateString.includes('T')) || // æ’é™¤ISOæ ¼å¼
        (dateString.includes('æœˆ') && dateString.includes('æ—¥'))
    )) {
        return dateString;
    }
    
    // å°è¯•è§£ææ—¥æœŸ
    let d;
    try {
        d = new Date(dateString);
        // æ£€æŸ¥æ—¥æœŸæ˜¯å¦æœ‰æ•ˆ
        if (isNaN(d.getTime())) {
            console.warn('Invalid date string:', dateString);
            return '';
        }
    } catch (e) {
        console.warn('Error parsing date:', dateString, e);
        return '';
    }
    
    const now = new Date();
    const diff = now - d;
    
    // å¦‚æœæ—¶é—´åœ¨æœªæ¥ï¼Œå¯èƒ½æ˜¯æ—¶åŒºé—®é¢˜ï¼Œä½¿ç”¨å½“å‰æ—¶é—´
    if (diff < 0) {
        console.warn('Future timestamp detected, using current time:', dateString);
        d = now;
    }
    
    // 2åˆ†é’Ÿå†…æ˜¾ç¤º"åˆšåˆš"
    if (diff < 2 * 60 * 1000) {
        return 'åˆšåˆš';
    }
    
    // 2åˆ†é’Ÿååˆ°1å°æ—¶å†…æ˜¾ç¤º"Xåˆ†é’Ÿå‰"
    if (diff < 60 * 60 * 1000) {
        const minutes = Math.floor(diff / (60 * 1000));
        return `${minutes}åˆ†é’Ÿå‰`;
    }
    
    // 1å°æ—¶åˆ°24å°æ—¶å†…æ˜¾ç¤º"Xå°æ—¶å‰"
    if (diff < 24 * 60 * 60 * 1000) {
        const hours = Math.floor(diff / (60 * 60 * 1000));
        return `${hours}å°æ—¶å‰`;
    }

    // è·å–ä»Šå¤©ã€æ˜¨å¤©ã€å‰å¤©çš„æ—¥æœŸï¼ˆåªæ¯”è¾ƒæ—¥æœŸéƒ¨åˆ†ï¼‰
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const messageDate = new Date(d.getFullYear(), d.getMonth(), d.getDate());
    
    // æ˜¨å¤©
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    if (yesterday.getTime() === messageDate.getTime()) {
        return 'æ˜¨å¤©';
    }
    
    // å‰å¤©
    const dayBeforeYesterday = new Date(today);
    dayBeforeYesterday.setDate(dayBeforeYesterday.getDate() - 2);
    if (dayBeforeYesterday.getTime() === messageDate.getTime()) {
        return 'å‰å¤©';
    }
    
    // ä¸€å‘¨å†…æ˜¾ç¤ºæ˜ŸæœŸå‡ 
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);
    if (d >= weekAgo) {
        const weekdays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
        return weekdays[d.getDay()];
    }
    
    // ä»Šå¹´å†…æ˜¾ç¤ºæœˆæ—¥
    if (d.getFullYear() === now.getFullYear()) {
        return `${d.getMonth() + 1}æœˆ${d.getDate()}æ—¥`;
    }
    
    // å…¶ä»–æ˜¾ç¤ºå¹´æœˆæ—¥
    return `${d.getFullYear()}å¹´${d.getMonth() + 1}æœˆ${d.getDate()}æ—¥`;
}

/**
 * æ ¼å¼åŒ–èŠå¤©æ—¶é—´æˆ³ (é’ˆå¯¹èŠå¤©æ¶ˆæ¯ä¼˜åŒ–)
 * @param {string} dateString - æ—¶é—´å­—ç¬¦ä¸²
 * @returns {string} æ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸²
 */
function formatChatTimestamp(dateString) {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return '';

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today.getTime() - 86400000);
    
    const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    const beijingTime = new Date(date.getTime());
    const hours = beijingTime.getHours().toString().padStart(2, '0');
    const minutes = beijingTime.getMinutes().toString().padStart(2, '0');
    const timeStr = `${hours}:${minutes}`;

    if (messageDate.getTime() === today.getTime()) {
        return timeStr;
    }
    if (messageDate.getTime() === yesterday.getTime()) {
        return `æ˜¨å¤© ${timeStr}`;
    }
    if (now.getFullYear() === date.getFullYear()) {
        const month = (date.getMonth() + 1);
        const day = date.getDate();
        return `${month}æœˆ${day}æ—¥ ${timeStr}`;
    } else {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1);
        const day = date.getDate();
        return `${year}å¹´${month}æœˆ${day}æ—¥ ${timeStr}`;
    }
}

/**
 * ç”Ÿæˆå”¯ä¸€ID
 * @returns {string} å”¯ä¸€çš„IDå­—ç¬¦ä¸² (æ—¶é—´æˆ³ + éšæœºå­—ç¬¦ä¸²)
 */
function generateId() {
    return Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);
}

/**
 * å°†æ–‡ä»¶è¯»å–ä¸ºData URLæ ¼å¼
 * @param {File} file - è¦è¯»å–çš„æ–‡ä»¶å¯¹è±¡
 * @returns {Promise<string>} Promiseï¼Œè§£æä¸ºData URLå­—ç¬¦ä¸²
 */
function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
        reader.readAsDataURL(file);
    });
}

/**
 * å°†Canvasè½¬æ¢ä¸ºBlobå¯¹è±¡
 * @param {HTMLCanvasElement} canvas - Canvaså…ƒç´ 
 * @returns {Promise<Blob>} Promiseï¼Œè§£æä¸ºBlobå¯¹è±¡
 */
function canvasToBlob(canvas) {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Canvasè½¬æ¢å¤±è´¥'));
            }
        }, 'image/jpeg', 0.9);
    });
}

/**
 * ç§»é™¤æ–‡æœ¬ä¸­çš„æ€ç»´é“¾æ ‡ç­¾
 * @param {string} text - åŒ…å«æ€ç»´é“¾çš„æ–‡æœ¬
 * @returns {string} æ¸…ç†åçš„æ–‡æœ¬
 */
function removeThinkingChain(text) {
    // åˆ é™¤ <think> ... </think> æ ‡ç­¾åŠå…¶å†…å®¹
    return text.replace(/<think\s*>[\s\S]*?<\/think\s*>/gi, '').trim();
}

/**
 * å®‰å…¨åˆ›å»ºIndexedDBäº‹åŠ¡
 * @param {IDBDatabase} db - æ•°æ®åº“å¯¹è±¡
 * @param {string|Array} storeNames - å­˜å‚¨åç§°
 * @param {string} mode - äº‹åŠ¡æ¨¡å¼ ('readonly' | 'readwrite')
 * @returns {IDBTransaction} äº‹åŠ¡å¯¹è±¡
 */
function safeCreateTransaction(db, storeNames, mode = 'readonly') {
    if (!db) {
        throw new Error('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨');
    }
    
    // æ£€æŸ¥æ‰€æœ‰å­˜å‚¨æ˜¯å¦å­˜åœ¨
    const missingStores = Array.isArray(storeNames) 
        ? storeNames.filter(storeName => !db.objectStoreNames.contains(storeName))
        : !db.objectStoreNames.contains(storeNames) ? [storeNames] : [];
    
    if (missingStores.length > 0) {
        throw new Error(`å­˜å‚¨ä¸å­˜åœ¨: ${missingStores.join(', ')}`);
    }
    
    return db.transaction(storeNames, mode);
}

/**
 * PromiseåŒ–IndexedDBè¯·æ±‚
 * @param {IDBRequest} request - IndexedDBè¯·æ±‚å¯¹è±¡
 * @param {string} operation - æ“ä½œæè¿°ï¼ˆç”¨äºé”™è¯¯æ—¥å¿—ï¼‰
 * @returns {Promise} Promiseå¯¹è±¡
 */
function promisifyRequest(request, operation = 'æ•°æ®åº“æ“ä½œ') {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => {
            console.error(`${operation}å¤±è´¥:`, request.error);
            reject(request.error);
        };
    });
}

/**
 * PromiseåŒ–IndexedDBäº‹åŠ¡
 * @param {IDBTransaction} transaction - äº‹åŠ¡å¯¹è±¡
 * @param {string} operation - æ“ä½œæè¿°ï¼ˆç”¨äºé”™è¯¯æ—¥å¿—ï¼‰
 * @returns {Promise} Promiseå¯¹è±¡
 */
function promisifyTransaction(transaction, operation = 'æ•°æ®åº“äº‹åŠ¡') {
    return new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => {
            console.error(`${operation}å¤±è´¥:`, transaction.error);
            reject(transaction.error);
        };
        transaction.onabort = () => {
            console.error(`${operation}è¢«ä¸­æ­¢:`, transaction.error);
            reject(transaction.error || new Error('äº‹åŠ¡è¢«ä¸­æ­¢'));
        };
    });
}

// å…¼å®¹æ€§ï¼šå°†å‡½æ•°åˆ†ç»„æš´éœ²åˆ°å…¨å±€windowå¯¹è±¡
if (typeof window !== 'undefined') {
    window.FormatUtils = {
        escapeHtml,
        formatMusicTime,
        formatTime,
        formatTimeLegacy,
        formatContactListTime,
        formatChatTimestamp,
        generateId,
        readFileAsDataURL,
        canvasToBlob,
        removeThinkingChain
    };
    
    window.DBUtils = {
        safeCreateTransaction,
        promisifyRequest,
        promisifyTransaction
    };
    
    // å‘åå…¼å®¹ï¼šä¿ç•™ç›´æ¥æŒ‚è½½çš„å‡½æ•°ï¼ˆé€æ­¥åºŸå¼ƒï¼‰
    window.escapeHtml = escapeHtml;
    window.formatMusicTime = formatMusicTime;
    window.formatTime = formatTime;
    window.formatTimeLegacy = formatTimeLegacy;
    window.formatContactListTime = formatContactListTime;
    window.formatChatTimestamp = formatChatTimestamp;
    window.generateId = generateId;
    window.readFileAsDataURL = readFileAsDataURL;
    window.canvasToBlob = canvasToBlob;
    window.removeThinkingChain = removeThinkingChain;
    window.safeCreateTransaction = safeCreateTransaction;
    window.promisifyRequest = promisifyRequest;
    window.promisifyTransaction = promisifyTransaction;
}
</script>
    <script>
ï»¿// === æ ¸å¿ƒåº”ç”¨è„šæœ¬ ===

// ğŸ›¡ï¸ å…¨å±€é”™è¯¯å¤„ç†å™¨ - å¤„ç†ç¬¬ä¸‰æ–¹åº“å’Œæµè§ˆå™¨å…¼å®¹æ€§é—®é¢˜
window.addEventListener('error', function(event) {
    // è¿‡æ»¤æ‰å·²çŸ¥çš„æ— å®³é”™è¯¯
    if (event.message && event.message.includes('document.currentScript')) {
        console.warn('ğŸ”§ æ•è·åˆ° currentScript å…¼å®¹æ€§é”™è¯¯ï¼Œå·²å®‰å…¨å¿½ç•¥:', event.message);
        event.preventDefault(); // é˜»æ­¢é”™è¯¯å†’æ³¡åˆ°æ§åˆ¶å°
        return true;
    }
    
    // è®°å½•å…¶ä»–çœŸæ­£çš„é”™è¯¯ä¾›è°ƒè¯•
    if (event.error && !event.message.includes('Script error')) {
        console.error('ğŸ› å…¨å±€é”™è¯¯:', {
            message: event.message,
            filename: event.filename,
            line: event.lineno,
            column: event.colno,
            error: event.error
        });
    }
});

// ğŸ›¡ï¸ Promise æœªæ•è·é”™è¯¯å¤„ç†å™¨ï¼ˆç»Ÿä¸€å¤„ç†ï¼‰
window.addEventListener('unhandledrejection', function(event) {
    // å¯¹äºæŸäº›ç¬¬ä¸‰æ–¹åº“çš„ Promise é”™è¯¯ï¼Œæˆ‘ä»¬ä¹Ÿå®‰å…¨å¿½ç•¥
    if (event.reason && event.reason.toString().includes('currentScript')) {
        console.warn('ğŸ”§ æ•è·åˆ°æœªå¤„ç†çš„ Promise é”™è¯¯ (currentScript)ï¼Œå·²å®‰å…¨å¿½ç•¥:', event.reason);
        event.preventDefault();
        return;
    }

    console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', {
        reason: event.reason,
        promise: event.promise,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
    });
    
    // è®°å½•åˆ°å…¨å±€é”™è¯¯æ—¥å¿—
    if (!window.errorLog) window.errorLog = [];
    window.errorLog.push({
        type: 'unhandledrejection',
        reason: event.reason?.toString() || 'Unknown',
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
    });
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯APIç›¸å…³çš„é”™è¯¯ï¼Œå¦‚æœæ˜¯åˆ™æ˜¾ç¤ºé‡è¯•å¯¹è¯æ¡†
    const errorMessage = event.reason?.message || event.reason?.toString() || '';
    const isAPIError = errorMessage.includes('APIè¯·æ±‚å¤±è´¥') || 
                      errorMessage.includes('API Error') || 
                      errorMessage.includes('429') ||
                      errorMessage.includes('500') ||
                      errorMessage.includes('503') ||
                      errorMessage.includes('502') ||
                      errorMessage.includes('ç©ºå›') ||
                      errorMessage.includes('AIå›å¤å†…å®¹ä¸ºç©º') ||
                      errorMessage.includes('AIæœªè¿”å›æœ‰æ•ˆå†…å®¹');
    
    if (isAPIError && typeof showApiError === 'function') {
        showApiError(event.reason || new Error(errorMessage));
    }
    
    // é˜²æ­¢æ§åˆ¶å°æ˜¾ç¤ºæœªå¤„ç†çš„é”™è¯¯ï¼ˆå·²è®°å½•ï¼‰
    event.preventDefault();
});

// å·²å°†ä»¥ä¸‹åŠŸèƒ½è¿ç§»åˆ°ä¸“é—¨çš„utilsæ–‡ä»¶ï¼š
// - ä¸»é¢˜ç®¡ç† â†’ uiManager.js
// - æ–‡ä»¶ä¸Šä¼ å¤„ç† â†’ imageStorageAPI.js  
// - æ•°æ®åº“ç®¡ç† â†’ dataMigrator.js
// - æ—¥å¿—ç³»ç»Ÿ â†’ systemUtilities.js
// - é¢œè‰²å·¥å…·å‡½æ•° â†’ colorUtils.js
// - UIäº¤äº’å·¥å…·å‡½æ•° â†’ uiUtils.js
// - æ ¼å¼åŒ–å·¥å…·å‡½æ•° â†’ formatUtils.js

// å·¥å…·å‡½æ•°ç°åœ¨é€šè¿‡å…¨å±€å¯¹è±¡è®¿é—®ï¼š
// - window.ColorUtils.* (é¢œè‰²å·¥å…·å‡½æ•°)
// - window.UIUtils.* (UIäº¤äº’å·¥å…·å‡½æ•°) 
// - window.FormatUtils.* (æ ¼å¼åŒ–å·¥å…·å‡½æ•°)
// - window.DBUtils.* (æ•°æ®åº“å·¥å…·å‡½æ•°)
// 
// åŒæ—¶ä¸ºå‘åå…¼å®¹ï¼Œæ‰€æœ‰å‡½æ•°ä¹Ÿç›´æ¥æŒ‚è½½åœ¨windowå¯¹è±¡ä¸Š

// ä¸»é¢˜ç®¡ç†å·²è¿ç§»åˆ° utils/uiManager.js

// é•¿æŒ‰å±è”½ç³»ç»Ÿå·²è¿ç§»åˆ° utils/uiManager.js


// escapeHtml function moved to utils/formatUtils.js

/**
 * ç»Ÿä¸€çš„è¯„è®ºæ ¼å¼åŒ–å‡½æ•° - è½¬æ¢ä¸ºæ ‡å‡†æ•°æ®æ¨¡å‹
 * æ–°ä»£ç åº”ä½¿ç”¨æ­¤å‡½æ•°ç¡®ä¿æ•°æ®æ ¼å¼ç»Ÿä¸€
 * @param {Object} comment - åŸå§‹è¯„è®ºå¯¹è±¡ï¼ˆå¯èƒ½åŒ…å«æ—§å­—æ®µåï¼‰
 * @returns {Object} - æ ‡å‡†æ ¼å¼çš„è¯„è®ºå¯¹è±¡
 */
function formatCommentForDataModel(comment) {
    return {
        commenter_name: comment.author || comment.commenter_name || 'åŒ¿å',
        comment_content: comment.content || comment.comment_content || '',
        like: comment.like !== undefined ? comment.like : false,
        timestamp: comment.time || comment.timestamp || new Date().toISOString()
    };
}

/**
 * è§£æè¯­éŸ³æ¶ˆæ¯æ ¼å¼ï¼Œæ”¯æŒæ–°çš„[V]æ ¼å¼å’Œå…¼å®¹æ—§çš„[è¯­éŸ³]:æ ¼å¼
 * @param {string} messageContent - åŸå§‹æ¶ˆæ¯å†…å®¹
 * @returns {Object} - { content: string, isVoice: boolean }
 */
function parseVoiceMessage(messageContent) {
    if (!messageContent) {
        return { content: messageContent, isVoice: false };
    }
    
    const NEW_VOICE_PREFIX = '[V]';
    const OLD_VOICE_PREFIX = '[è¯­éŸ³]:';
    
    // æ£€æŸ¥æ–°æ ¼å¼ï¼š[V]å†…å®¹
    if (messageContent.startsWith(NEW_VOICE_PREFIX)) {
        const content = messageContent.substring(NEW_VOICE_PREFIX.length);
        return { content: content, isVoice: true };
    }
    
    // æ£€æŸ¥æ—§æ ¼å¼ï¼š[è¯­éŸ³]:å†…å®¹
    if (messageContent.startsWith(OLD_VOICE_PREFIX)) {
        const content = messageContent.substring(OLD_VOICE_PREFIX.length).trim();
        return { content: content, isVoice: true };
    }
    
    // æ™®é€šæ–‡å­—æ¶ˆæ¯
    return { content: messageContent, isVoice: false };
}

/**
 * ä¸ºè¯­éŸ³æ¶ˆæ¯è®¾ç½®UIï¼ŒåŒ…æ‹¬æ·»åŠ è¯­éŸ³å›¾æ ‡å’Œç‚¹å‡»äº‹ä»¶
 * @param {HTMLElement} msgDiv - æ¶ˆæ¯divå…ƒç´ 
 * @param {Object} message - æ¶ˆæ¯å¯¹è±¡ï¼ŒåŒ…å«contentã€isVoiceç­‰å±æ€§
 * @param {Object} currentContact - å½“å‰è”ç³»äººå¯¹è±¡
 */
function setupVoiceMessageUI(msgDiv, message, currentContact) {
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    if (!message.isVoice || !currentContact.voiceId || !minimaxGroupId || !minimaxApiKey) {
        return;
    }
    
    // å…¼å®¹è‡ªå®šä¹‰æ°”æ³¡å’Œé»˜è®¤æ°”æ³¡
    const bubble = msgDiv.querySelector('.message-bubble') || 
                  msgDiv.querySelector('.custom-bubble-container') || 
                  msgDiv.querySelector('.chat-bubble');
    if (!bubble) {
        return;
    }
    
    const messageUniqueId = `${currentContact.id}-${message.time}`;
    
    // ç»™æ°”æ³¡æ·»åŠ è¯­éŸ³æ¶ˆæ¯æ ‡è¯†
    bubble.classList.add('voice-message');
    bubble.dataset.voiceMessageId = `voice-${messageUniqueId}`;
    
    // åœ¨æ¶ˆæ¯å†…å®¹å‰æ·»åŠ è¯­éŸ³ç¬¦å·
    const textContentDiv = bubble.querySelector('.message-content') || bubble;
    if (textContentDiv && !textContentDiv.querySelector('.voice-icon')) {
        const voiceIcon = document.createElement('span');
        voiceIcon.className = 'voice-icon';
        voiceIcon.innerHTML = createVoiceIcon();
        
        // ç¡®å®šæ’å…¥ç‚¹å¹¶æ’å…¥è¯­éŸ³ç¬¦å·
        let insertionPoint = textContentDiv.firstChild;
        if (textContentDiv === bubble) {
            const firstTextNode = Array.from(textContentDiv.childNodes).find(node => 
                node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ''
            );
            if (firstTextNode) {
                insertionPoint = firstTextNode;
            }
        }
        textContentDiv.insertBefore(voiceIcon, insertionPoint);
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
        bubble.addEventListener('click', () => {
            playVoiceMessage(bubble, message.content, message.senderId || currentContact.id);
        });
    }
}

// --- å…¨å±€çŠ¶æ€ ---
let contacts = [];
// ç¡®ä¿æš´éœ²åˆ°å…¨å±€å¯¹è±¡
window.contacts = contacts;
let currentContact = null;
window.currentContact = currentContact;
let editingContact = null;
window.editingContact = editingContact;

// ğŸ”¥ æ•°æ®åº“åˆå§‹åŒ–å·²ç»Ÿä¸€åˆ° UnifiedDBManagerï¼Œæ—§çš„ç«æ€æ§åˆ¶å˜é‡å·²ç§»é™¤

// APIé…ç½®è®¾ç½®ï¼ˆä¸åŒ…å«minimaxè¯­éŸ³é…ç½®ï¼‰
// æ³¨æ„ï¼šmodelç›¸å…³ä¿¡æ¯ç°åœ¨ä»å…¨å±€æ¨¡å‹é…ç½®è·å–
let apiSettings = {
    url: '',
    key: '',
    contextMessageCount: 10,
    timeout: 60
    // minimaxé…ç½®å·²ç§»è‡³localStorageç‹¬ç«‹ç®¡ç†
    // modelå’ŒsecondaryModelå·²è¿ç§»åˆ°ç‹¬ç«‹çš„å…¨å±€æ¨¡å‹é…ç½®
};

// --- ç”¨æˆ·é…ç½®è·å–å‡½æ•° ---
async function getUserProfile() {
    // è¿”å›å…¨å±€çš„ userProfile å¯¹è±¡
    return userProfile || {
        name: 'æˆ‘çš„æ˜µç§°',
        avatar: null,
        personality: ''
    };
}
// ç¡®ä¿æš´éœ²åˆ°å…¨å±€å¯¹è±¡
window.apiSettings = apiSettings;
let emojis = [];
let backgrounds = {};
let userProfile = {
    name: 'æˆ‘çš„æ˜µç§°',
    avatar: '',
    personality: '' 
};

// å°† userProfile ç»‘å®šåˆ°å…¨å±€ä½œç”¨åŸŸ
window.userProfile = userProfile;
let moments = [];
let weiboPosts = [];

const RELATION_PRESETS = {
    'CP': 'CPï¼ˆä¸¤è€…äº’ä¸ºæƒ…ä¾£ï¼‰',
    'CB': 'CBï¼ˆå‹æƒ…ã€äº²æƒ…ç­‰éæ‹çˆ±çš„äº²å¯†å…³ç³»ï¼‰', 
    'å¥½å‹': 'å¥½å‹',
    'å®¿æ•Œ': 'å®¿æ•Œï¼ˆä¸¤è€…äº’ä¸ºèƒ½æŒç»­æ°¸æ’çš„è¾ƒé‡ï¼Œé•¿æœŸçš„æ•Œäººï¼Œå¤©ç”Ÿçš„å¯¹æ‰‹ï¼Œå‘½ä¸­æ³¨å®šçš„ç«äº‰è€…ï¼‰'
};

let hashtagCache = {};

let audio = null;
// IndexedDB å®ä¾‹ç»Ÿä¸€ä½¿ç”¨ window.dbï¼Œä¸å†ä½¿ç”¨å±€éƒ¨å˜é‡

// å…¨å±€é”™è¯¯å¤„ç†å·²ç»Ÿä¸€åˆ°æ–‡ä»¶å¼€å¤´çš„ unhandledrejection ç›‘å¬å™¨ä¸­

// === å›¾ç‰‡å¤„ç†è¾…åŠ©å‡½æ•° ===

/**
 * è·å–å¤´åƒHTMLï¼ˆæ”¯æŒæ–°çš„æ–‡ä»¶å­˜å‚¨æ ¼å¼å’Œæ—§çš„base64æ ¼å¼ï¼‰
 * @param {Object} entity - å®ä½“å¯¹è±¡ï¼ˆè”ç³»äººæˆ–ç”¨æˆ·ï¼‰
 * @param {string} entityType - å®ä½“ç±»å‹ ('contact' æˆ– 'user')
 * @param {string} className - CSSç±»åï¼ˆå¯é€‰ï¼‰
 * @returns {Promise<string>} è¿”å›HTMLå­—ç¬¦ä¸²
 */
async function getAvatarHTML(entity, entityType = 'contact', className = '') {
    if (!entity) return '';
    
    try {
        // å¦‚æœæœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨ï¼Œä½¿ç”¨ImageDisplayHelper
        if (entity.avatarFileId && window.ImageDisplayHelper) {
            return await window.ImageDisplayHelper.createAvatarHTML(entity, entityType, className);
        }
        
        // å›é€€åˆ°æ—§çš„base64æ ¼å¼
        const classAttr = className ? ` class="${className}"` : '';
        if (entity.avatar && entity.avatar.startsWith('data:')) {
            return `<img src="${entity.avatar}"${classAttr}>`;
        } else {
            // ä½¿ç”¨é¦–å­—ç¬¦ä½œä¸ºé»˜è®¤å¤´åƒ
            const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? 'æˆ‘' : '?');
            return `<span${classAttr}>${firstChar}</span>`;
        }
    } catch (error) {
        console.warn(`è·å–${entityType}å¤´åƒHTMLå¤±è´¥:`, error);
        // å®‰å…¨å›é€€
        const classAttr = className ? ` class="${className}"` : '';
        const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? 'æˆ‘' : '?');
        return entity.avatar ? `<img src="${entity.avatar}"${classAttr}>` : `<span${classAttr}>${firstChar}</span>`;
    }
}

/**
 * åŒæ­¥è·å–å¤´åƒHTMLï¼ˆç”¨äºä¸èƒ½ä½¿ç”¨asyncçš„åœ°æ–¹ï¼‰
 * æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°ä¸æ”¯æŒæ–°çš„æ–‡ä»¶å­˜å‚¨æ ¼å¼ï¼Œåªç”¨äºç´§æ€¥æƒ…å†µä¸‹çš„å›é€€
 */
function getAvatarHTMLSync(entity, entityType = 'contact', className = '') {
    if (!entity) return '';
    
    const classAttr = className ? ` class="${className}"` : '';
    if (entity.avatar && entity.avatar.startsWith('data:')) {
        return `<img src="${entity.avatar}"${classAttr}>`;
    } else {
        const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? 'æˆ‘' : '?');
        return `<span${classAttr}>${firstChar}</span>`;
    }
}

/**
 * è·å–èƒŒæ™¯å›¾ç‰‡URL
 * @param {Object} background - èƒŒæ™¯å¯¹è±¡
 * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
 */
async function getBackgroundImageURL(background) {
    if (!background) return '';
    
    try {
        // å¦‚æœæœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨ï¼Œä½¿ç”¨ImageDisplayHelper
        if (background.fileId && window.ImageDisplayHelper) {
            return await window.ImageDisplayHelper.getBackgroundURL(background);
        }
        
        // å›é€€åˆ°æ—§æ ¼å¼
        return background.data || background.url || '';
    } catch (error) {
        console.warn('è·å–èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
        return background.data || background.url || '';
    }
}

/**
 * è·å–è¡¨æƒ…åŒ…URL
 * @param {Object} emoji - è¡¨æƒ…åŒ…å¯¹è±¡
 * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
 */
async function getEmojiImageURL(emoji) {
    if (!emoji) return '';
    
    try {
        // å¦‚æœæœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨ï¼Œä½¿ç”¨ImageDisplayHelper
        if (emoji.fileId && window.ImageDisplayHelper) {
            return await window.ImageDisplayHelper.getEmojiURL(emoji);
        }
        
        // å›é€€åˆ°æ—§æ ¼å¼
        return emoji.data || emoji.url || '';
    } catch (error) {
        console.warn('è·å–è¡¨æƒ…åŒ…å¤±è´¥:', error);
        return emoji.data || emoji.url || '';
    }
} 
let playlist = [];
let currentSongIndex = -1;
let isPlaying = false;
let lyricTimer = null;
let currentObjectUrl = null;

// --- æ ‡å¿—ä½ä¸åˆ†é¡µåŠ è½½çŠ¶æ€ ---
let isEmojiGridRendered = false;
let isMomentsRendered = false;
let isMomentsDataModified = false; // æœ‹å‹åœˆæ•°æ®æ˜¯å¦è¢«ä¿®æ”¹ï¼Œéœ€è¦é‡æ–°æ¸²æŸ“
let isMusicPlayerInitialized = false;
let isIndexedDBReady = false; 
// âš ï¸ æ³¨æ„ï¼šæ•°æ®åº“æ“ä½œç»Ÿä¸€ä½¿ç”¨ window.db å’Œ window.isIndexedDBReadyï¼Œä¸è¦ä½¿ç”¨å±€éƒ¨å˜é‡ 
const MESSAGES_PER_PAGE = 15;
let currentlyDisplayedMessageCount = 0;
let isLoadingMoreMessages = false;

// è®ºå›å¸–å­åˆ†é¡µç›¸å…³å˜é‡
const POSTS_PER_PAGE = 10;
let currentlyDisplayedPostCount = 0;
let isLoadingMorePosts = false;

// è™šæ‹Ÿæ»šåŠ¨ç›¸å…³å˜é‡
const VIRTUAL_WINDOW_SIZE = 8; // è™šæ‹Ÿæ»šåŠ¨çª—å£å¤§å°
const ESTIMATED_POST_HEIGHT = 300; // ä¼°ç®—çš„å¸–å­é«˜åº¦ï¼ˆåƒç´ ï¼‰
let allPosts = []; // æ‰å¹³åŒ–çš„æ‰€æœ‰å¸–å­åˆ—è¡¨
let virtualScrollTop = 0;
let currentStartIndex = 0;
let currentEndIndex = 0;

// å¤šé€‰æ¨¡å¼çŠ¶æ€
let isMultiSelectMode = false;
let selectedMessages = new Set();

// è¯­éŸ³æ’­æ”¾ç›¸å…³å…¨å±€å˜é‡
let voiceAudio = new Audio(); // ç”¨äºæ’­æ”¾è¯­éŸ³æ¶ˆæ¯çš„å…¨å±€Audioå¯¹è±¡
let currentPlayingElement = null; // è·Ÿè¸ªå½“å‰æ’­æ”¾çš„è¯­éŸ³å…ƒç´ 


console.log('ServiceWorker disabled in single-file mode');

// --- åˆå§‹åŒ–è¿›åº¦æ˜¾ç¤ºå‡½æ•° ---

/**
 * æ˜¾ç¤ºåˆå§‹åŒ–è¿›åº¦æç¤º
 * @param {string} message - æ˜¾ç¤ºæ¶ˆæ¯
 * @param {string} type - æ¶ˆæ¯ç±»å‹ (system/api/worker/url/import/database/error)
 */
function showInitializationProgress(message, type = 'info') {
    // æŸ¥æ‰¾æˆ–åˆ›å»ºè¿›åº¦å®¹å™¨
    let progressContainer = document.getElementById('init-progress-container');
    if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'init-progress-container';
        progressContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;
        
        const progressBox = document.createElement('div');
        progressBox.id = 'init-progress-box';
        progressBox.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `;
        
        progressBox.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                <div class="spinner" style="
                    width: 24px; height: 24px; margin-right: 12px;
                    border: 3px solid #f3f3f3; border-top: 3px solid #007bff;
                    border-radius: 50%; animation: spin 1s linear infinite;
                "></div>
                <h3 style="margin: 0; color: #333;">Whale-LLT æ­£åœ¨å¯åŠ¨</h3>
            </div>
            <p id="init-progress-message" style="margin: 0; color: #666; line-height: 1.5;"></p>
            <div id="init-progress-steps" style="margin-top: 15px; font-size: 12px; color: #999; text-align: left;"></div>
        `;
        
        progressContainer.appendChild(progressBox);
        document.body.appendChild(progressContainer);
        
        // æ·»åŠ CSSåŠ¨ç”»
        if (!document.getElementById('init-progress-styles')) {
            const style = document.createElement('style');
            style.id = 'init-progress-styles';
            style.textContent = `
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    const messageEl = document.getElementById('init-progress-message');
    const stepsEl = document.getElementById('init-progress-steps');
    
    if (messageEl) {
        messageEl.textContent = message;
        messageEl.style.color = type === 'error' ? '#dc3545' : '#666';
    }
    
    // è®°å½•æ­¥éª¤
    if (type !== 'error' && stepsEl) {
        const timestamp = new Date().toLocaleTimeString();
        const stepEl = document.createElement('div');
        stepEl.textContent = `${timestamp} - ${message}`;
        stepEl.style.cssText = 'margin: 2px 0; opacity: 0.7;';
        stepsEl.appendChild(stepEl);
        
        // åªä¿ç•™æœ€è¿‘5ä¸ªæ­¥éª¤
        while (stepsEl.children.length > 5) {
            stepsEl.removeChild(stepsEl.firstChild);
        }
    }
    
    console.log(`[åˆå§‹åŒ–è¿›åº¦] ${message}`);
}

/**
 * éšè—åˆå§‹åŒ–è¿›åº¦æç¤º
 */
function hideInitializationProgress() {
    const progressContainer = document.getElementById('init-progress-container');
    if (progressContainer) {
        progressContainer.style.opacity = '0';
        progressContainer.style.transition = 'opacity 0.3s ease-out';
        
        setTimeout(() => {
            if (progressContainer.parentNode) {
                progressContainer.parentNode.removeChild(progressContainer);
            }
        }, 300);
    }
    
    // æ¸…ç†æ ·å¼
    const styles = document.getElementById('init-progress-styles');
    if (styles && styles.parentNode) {
        styles.parentNode.removeChild(styles);
    }
}

// --- åˆå§‹åŒ– ---
async function init() {
    try {
        console.log('[DEBUG] å¼€å§‹åº”ç”¨åˆå§‹åŒ–...');
        
        // [DEBUG-MOMENTS-ROLES-START] ä½¿ç”¨ç»Ÿä¸€çš„æ•°æ®åº“åˆå§‹åŒ–ï¼Œä¿®å¤å®Œæˆåå¯é€‰æ‹©ä¿ç•™
        await executeWithRetry(async () => {
            console.log('[DEBUG] è°ƒç”¨ç»Ÿä¸€çš„æ•°æ®åº“åˆå§‹åŒ–å‡½æ•°');
            
            // ä½¿ç”¨ç»Ÿä¸€çš„æ•°æ®åº“åˆå§‹åŒ–å‡½æ•°ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶
            const db = await initializeDatabaseOnce();
            
            // äºŒæ¬¡ç¡®è®¤åˆå§‹åŒ–ç»“æœ
            if (!db || !window.isIndexedDBReady) {
                throw new Error('ç»Ÿä¸€æ•°æ®åº“åˆå§‹åŒ–åè¿æ¥ä»æœªå»ºç«‹');
            }
            
            // éªŒè¯å…³é”®è¡¨æ˜¯å¦å­˜åœ¨
            const requiredStores = ['contacts', 'moments', 'apiSettings'];
            const missingStores = requiredStores.filter(store => !window.db.objectStoreNames.contains(store));
            if (missingStores.length > 0) {
                throw new Error(`æ•°æ®åº“åˆå§‹åŒ–ä¸å®Œæ•´ï¼Œç¼ºå°‘å­˜å‚¨: ${missingStores.join(', ')}`);
            }
            
            console.log('[DEBUG] ç»Ÿä¸€æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
            console.log('[DEBUG] æ•°æ®åº“ç‰ˆæœ¬:', window.db.version);
            console.log('[DEBUG] å¯ç”¨å­˜å‚¨:', Array.from(window.db.objectStoreNames));
            
        }, 'åº”ç”¨åˆå§‹åŒ– - ç»Ÿä¸€æ•°æ®åº“è¿æ¥');
        // [DEBUG-MOMENTS-ROLES-END]
        
        // ä»IndexedDBåŠ è½½æ•°æ®
        await loadDataFromDB();
        console.log('åº”ç”¨æ•°æ®åŠ è½½å®Œæˆ');
        
        // åˆå§‹åŒ–å›¾ç‰‡å…³é”®è¯ç”Ÿæˆå™¨
        if (window.imageKeywordGenerator && window.apiService) {
            window.imageKeywordGenerator.init(apiSettings, window.apiService);
            console.log('å›¾ç‰‡å…³é”®è¯ç”Ÿæˆå™¨åˆå§‹åŒ–å®Œæˆ');
        }
        
        // ä¸ƒå¤•èŠ‚ç‰¹æ®Šå¤„ç† - æ£€æŸ¥æ˜¯å¦ä¸º8æœˆ29æ—¥ä¸”ç¬¬ä¸€æ¬¡æ‰“å¼€
        await window.SystemUtils.checkSpecialEvents();
        
    } catch (error) {
        console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
        
        // åˆ†æé”™è¯¯ç±»å‹å¹¶æä¾›é’ˆå¯¹æ€§è§£å†³æ–¹æ¡ˆ
        let errorType = 'unknown';
        if (error.message.includes('æ•°æ®åº“') || error.message.includes('IndexedDB') || error.message.includes('objectStoreNames')) {
            errorType = 'database';
        } else if (error.message.includes('ç½‘ç»œ') || error.message.includes('fetch')) {
            errorType = 'network';
        }
        
        // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯ç”¨äºè°ƒè¯•
        window.lastInitError = {
            timestamp: new Date().toISOString(),
            error: error.message,
            stack: error.stack,
            userAgent: navigator.userAgent,
            url: window.location.href,
            type: errorType,
            dbState: {
                hasWindow: !!window.db,
                isReady: !!window.isIndexedDBReady,
                dbVersion: window.db?.version
            }
        };
        
        showDatabaseErrorDialog(error, false);
        throw error;
    }

    await renderContactList();
    // ç«‹å³æ›´æ–°ä¸€æ¬¡æ—¶é—´æ˜¾ç¤ºï¼Œç¡®ä¿é¦–æ¬¡è¿›å…¥é¡µé¢æ˜¾ç¤ºæ­£ç¡®çš„æ—¶é—´
    updateContactListTimes();
    await updateUserProfileUI();
    updateContextIndicator();
    
    // ç»‘å®šåŸºç¡€äº‹ä»¶
    const chatInput = document.getElementById('chatInput');
    chatInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
    });
    
    setTimeout(() => {
        const hint = document.getElementById('featureHint');
        if (hint) {
            hint.style.display = 'block';
            setTimeout(() => {
                hint.style.display = 'none';
            }, 5000);
        }
    }, 1000);

    // ä¸ºå…¨å±€voiceAudioå¯¹è±¡ç»‘å®šäº‹ä»¶
    voiceAudio.onended = () => {
        if (currentPlayingElement) {
            currentPlayingElement.classList.remove('playing');
            const voiceIcon = currentPlayingElement.querySelector('.voice-icon');
            if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
            currentPlayingElement = null;
        }
    };
    voiceAudio.onerror = () => {
        showToast('éŸ³é¢‘æ–‡ä»¶åŠ è½½å¤±è´¥');
        if (currentPlayingElement) {
             currentPlayingElement.classList.remove('playing', 'loading');
             const voiceIcon = currentPlayingElement.querySelector('.voice-icon');
             if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
             currentPlayingElement = null;
        }
    };


    // Check for update announcements
    const unreadAnnouncements = await announcementManager.getUnread();
    if (unreadAnnouncements.length > 0) {
        const modalBody = document.getElementById('updateModalBody');
        const modalFooter = document.querySelector('#updateModal .modal-footer');
        
        const combinedContent = unreadAnnouncements.reverse()
            .map(ann => ann.content)
            .join('<hr style="margin: 20px 0; border: 0; border-top: 1px solid #eee;">');
        
        modalBody.innerHTML = marked.parse(combinedContent);
        showModal('updateModal');

        // Logic to show button when scrolled to bottom
        modalBody.onscroll = () => {
            // Check if the user has scrolled to the bottom
            // Adding a 5px tolerance
            if (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 5) {
                modalFooter.classList.add('visible');
            }
        };

        // Also check if the content is not long enough to scroll
        // Use a timeout to allow the DOM to render first
        setTimeout(() => {
            if (modalBody.scrollHeight <= modalBody.clientHeight) {
                modalFooter.classList.add('visible');
            }
        }, 100);


        document.getElementById('updateModalCloseBtn').onclick = () => {
            closeModal('updateModal');
            const idsToMark = unreadAnnouncements.map(ann => ann.id);
            announcementManager.markAsSeen(idsToMark);
        };
    }
}



// --- IndexedDB æ ¸å¿ƒå‡½æ•° ---

// è¡¨æƒ…æ•°æ®ç»“æ„ä¼˜åŒ–å‡½æ•°ï¼ˆç‰ˆæœ¬4ã€5ç”¨æˆ·å‡çº§åˆ°7æ—¶è‡ªåŠ¨æ‰§è¡Œï¼‰
async function performEmojiOptimization() {
    try {
        console.log('å¼€å§‹æ‰§è¡Œè¡¨æƒ…æ•°æ®ç»“æ„ä¼˜åŒ–...');
        
        if (!window.isIndexedDBReady) {
            console.error('æ•°æ®åº“æœªå‡†å¤‡å°±ç»ªï¼Œæ— æ³•æ‰§è¡Œä¼˜åŒ–');
            return;
        }
        
        // è·å–å½“å‰æ•°æ®
        const transaction = window.db.transaction(['contacts', 'emojis', 'emojiImages'], 'readonly');
        const contactsStore = transaction.objectStore('contacts');
        const emojisStore = transaction.objectStore('emojis');
        const emojiImagesStore = transaction.objectStore('emojiImages');
        
        const contacts = await promisifyRequest(contactsStore.getAll()) || [];
        const emojis = await promisifyRequest(emojisStore.getAll()) || [];
        const existingEmojiImages = await promisifyRequest(emojiImagesStore.getAll()) || [];
        
        if (contacts.length === 0 || emojis.length === 0) {
            console.log('æ²¡æœ‰æ•°æ®éœ€è¦ä¼˜åŒ–ï¼Œè·³è¿‡');
            return;
        }
        
        let processedCount = 0;
        const base64UrlPattern = /data:image\/[^;]+;base64,[A-Za-z0-9+\/=]+/g;
        const newEmojiImages = [];
        const updatedEmojis = [...emojis];
        const updatedContacts = [];
        
        // éå†æ‰€æœ‰è”ç³»äººçš„æ¶ˆæ¯
        for (const contact of contacts) {
            const updatedContact = { ...contact };
            let contactUpdated = false;
            
            if (contact.messages && Array.isArray(contact.messages)) {
                updatedContact.messages = [];
                
                for (const message of contact.messages) {
                    const updatedMessage = { ...message };
                    
                    if (message.content && typeof message.content === 'string') {
                        const matches = message.content.match(base64UrlPattern);
                        if (matches) {
                            for (const base64Url of matches) {
                                // æŸ¥æ‰¾å¯¹åº”çš„è¡¨æƒ…
                                const emoji = updatedEmojis.find(e => e.url === base64Url);
                                if (emoji && emoji.meaning) {
                                    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„è¡¨æƒ…å›¾ç‰‡
                                    const existingImage = existingEmojiImages.find(img => img.tag === emoji.meaning) ||
                                                        newEmojiImages.find(img => img.tag === emoji.meaning);
                                    
                                    if (!existingImage) {
                                        newEmojiImages.push({
                                            tag: emoji.meaning,
                                            data: base64Url
                                        });
                                    }
                                    
                                    // æ›´æ–°è¡¨æƒ…æ•°æ®ç»“æ„
                                    if (!emoji.tag) {
                                        emoji.tag = emoji.meaning;
                                    }
                                    if (emoji.url) {
                                        delete emoji.url;
                                    }
                                    
                                    // æ›¿æ¢æ¶ˆæ¯ä¸­çš„æ ¼å¼
                                    updatedMessage.content = updatedMessage.content.replace(
                                        base64Url,
                                        `[emoji:${emoji.meaning}]`
                                    );
                                    
                                    processedCount++;
                                    contactUpdated = true;
                                }
                            }
                        }
                    }
                    
                    updatedContact.messages.push(updatedMessage);
                }
            }
            
            if (contactUpdated) {
                updatedContacts.push(updatedContact);
            }
        }
        
        // ä¿å­˜ä¼˜åŒ–åçš„æ•°æ®
        if (processedCount > 0) {
            const writeTransaction = window.db.transaction(['contacts', 'emojis', 'emojiImages'], 'readwrite');
            
            // æ›´æ–°è¡¨æƒ…å›¾ç‰‡æ•°æ®
            if (newEmojiImages.length > 0) {
                const emojiImagesStore = writeTransaction.objectStore('emojiImages');
                for (const emojiImage of newEmojiImages) {
                    await promisifyRequest(emojiImagesStore.put(emojiImage));
                }
            }
            
            // æ›´æ–°è¡¨æƒ…å…ƒæ•°æ®
            const emojisStore = writeTransaction.objectStore('emojis');
            for (const emoji of updatedEmojis) {
                if (emoji.tag) { // åªæ›´æ–°æœ‰tagçš„è¡¨æƒ…
                    await promisifyRequest(emojisStore.put(emoji));
                }
            }
            
            // æ›´æ–°è”ç³»äººæ¶ˆæ¯
            const contactsStore = writeTransaction.objectStore('contacts');
            for (const contact of updatedContacts) {
                await promisifyRequest(contactsStore.put(contact));
            }
            
            console.log(`è¡¨æƒ…æ•°æ®ç»“æ„ä¼˜åŒ–å®Œæˆï¼`);
            console.log(`- å¤„ç†äº† ${processedCount} ä¸ªè¡¨æƒ…å¼•ç”¨`);
            console.log(`- åˆ›å»ºäº† ${newEmojiImages.length} ä¸ªæ–°çš„è¡¨æƒ…å›¾ç‰‡è®°å½•`);
            console.log(`- æ›´æ–°äº† ${updatedContacts.length} ä¸ªè”ç³»äººçš„æ¶ˆæ¯`);
            
            // æ˜¾ç¤ºæç¤º
            if (typeof showToast === 'function') {
                showToast(`è¡¨æƒ…æ•°æ®ä¼˜åŒ–å®Œæˆï¼å¤„ç†äº† ${processedCount} ä¸ªè¡¨æƒ…`, 'success');
            }
            
            // é‡æ–°åŠ è½½æ•°æ®ä»¥ç¡®ä¿ç•Œé¢åŒæ­¥
            await loadDataFromDB();
        } else {
            console.log('æ²¡æœ‰éœ€è¦ä¼˜åŒ–çš„è¡¨æƒ…æ•°æ®');
        }
        
    } catch (error) {
        console.error('è¡¨æƒ…æ•°æ®ä¼˜åŒ–å¤±è´¥:', error);
        if (typeof showToast === 'function') {
            showToast('è¡¨æƒ…æ•°æ®ä¼˜åŒ–å¤±è´¥: ' + error.message, 'error');
        }
    }
}

async function loadDataFromDB() {
    return await ensureDBReady(async () => {
        console.log('[FIXED] å¼€å§‹ä»æ•°æ®åº“åŠ è½½æ•°æ®ï¼Œä½¿ç”¨ window.db...');
        
        const storeNames = [
        'contacts', 
        'apiSettings', 
        'emojis', 
        'backgrounds', 
        'userProfile', 
        'moments', 
        'weiboPosts', 
        'hashtagCache'
        ];

        // å…ˆæ£€æŸ¥å­˜ä¸å­˜åœ¨ emojiImages
        if (window.db.objectStoreNames.contains('emojiImages')) {
            storeNames.push('emojiImages');
        } else {
            console.warn('æ•°æ®åº“ç‰ˆæœ¬æœªåŒ…å« emojiImages å­˜å‚¨ï¼Œå»ºè®®æ›´æ–°é¡µé¢ä»¥å‡çº§æ•°æ®åº“ã€‚');
        }
        
        const transaction = window.db.transaction(storeNames, 'readonly');
        
        const contactsStore = transaction.objectStore('contacts');
        const apiSettingsStore = transaction.objectStore('apiSettings');
        const emojisStore = transaction.objectStore('emojis');
        const backgroundsStore = transaction.objectStore('backgrounds');
        const userProfileStore = transaction.objectStore('userProfile');
        const momentsStore = transaction.objectStore('moments');
        const weiboPostsStore = transaction.objectStore('weiboPosts');
        
        // åŠ è½½è”ç³»äººæ•°æ®
        contacts = (await promisifyRequest(contactsStore.getAll(), 'åŠ è½½è”ç³»äººæ•°æ®')) || [];
        console.log(`[DEBUG] ä»æ•°æ®åº“åŠ è½½äº† ${contacts.length} ä¸ªè”ç³»äºº`);
        
        // æ›´æ–°å…¨å±€å¼•ç”¨
        window.contacts = contacts;
        
        // [DEBUG-MOMENTS-ROLES-START] è°ƒè¯•ä¿¡æ¯ï¼Œä¿®å¤å®Œæˆååˆ é™¤
        if (contacts.length > 0) {
            const privateContacts = contacts.filter(c => c.type === 'private');
            console.log('[DEBUG] contactsæ•°æ®åŠ è½½è¯¦æƒ…:', {
                totalContacts: contacts.length,
                privateContacts: privateContacts.length,
                contactsList: contacts.map(c => ({ name: c.name, id: c.id, type: c.type })),
                windowContactsSet: !!window.contacts,
                windowContactsLength: window.contacts ? window.contacts.length : 0
            });
        } else {
            console.warn('[DEBUG] æ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•è”ç³»äººæ•°æ®');
        }
        // [DEBUG-MOMENTS-ROLES-END]
        
        // è¿ç§»æ—§æ•°æ®æ ¼å¼æˆ–æ·»åŠ é»˜è®¤å€¼
        contacts.forEach(contact => {
            if (contact.type === undefined) contact.type = 'private';
            // ä¸ºæ—§è”ç³»äººæ•°æ®æ·»åŠ  voiceId é»˜è®¤å€¼
            if (contact.voiceId === undefined) contact.voiceId = '';
            window.memoryTableManager.initContactMemoryTable(contact);
            if (contact.messages) {
                contact.messages.forEach(msg => {
                    if (msg.role === 'user' && msg.senderId === undefined) msg.senderId = 'user';
                    else if (msg.role === 'assistant' && msg.senderId === undefined) msg.senderId = contact.id;
                });
            }
        });

        // åŠ è½½APIè®¾ç½®ï¼ˆåªåŒ…å«è¿æ¥ä¿¡æ¯ï¼‰
        const savedApiSettings = (await promisifyRequest(apiSettingsStore.get('settings'), 'åŠ è½½APIè®¾ç½®')) || {};
        apiSettings = {
            ...apiSettings,
            url: savedApiSettings.url || '',
            key: savedApiSettings.key || '',
            contextMessageCount: savedApiSettings.contextMessageCount || 10,
            timeout: savedApiSettings.timeout || 60
        };

        // ä¸ºæ—§APIè®¾ç½®æ•°æ®æ·»åŠ  elevenLabsApiKey é»˜è®¤å€¼
        if (apiSettings.elevenLabsApiKey === undefined) apiSettings.elevenLabsApiKey = '';

        // æ›´æ–°å…¨å±€å¼•ç”¨
        window.apiSettings = apiSettings;
        console.log('APIè®¾ç½®åŠ è½½å®Œæˆ');

        // åŠ è½½è¡¨æƒ…æ•°æ®
        emojis = (await promisifyRequest(emojisStore.getAll(), 'åŠ è½½è¡¨æƒ…æ•°æ®')) || [];
        console.log(`åŠ è½½äº† ${emojis.length} ä¸ªè¡¨æƒ…`);
        
        // åŠ è½½èƒŒæ™¯æ•°æ®
        backgrounds = (await promisifyRequest(backgroundsStore.get('backgroundsMap'), 'åŠ è½½èƒŒæ™¯æ•°æ®')) || {};
        console.log(`åŠ è½½äº† ${Object.keys(backgrounds).length} ä¸ªèƒŒæ™¯`);
        
        // åŠ è½½ç”¨æˆ·èµ„æ–™
        const savedUserProfile = (await promisifyRequest(userProfileStore.get('profile'), 'åŠ è½½ç”¨æˆ·èµ„æ–™')) || {};
        userProfile = { ...userProfile, ...savedUserProfile };
        if (userProfile.personality === undefined) {
            userProfile.personality = '';
        }
        console.log('ç”¨æˆ·èµ„æ–™åŠ è½½å®Œæˆ');
        
        // åŠ è½½æœ‹å‹åœˆæ•°æ®
        moments = (await promisifyRequest(momentsStore.getAll(), 'åŠ è½½æœ‹å‹åœˆæ•°æ®')) || [];
        console.log(`åŠ è½½äº† ${moments.length} ä¸ªæœ‹å‹åœˆ`);
        
        // åŠ è½½å¾®åšæ•°æ®
        weiboPosts = (await promisifyRequest(weiboPostsStore.getAll(), 'åŠ è½½å¾®åšæ•°æ®')) || [];
        console.log(`åŠ è½½äº† ${weiboPosts.length} ä¸ªå¾®åšå¸–å­`);

        // åŠ è½½hashtagç¼“å­˜
        const hashtagCacheStore = transaction.objectStore('hashtagCache');
        const savedHashtagCache = (await promisifyRequest(hashtagCacheStore.get('cache'), 'åŠ è½½æ ‡ç­¾ç¼“å­˜')) || {};
        hashtagCache = savedHashtagCache;
        console.log('æ ‡ç­¾ç¼“å­˜åŠ è½½å®Œæˆ');

        // é‡æ–°åˆå§‹åŒ–è§’è‰²è®°å¿†ç®¡ç†å™¨çš„æ•°æ®ï¼ˆç°åœ¨æ•°æ®åº“å·²å‡†å¤‡å¥½ï¼‰
        if (window.characterMemoryManager) {
            try {
                await window.characterMemoryManager.loadConversationCounters();
                await window.characterMemoryManager.getGlobalMemory();
                console.log('è§’è‰²è®°å¿†ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
            } catch (memoryError) {
                console.error('è§’è‰²è®°å¿†ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', memoryError);
            }
        }
        
        // åˆå§‹åŒ–å®Œæˆåè¿›è¡Œæ•°æ®ä¸€è‡´æ€§æ£€æŸ¥
        if (weiboPosts && weiboPosts.length > 0) {
            const repaired = await checkAndRepairDataConsistency();
            if (repaired) {
                console.log('åˆå§‹åŒ–æ—¶ä¿®å¤äº†æ•°æ®ä¸ä¸€è‡´æ€§');
            }
        }
        
        // æ•°æ®åº“å¥åº·æ£€æŸ¥å’Œä¿®å¤æç¤º
        if (window.DatabaseManager && window.DatabaseManager.checkAndOfferRepair) {
            window.DatabaseManager.checkAndOfferRepair();
        }

        console.log('æ•°æ®åº“äº‹åŠ¡æ•°æ®åŠ è½½å®Œæˆ');

    }, 'æ•°æ®åº“åŠ è½½æ“ä½œ');

    // åœ¨äº‹åŠ¡ç»“æŸååŠ è½½å…¨å±€æ¨¡å‹é…ç½®
    try {
        const modelConfig = await window.apiConfigManager.getGlobalModelConfig();
        window.modelSettings = {
            apiConfigId: modelConfig.apiConfigId || '',
            primaryModel: modelConfig.primaryModel || '',
            secondaryModel: modelConfig.secondaryModel || ''
        };
        console.log('å…¨å±€æ¨¡å‹é…ç½®åŠ è½½å®Œæˆ:', window.modelSettings);
    } catch (error) {
        console.warn('åŠ è½½å…¨å±€æ¨¡å‹é…ç½®å¤±è´¥:', error);
        window.modelSettings = {
            apiConfigId: '',
            primaryModel: '',
            secondaryModel: ''
        };
    }

    console.log('æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆ');
    showToast('æ•°æ®åŠ è½½å®Œæˆ', 'success');
}

async function saveDataToDB() {
    return await ensureDBReady(async () => {
        console.log('[FIXED] å¼€å§‹ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“ï¼Œä½¿ç”¨ window.db...');
        
        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ–°çš„emojiImageså­˜å‚¨
        const storeNames = ['contacts', 'apiSettings', 'emojis', 'backgrounds', 'userProfile', 'moments', 'hashtagCache'];
        if (window.db.objectStoreNames.contains('emojiImages')) {
            storeNames.push('emojiImages');
        }
        
        const transaction = window.db.transaction(storeNames, 'readwrite');
        
        const contactsStore = transaction.objectStore('contacts');
        const apiSettingsStore = transaction.objectStore('apiSettings');
        const emojisStore = transaction.objectStore('emojis');
        const backgroundsStore = transaction.objectStore('backgrounds');
        const userProfileStore = transaction.objectStore('userProfile');
        const momentsStore = transaction.objectStore('moments');
        
        // æ¸…ç©ºcontactsï¼Œç„¶åé‡æ–°æ·»åŠ ï¼Œç¡®ä¿æ•°æ®æœ€æ–°
        await promisifyRequest(contactsStore.clear(), 'æ¸…ç©ºè”ç³»äººæ•°æ®');
        console.log(`å¼€å§‹ä¿å­˜ ${contacts.length} ä¸ªè”ç³»äºº...`);
        for (const contact of contacts) {
            await promisifyRequest(contactsStore.put(contact), `ä¿å­˜è”ç³»äºº ${contact.name || contact.id}`);
        }
        console.log('è”ç³»äººæ•°æ®ä¿å­˜å®Œæˆ');

        // ä¿å­˜APIè®¾ç½®
        await promisifyRequest(apiSettingsStore.put({ id: 'settings', ...apiSettings }), 'ä¿å­˜APIè®¾ç½®');
        console.log('APIè®¾ç½®ä¿å­˜å®Œæˆ');
        
        // ä¿å­˜è¡¨æƒ…æ•°æ®
        await promisifyRequest(emojisStore.clear(), 'æ¸…ç©ºè¡¨æƒ…æ•°æ®');
        console.log(`å¼€å§‹ä¿å­˜ ${emojis.length} ä¸ªè¡¨æƒ…...`);
        for (const emoji of emojis) {
            await promisifyRequest(emojisStore.put(emoji), `ä¿å­˜è¡¨æƒ… ${emoji.id}`);
        }
        console.log('è¡¨æƒ…æ•°æ®ä¿å­˜å®Œæˆ');

        // ä¿å­˜èƒŒæ™¯å’Œç”¨æˆ·èµ„æ–™
        await promisifyRequest(backgroundsStore.put({ id: 'backgroundsMap', ...backgrounds }), 'ä¿å­˜èƒŒæ™¯æ•°æ®');
        await promisifyRequest(userProfileStore.put({ id: 'profile', ...userProfile }), 'ä¿å­˜ç”¨æˆ·èµ„æ–™');
        console.log('èƒŒæ™¯å’Œç”¨æˆ·èµ„æ–™ä¿å­˜å®Œæˆ');
        
        // ä¿å­˜æœ‹å‹åœˆæ•°æ®
        await promisifyRequest(momentsStore.clear(), 'æ¸…ç©ºæœ‹å‹åœˆæ•°æ®');
        console.log(`å¼€å§‹ä¿å­˜ ${moments.length} ä¸ªæœ‹å‹åœˆ...`);
        for (const moment of moments) {
            await promisifyRequest(momentsStore.put(moment), `ä¿å­˜æœ‹å‹åœˆ ${moment.id}`);
        }
        console.log('æœ‹å‹åœˆæ•°æ®ä¿å­˜å®Œæˆ');

        // ä¿å­˜hashtagç¼“å­˜
        const hashtagCacheStore = transaction.objectStore('hashtagCache');
        await promisifyRequest(hashtagCacheStore.put({ id: 'cache', ...hashtagCache }), 'ä¿å­˜æ ‡ç­¾ç¼“å­˜');
        console.log('æ ‡ç­¾ç¼“å­˜ä¿å­˜å®Œæˆ');

        // ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆ
        await promisifyTransaction(transaction, 'æ•°æ®ä¿å­˜äº‹åŠ¡');
        console.log('æ‰€æœ‰æ•°æ®ä¿å­˜å®Œæˆ');        
    }, 'æ•°æ®åº“ä¿å­˜æ“ä½œ');
}


/**
 * ğŸ”¥ ç®€åŒ–çš„æ•°æ®åº“åˆå§‹åŒ–å‡½æ•° - ä½¿ç”¨ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨
 * æ›¿ä»£äº†å¤æ‚çš„ initializeDatabaseOnce é€»è¾‘
 */
async function initializeDatabaseOnce() {
    console.log('ğŸ”¥ [ç®€åŒ–åˆå§‹åŒ–] ä½¿ç”¨ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨åˆå§‹åŒ–...');
    
    try {
        // ä½¿ç”¨ç»Ÿä¸€æ•°æ®åº“ç®¡ç†å™¨è¿›è¡Œåˆå§‹åŒ–
        const db = await window.unifiedDB.init();
        
        console.log('ğŸ”¥ [ç®€åŒ–åˆå§‹åŒ–] æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸï¼Œç‰ˆæœ¬:', db.version);
        console.log('ğŸ”¥ [ç®€åŒ–åˆå§‹åŒ–] å¯ç”¨å­˜å‚¨:', Array.from(db.objectStoreNames));
        
        // åˆå§‹åŒ–APIé…ç½®ç®¡ç†å™¨
        if (window.apiConfigManager) {
            try {
                await window.apiConfigManager.init();
                console.log('ğŸ”¥ [ç®€åŒ–åˆå§‹åŒ–] APIé…ç½®ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('ğŸ”¥ [ç®€åŒ–åˆå§‹åŒ–] APIé…ç½®ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }
        
        return db;
        
    } catch (error) {
        console.error('ğŸ”¥ [ç®€åŒ–åˆå§‹åŒ–] æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
        throw error;
    }
}


// --- è®ºå›åŠŸèƒ½ ---

// formatTime function moved to utils/formatUtils.js

// --- é¡µé¢å¯¼èˆª ---
const pageIds = ['contactListPage', 'weiboPage', 'momentsPage', 'profilePage', 'chatPage', 'dataManagementPage', 'debugLogPage', 'memoryManagementPage', 'userProfilePage', 'appearanceManagementPage', 'apiConfigManagementPage', 'interactivePage'];

function showPage(pageIdToShow) {
    // å¼‚æ­¥åŒ…è£…å‡½æ•°ï¼Œç”¨äºå¤„ç†åŒ…å«å¼‚æ­¥æ“ä½œçš„é¡µé¢æ˜¾ç¤º
    showPageAsync(pageIdToShow).catch(error => {
        console.error('é¡µé¢æ˜¾ç¤ºé”™è¯¯:', error);
    });
}

async function showPageAsync(pageIdToShow) {
    // è®°å½•å½“å‰æ´»è·ƒé¡µé¢ï¼Œç”¨äºå¯¼èˆªå†å²
    const currentActivePage = pageNavManager.getCurrentActivePage();
    if (currentActivePage && currentActivePage !== pageIdToShow) {
        pageNavManager.navigateTo(currentActivePage, pageIdToShow);
    }

    // Hide all main pages and the chat page
    pageIds.forEach(pageId => {
        const page = document.getElementById(pageId);
        if (page) {
            page.classList.remove('active');
        }
    });

    // Show the requested page
    const pageToShow = document.getElementById(pageIdToShow);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }

    // Update the active state of the bottom navigation buttons
    const navItems = document.querySelectorAll('.bottom-nav .nav-item');
    const navMapping = ['contactListPage', 'weiboPage', 'momentsPage', 'profilePage'];
    navItems.forEach((item, index) => {
        // This relies on the order in the HTML, which is correct.
        if (navMapping[index] === pageIdToShow) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });

    // å…¼å®¹æ€§é€‚é…ï¼šæ˜¾å¼æ§åˆ¶åº•éƒ¨å¯¼èˆªæ çš„æ˜¾ç¤º/éšè—
    // ä¸ºä¸æ”¯æŒ :has() é€‰æ‹©å™¨çš„æµè§ˆå™¨æä¾›JavaScriptå¤‡ç”¨æ–¹æ¡ˆ
    const bottomNav = document.querySelector('.bottom-nav');
    if (bottomNav) {
        if (pageIdToShow === 'chatPage') {
            // èŠå¤©é¡µé¢æ—¶éšè—å¯¼èˆªæ 
            bottomNav.style.display = 'none';
            document.body.classList.add('chat-active');
        } else {
            // å…¶ä»–é¡µé¢æ—¶æ˜¾ç¤ºå¯¼èˆªæ 
            bottomNav.style.display = 'flex';
            document.body.classList.remove('chat-active');
        }
    }

    // --- Lazy Loading/Rendering ---
    // Render Weibo posts when the page is shown
    if (pageIdToShow === 'weiboPage') {
        renderAllWeiboPosts();
    } else {
        // ç¦»å¼€è®ºå›é¡µé¢æ—¶æ¸…ç†è™šæ‹Ÿæ»šåŠ¨ç›‘å¬å™¨
        const weiboPage = document.getElementById('weiboPage');
        if (weiboPage) {
            weiboPage.onscroll = null;
        }
    }
    // Render Moments only on the first time it's opened OR if data has been modified
    if (pageIdToShow === 'momentsPage' && (!isMomentsRendered || isMomentsDataModified)) {
        await renderMomentsList();
        isMomentsRendered = true;
        isMomentsDataModified = false; // é‡ç½®ä¿®æ”¹æ ‡å¿—
    }
    
    // Load API Config Management page content
    if (pageIdToShow === 'apiConfigManagementPage') {
        await loadApiConfigManagementPage();
    }
    
    // æ›´æ–°æœ‹å‹åœˆé”å®šæŒ‡ç¤ºå™¨æ˜¾ç¤ºçŠ¶æ€
    if (window.momentsLockManager) {
        window.momentsLockManager.updateLockIndicator();
    }

    if (pageIdToShow === 'dataManagementPage') {
        refreshDatabaseStats();
    }
    
    // åˆ‡æ¢åˆ°è”ç³»äººåˆ—è¡¨æ—¶æ‰‹åŠ¨åˆ·æ–°æ—¶é—´æ˜¾ç¤º
    if (pageIdToShow === 'contactListPage') {
        updateContactListTimes();
    }
    
    // åˆ‡æ¢åˆ°ä¸ªäººä¿¡æ¯é¡µé¢æ—¶æ›´æ–°ç‰ˆæœ¬å·æ˜¾ç¤º
    if (pageIdToShow === 'profilePage') {
        updateProfileVersion();
    }

    // å®šæœŸæ¸…ç†å¯¼èˆªå†å²
    pageNavManager.cleanupHistory();
}

/**
 * æ›´æ–°ä¸ªäººä¿¡æ¯é¡µé¢çš„ç‰ˆæœ¬å·æ˜¾ç¤º
 */
function updateProfileVersion() {
    try {
        // ç¡®ä¿ EnvironmentConfig å·²åŠ è½½
        if (typeof EnvironmentConfig === 'undefined') {
            console.warn('EnvironmentConfig not loaded, using fallback version');
            return;
        }
        
        const versionElement = document.getElementById('profileVersionText');
        if (versionElement) {
            const version = EnvironmentConfig.getVersion();
            versionElement.textContent = version; // ä¸åŠ  v å‰ç¼€ï¼Œç›´æ¥æ˜¾ç¤º commit hash
        }
    } catch (error) {
        console.warn('Failed to update profile version:', error);
    }
}

function showGeneratePostModal() {
    const select = document.getElementById('postGenCharacterSelect');
    select.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>'; // Reset
    contacts.forEach(contact => {
        if (contact.type === 'private') {
            const option = document.createElement('option');
            option.value = contact.id;
            option.textContent = contact.name;
            select.appendChild(option);
        }
    });
    
    // é‡ç½®å…³ç³»é€‰æ‹©
    const relationSelect = document.getElementById('postGenRelations');
    relationSelect.value = '';
    handleRelationChange();
    
    // postUnsplashKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œä¸å†æ¢å¤Unsplash API Key
    
    showModal('generatePostModal');
}

// æ–°å¢ï¼šå¤„ç†å…³ç³»é€‰æ‹©å˜åŒ–
function handleRelationChange() {
    const relationSelect = document.getElementById('postGenRelations');
    const customRelationInput = document.getElementById('postGenCustomRelation');
    
    if (relationSelect.value === 'custom') {
        customRelationInput.parentElement.style.display = 'block'; // æ˜¾ç¤ºçˆ¶çº§ .form-group
        customRelationInput.required = true;
    } else {
        customRelationInput.parentElement.style.display = 'none'; // éšè—çˆ¶çº§ .form-group
        customRelationInput.required = false;
        customRelationInput.value = '';
    }
}

// æ–°å¢ï¼šå¤„ç†è§’è‰²é€‰æ‹©å˜åŒ–ï¼ŒåŠ è½½hashtagç¼“å­˜
function handleCharacterChange() {
    const contactId = document.getElementById('postGenCharacterSelect').value;
    const hashtagInput = document.getElementById('postGenHashtag');
    
    if (contactId && hashtagCache[contactId]) {
        hashtagInput.value = hashtagCache[contactId];
    } else {
        const contact = contacts.find(c => c.id === contactId);
        if (contact) {
            // é»˜è®¤hashtagä¸º #A & B#
            hashtagInput.value = `${contact.name} & ${userProfile.name}`;
        }
    }
}

async function handleGeneratePost(event) {
    event.preventDefault();
    const contactId = document.getElementById('postGenCharacterSelect').value;
    const relationSelect = document.getElementById('postGenRelations');
    const customRelationInput = document.getElementById('postGenCustomRelation');
    const hashtagInput = document.getElementById('postGenHashtag');
    const count = document.getElementById('postGenCount').value;
    // postUnsplashKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œä»localStorageç›´æ¥è·å–
    const unsplashKey = localStorage.getItem('forumUnsplashApiKey') || '';

    if (!contactId) {
        showToast('è¯·é€‰æ‹©è§’è‰²');
        return;
    }

    let relations;
    let relationDescription;
    
    if (relationSelect.value === 'custom') {
        if (!customRelationInput.value.trim()) {
            showToast('è¯·å¡«å†™è‡ªå®šä¹‰å…³ç³»');
            return;
        }
        relations = customRelationInput.value.trim();
        relationDescription = relations; // è‡ªå®šä¹‰å…³ç³»ç›´æ¥ä½¿ç”¨ç”¨æˆ·è¾“å…¥
    } else {
        if (!relationSelect.value) {
            showToast('è¯·é€‰æ‹©å…³ç³»ç±»å‹');
            return;
        }
        relations = relationSelect.value;
        relationDescription = RELATION_PRESETS[relations];
    }

    const hashtag = hashtagInput.value.trim();
    if (!hashtag) {
        showToast('è¯·å¡«å†™è¯é¢˜æ ‡ç­¾');
        return;
    }

    // ç¼“å­˜hashtag
    hashtagCache[contactId] = hashtag;
    await saveDataToDB();
    
    // Unsplash API Keyå·²ä»localStorageè·å–ï¼Œæ— éœ€é‡å¤ä¿å­˜

    closeModal('generatePostModal');
    await generateWeiboPosts(contactId, relations, relationDescription, hashtag, count, unsplashKey);
}

async function saveWeiboPost(postData) {
    if (!window.isIndexedDBReady) {
        console.error('IndexedDB not ready, cannot save post.');
        showToast('æ•°æ®åº“é”™è¯¯ï¼Œæ— æ³•ä¿å­˜å¸–å­');
        return;
    }
    try {
        const transaction = window.db.transaction(['weiboPosts'], 'readwrite');
        const store = transaction.objectStore('weiboPosts');
        await promisifyRequest(store.add(postData));
        await promisifyTransaction(transaction);
    } catch (error) {
        console.error('Failed to save Weibo post to DB:', error);
        showToast('ä¿å­˜å¸–å­å¤±è´¥');
    }
}

async function generateWeiboPosts(contactId, relations, relationDescription, hashtag, count = 1, unsplashKey = null) {
    
    const contact = contacts.find(c => c.id === contactId);
    
    if (!contact) {
        console.error('æœªæ‰¾åˆ°è”ç³»äººï¼ŒcontactId:', contactId, 'æ‰€æœ‰è”ç³»äºº:', contacts);
        showToast('æœªæ‰¾åˆ°æŒ‡å®šçš„èŠå¤©å¯¹è±¡');
        return;
    }
    
    
    // æ£€æŸ¥APIé…ç½®å’Œæ¨¡å‹é…ç½®
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        console.error('APIé…ç½®ä¸å®Œæ•´:', error.message);
        showToast('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®APIå’Œæ¨¡å‹');
        return;
    }

    if (!apiCallInfo.url || !apiCallInfo.key || !apiCallInfo.model) {
        console.error('APIé…ç½®ä¸å®Œæ•´:', apiCallInfo);
        showToast('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®APIå’Œæ¨¡å‹');
        return;
    }
    
    const container = document.getElementById('weiboContainer');
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'loading-text';
    loadingIndicator.textContent = 'æ­£åœ¨ç”Ÿæˆè®ºå›å†…å®¹...';
    container.prepend(loadingIndicator);

    console.log('æ­£åœ¨æ„å»ºç³»ç»Ÿæç¤ºè¯...');
    const systemPrompt = await window.promptBuilder.buildWeiboPrompt(
        contactId, 
        relations, 
        relationDescription,
        hashtag,
        count, 
        contact, 
        userProfile, 
        contacts,
        emojis
    );

    try {
        const payload = {
            model: apiCallInfo.model,
            messages: [{ role: 'user', content: systemPrompt }],
            response_format: { type: "json_object" },
            temperature: 0.7
        };

        const apiUrl = `${apiCallInfo.url}/chat/completions`;
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiCallInfo.key}`
            },
            body: JSON.stringify(payload)
        });

        console.log('æ”¶åˆ°APIå“åº”:', {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok,
            headers: Object.fromEntries(response.headers.entries())
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('APIè¯·æ±‚å¤±è´¥ï¼Œé”™è¯¯è¯¦æƒ…:', {
                status: response.status,
                statusText: response.statusText,
                errorText: errorText
            });
            throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        console.log('APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
        
        let rawText = data.choices[0].message.content;
        
        if (!rawText) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆå†…å®¹");
        }
        
        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let jsonText;
        try {
            jsonText = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }

        // è§£æJSON
        let weiboData;
        try {
            weiboData = JSON.parse(jsonText);
        } catch (parseError) {
            console.error('ERROR: JSONè§£æå¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONè§£æå¤±è´¥ - å°è¯•è§£æçš„æ–‡æœ¬:', jsonText);
            console.error('ERROR: JSONè§£æå¤±è´¥ - é”™è¯¯è¯¦æƒ…:', parseError);
            throw new Error(`JSONè§£æå¤±è´¥: ${parseError.message}`);
        }

        // --- æ—¶é—´æˆ³æ³¨å…¥ ---
        // æ³¨å…¥æ—¶é—´æˆ³
        const now = Date.now();
        // ä¸»æ¥¼æ—¶é—´è®¾ä¸º2-5åˆ†é’Ÿå‰
        const postCreatedAt = new Date(now - (Math.random() * 3 + 2) * 60 * 1000);
        let lastCommentTime = postCreatedAt.getTime();
        

        if (weiboData.posts && Array.isArray(weiboData.posts)) {
            weiboData.posts.forEach((post, index) => {
                post.timestamp = postCreatedAt.toISOString(); // ç»™ä¸»æ¥¼åŠ æ—¶é—´æˆ³
                
                if (post.comments && Array.isArray(post.comments)) {
                    post.comments.forEach((comment, commentIndex) => {
                        // å›å¤æ—¶é—´åœ¨ä¸»æ¥¼å’Œç°åœ¨ä¹‹é—´ï¼Œä¸”æ¯”ä¸Šä¸€æ¡æ™šä¸€ç‚¹
                        const newCommentTimestamp = lastCommentTime + (Math.random() * 2 * 60 * 1000); // 0-2åˆ†é’Ÿå
                        lastCommentTime = newCommentTimestamp;
                        comment.timestamp = new Date(Math.min(newCommentTimestamp, now)).toISOString(); // ä¸è¶…è¿‡å½“å‰æ—¶é—´
                    });
                }
            });
        } else {
            console.error('weiboData.postsä¸æ˜¯æ•°ç»„æˆ–ä¸å­˜åœ¨:', weiboData);
        }
        // --- æ—¶é—´æˆ³æ³¨å…¥ç»“æŸ ---
        
        // --- å›¾ç‰‡ç”Ÿæˆé€»è¾‘ ---
        if (unsplashKey && weiboData.posts && Array.isArray(weiboData.posts)) {
            try {
                for (const post of weiboData.posts) {
                    if (post.image_description && post.image_description.trim()) {
                        try {
                            const imageUrl = await fetchMatchingImageForPublish(post.image_description, unsplashKey);
                            if (imageUrl) {
                                // å°†å›¾ç‰‡æè¿°æ›¿æ¢ä¸ºå®é™…å›¾ç‰‡HTML
                                post.actual_image_url = imageUrl;
                                // ä¿ç•™åŸå§‹æè¿°ç”¨äºå¤‡ä»½
                                post.original_image_description = post.image_description;
                                post.image_description = `<img src="${imageUrl}" alt="${post.image_description}" style="width: 100%; max-width: 300px; border-radius: 8px;">`;
                            }
                        } catch (imageError) {
                            console.warn(`ä¸ºå¸–å­ç”Ÿæˆå›¾ç‰‡å¤±è´¥: ${imageError.message}`);
                            // å›¾ç‰‡ç”Ÿæˆå¤±è´¥æ—¶ä¿æŒåŸå§‹æ–‡å­—æè¿°
                        }
                    }
                }
            } catch (error) {
                console.warn('æ‰¹é‡å›¾ç‰‡ç”Ÿæˆè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
            }
        }
        // --- å›¾ç‰‡ç”Ÿæˆç»“æŸ ---
        
        const newPost = {
            id: Date.now(),
            contactId: contactId,
            relations: relations,
            relationDescription: relationDescription,
            hashtag: hashtag,
            data: weiboData,
            createdAt: postCreatedAt.toISOString()
        };

        console.log('å‡†å¤‡ä¿å­˜æ–°å¸–å­:', {
            id: newPost.id,
            contactId: newPost.contactId,
            relations: newPost.relations,
            hashtag: newPost.hashtag,
            createdAt: newPost.createdAt,
            dataStructure: {
                hasWeiboPosts: !!newPost.data.posts,
                postsCount: newPost.data.posts ? newPost.data.posts.length : 0
            }
        });

        console.log('ä¿å­˜å¸–å­åˆ°æ•°æ®åº“...');
        await saveWeiboPost(newPost);
        console.log('å¸–å­ä¿å­˜æˆåŠŸï¼Œæ·»åŠ åˆ°å†…å­˜æ•°ç»„...');
        weiboPosts.push(newPost); // Update in-memory array
        console.log('å½“å‰å†…å­˜ä¸­çš„å¸–å­æ•°é‡:', weiboPosts.length);
        
        console.log('é‡æ–°æ¸²æŸ“æ‰€æœ‰å¸–å­...');
        renderAllWeiboPosts();
        console.log('=== è®ºå›å¸–å­ç”Ÿæˆå®Œæˆ ===');
        showToast('å¸–å­å·²åˆ·æ–°ï¼');

    } catch (error) {
        console.error('=== ç”Ÿæˆè®ºå›å¤±è´¥ ===');
        console.error('é”™è¯¯ç±»å‹:', error.name);
        console.error('é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('å®Œæ•´é”™è¯¯å¯¹è±¡:', error);
        showApiError(error);
    } finally {
        loadingIndicator.remove();
    }
}


// æ‰å¹³åŒ–å¸–å­æ•°æ®ï¼Œæ¯ä¸ªå¸–å­åŒ…å«åŸå§‹ä¿¡æ¯å’Œä½ç½®ä¿¡æ¯
function flattenPosts() {
    if (!weiboPosts || weiboPosts.length === 0) {
        allPosts = [];
        return;
    }

    const sortedPosts = weiboPosts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    allPosts = [];
    
    sortedPosts.forEach(storedPost => {
        if (storedPost.data?.posts) {
            storedPost.data.posts.forEach((post, postIndex) => {
                allPosts.push({
                    storedPost,
                    post,
                    postIndex,
                    height: ESTIMATED_POST_HEIGHT,
                    rendered: false
                });
            });
        }
    });
}

// è®¡ç®—è™šæ‹Ÿæ»šåŠ¨çš„æ¸²æŸ“èŒƒå›´
function calculateRenderRange(scrollTop) {
    const containerHeight = document.getElementById('weiboContainer').clientHeight;
    
    // ä½¿ç”¨å®é™…é«˜åº¦è®¡ç®—å¯è§åŒºåŸŸ
    let currentHeight = 0;
    let visibleStartIndex = 0;
    let visibleEndIndex = allPosts.length;
    
    // æ‰¾åˆ°å¯è§åŒºåŸŸå¼€å§‹çš„ç´¢å¼•
    for (let i = 0; i < allPosts.length; i++) {
        const postHeight = allPosts[i].height || ESTIMATED_POST_HEIGHT;
        if (currentHeight + postHeight > scrollTop) {
            visibleStartIndex = i;
            break;
        }
        currentHeight += postHeight;
    }
    
    // æ‰¾åˆ°å¯è§åŒºåŸŸç»“æŸçš„ç´¢å¼•
    const viewportBottom = scrollTop + containerHeight;
    let heightFromStart = currentHeight; // ä»å¯è§å¼€å§‹ä½ç½®çš„ç´¯ç§¯é«˜åº¦
    
    for (let i = visibleStartIndex; i < allPosts.length; i++) {
        const postHeight = allPosts[i].height || ESTIMATED_POST_HEIGHT;
        heightFromStart += postHeight;
        if (heightFromStart > viewportBottom) {
            visibleEndIndex = i + 1; // åŒ…å«å½“å‰é¡¹ç›®
            break;
        }
    }
    
    // ä¸Šä¸‹å„é¢„ç•™4æ¡å¸–å­ï¼Œæä¾›é€‚ä¸­çš„ç¼“å†²åŒº
    const startIndex = Math.max(0, visibleStartIndex - 4);
    const endIndex = Math.min(allPosts.length, visibleEndIndex + 4);
    
    // ç¡®ä¿è‡³å°‘æ¸²æŸ“ä¸€äº›å¸–å­
    if (endIndex <= startIndex) {
        return { 
            startIndex: Math.max(0, Math.min(visibleStartIndex, allPosts.length - VIRTUAL_WINDOW_SIZE)), 
            endIndex: Math.min(allPosts.length, Math.max(visibleStartIndex + VIRTUAL_WINDOW_SIZE, VIRTUAL_WINDOW_SIZE))
        };
    }
    
    return { startIndex, endIndex };
}

// æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å’Œä¿®å¤å‡½æ•°
async function checkAndRepairDataConsistency() {
    if (!window.isIndexedDBReady || !window.db) {
        return false;
    }
    
    try {
        // ä»æ•°æ®åº“é‡æ–°åŠ è½½æ‰€æœ‰å¸–å­
        const transaction = window.db.transaction(['weiboPosts'], 'readonly');
        const store = transaction.objectStore('weiboPosts');
        const allDbPosts = await promisifyRequest(store.getAll());
        
        // æ£€æŸ¥å†…å­˜ä¸­çš„å¸–å­æ˜¯å¦ä¸æ•°æ®åº“ä¸€è‡´
        const memoryPostIds = new Set(weiboPosts.map(p => p.id));
        const dbPostIds = new Set(allDbPosts.map(p => p.id));
        
        // æ‰¾å‡ºä¸ä¸€è‡´çš„æ•°æ®
        const missingInMemory = allDbPosts.filter(p => !memoryPostIds.has(p.id));
        const extraInMemory = weiboPosts.filter(p => !dbPostIds.has(p.id));
        
        if (missingInMemory.length > 0 || extraInMemory.length > 0) {
            console.warn(`æ•°æ®ä¸ä¸€è‡´: å†…å­˜ç¼ºå°‘ ${missingInMemory.length} ä¸ªå¸–å­ï¼Œå†…å­˜å¤šä½™ ${extraInMemory.length} ä¸ªå¸–å­`);
            
            // ä½¿ç”¨æ•°æ®åº“æ•°æ®ä½œä¸ºå‡†ç¡®æ¥æº
            weiboPosts = allDbPosts;
            console.log('å·²ä»æ•°æ®åº“æ¢å¤æ•°æ®ä¸€è‡´æ€§');
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å¤±è´¥:', error);
        return false;
    }
}

function renderAllWeiboPosts(isInitialLoad = true) {
    const container = document.getElementById('weiboContainer');
    
    if (!weiboPosts || weiboPosts.length === 0) {
        container.innerHTML = '<div class="loading-text">è¿˜æ²¡æœ‰ä»»ä½•å¸–å­ï¼Œç‚¹å‡»å³ä¸Šè§’"+"æ¥ç”Ÿæˆå§ï¼</div>';
        allPosts = [];
        return;
    }

    // æ‰å¹³åŒ–å¸–å­æ•°æ®
    flattenPosts();
    
    // å¦‚æœå¸–å­æ•°é‡è¾ƒå°‘ï¼Œç›´æ¥æ¸²æŸ“å…¨éƒ¨è€Œä¸ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
    if (allPosts.length <= 15) {
        renderAllPostsDirectly();
        return;
    }
    
    if (isInitialLoad) {
        currentStartIndex = 0;
        // åˆå§‹æ—¶æ¸²æŸ“ç¨å¤šä¸€äº›å†…å®¹ï¼Œé¿å…ç©ºç™½ä½†ä¸ä¼šå¤ªå¤š
        const initialRenderCount = Math.min(allPosts.length, Math.max(VIRTUAL_WINDOW_SIZE, 12));
        currentEndIndex = initialRenderCount;
        renderVirtualPosts();
    }

    // è®¾ç½®è™šæ‹Ÿæ»šåŠ¨ç›‘å¬å™¨
    setupVirtualScrollListener();
}

// ç›´æ¥æ¸²æŸ“æ‰€æœ‰å¸–å­ï¼ˆç”¨äºå¸–å­æ•°é‡è¾ƒå°‘çš„æƒ…å†µï¼‰
function renderAllPostsDirectly() {
    const container = document.getElementById('weiboContainer');
    container.innerHTML = '';
    
    // æ¸…ç†è™šæ‹Ÿæ»šåŠ¨ç›‘å¬å™¨
    const scrollContainer = document.getElementById('weiboContainer');
    if (scrollContainer) {
        scrollContainer.onscroll = null;
    }
    
    // æ¸²æŸ“æ‰€æœ‰å¸–å­
    allPosts.forEach((postData, index) => {
        const postElement = renderSingleVirtualPost(postData, index);
        if (postElement) {
            container.appendChild(postElement);
        }
    });
}

// è™šæ‹Ÿæ»šåŠ¨æ¸²æŸ“å‡½æ•°
function renderVirtualPosts() {
    const container = document.getElementById('weiboContainer');
    
    // åˆ›å»ºè™šæ‹Ÿå®¹å™¨ï¼Œç”¨äºä¿æŒæ€»é«˜åº¦
    container.innerHTML = '';
    
    // è®¡ç®—é¡¶éƒ¨å ä½ç¬¦é«˜åº¦ï¼ˆä½¿ç”¨å®é™…é«˜åº¦ï¼‰
    let topSpacerHeight = 0;
    for (let i = 0; i < currentStartIndex; i++) {
        topSpacerHeight += allPosts[i] ? (allPosts[i].height || ESTIMATED_POST_HEIGHT) : ESTIMATED_POST_HEIGHT;
    }
    
    // æ·»åŠ é¡¶éƒ¨å ä½ç¬¦
    const topSpacer = document.createElement('div');
    topSpacer.style.height = `${topSpacerHeight}px`;
    topSpacer.className = 'virtual-spacer-top';
    container.appendChild(topSpacer);
    
    // æ¸²æŸ“å½“å‰çª—å£å†…çš„å¸–å­
    const renderedPosts = [];
    for (let i = currentStartIndex; i < currentEndIndex; i++) {
        if (i >= allPosts.length) break;
        const postElement = renderSingleVirtualPost(allPosts[i], i);
        if (postElement) {
            renderedPosts.push(postElement);
            // å…³é”®ä¿®å¤ï¼šå°†å¸–å­å…ƒç´ æ·»åŠ åˆ°å®¹å™¨ä¸­ï¼
            container.appendChild(postElement);
        }
    }
    
    // è®¡ç®—åº•éƒ¨å ä½ç¬¦é«˜åº¦ï¼ˆä½¿ç”¨å®é™…é«˜åº¦ï¼‰
    let bottomSpacerHeight = 0;
    for (let i = currentEndIndex; i < allPosts.length; i++) {
        bottomSpacerHeight += allPosts[i] ? (allPosts[i].height || ESTIMATED_POST_HEIGHT) : ESTIMATED_POST_HEIGHT;
    }
    
    // æ·»åŠ åº•éƒ¨å ä½ç¬¦
    const bottomSpacer = document.createElement('div');
    bottomSpacer.style.height = `${Math.max(0, bottomSpacerHeight)}px`;
    bottomSpacer.className = 'virtual-spacer-bottom';
    container.appendChild(bottomSpacer);
    
    const containerWidth = container.offsetWidth;
    
    // å¼ºåˆ¶é‡æ’ä»¥ä¿®å¤å¸ƒå±€é—®é¢˜
    container.offsetHeight; // è§¦å‘é‡æ’
    
    // æµ‹é‡å®é™…é«˜åº¦å¹¶æ›´æ–°ä¼°ç®—å€¼ï¼ˆå»¶è¿Ÿæ‰§è¡Œé¿å…å¸ƒå±€æŠ–åŠ¨ï¼‰
    setTimeout(() => {
        updatePostHeights(renderedPosts);
    }, 50);
}

// æ¸²æŸ“å•ä¸ªè™šæ‹Ÿå¸–å­
function renderSingleVirtualPost(postData, index) {
    const container = document.getElementById('weiboContainer');
    const { storedPost, post, postIndex } = postData;
    
    const contact = contacts.find(c => c.id === storedPost.contactId);
    if (storedPost.contactId && !contact) return null;
    
    const postAuthorContact = post.author_type === 'User' ? userProfile : contact;
    const postAuthorNickname = post.author_type === 'User' ? userProfile.name : (contact ? contact.name : 'æœªçŸ¥ç”¨æˆ·');
    const postAuthorAvatar = postAuthorContact ? postAuthorContact.avatar : '';
    const otherPartyName = post.author_type === 'User' ? (contact ? contact.name : '') : userProfile.name;

    const postElement = document.createElement('div');
    postElement.className = 'post';
    // ä½¿ç”¨ä¸å¸¸è§„æ¸²æŸ“ä¸€è‡´çš„IDæ ¼å¼ï¼šweibo-post-{storedPostId}-{postIndex}
    const postHtmlId = `weibo-post-${storedPost.id}-${postIndex}`;
    postElement.id = postHtmlId;
    postElement.setAttribute('data-index', index);

    // ä½¿ç”¨å›ºå®šçš„éšæœºæ•°ï¼Œé¿å…æ¯æ¬¡æ¸²æŸ“éƒ½é‡æ–°ç”Ÿæˆ
    const savedRandomRetweet = postData.randomRetweet || (postData.randomRetweet = Math.floor(Math.random() * 500));
    const savedRandomLike = postData.randomLike || (postData.randomLike = Math.floor(Math.random() * 5000));

    postElement.innerHTML = `
        <div class="post-header">
            <div class="avatar">
                ${postAuthorAvatar ? `<img src="${postAuthorAvatar}" alt="${postAuthorNickname[0]}">` : postAuthorNickname[0]}
            </div>
            <div class="post-info">
                <div class="user-name">
                    ${postAuthorNickname}
                    <span class="vip-badge">${post.author_type === 'User' ? 'ä¼šå‘˜' : 'è“æ˜Ÿ'}</span>
                </div>
                <div class="post-time">${formatTime(post.timestamp)}</div>
                <div class="post-source">æ¥è‡ª ${storedPost.relations} ç ”ç©¶æ‰€</div>
            </div>
            <div class="post-menu" onclick="toggleWeiboMenu(event, '${storedPost.id}', ${postIndex})">
                ...
                <div class="post-menu-dropdown" id="weibo-menu-${storedPost.id}-${postIndex}">
                    <div class="menu-item" onclick="regeneratePostImage('${storedPost.id}', ${postIndex})">é‡æ–°ç”Ÿæˆå›¾ç‰‡</div>
                    <div class="menu-item" onclick="removePostImage('${storedPost.id}', ${postIndex})">åˆ é™¤å›¾ç‰‡æ¢å¤æ–‡å­—</div>
                    <div class="menu-item" onclick="regeneratePostComments('${storedPost.id}', ${postIndex})">é‡æ–°ç”Ÿæˆè¯„è®º</div>
                    <div class="menu-item" onclick="deleteWeiboPost('${storedPost.id}', ${postIndex})">åˆ é™¤</div>
                </div>
            </div>
        </div>
        <div class="post-content">
            <a href="#" class="hashtag">#${storedPost.hashtag || storedPost.data.relation_tag}#</a>
            ${post.post_content}
            ${otherPartyName ? `<a href="#" class="mention">@${otherPartyName}</a>` : ''}
        </div>
        <div class="post-image-desc">
            ${post.image_description}
        </div>
        <div class="post-actions">
            <a href="#" class="action-btn-weibo">
                <span class="action-icon">ğŸ”„</span>
                <span>${savedRandomRetweet}</span>
            </a>
            <a href="#" class="action-btn-weibo" onclick="showReplyBox('${postHtmlId}').catch(console.error)">
                <span class="action-icon">ğŸ’¬</span>
                <span>${post.comments ? post.comments.length : 0}</span>
            </a>
            <a href="#" class="action-btn-weibo">
                <span class="action-icon">ğŸ‘</span>
                <span>${savedRandomLike}</span>
            </a>
        </div>
        <div class="comments-section"></div>
    `;

    container.appendChild(postElement);
    
    // è°ƒè¯•ï¼šæ£€æŸ¥å¸–å­å®½åº¦
    setTimeout(() => {
        const postWidth = postElement.offsetWidth;
        if (postWidth < 500) { // å¦‚æœå®½åº¦å¼‚å¸¸å°
        }
    }, 10);
    
    // æ¸²æŸ“è¯„è®º
    const commentsSection = postElement.querySelector('.comments-section');
    
    // æ·»åŠ è¯„è®ºåŒºç‚¹å‡»äº‹ä»¶ï¼ˆä¸å¸¸è§„æ¸²æŸ“ä¿æŒä¸€è‡´ï¼‰
    commentsSection.onclick = () => showReplyBox(postHtmlId).catch(console.error);
    
    if (post.comments && post.comments.length > 0) {
        post.comments.forEach(comment => {
            const commenterType = comment.commenter_type ? ` (${comment.commenter_type})` : '';
            
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment';
            
            // å‘åå…¼å®¹ï¼ˆHelper functionï¼‰
            // æ–°ä»£ç åº”ä½¿ç”¨ç»Ÿä¸€å­—æ®µï¼šcommenter_name, comment_content, timestamp
            commentDiv.innerHTML = `
                <span class="comment-user">${comment.commenter_name}${commenterType}:</span>
                <span class="comment-content">${comment.comment_content}</span>
                <span class="comment-time">${formatTime(comment.timestamp)}</span>
            `;

            commentDiv.addEventListener('click', (event) => {
                event.stopPropagation();
                replyToComment(comment.commenter_name || comment.author, postHtmlId).catch(console.error);
            });
            
            commentsSection.appendChild(commentDiv);
        });
    }
    
    return postElement;
}

// æµ‹é‡å¹¶æ›´æ–°å¸–å­çš„å®é™…é«˜åº¦
function updatePostHeights(renderedPosts) {
    if (!renderedPosts || renderedPosts.length === 0) return;
    
    let totalMeasuredHeight = 0;
    let measuredCount = 0;
    
    renderedPosts.forEach(postElement => {
        if (postElement && postElement.offsetHeight > 0) {
            const index = parseInt(postElement.getAttribute('data-index'));
            const actualHeight = postElement.offsetHeight + 8; // åŒ…æ‹¬margin-bottom
            
            if (allPosts[index]) {
                allPosts[index].height = actualHeight;
                totalMeasuredHeight += actualHeight;
                measuredCount++;
            }
        }
    });
    
    // æ›´æ–°å…¨å±€ä¼°ç®—é«˜åº¦
    if (measuredCount > 0) {
        const newEstimatedHeight = Math.round(totalMeasuredHeight / measuredCount);
        if (Math.abs(newEstimatedHeight - ESTIMATED_POST_HEIGHT) > 50) {
            // åªæœ‰å½“å·®å¼‚è¾ƒå¤§æ—¶æ‰æ›´æ–°å…¨å±€ä¼°ç®—å€¼
        }
    }
}

// è™šæ‹Ÿæ»šåŠ¨ç›‘å¬å™¨
function setupVirtualScrollListener() {
    // ä¿®å¤ï¼šä½¿ç”¨å®é™…çš„æ»šåŠ¨å®¹å™¨ weiboContainer è€Œä¸æ˜¯ weiboPage
    const scrollContainer = document.getElementById('weiboContainer');
    if (!scrollContainer) {
        console.error('æ‰¾ä¸åˆ°æ»šåŠ¨å®¹å™¨ weiboContainer');
        return;
    }

    // ç§»é™¤æ—§çš„ç›‘å¬å™¨
    scrollContainer.onscroll = null;
    
    
    let ticking = false;
    let lastScrollTime = 0;
    
    scrollContainer.onscroll = () => {
        const now = performance.now();
        if (now - lastScrollTime < 16) return; // é™åˆ¶åˆ°60fps
        lastScrollTime = now;
        
        if (!ticking) {
            requestAnimationFrame(() => {
                handleVirtualScroll();
                ticking = false;
            });
            ticking = true;
        }
    };
}

function handleVirtualScroll() {
    const scrollContainer = document.getElementById('weiboContainer');
    const scrollTop = scrollContainer.scrollTop;
    
    
    // è®¡ç®—æ–°çš„æ¸²æŸ“èŒƒå›´
    const { startIndex, endIndex } = calculateRenderRange(scrollTop);
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°æ¸²æŸ“èŒƒå›´ï¼ˆå‡å°‘é˜ˆå€¼ä»¥æä¾›æ›´å¥½çš„å“åº”ï¼‰
    const threshold = 1; // ç´¢å¼•å˜åŒ–é˜ˆå€¼
    const startIndexChanged = Math.abs(startIndex - currentStartIndex) >= threshold;
    const endIndexChanged = Math.abs(endIndex - currentEndIndex) >= threshold;
    
    if (startIndexChanged || endIndexChanged) {
        currentStartIndex = startIndex;
        currentEndIndex = endIndex;
        
        renderVirtualPosts();
    }
}

// åŠ è½½æ›´å¤šå¸–å­æ•°æ®çš„å‡½æ•°
async function loadMorePostData() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;
    
    // è¿™é‡Œå¯ä»¥å®ç°åŠ è½½æ›´å¤šå¸–å­æ•°æ®çš„é€»è¾‘
    // ç›®å‰åªæ˜¯ç®€å•çš„å»¶æ—¶ï¼Œå®é™…åº”ç”¨ä¸­å¯ä»¥è°ƒç”¨APIè·å–æ›´å¤šå¸–å­
    setTimeout(() => {
        isLoadingMorePosts = false;
    }, 1000);
}

function renderSingleWeiboPost(storedPost) {
    const container = document.getElementById('weiboContainer');
    const contact = contacts.find(c => c.id === storedPost.contactId);
    
    // å¯¹äºç”¨æˆ·è‡ªå·±å‘çš„å¸–å­ï¼ŒcontactIdä¸ºnullï¼Œcontactä¸ºundefinedï¼Œè¿™æ˜¯æ­£å¸¸çš„
    // åªæœ‰å½“contactIdä¸ä¸ºnullä½†æ‰¾ä¸åˆ°å¯¹åº”è”ç³»äººæ—¶æ‰è·³è¿‡æ¸²æŸ“
    if (storedPost.contactId && !contact) return; // Don't render if contact should exist but is deleted

    const data = storedPost.data;

    if (!data || !data.posts || !Array.isArray(data.posts)) {
        return;
    }

    data.posts.forEach((post, index) => {
        const postAuthorContact = post.author_type === 'User' ? userProfile : contact;
        const postAuthorNickname = post.author_type === 'User' ? userProfile.name : (contact ? contact.name : 'æœªçŸ¥ç”¨æˆ·');
        const postAuthorAvatar = postAuthorContact ? postAuthorContact.avatar : '';
        // ä¿®å¤otherPartyNameé€»è¾‘ï¼Œå¯¹äºç”¨æˆ·è‡ªå·±å‘çš„å¸–å­ï¼ŒotherPartyNameå¯ä»¥æ˜¯ç©ºæˆ–è€…è¯é¢˜æ ‡ç­¾
        const otherPartyName = post.author_type === 'User' ? (contact ? contact.name : '') : userProfile.name;

        const postElement = document.createElement('div');
        postElement.className = 'post';
        const postHtmlId = `weibo-post-${storedPost.id}-${index}`;
        postElement.id = postHtmlId;

        // Set the main structure of the post
        postElement.innerHTML = `
            <div class="post-header">
                <div class="avatar">
                    ${postAuthorAvatar ? `<img src="${postAuthorAvatar}" alt="${postAuthorNickname[0]}">` : postAuthorNickname[0]}
                </div>
                <div class="post-info">
                    <div class="user-name">
                        ${postAuthorNickname}
                        <span class="vip-badge">${post.author_type === 'User' ? 'ä¼šå‘˜' : 'è“æ˜Ÿ'}</span>
                    </div>
                    <div class="post-time">${formatTime(post.timestamp)}</div>
                    <div class="post-source">æ¥è‡ª ${storedPost.relations} ç ”ç©¶æ‰€</div>
                </div>
                <div class="post-menu" onclick="toggleWeiboMenu(event, '${storedPost.id}', ${index})">
                    ...
                    <div class="post-menu-dropdown" id="weibo-menu-${storedPost.id}-${index}">
                        <div class="menu-item" onclick="regeneratePostImage('${storedPost.id}', ${index})">é‡æ–°ç”Ÿæˆå›¾ç‰‡</div>
                        <div class="menu-item" onclick="removePostImage('${storedPost.id}', ${index})">åˆ é™¤å›¾ç‰‡æ¢å¤æ–‡å­—</div>
                        <div class="menu-item" onclick="regeneratePostComments('${storedPost.id}', ${index})">é‡æ–°ç”Ÿæˆè¯„è®º</div>
                        <div class="menu-item" onclick="deleteWeiboPost('${storedPost.id}', ${index})">åˆ é™¤</div>
                    </div>
                </div>
            </div>
            <div class="post-content">
                <a href="#" class="hashtag">#${storedPost.hashtag || data.relation_tag}#</a>
                ${post.post_content}
                ${otherPartyName ? `<a href="#" class="mention">@${otherPartyName}</a>` : ''}
            </div>
            <div class="post-image-desc">
                ${post.image_description}
            </div>
            <div class="post-actions">
                <a href="#" class="action-btn-weibo">
                    <span class="action-icon">ğŸ”„</span>
                    <span>${Math.floor(Math.random() * 500)}</span>
                </a>
                <a href="#" class="action-btn-weibo" onclick="showReplyBox('${postHtmlId}').catch(console.error)">
                    <span class="action-icon">ğŸ’¬</span>
                    <span>${post.comments ? post.comments.length : 0}</span>
                </a>
                <a href="#" class="action-btn-weibo">
                    <span class="action-icon">ğŸ‘</span>
                    <span>${Math.floor(Math.random() * 5000)}</span>
                </a>
            </div>
            <div class="comments-section"></div>
        `;

        // Programmatically create and append comments
        const commentsSection = postElement.querySelector('.comments-section');
        if (commentsSection) {
            commentsSection.onclick = () => showReplyBox(postHtmlId).catch(console.error);

            if (post.comments && Array.isArray(post.comments)) {
                post.comments.forEach(comment => {
                    const commenterType = comment.commenter_type ? ` (${comment.commenter_type})` : '';
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'comment';
                    
                    // å…¼å®¹æ€§æ¸²æŸ“ï¼šæ”¯æŒæ–°æ—§å­—æ®µå
                    // æ–°ä»£ç åº”ä½¿ç”¨ç»Ÿä¸€å­—æ®µï¼šcommenter_name, comment_content, timestamp
                    commentDiv.innerHTML = `
                        <span class="comment-user">${comment.commenter_name || comment.author}${commenterType}:</span>
                        <span class="comment-content">${comment.comment_content || comment.content}</span>
                        <span class="comment-time">${formatTime(comment.timestamp || comment.time)}</span>
                    `;

                    commentDiv.addEventListener('click', (event) => {
                        event.stopPropagation();
                        replyToComment(comment.commenter_name || comment.author, postHtmlId).catch(console.error);
                    });

                    commentsSection.appendChild(commentDiv);
                });
            }
        }
        
        container.appendChild(postElement);
    });
}

async function replyToComment(commenterName, postHtmlId) {
    // First, ensure the reply box is visible for the post.
    await showReplyBox(postHtmlId);

    // Now, find the reply box and its textarea.
    const postElement = document.getElementById(postHtmlId);
    if (!postElement) return;

    const replyInput = postElement.querySelector('.reply-input');
    if (!replyInput) return;

    // Pre-fill the textarea with the @-mention.
    const currentText = replyInput.value;
    const mention = `@${commenterName} `;
    
    // Avoid adding duplicate mentions if the user clicks multiple times.
    if (!currentText.includes(mention)) {
        replyInput.value = mention + currentText;
    }
    
    // Focus the input and place the cursor at the end.
    replyInput.focus();
    replyInput.setSelectionRange(replyInput.value.length, replyInput.value.length);
}

async function showReplyBox(postHtmlId) {
    const postElement = document.getElementById(postHtmlId);
    if (!postElement) {
        console.warn(`æ‰¾ä¸åˆ°å¸–å­å…ƒç´ : ${postHtmlId}`);
        return;
    }
    
    // åœ¨æ˜¾ç¤ºå›å¤æ¡†å‰æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§
    const storedPostId = parseInt(postHtmlId.split('-')[2], 10);
    const storedPost = weiboPosts.find(p => p.id === storedPostId);
    if (!storedPost) {
        console.warn(`æ•°æ®ä¸ä¸€è‡´ï¼Œå¸–å­ID ${storedPostId} ä¸å­˜åœ¨ï¼Œå°è¯•ä¿®å¤...`);
        const repaired = await checkAndRepairDataConsistency();
        if (repaired) {
            // æ•°æ®ä¿®å¤åé‡æ–°æ¸²æŸ“é¡µé¢
            renderAllWeiboPosts();
            showToast('æ•°æ®å·²åŒæ­¥ï¼Œè¯·é‡æ–°ç‚¹å‡»å›å¤');
            return;
        }
    }

    let replyBox = postElement.querySelector('.reply-box');
    if (replyBox) {
        replyBox.querySelector('textarea').focus();
        return;
    }

    const commentsSection = postElement.querySelector('.comments-section');
    
    replyBox = document.createElement('div');
    replyBox.className = 'reply-box';
    replyBox.innerHTML = `
        <textarea class="reply-input" placeholder="è¾“å…¥ä½ çš„å›å¤..."></textarea>
        <button class="reply-button">å›å¤</button>
    `;
    
    commentsSection.appendChild(replyBox);
    const replyInput = replyBox.querySelector('.reply-input');
    const replyButton = replyBox.querySelector('.reply-button');

    replyInput.focus();
    
    // ç¡®ä¿å›å¤æ¡†ä¸è¢«åº•éƒ¨å¯¼èˆªæ é®æŒ¡
    setTimeout(() => {
        replyBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }, 100);

    replyButton.onclick = async () => {
        const replyContent = replyInput.value.trim();
        if (!replyContent) {
            showToast('å›å¤å†…å®¹ä¸èƒ½ä¸ºç©º');
            return;
        }

        // --- Find the target post ---
        const storedPostId = parseInt(postHtmlId.split('-')[2], 10);
        const postIndex = parseInt(postHtmlId.split('-')[3], 10);
        let storedPost = weiboPosts.find(p => p.id === storedPostId);
        
        // å®¹é”™æœºåˆ¶ï¼šå¦‚æœæ‰¾ä¸åˆ°å¸–å­ï¼Œå°è¯•ä»æ•°æ®åº“é‡æ–°åŠ è½½
        if (!storedPost) {
            console.warn(`æ‰¾ä¸åˆ°å¸–å­ID ${storedPostId}ï¼Œå°è¯•ä»æ•°æ®åº“é‡æ–°åŠ è½½...`);
            
            // é¦–å…ˆå°è¯•æŒ‰ä¸åŒç±»å‹æŸ¥æ‰¾
            let foundByString = weiboPosts.find(p => p.id.toString() === storedPostId.toString());
            if (foundByString) {
                storedPost = foundByString;
            } else {
                // å°è¯•ä»æ•°æ®åº“é‡æ–°åŠ è½½
                try {
                    if (window.isIndexedDBReady && window.db) {
                        const transaction = window.db.transaction(['weiboPosts'], 'readonly');
                        const store = transaction.objectStore('weiboPosts');
                        
                        // å°è¯•æ•°å­—IDå’Œå­—ç¬¦ä¸²ID
                        let dbPost = await promisifyRequest(store.get(storedPostId));
                        if (!dbPost) {
                            dbPost = await promisifyRequest(store.get(storedPostId.toString()));
                        }
                        
                        if (dbPost) {
                            // å°†ä»æ•°æ®åº“æ‰¾åˆ°çš„å¸–å­é‡æ–°æ·»åŠ åˆ°å†…å­˜æ•°ç»„
                            weiboPosts.push(dbPost);
                            storedPost = dbPost;
                            console.log(`æˆåŠŸä»æ•°æ®åº“æ¢å¤å¸–å­ID ${storedPostId}`);
                        } else {
                            // æ•°æ®åº“ä¸­ä¹Ÿæ²¡æœ‰ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯å¼‚å¸¸IDï¼ˆå¦‚0ã€1ç­‰ï¼‰
                            if (storedPostId < 1000000000000) {
                                showToast('æ£€æµ‹åˆ°æ•°æ®å¼‚å¸¸ï¼Œæ­£åœ¨é‡æ–°åŒæ­¥...');
                                const repaired = await checkAndRepairDataConsistency();
                                if (repaired) {
                                    renderAllWeiboPosts();
                                    return;
                                }
                            }
                            
                            // æ•°æ®åº“ä¸­ä¹Ÿæ²¡æœ‰ï¼Œå¯èƒ½å¸–å­å·²è¢«åˆ é™¤ï¼Œåˆ·æ–°é¡µé¢
                            showToast('å¸–å­å¯èƒ½å·²è¢«åˆ é™¤ï¼Œæ­£åœ¨åˆ·æ–°é¡µé¢...');
                            renderAllWeiboPosts();
                            return;
                        }
                    } else {
                        showToast('æ•°æ®åº“æœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                        return;
                    }
                } catch (error) {
                    console.error('ä»æ•°æ®åº“æ¢å¤å¸–å­å¤±è´¥:', error);
                    showToast('æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                    return;
                }
            }
        }
        
        // æ£€æŸ¥å¸–å­ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
        if (!storedPost.data?.posts || !storedPost.data.posts[postIndex]) {
            console.error(`å¸–å­ç´¢å¼•æ— æ•ˆ: storedPostId=${storedPostId}, postIndex=${postIndex}`);
            showToast('å¸–å­æ•°æ®å¼‚å¸¸ï¼Œæ­£åœ¨åˆ·æ–°é¡µé¢...');
            renderAllWeiboPosts();
            return;
        }
        
        const postData = storedPost.data.posts[postIndex];

        // --- Create User Comment ---
        const userComment = {
            commenter_name: userProfile.name,
            commenter_type: 'User',
            comment_content: replyContent,
            timestamp: new Date().toISOString()
        };

        // --- Disable UI ---
        replyInput.disabled = true;
        replyButton.disabled = true;
        replyButton.textContent = 'è¯·ç¨å...';

        // --- Add user's comment to the list immediately for better UX ---
        if (!postData.comments) {
            postData.comments = [];
        }
        postData.comments.push(userComment);
        renderAllWeiboPosts(); // Re-render to show the user's comment
        await showReplyBox(postHtmlId); // Keep the reply box open

        // æ£€æŸ¥å¹¶æ›´æ–°å…¨å±€è®°å¿†ï¼ˆç”¨æˆ·å›å¤å†…å®¹ï¼‰
        if (window.characterMemoryManager) {
            const forumContent = `ç”¨æˆ·å›å¤è®ºå›ï¼š\nåŸå¸–ï¼š${postData.post_content}\nç”¨æˆ·å›å¤ï¼š${replyContent}`;
            window.characterMemoryManager.checkAndUpdateGlobalMemory(forumContent);
        }

        try {
            const mentionRegex = /@(\S+)/;
            const match = replyContent.match(mentionRegex);
            let mentionedContact = null;

            if (match) {
                const mentionedName = match[1].trim();
                mentionedContact = contacts.find(c => c.name === mentionedName && c.type === 'private');
            }

            if (match) {
                const mentionedName = match[1].trim();
                const mentionedPersonContact = mentionedContact || {
                    name: mentionedName,
                    personality: `ä¸€ä¸ªè¢«@çš„ç½‘å‹ï¼Œåå­—å«${mentionedName}`
                };
                
                const aiReplyContent = await getMentionedAIReply(postData, userComment, mentionedPersonContact);
                const aiComment = {
                    commenter_name: mentionedName,
                    commenter_type: 'Mentioned',
                    comment_content: aiReplyContent,
                    timestamp: new Date().toISOString()
                };
                postData.comments.push(aiComment);
                await updateWeiboPost(storedPost);
                showToast('AIå·²å›å¤ï¼');
                renderAllWeiboPosts();
                return;
            }

            if (postData.author_type !== 'User') {
                const postAuthorContact = contacts.find(c => c.id === storedPost.contactId);
                if (!postAuthorContact) throw new Error('Post author not found');
                
                const aiReplyContent = await getAIReply(postData, replyContent, storedPost.contactId);
                const aiComment = {
                    commenter_name: postAuthorContact.name,
                    commenter_type: 'æ¥¼ä¸»',
                    comment_content: aiReplyContent,
                    timestamp: new Date().toISOString()
                };
                postData.comments.push(aiComment);
                await updateWeiboPost(storedPost);
                showToast('AIå·²å›å¤ï¼');
                renderAllWeiboPosts();
                return;
            }

            await updateWeiboPost(storedPost);
            showToast('å·²å›å¤');
            renderAllWeiboPosts();

        } catch (error) {
            showApiError(error);
            console.error('AIå›å¤ç”Ÿæˆå¤±è´¥:', error);
            // On failure, remove the user's comment that was added optimistically
            postData.comments.pop();
            renderAllWeiboPosts();
        }
    };
}

async function getMentionedAIReply(postData, mentioningComment, mentionedContact) {
    const apiCallInfo = await getApiCallInfo();
    if (!apiCallInfo.url || !apiCallInfo.key || !apiCallInfo.model) {
        throw new Error('APIæˆ–æ¨¡å‹æœªé…ç½®');
    }

    const systemPrompt = window.promptBuilder.buildMentionReplyPrompt(postData, mentioningComment, mentionedContact, contacts, userProfile);
    
    const data = await window.apiService.callOpenAIAPI(
        apiCallInfo.url,
        apiCallInfo.key,
        apiCallInfo.model,
        [{ role: 'user', content: systemPrompt }],
        { temperature: 0.75 }, // Slightly higher temp for more creative/natural replies
        (apiCallInfo.timeout || 60) * 1000
    );

    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
        console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
        throw new Error('AIæœªè¿”å›æœ‰æ•ˆå›å¤');
    }
    
    return data.choices[0].message.content;
}

async function getAIReply(postData, userReply, contactId) {
    const apiCallInfo = await getApiCallInfo();
    if (!apiCallInfo.url || !apiCallInfo.key || !apiCallInfo.model) {
        throw new Error('APIæˆ–æ¨¡å‹æœªé…ç½®');
    }

    const systemPrompt = window.promptBuilder.buildReplyPrompt(postData, userReply, contactId, contacts, userProfile);
    const data = await window.apiService.callOpenAIAPI(
        apiCallInfo.url,
        apiCallInfo.key,
        apiCallInfo.model,
        [{ role: 'user', content: systemPrompt }],
        { temperature: 0.7 },
        (apiCallInfo.timeout || 60) * 1000
    );

    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
        console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
        throw new Error('AIæœªè¿”å›æœ‰æ•ˆå›å¤');
    }
    
    return data.choices[0].message.content;
}




function toggleWeiboMenu(event, storedPostId, postIndex) {
    event.stopPropagation();
    const menu = document.getElementById(`weibo-menu-${storedPostId}-${postIndex}`);
    
    // Close all other menus
    document.querySelectorAll('.post-menu-dropdown').forEach(m => {
        if (m.id !== menu.id) {
            m.style.display = 'none';
        }
    });

    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

// Close dropdown when clicking anywhere else
window.addEventListener('click', (event) => {
    if (!event.target.matches('.post-menu')) {
        document.querySelectorAll('.post-menu-dropdown').forEach(m => {
            m.style.display = 'none';
        });
    }
});


// é‡æ–°ç”Ÿæˆå¸–å­å›¾ç‰‡
async function regeneratePostImage(storedPostId, postIndex) {
    const numericStoredPostId = parseInt(storedPostId, 10);
    const storedPost = weiboPosts.find(p => p.id === numericStoredPostId);
    
    if (!storedPost || !storedPost.data.posts[postIndex]) {
        showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„å¸–å­');
        return;
    }
    
    const post = storedPost.data.posts[postIndex];
    
    // æ£€æŸ¥æ˜¯å¦æœ‰åŸå§‹å›¾ç‰‡æè¿°
    const imageDescription = post.original_image_description || post.image_description;
    
    if (!imageDescription || imageDescription.trim() === 'æš‚æ— å›¾ç‰‡æè¿°') {
        showToast('è¯¥å¸–å­æ²¡æœ‰å›¾ç‰‡æè¿°ï¼Œæ— æ³•ç”Ÿæˆå›¾ç‰‡');
        return;
    }
    
    const unsplashKey = localStorage.getItem('forumUnsplashApiKey');
    if (!unsplashKey) {
        showToast('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®Unsplash API Key');
        return;
    }
    
    try {
        showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆå›¾ç‰‡...');
        
        const imageUrl = await fetchMatchingImageForPublish(imageDescription, unsplashKey);
        if (imageUrl) {
            // æ›´æ–°å¸–å­æ•°æ®
            post.actual_image_url = imageUrl;
            post.original_image_description = imageDescription;
            post.image_description = `<img src="${imageUrl}" alt="${imageDescription}" style="width: 100%; max-width: 300px; border-radius: 8px;">`;
            
            // æ›´æ–°æ•°æ®åº“
            await updateWeiboPostInDB(storedPost);
            
            // é‡æ–°æ¸²æŸ“
            renderAllWeiboPosts();
            
            showToast('å›¾ç‰‡å·²é‡æ–°ç”Ÿæˆï¼');
        } else {
            showToast('å›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
        }
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
        showToast('å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
}


// åˆ é™¤å¸–å­å›¾ç‰‡æ¢å¤æ–‡å­—æ˜¾ç¤º
async function removePostImage(storedPostId, postIndex) {
    const numericStoredPostId = parseInt(storedPostId, 10);
    const storedPost = weiboPosts.find(p => p.id === numericStoredPostId);
    
    if (!storedPost || !storedPost.data.posts[postIndex]) {
        showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„å¸–å­');
        return;
    }
    
    const post = storedPost.data.posts[postIndex];
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡å¯ä»¥åˆ é™¤
    if (!post.actual_image_url && !post.image_description.includes('<img')) {
        showToast('è¯¥å¸–å­æ²¡æœ‰Unsplashå›¾ç‰‡ï¼Œæ— éœ€åˆ é™¤');
        return;
    }
    
    try {
        // æ¢å¤åŸå§‹æ–‡å­—æè¿°
        if (post.original_image_description) {
            post.image_description = post.original_image_description;
        } else {
            // å¦‚æœæ²¡æœ‰åŸå§‹æè¿°ï¼Œä»imgæ ‡ç­¾ä¸­æå–altæ–‡æœ¬
            const imgMatch = post.image_description.match(/alt="([^"]*)"/);
            if (imgMatch) {
                post.image_description = imgMatch[1];
            } else {
                post.image_description = 'å›¾ç‰‡æè¿°';
            }
        }
        
        // æ¸…é™¤å›¾ç‰‡ç›¸å…³å­—æ®µ
        delete post.actual_image_url;
        delete post.original_image_description;
        
        // æ›´æ–°æ•°æ®åº“
        await updateWeiboPostInDB(storedPost);
        
        // é‡æ–°æ¸²æŸ“
        renderAllWeiboPosts();
        
        showToast('å·²åˆ é™¤å›¾ç‰‡ï¼Œæ¢å¤æ–‡å­—æ˜¾ç¤º');
    } catch (error) {
        console.error('åˆ é™¤å¸–å­å›¾ç‰‡å¤±è´¥:', error);
        showToast('åˆ é™¤å›¾ç‰‡å¤±è´¥: ' + error.message);
    }
}

// é‡æ–°ç”Ÿæˆå¸–å­è¯„è®º
async function regeneratePostComments(storedPostId, postIndex) {
    const numericStoredPostId = parseInt(storedPostId, 10);
    const storedPost = weiboPosts.find(p => p.id === numericStoredPostId);
    
    if (!storedPost || !storedPost.data.posts[postIndex]) {
        showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„å¸–å­');
        return;
    }
    
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('è¯·å…ˆé…ç½®APIå’Œæ¨¡å‹è®¾ç½®');
        return;
    }
    
    const post = storedPost.data.posts[postIndex];
    
    try {
        showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆè¯„è®º...');
        
        // æ„å»ºé‡æ–°ç”Ÿæˆè¯„è®ºçš„æç¤ºè¯
        const newComments = await generateAICommentsWithCurrentTime(post.post_content);
        
        // æ›´æ–°å¸–å­è¯„è®º
        post.comments = newComments;
        
        // æ›´æ–°æ•°æ®åº“
        await updateWeiboPostInDB(storedPost);
        
        // é‡æ–°æ¸²æŸ“
        renderAllWeiboPosts();
        
        showToast('è¯„è®ºå·²é‡æ–°ç”Ÿæˆï¼');
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆè¯„è®ºå¤±è´¥:', error);
        showApiError(error);
    }
}

async function deleteWeiboPost(storedPostId, postIndex) {
    // Convert storedPostId to the correct type if necessary, assuming it's a number from the template
    const numericStoredPostId = parseInt(storedPostId, 10);

    // Find the specific post group in the in-memory weiboPosts array
    const postGroupIndex = weiboPosts.findIndex(p => p.id === numericStoredPostId);
    
    if (postGroupIndex > -1) {
        // The specific post to be deleted
        const postGroup = weiboPosts[postGroupIndex];
        
        // Remove the specific post from the 'posts' array within the group
        if (postGroup.data && postGroup.data.posts && postGroup.data.posts.length > postIndex) {
            postGroup.data.posts.splice(postIndex, 1);
        }

        // If this was the last post in the group, remove the entire group
        if (postGroup.data.posts.length === 0) {
            weiboPosts.splice(postGroupIndex, 1);
            // Also delete the entire entry from IndexedDB
            if (window.isIndexedDBReady) {
                try {
                    const transaction = window.db.transaction(['weiboPosts'], 'readwrite');
                    const store = transaction.objectStore('weiboPosts');
                    await promisifyRequest(store.delete(numericStoredPostId));
                    await promisifyTransaction(transaction);
                } catch (error) {
                    console.error('Failed to delete Weibo post group from DB:', error);
                    showToast('ä»æ•°æ®åº“åˆ é™¤å¸–å­å¤±è´¥');
                    // Optional: Add back the data to memory to maintain consistency
                    return;
                }
            }
        } else {
            // Otherwise, just update the modified group in IndexedDB
            await updateWeiboPost(postGroup);
        }
    }

    // Re-render the UI
    renderAllWeiboPosts();
    showToast('å¸–å­å·²åˆ é™¤');
}

async function updateWeiboPost(postToUpdate) {
    if (!window.isIndexedDBReady) {
        console.error('IndexedDB not ready, cannot update post.');
        showToast('æ•°æ®åº“é”™è¯¯ï¼Œæ— æ³•æ›´æ–°å¸–å­');
        return;
    }
    try {
        const transaction = window.db.transaction(['weiboPosts'], 'readwrite');
        const store = transaction.objectStore('weiboPosts');
        await promisifyRequest(store.put(postToUpdate));
        await promisifyTransaction(transaction);
    } catch (error) {
        console.error('Failed to update Weibo post in DB:', error);
        showToast('æ›´æ–°å¸–å­å¤±è´¥');
    }
}

// åˆ«åå‡½æ•°ï¼Œç”¨äºä¿æŒä¸€è‡´æ€§
async function updateWeiboPostInDB(postToUpdate) {
    return await updateWeiboPost(postToUpdate);
}

// --- æœ‹å‹åœˆåŠŸèƒ½ ---

// å­˜å‚¨ä¸Šä¼ çš„å›¾ç‰‡æ•°æ®
let momentUploadedImages = [];

// æœ‹å‹åœˆå‘å¸ƒæ–¹å¼é€‰æ‹©
function showPublishMomentModal() {
    // æ£€æŸ¥æœ‹å‹åœˆæ“ä½œæ˜¯å¦è¢«é”å®š
    if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
        return;
    }
    
    // æ˜¾ç¤ºæœ‹å‹åœˆå‘å¸ƒæ–¹å¼é€‰æ‹©æ¨¡æ€æ¡†
    showModal('momentChoiceModal');
}

function selectMomentType(type) {
    closeModal('momentChoiceModal');
    
    if (type === 'manual') {
        showManualMomentModal();
    } else if (type === 'generate') {
        showGenerateMomentModal();
    }
}

async function showManualMomentModal() {
    showModal('manualMomentModal');
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const userProfile = await getUserProfile();
    
    // è®¾ç½®å‘å¸ƒäººä¸ºå½“å‰ç”¨æˆ·
    document.getElementById('manualMomentAuthor').value = userProfile.name || 'æˆ‘';
    
    // æ¸…ç©ºä¹‹å‰çš„å†…å®¹ã€ä½ç½®å’Œå›¾ç‰‡
    document.getElementById('manualMomentContent').value = '';
    document.getElementById('manualMomentLocation').value = '';
    momentUploadedImages = [];
    document.getElementById('momentImagesPreview').innerHTML = '';
}

function showGenerateMomentModal() {
    // [DEBUG-MOMENTS-ROLES-START] è°ƒè¯•ä¿¡æ¯ï¼Œä¿®å¤å®Œæˆååˆ é™¤
    console.log('[DEBUG] showGenerateMomentModal è¢«è°ƒç”¨');
    console.log('[DEBUG] æ‰“å¼€ç”Ÿæˆæœ‹å‹åœˆæ¨¡æ€æ¡†æ—¶çš„å…¨å±€çŠ¶æ€:', {
        windowContacts: !!window.contacts,
        contactsLength: window.contacts ? window.contacts.length : 0,
        isIndexedDBReady: !!window.isIndexedDBReady,
        dbConnected: !!window.db,
        dbVersion: window.db ? window.db.version : 'no-db',
        timestamp: new Date().toISOString()
    });
    
    if (window.contacts && window.contacts.length > 0) {
        const privateContacts = window.contacts.filter(c => c.type === 'private');
        console.log('[DEBUG] ç§èŠè§’è‰²è¯¦æƒ…:', {
            totalContacts: window.contacts.length,
            privateContactsCount: privateContacts.length,
            privateContactsNames: privateContacts.map(c => ({ name: c.name, id: c.id, type: c.type }))
        });
    }
    // [DEBUG-MOMENTS-ROLES-END]
    
    showModal('generateMomentModal');
    
    // æ¸…ç©ºè¡¨å•
    document.getElementById('momentGenTopic').value = '';
    // momentUnsplashKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œç§»é™¤ç›¸å…³ä»£ç é¿å…nullæŒ‡é’ˆå¼‚å¸¸
    
    // åŠ è½½è§’è‰²åˆ—è¡¨
    loadMomentCharacterOptions();
}

// åŠ è½½è§’è‰²é€‰é¡¹ - å¢å¼ºç‰ˆæœ¬ï¼Œå¤„ç†æ•°æ®æœªå°±ç»ªæƒ…å†µ
async function loadMomentCharacterOptions() {
    const select = document.getElementById('momentGenCharacterSelect');
    select.innerHTML = '<option value="">åŠ è½½ä¸­...</option>';
    
    // [DEBUG-MOMENTS-ROLES-START] è°ƒè¯•ä¿¡æ¯ï¼Œä¿®å¤å®Œæˆååˆ é™¤
    console.log('[DEBUG] loadMomentCharacterOptions å¼€å§‹æ‰§è¡Œ');
    console.log('[DEBUG] å½“å‰çŠ¶æ€:', {
        windowContacts: !!window.contacts,
        contactsLength: window.contacts ? window.contacts.length : 0,
        isIndexedDBReady: !!window.isIndexedDBReady,
        dbConnected: !!window.db,
        dbReadyState: window.db ? window.db.readyState : 'no-db'
    });
    // [DEBUG-MOMENTS-ROLES-END]
    
    try {
        // ç¡®ä¿æ•°æ®å·²ç»åŠ è½½å®Œæˆ - æœ€å¤šç­‰å¾…10ç§’
        let attempts = 0;
        const maxAttempts = 20; // 10ç§’ (20 * 500ms)
        
        while ((!window.contacts || window.contacts.length === 0) && attempts < maxAttempts) {
            console.log(`[DEBUG] è§’è‰²æ•°æ®æœªå‡†å¤‡å¥½ï¼Œç­‰å¾…åŠ è½½... (å°è¯• ${attempts + 1}/${maxAttempts})`);
            
            // å¦‚æœæ•°æ®åº“è¿˜æ²¡å°±ç»ªï¼Œç­‰å¾…æ•°æ®åº“åˆå§‹åŒ–
            if (!window.isIndexedDBReady || !window.db) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                continue;
            }
            
            // å¦‚æœæ•°æ®åº“å°±ç»ªä½†contactsä¸ºç©ºï¼Œå°è¯•ä¸»åŠ¨åŠ è½½
            if ((!window.contacts || window.contacts.length === 0) && attempts === 5) {
                console.log('[DEBUG] ä¸»åŠ¨è§¦å‘æ•°æ®é‡æ–°åŠ è½½');
                try {
                    await loadDataFromDB();
                } catch (loadError) {
                    console.error('[DEBUG] ä¸»åŠ¨åŠ è½½æ•°æ®å¤±è´¥:', loadError);
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            attempts++;
        }
        
        // æ›´æ–°é€‰æ‹©æ¡†
        select.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>';
        
        // [DEBUG-MOMENTS-ROLES-START] è°ƒè¯•ä¿¡æ¯ï¼Œä¿®å¤å®Œæˆååˆ é™¤
        console.log('[DEBUG] ç­‰å¾…å®Œæˆåçš„çŠ¶æ€:', {
            windowContacts: !!window.contacts,
            contactsLength: window.contacts ? window.contacts.length : 0,
            attempts: attempts,
            timedOut: attempts >= maxAttempts
        });
        // [DEBUG-MOMENTS-ROLES-END]
        
        // åªæ·»åŠ è”ç³»äººé€‰é¡¹ï¼ˆAIè§’è‰²ï¼‰ï¼Œä¸åŒ…æ‹¬"æˆ‘"
        if (window.contacts && window.contacts.length > 0) {
            let addedCount = 0;
            window.contacts.forEach(contact => {
                if (contact.type === 'private') { // åªæ˜¾ç¤ºç§èŠè§’è‰²
                    const option = document.createElement('option');
                    option.value = contact.id;
                    option.textContent = contact.name;
                    select.appendChild(option);
                    addedCount++;
                    
                    // [DEBUG-MOMENTS-ROLES-START] è°ƒè¯•ä¿¡æ¯ï¼Œä¿®å¤å®Œæˆååˆ é™¤
                    console.log(`[DEBUG] æ·»åŠ è§’è‰²: ${contact.name} (ID: ${contact.id})`);
                    // [DEBUG-MOMENTS-ROLES-END]
                }
            });
            
            // [DEBUG-MOMENTS-ROLES-START] è°ƒè¯•ä¿¡æ¯ï¼Œä¿®å¤å®Œæˆååˆ é™¤
            console.log(`[DEBUG] æˆåŠŸæ·»åŠ  ${addedCount} ä¸ªè§’è‰²åˆ°é€‰æ‹©åˆ—è¡¨`);
            // [DEBUG-MOMENTS-ROLES-END]
            
            if (addedCount === 0) {
                select.innerHTML = '<option value="">æœªæ‰¾åˆ°AIè§’è‰²ï¼Œè¯·å…ˆæ·»åŠ è§’è‰²</option>';
                console.warn('[DEBUG] æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç§èŠç±»å‹çš„è§’è‰²');
            }
        } else {
            select.innerHTML = '<option value="">æœªæ‰¾åˆ°AIè§’è‰²ï¼Œè¯·å…ˆæ·»åŠ è§’è‰²</option>';
            console.warn('[DEBUG] window.contacts ä¸ºç©ºæˆ–ä¸å­˜åœ¨');
        }
        
    } catch (error) {
        console.error('[DEBUG] åŠ è½½è§’è‰²é€‰é¡¹å¤±è´¥:', error);
        select.innerHTML = '<option value="">åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•</option>';
        
        // å¦‚æœæ˜¯ä¸¥é‡é”™è¯¯ï¼Œå°è¯•æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
        if (typeof showToast === 'function') {
            showToast('è§’è‰²åˆ—è¡¨åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
        }
    }
}

// å¤„ç†ç”Ÿæˆæœ‹å‹åœˆè¡¨å•æäº¤
async function handleGenerateMoment(event) {
    event.preventDefault();
    
    const contactId = document.getElementById('momentGenCharacterSelect').value;
    const topic = document.getElementById('momentGenTopic').value.trim();
    const location = document.getElementById('momentGenLocation').value.trim();
    // momentUnsplashKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œä»localStorageç›´æ¥è·å–
    const unsplashKey = localStorage.getItem('unsplashApiKey') || '';
    
    if (!contactId) {
        showToast('è¯·é€‰æ‹©è§’è‰²');
        return;
    }

    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
        return;
    }
    
    // Unsplash API Keyå·²ä»localStorageè·å–ï¼Œæ— éœ€é‡å¤ä¿å­˜
    
    try {
        // æ‰¾åˆ°è§’è‰²ä¿¡æ¯
        const character = window.contacts?.find(c => c.id === contactId);
        if (!character) {
            showToast('æœªæ‰¾åˆ°é€‰ä¸­çš„è§’è‰²');
            return;
        }
        
        showToast('æ­£åœ¨ç”Ÿæˆæœ‹å‹åœˆå†…å®¹å’Œè¯„è®º...');
        
        // è·å–ç”¨æˆ·ä¿¡æ¯
        const userProfile = await getUserProfile();
        
        // ä¸€æ¬¡æ€§ç”Ÿæˆæœ‹å‹åœˆå†…å®¹ã€å›¾ç‰‡å…³é”®è¯å’Œè¯„è®ºï¼Œä¼ å…¥ä½ç½®ä¿¡æ¯
        const momentData = await generateMomentAndComments(character, userProfile, topic, location);
        
        let imageUrl = null;
        
        // å¦‚æœæä¾›äº†Unsplash API Key ä¸” AIè¿”å›äº†å…³é”®è¯ï¼Œå°è¯•è·å–é…å›¾
        if (unsplashKey && momentData.imageKeyword) {
            showToast('æ­£åœ¨è·å–é…å›¾...');
            try {
                // ä½¿ç”¨AIè¿”å›çš„å…³é”®è¯è¿›è¡Œæœç´¢
                imageUrl = await getUnsplashImage(momentData.imageKeyword, unsplashKey);
            } catch (imageError) {
                console.warn('è·å–Unsplashå›¾ç‰‡å¤±è´¥:', imageError);
                // å³ä½¿å›¾ç‰‡è·å–å¤±è´¥ä¹Ÿç»§ç»­å‘å¸ƒæœ‹å‹åœˆ
            }
        }
        
        // åˆ›å»ºæœ‹å‹åœˆå¯¹è±¡
        const moment = {
            id: Date.now().toString(),
            authorName: character.name,
            authorAvatar: character.avatar,
            content: momentData.content,
            location: momentData.location || location, // ä¼˜å…ˆä½¿ç”¨AIç”Ÿæˆçš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„ä½ç½®
            image: imageUrl, // Unsplashå›¾ç‰‡URL
            imageCount: imageUrl ? 1 : 0,
            isUnsplashImage: imageUrl ? true : false, // æ ‡è®°ä¸ºUnsplashå›¾ç‰‡
            time: new Date().toISOString(),
            likes: 0,
            comments: momentData.comments
        };
        
        // ä¿å­˜æœ‹å‹åœˆ
        moments.unshift(moment);
        await saveDataToDB();
        await renderMomentsList();
        
        closeModal('generateMomentModal');
        showToast('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸï¼');
        
    } catch (error) {
        console.error('ç”Ÿæˆæœ‹å‹åœˆå¤±è´¥:', error);
        showApiError(error);
    }
}

// è·å–Unsplashå›¾ç‰‡
async function getUnsplashImage(searchQuery, apiKey) {
    // ç°åœ¨æ­¤å‡½æ•°ç›´æ¥è°ƒç”¨æ–°çš„ fetchMatchingImageForPublish
    return await fetchMatchingImageForPublish(searchQuery, apiKey);
}

// ä¸€æ¬¡æ€§ç”Ÿæˆæœ‹å‹åœˆå†…å®¹å’Œè¯„è®º
async function generateMomentAndComments(character, userProfile, topic = '', location = '') {
    try {
        
        // æ£€æŸ¥å¿…è¦çš„ä¾èµ–
        if (!window.promptBuilder) {
            throw new Error('PromptBuilderæœªåˆå§‹åŒ–');
        }
        
        if (!window.apiService) {
            throw new Error('APIServiceæœªåˆå§‹åŒ–');
        }
        
        // ä½¿ç”¨æ–°çš„å…¨å±€APIè°ƒç”¨ä¿¡æ¯æ¥å£è·å–å®Œæ•´è¿æ¥å’Œæ¨¡å‹ä¿¡æ¯
        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            throw new Error('APIè®¾ç½®æœªå®Œæˆ');
        }

        // ä½¿ç”¨PromptBuilderæ„å»ºpromptï¼ˆä¼ å…¥ apiCallInfo ä»¥åŒ…å«æ¨¡å‹ä¿¡æ¯ï¼‰
        const systemPrompt = await window.promptBuilder.buildMomentAndCommentsPrompt(
            character,
            userProfile,
            apiCallInfo,
            window.contacts,
            topic,
            location
        );

        // ä½¿ç”¨äº‘ç«¯APIæœåŠ¡ (ä½¿ç”¨ apiCallInfo ä¸­çš„è¿æ¥/æ¨¡å‹ä¿¡æ¯)
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            {
                temperature: 0.9,
                max_tokens: 10000,
                response_format: { type: "json_object" },
            },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        
        const rawContent = data.choices[0]?.message?.content;
        console.log('APIè¿”å›çš„åŸå§‹å†…å®¹:', rawContent);
        
        if (!rawContent) {
            console.error('ERROR: APIè¿”å›ç©ºå†…å®¹ - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error('APIè¿”å›ç©ºå†…å®¹');
        }
        
        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawContent);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawContent);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }
        
        // è§£æJSONç»“æœ
        let momentData;
        try {
            momentData = JSON.parse(cleanedJson);
        } catch (parseError) {
            console.error('ERROR: è§£æJSONå¤±è´¥ - APIå®Œæ•´è¿”å›:', rawContent);
            console.error('ERROR: è§£æJSONå¤±è´¥ - é”™è¯¯è¯¦æƒ…:', parseError);
            throw new Error('AIè¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œæ— æ³•è§£æä¸ºJSONã€‚');
        }
        
        // ç¡®ä¿è¿”å›æ ¼å¼æ­£ç¡®
        if (!momentData.content) {
            throw new Error('ç”Ÿæˆçš„æœ‹å‹åœˆå†…å®¹ä¸ºç©º');
        }
        
        if (!Array.isArray(momentData.comments)) {
            momentData.comments = [];
        }

        // è·å–å›¾ç‰‡å…³é”®è¯ï¼Œå¯èƒ½ä¸º null
        const imageKeyword = momentData.imageKeyword || null;
        
        // ä½¿ç”¨ç»Ÿä¸€helperå‡½æ•°è½¬æ¢è¯„è®ºæ ¼å¼
        const formattedComments = momentData.comments.map(formatCommentForDataModel);
        
        const result = {
            content: momentData.content,
            imageKeyword: imageKeyword, // æ·»åŠ æ–°çš„å­—æ®µ
            comments: formattedComments
        };
        
        return result;
        
    } catch (error) {
        console.error('ç”Ÿæˆæœ‹å‹åœˆå’Œè¯„è®ºå¤±è´¥:', error);
        throw error; // ç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œä¸è¿”å›é»˜è®¤å†…å®¹
    }
}

// === å›¾ç‰‡AIè¯†åˆ«ç›¸å…³åŠŸèƒ½ ===

// åˆ†æä¸Šä¼ çš„å›¾ç‰‡å†…å®¹
async function analyzeImageContent(imageBase64, prompt = 'è¯·æè¿°è¿™å¼ å›¾ç‰‡çš„å†…å®¹') {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        throw new Error('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
    }

    try {
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: prompt
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: imageBase64
                        }
                    }
                ]
            }],
            { max_tokens: 5000, temperature: 0.7 },
            (apiCallInfo.timeout || 60) * 1000
        );

        return data.choices[0]?.message?.content || 'æ— æ³•è¯†åˆ«å›¾ç‰‡å†…å®¹';

    } catch (error) {
        console.error('å›¾ç‰‡åˆ†æå¤±è´¥:', error);
        return 'å›¾ç‰‡åˆ†æåŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨';
    }
}

// æ ¹æ®å›¾ç‰‡å†…å®¹ç”Ÿæˆæœ‹å‹åœˆæ–‡æ¡ˆ
async function generateMomentTextFromImage(imageBase64, character) {
    const analysisPrompt = `ä½ æ˜¯${character.name}ï¼Œæ€§æ ¼ç‰¹ç‚¹ï¼š${character.personality}ã€‚
è¯·çœ‹è¿™å¼ å›¾ç‰‡ï¼Œç„¶åä»¥${character.name}çš„èº«ä»½å‘å¸ƒä¸€æ¡æœ‹å‹åœˆåŠ¨æ€ã€‚

è¦æ±‚ï¼š
1. åŸºäºå›¾ç‰‡å†…å®¹æ¥å†™æœ‹å‹åœˆ
2. ç¬¦åˆ${character.name}çš„æ€§æ ¼ç‰¹ç‚¹å’Œè¯´è¯é£æ ¼
3. å†…å®¹è¦è‡ªç„¶çœŸå®ï¼Œå°±åƒçœŸçš„æœ‹å‹åœˆä¸€æ ·
4. é•¿åº¦æ§åˆ¶åœ¨30-100å­—ä¹‹é—´
5. å¯ä»¥é€‚å½“ä½¿ç”¨emojiè¡¨æƒ…
6. ä¸è¦è¯´"è¿™å¼ å›¾ç‰‡"ä¹‹ç±»çš„è¯ï¼Œè¦åƒæ˜¯è‡ªå·±æ‹çš„ç…§ç‰‡ä¸€æ ·

ç›´æ¥è¿”å›æœ‹å‹åœˆå†…å®¹ï¼Œä¸è¦æœ‰å…¶ä»–è¯´æ˜æ–‡å­—ã€‚`;

    return await analyzeImageContent(imageBase64, analysisPrompt);
}

// æ£€æŸ¥å›¾ç‰‡å†…å®¹æ˜¯å¦åˆé€‚
async function checkImageContent(imageBase64) {
    const checkPrompt = `è¯·æ£€æŸ¥è¿™å¼ å›¾ç‰‡æ˜¯å¦åŒ…å«ä»¥ä¸‹ä¸å½“å†…å®¹ï¼š
1. æš´åŠ›è¡€è…¥å†…å®¹
2. è‰²æƒ…å†…å®¹  
3. æ”¿æ²»æ•æ„Ÿå†…å®¹
4. å…¶ä»–ä¸é€‚åˆåœ¨ç¤¾äº¤åª’ä½“åˆ†äº«çš„å†…å®¹

å¦‚æœå›¾ç‰‡å†…å®¹åˆé€‚ï¼Œè¯·å›å¤"åˆé€‚"ï¼›å¦‚æœä¸åˆé€‚ï¼Œè¯·ç®€çŸ­è¯´æ˜åŸå› ã€‚`;

    const result = await analyzeImageContent(imageBase64, checkPrompt);
    return {
        isAppropriate: result.includes('åˆé€‚'),
        reason: result.includes('åˆé€‚') ? '' : result
    };
}

// ä¸ºç‰¹å®šè§’è‰²ç”Ÿæˆæœ‹å‹åœˆå†…å®¹
async function generateMomentForCharacter(character, topic = '') {
    const topicPrompt = topic ? `å›´ç»•"${topic}"è¿™ä¸ªä¸»é¢˜ï¼Œ` : '';
    
    const prompt = `ä½ æ˜¯${character.name}ï¼Œæ€§æ ¼ç‰¹ç‚¹ï¼š${character.personality}ã€‚
è¯·${topicPrompt}å‘å¸ƒä¸€æ¡ç¬¦åˆä½ æ€§æ ¼çš„æœ‹å‹åœˆåŠ¨æ€ã€‚

è¦æ±‚ï¼š
1. å†…å®¹è¦ç¬¦åˆ${character.name}çš„æ€§æ ¼ç‰¹ç‚¹
2. è¯­è¨€é£æ ¼è¦è‡ªç„¶ï¼Œå°±åƒçœŸçš„æœ‹å‹åœˆä¸€æ ·
3. é•¿åº¦æ§åˆ¶åœ¨50-150å­—ä¹‹é—´
4. å¯ä»¥åŒ…å«ç”Ÿæ´»æ„Ÿæ‚Ÿã€æ—¥å¸¸åˆ†äº«ã€å¿ƒæƒ…è¡¨è¾¾ç­‰
5. ä¸è¦ä½¿ç”¨è¿‡äºæ­£å¼çš„è¯­è¨€
6. å¯ä»¥é€‚å½“ä½¿ç”¨emojiè¡¨æƒ…

ç›´æ¥è¿”å›æœ‹å‹åœˆå†…å®¹ï¼Œä¸è¦æœ‰å…¶ä»–è¯´æ˜æ–‡å­—ã€‚`;

    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        throw new Error('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
    }

    const data = await window.apiService.callOpenAIAPI(
        apiCallInfo.url,
        apiCallInfo.key,
        apiCallInfo.model,
        [{ role: 'user', content: prompt }],
        { max_tokens: 5000, temperature: 0.8 },
        (apiCallInfo.timeout || 60) * 1000
    );

    return data.choices[0]?.message?.content || 'ä»Šå¤©å¿ƒæƒ…ä¸é”™~';
}

// å¤„ç†å›¾ç‰‡ä¸Šä¼ 
async function handleMomentImagesUpload(event) {
    const files = Array.from(event.target.files);
    if (files.length + momentUploadedImages.length > 9) {
        showToast('æœ€å¤šåªèƒ½ä¸Šä¼ 9å¼ å›¾ç‰‡');
        return;
    }
    
    for (const file of files) {
        if (file.type.startsWith('image/')) {
            try {
                // ç›´æ¥å­˜å‚¨Fileå¯¹è±¡ï¼Œç”¨äºåç»­ä¿å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿ
                momentUploadedImages.push({
                    file: file,
                    previewUrl: await fileToBase64(file) // ç”¨äºé¢„è§ˆ
                });
            } catch (error) {
                console.error('å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
                showToast(`å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
            }
        }
    }
    
    renderMomentImagesPreview();
    event.target.value = ''; // æ¸…ç©ºinput
}

// æ¸²æŸ“å›¾ç‰‡é¢„è§ˆ
function renderMomentImagesPreview() {
    const preview = document.getElementById('momentImagesPreview');
    preview.innerHTML = '';
    
    momentUploadedImages.forEach((imageItem, index) => {
        const item = document.createElement('div');
        item.className = 'moment-image-item';
        item.innerHTML = `
            <img src="${imageItem.previewUrl}" alt="é¢„è§ˆå›¾">
            <div class="moment-image-remove" onclick="removeMomentUploadImage(${index})">Ã—</div>
        `;
        preview.appendChild(item);
    });
}

// åˆ é™¤å›¾ç‰‡
function removeMomentUploadImage(index) {
    momentUploadedImages.splice(index, 1);
    renderMomentImagesPreview();
}

// æ–‡ä»¶è½¬Base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// æ‰‹åŠ¨å‘å¸ƒæœ‹å‹åœˆ
async function handleManualMoment(event) {
    event.preventDefault();
    
    const authorName = document.getElementById('manualMomentAuthor').value;
    const content = document.getElementById('manualMomentContent').value.trim();
    const location = document.getElementById('manualMomentLocation').value.trim();
    
    if (!content) {
        showToast('è¯·å¡«å†™æœ‹å‹åœˆå†…å®¹');
        return;
    }
    
    closeModal('manualMomentModal');
    
    // å‘å¸ƒæ‰‹åŠ¨æœ‹å‹åœˆ
    await publishManualMoment(authorName, content, momentUploadedImages, location);
}

async function publishManualMoment(authorName, content, imageItems, location = '') {
    // ä½¿ç”¨å½“å‰æ—¶é—´ä½œä¸ºå‘å¸ƒæ—¶é—´ï¼Œå°±åƒè®ºå›ä¸€æ ·
    const momentCreatedAt = new Date();
    const momentId = Date.now().toString();
    
    try {
        // å­˜å‚¨å›¾ç‰‡åˆ°æ–‡ä»¶ç³»ç»Ÿ
        let imageFileIds = [];
        let imageCount = 0;
        
        if (imageItems && imageItems.length > 0) {
            showToast('æ­£åœ¨ä¿å­˜å›¾ç‰‡...');
            
            // ç¡®ä¿ImageStorageAPIå·²åˆå§‹åŒ–
            if (window.ImageStorageAPI) {
                await window.ImageStorageAPI.init();
                
                // æå–Fileå¯¹è±¡
                const imageFiles = imageItems.map(item => item.file);
                
                // å­˜å‚¨å¤šå¼ å›¾ç‰‡
                imageFileIds = await window.ImageStorageAPI.storeMomentImages(imageFiles, momentId);
                imageCount = imageFiles.length;
                
            } else {
                console.warn('ImageStorageAPIæœªåˆå§‹åŒ–ï¼Œè·³è¿‡å›¾ç‰‡å­˜å‚¨');
            }
        }
        
        // åˆ›å»ºæœ‹å‹åœˆå¯¹è±¡
        const moment = {
            id: momentId,
            authorName: authorName,
            authorAvatar: userProfile.avatar || '',
            content: content,
            location: location, // æ·»åŠ ä½ç½®å­—æ®µ
            imageFileIds: imageFileIds, // å­˜å‚¨fileIdæ•°ç»„
            imageCount: imageCount, // å­˜å‚¨å›¾ç‰‡æ•°é‡ï¼Œç”¨äºåç»­è·å–
            time: momentCreatedAt.toISOString(),
            likes: 0,
            comments: [] // å…ˆåˆ›å»ºç©ºè¯„è®º
        };

        // ä¿å­˜å¹¶ç«‹å³æ˜¾ç¤ºæœ‹å‹åœˆ
        moments.unshift(moment);
        await saveDataToDB();
        await renderMomentsList();
        showToast('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸï¼Œæ­£åœ¨ç”Ÿæˆè¯„è®º...');

        // å¼‚æ­¥ç”Ÿæˆè¯„è®º
        setTimeout(async () => {
            try {
                // ä¸ºç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡ç”Ÿæˆè¯„è®ºæ—¶ï¼Œéœ€è¦è€ƒè™‘visionæ”¯æŒ
                let commentsWithTime;
                if (imageItems && imageItems.length > 0) {
                    // è·å–å½“å‰æ¨¡å‹å¹¶æ£€æµ‹visionæ”¯æŒ
                    const currentModel = await getCurrentModel();
                    const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModel) || false;
                    if (supportsVision) {
                        // æ”¯æŒvisionçš„æ¨¡å‹ï¼Œå‡†å¤‡å›¾ç‰‡æ•°æ®è¿›è¡Œå¤šæ¨¡æ€åˆ†æ
                        commentsWithTime = await generateAICommentsWithVision(content, moment.id, imageItems);
                    } else {
                        // ä¸æ”¯æŒvisionçš„æ¨¡å‹ï¼ŒåªåŸºäºæ–‡å­—å†…å®¹ç”Ÿæˆè¯„è®ºï¼ˆåŒ…å«ä½ç½®ä¿¡æ¯ï¼‰
                        commentsWithTime = await generateAICommentsWithCurrentTime(content, { location });
                    }
                } else {
                    // æ²¡æœ‰å›¾ç‰‡ï¼Œä½¿ç”¨å½“å‰æ—¶é—´ç”Ÿæˆè¯„è®ºï¼ˆåŒ…å«ä½ç½®ä¿¡æ¯ï¼‰
                    commentsWithTime = await generateAICommentsWithCurrentTime(content, { location });
                }
                // æ›´æ–°æœ‹å‹åœˆçš„è¯„è®º
                const momentIndex = moments.findIndex(m => m.id === moment.id);
                if (momentIndex !== -1) {
                    moments[momentIndex].comments = commentsWithTime;
                    await saveDataToDB();
                    // æ€§èƒ½ä¼˜åŒ–ï¼šåªæ›´æ–°è¯„è®ºéƒ¨åˆ†ï¼Œè€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
                    await updateMomentElement(moment.id, 'comments');
                }
            } catch (error) {
                console.error('è¯„è®ºç”Ÿæˆå¤±è´¥:', error);
            }
        }, 1000);
        
        // æ¸…ç©ºè¡¨å•å’Œå›¾ç‰‡
        document.getElementById('manualMomentContent').value = '';
        momentUploadedImages = [];
        
    } catch (error) {
        console.error('å‘å¸ƒæœ‹å‹åœˆå¤±è´¥:', error);
        showToast('å‘å¸ƒå¤±è´¥: ' + error.message);
    }
}

/**
 * @description æ ¹æ®èŠå¤©è®°å½•å’Œè§’è‰²ä¿¡æ¯ç”Ÿæˆæœ‹å‹åœˆå†…å®¹
 * @changes **MODIFIED**: Changed API request to be compatible with OpenAI format.
 */
async function generateMomentContent() {
    // æ£€æŸ¥æœ‹å‹åœˆæ“ä½œæ˜¯å¦è¢«é”å®š
    if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
        return;
    }
    
    if (!currentContact) {
        showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè”ç³»äºº');
        return;
    }

    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
        return;
    }

    const generateBtn = document.querySelector('.generate-moment-btn');
    generateBtn.disabled = true;
    generateBtn.textContent = 'ç”Ÿæˆä¸­...';

    try {
        const systemPrompt = window.promptBuilder.buildMomentContentPrompt(currentContact, userProfile, apiCallInfo, contacts);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { temperature: 0.8 },
            (apiCallInfo.timeout || 60) * 1000
        );

        const momentContent = data.choices[0].message.content || '';

        let imageData = null;
        // unsplashApiKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œä»localStorageç›´æ¥è·å–
        const unsplashKey = localStorage.getItem('unsplashApiKey') || '';
        if (unsplashKey) {
            imageData = await fetchMatchingImageForPublish(momentContent, unsplashKey);
        }

        // ä½¿ç”¨å½“å‰æ—¶é—´ç”Ÿæˆè¯„è®ºï¼ˆå°±åƒè®ºå›ä¸€æ ·ï¼‰
        const comments = await generateAICommentsWithCurrentTime(momentContent, { imageData });

        // ç”Ÿæˆæœ‹å‹åœˆID
        const momentId = Date.now().toString();

        const moment = {
            id: momentId,
            authorName: currentContact.name,
            authorAvatar: currentContact.avatar,
            content: momentContent,
            image: imageData ? imageData.url : null, // ä¿å­˜Unsplash URL
            imageDescription: imageData ? imageData.description : null, // ä¿å­˜å›¾ç‰‡æè¿°
            imageAltDescription: imageData ? imageData.altDescription : null, // ä¿å­˜Unsplashæä¾›çš„æè¿°
            imageCount: imageData ? 1 : 0, // ç®€å•çš„è®¡æ•°ï¼Œä¸å†å¤„ç†æ–‡ä»¶å­˜å‚¨
            isUnsplashImage: imageData ? true : false, // æ ‡è®°ä¸ºUnsplashå›¾ç‰‡
            time: new Date().toISOString(),
            likes: 0,
            comments: comments
        };

        moments.unshift(moment);
        await saveDataToDB();
        await renderMomentsList();
        closeModal('generateMomentModal');
        showToast('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸ');

    } catch (error) {
        console.error('ç”Ÿæˆæœ‹å‹åœˆå¤±è´¥:', error);
        showApiError(error);
    } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = 'ç”Ÿæˆæœ‹å‹åœˆ';
    }
}


/**
 * @description æ ¹æ®å†…å®¹ç”Ÿæˆå›¾ç‰‡æœç´¢å…³é”®è¯ï¼Œå¹¶è°ƒç”¨ Unsplash API è·å–å›¾ç‰‡
 * @changes ç°åœ¨ä½¿ç”¨AIç”Ÿæˆæ›´ç²¾å‡†çš„æœç´¢å…³é”®è¯
 */
async function fetchMatchingImageForPublish(content, apiKey) {
    try {
        // ä½¿ç”¨AIç”Ÿæˆæ›´ç²¾å‡†çš„æœç´¢å…³é”®è¯
        const searchQuery = await generateImageSearchKeyword(content);
        console.log(`[fetchMatchingImageForPublish] åŸå§‹å†…å®¹: "${content}"`);
        console.log(`[fetchMatchingImageForPublish] æœç´¢å…³é”®è¯: "${searchQuery}"`);
        
        // æ£€æŸ¥å…³é”®è¯æ˜¯å¦ä¸ºè‹±æ–‡ï¼ˆç®€å•æ£€æŸ¥ï¼‰
        const isEnglish = /^[a-zA-Z0-9\s\-.,!?]+$/.test(searchQuery.trim());
        if (!isEnglish) {
            console.warn(`[fetchMatchingImageForPublish] å…³é”®è¯ä¼¼ä¹ä¸æ˜¯è‹±æ–‡ï¼Œå¯èƒ½AIç”Ÿæˆå¤±è´¥: "${searchQuery}"`);
        }
        
        // è°ƒç”¨Unsplash APIæœç´¢å›¾ç‰‡
        const apiUrl = `https://api.unsplash.com/search/photos?query=${encodeURIComponent(searchQuery)}&per_page=3&orientation=landscape`;
        console.log(`[fetchMatchingImageForPublish] API URL: ${apiUrl}`);
        
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `Client-ID ${apiKey}`
            }
        });
        
        console.log(`[fetchMatchingImageForPublish] Response status: ${response.status} ${response.statusText}`);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`[fetchMatchingImageForPublish] APIé”™è¯¯è¯¦æƒ…: ${errorText}`);
            throw new Error(`Unsplash APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log(`[fetchMatchingImageForPublish] æœç´¢ç»“æœ: ä½¿ç”¨å…³é”®è¯"${searchQuery}"æ‰¾åˆ°${data.results?.length || 0}å¼ å›¾ç‰‡`);
        
        if (data.results && data.results.length > 0) {
            console.log(`[fetchMatchingImageForPublish] è¿”å›å›¾ç‰‡URL: ${data.results[0].urls.regular}`);
            // è¿”å›å›¾ç‰‡URLå’Œæè¿°ä¿¡æ¯
            return {
                url: data.results[0].urls.regular,
                description: searchQuery, // æœç´¢å…³é”®è¯ä½œä¸ºæè¿°
                altDescription: data.results[0].alt_description || searchQuery // Unsplashæä¾›çš„æè¿°
            };
        } else {
            console.warn(`[fetchMatchingImageForPublish] æœªæ‰¾åˆ°åŒ¹é…å›¾ç‰‡`);
            return null;
        }
    } catch (error) {
        console.error('[fetchMatchingImageForPublish] è·å–é…å›¾å¤±è´¥:', error);
        return null;
    }
}

/**
 * @description è°ƒç”¨ API ç”Ÿæˆå›¾ç‰‡æœç´¢å…³é”®è¯
 * @changes **MODIFIED**: Changed API request to be compatible with OpenAI format.
 */
async function generateImageSearchQuery(content) {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        console.error('è·å–APIé…ç½®å¤±è´¥:', error);
        return null;
    }
    try {
        const systemPrompt = window.promptBuilder.buildImageSearchPrompt(content);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { temperature: 0.5 },
            (apiCallInfo.timeout || 60) * 1000
        );
        return data.choices[0].message.content || null;
    } catch (error) {
        console.error('AIå…³é”®è¯ç”Ÿæˆå¤±è´¥:', error);
        return null;
    }
}


function extractImageKeywords(content) {
    const emotionMap = { 'å¼€å¿ƒ': 'happy sunshine joy', 'éš¾è¿‡': 'sad rain melancholy', 'å…´å¥‹': 'excited celebration party', 'å¹³é™': 'peaceful calm nature', 'æµªæ¼«': 'romantic sunset flowers', 'æ€€å¿µ': 'nostalgic vintage memories' };
    const sceneMap = { 'å’–å•¡': 'coffee cafe cozy', 'æ—…è¡Œ': 'travel landscape adventure', 'ç¾é£Ÿ': 'food delicious cooking', 'å·¥ä½œ': 'office workspace productivity', 'è¿åŠ¨': 'sports fitness outdoor', 'è¯»ä¹¦': 'books reading library', 'éŸ³ä¹': 'music instruments concert', 'ç”µå½±': 'cinema movie theater', 'è´­ç‰©': 'shopping fashion style', 'èšä¼š': 'party friends celebration' };
    let keywords = [];
    for (const [chinese, english] of Object.entries(emotionMap)) { if (content.includes(chinese)) { keywords.push(english); break; } }
    for (const [chinese, english] of Object.entries(sceneMap)) { if (content.includes(chinese)) { keywords.push(english); break; } }
    if (keywords.length === 0) keywords.push('lifestyle daily life aesthetic');
    return keywords.join(' ');
}

/**
 * @description è°ƒç”¨ API ç”Ÿæˆæœ‹å‹åœˆè¯„è®º
 * @changes **MODIFIED**: Changed API request to be compatible with OpenAI format.
 */
async function generateAIComments(momentContent, location = '') {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        const systemPrompt = await window.promptBuilder.buildCommentsPrompt(momentContent, contacts, location);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆçš„JSONæ ¼å¼");
        }

        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        return commentsData.comments.map(formatCommentForDataModel);
    } catch (error) {
        console.error('AIè¯„è®ºç”Ÿæˆå¤±è´¥:', error);
        return [];
    }
}

// ç”Ÿæˆå¸¦å½“å‰æ—¶é—´æˆ³çš„è¯„è®ºï¼ˆåƒè®ºå›ä¸€æ ·ï¼‰
async function generateAICommentsWithCurrentTime(momentContent, options = {}) {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        // è§£æ„å‚æ•°ï¼Œæ”¯æŒlocationå’ŒimageData
        const { location = '', imageData = null } = options;

        // å¦‚æœæœ‰Unsplashå›¾ç‰‡æè¿°ï¼Œå°†å…¶æ·»åŠ åˆ°å†…å®¹ä¸­
        let enhancedContent = momentContent;
        if (imageData && imageData.description) {
            enhancedContent += ` [å›¾ç‰‡æè¿°: ${imageData.description}]`;
            if (imageData.altDescription && imageData.altDescription !== imageData.description) {
                enhancedContent += ` [è¯¦ç»†æè¿°: ${imageData.altDescription}]`;
            }
        }

        // æ„å»ºç³»ç»Ÿæç¤ºï¼ŒåŒæ—¶æ”¯æŒlocationå’ŒenhancedContent
        const systemPrompt = await window.promptBuilder.buildCommentsPrompt(enhancedContent, contacts, location);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆçš„JSONæ ¼å¼");
        }

        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        const baseComments = commentsData.comments || [];
        
        // æ‰€æœ‰è¯„è®ºéƒ½ä½¿ç”¨å½“å‰æ—¶é—´ï¼ˆå°±åƒè®ºå›ä¸€æ ·ï¼‰
        return baseComments.map(formatCommentForDataModel);
    } catch (error) {
        console.error('ç”Ÿæˆå¸¦æ—¶é—´æˆ³è¯„è®ºå¤±è´¥:', error);
        return [];
    }
}

// ä¸ºæ”¯æŒvisionçš„æ¨¡å‹ç”Ÿæˆå¸¦å›¾ç‰‡åˆ†æçš„è¯„è®º
async function generateAICommentsWithVision(momentContent, momentId, imageItems) {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        // è·å–å›¾ç‰‡çš„base64æ•°æ®ç”¨äºvisionåˆ†æ
        const imagePromises = imageItems.slice(0, 9) // é™åˆ¶æœ€å¤š9å¼ å›¾ç‰‡
            .filter(item => item.file)
            .map(async (imageItem) => {
                const base64Data = await fileToBase64(imageItem.file);
                return {
                    type: "image_url",
                    image_url: {
                        url: `data:${imageItem.file.type};base64,${base64Data}`
                    }
                };
            });
        const imageMessages = await Promise.all(imagePromises);
        
        // æ„å»ºå¤šæ¨¡æ€æ¶ˆæ¯
        const messages = [{
            role: 'user',
            content: [
                {
                    type: "text", 
                    text: `è¯·åŸºäºä»¥ä¸‹æœ‹å‹åœˆå†…å®¹å’Œå›¾ç‰‡ï¼Œç”Ÿæˆ3-5æ¡æœ‹å‹è¯„è®ºã€‚å†…å®¹ï¼š"${momentContent}"`
                },
                ...imageMessages
            ]
        }];
        
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            messages,
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆçš„JSONæ ¼å¼");
        }

        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        const baseComments = commentsData.comments || [];
        
        // æ‰€æœ‰è¯„è®ºéƒ½ä½¿ç”¨å½“å‰æ—¶é—´ï¼ˆå°±åƒè®ºå›ä¸€æ ·ï¼‰
        return baseComments.map(formatCommentForDataModel);
    } catch (error) {
        console.error('ç”Ÿæˆå¸¦visionçš„è¯„è®ºå¤±è´¥:', error);
        // å¤±è´¥æ—¶å›é€€åˆ°æ™®é€šè¯„è®ºç”Ÿæˆ
        return await generateAICommentsWithCurrentTime(momentContent);
    }
}

// å°†Fileå¯¹è±¡è½¬æ¢ä¸ºbase64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
            const result = reader.result;
            const base64 = result.split(',')[1]; // å»æ‰data:image/...;base64,å‰ç¼€
            resolve(base64);
        };
        reader.onerror = error => reject(error);
    });
}

// ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„è¯„è®ºï¼ˆåŸºäºæœ‹å‹åœˆå‘å¸ƒæ—¶é—´ï¼‰
async function generateAICommentsWithTime(momentContent, momentTime, location = '') {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        const systemPrompt = await window.promptBuilder.buildCommentsPrompt(momentContent, contacts, location);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆçš„JSONæ ¼å¼");
        }

        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        const baseComments = commentsData.comments || [];
        
        // ä¸ºæ¯ä¸ªè¯„è®ºæ·»åŠ æ—¶é—´æˆ³ï¼ˆåœ¨æœ‹å‹åœˆå‘å¸ƒæ—¶é—´ä¹‹åï¼‰
        const momentTimeMs = new Date(momentTime).getTime();
        return baseComments.map((comment, index) => {
            // è¯„è®ºæ—¶é—´åœ¨æœ‹å‹åœˆå‘å¸ƒåçš„å‡ åˆ†é’Ÿåˆ°å‡ å°æ—¶å†…
            const minDelayMs = (index + 1) * 2 * 60 * 1000; // æ¯ä¸ªè¯„è®ºé—´éš”è‡³å°‘2åˆ†é’Ÿ
            const maxDelayMs = (index + 1) * 30 * 60 * 1000; // æœ€å¤š30åˆ†é’Ÿå
            const randomDelay = minDelayMs + Math.random() * (maxDelayMs - minDelayMs);
            const commentTime = new Date(momentTimeMs + randomDelay);
            
            const processedComment = formatCommentForDataModel({
                ...comment,
                time: commentTime.toISOString() // ä½¿ç”¨è®¡ç®—å‡ºçš„æ—¶é—´
            });
            return processedComment;
        });
    } catch (error) {
        console.error('ç”Ÿæˆå¸¦æ—¶é—´æˆ³è¯„è®ºå¤±è´¥:', error);
        return [];
    }
}


async function publishMoment() {
    const content = document.getElementById('momentPreviewContent').textContent;
    const imageElement = document.getElementById('momentPreviewImage');
    const imageUrl = imageElement.style.display === 'block' ? imageElement.src : null;
    if (!content) {
        showToast('è¯·å…ˆç”Ÿæˆæœ‹å‹åœˆå†…å®¹');
        return;
    }
    const publishBtn = document.getElementById('publishMomentBtn');
    publishBtn.disabled = true;
    publishBtn.textContent = 'å‘å¸ƒä¸­...';
    try {
        // ä½¿ç”¨å½“å‰æ—¶é—´ç”Ÿæˆè¯„è®ºï¼ˆå°±åƒè®ºå›ä¸€æ ·ï¼‰
        const comments = await generateAICommentsWithCurrentTime(content);
        const moment = { id: Date.now().toString(), authorName: currentContact.name, authorAvatar: currentContact.avatar, content, image: imageUrl, time: new Date().toISOString(), likes: 0, comments };
        moments.unshift(moment);
        await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
        await renderMomentsList();
        closeModal('generateMomentModal');
        showToast('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸ');
    } catch (error) {
        console.error('å‘å¸ƒæœ‹å‹åœˆå¤±è´¥:', error);
        showToast('å‘å¸ƒå¤±è´¥: ' + error.message);
    } finally {
        publishBtn.disabled = false;
        publishBtn.textContent = 'å‘å¸ƒ';
    }
}

async function renderMomentsList() {
    const momentsEmpty = document.getElementById('momentsEmpty');
    const momentsList = document.getElementById('momentsList');
    if (moments.length === 0) { 
        momentsEmpty.style.display = 'block';
        momentsList.style.display = 'none';
    } else {
        momentsEmpty.style.display = 'none';
        momentsList.style.display = 'block';
        momentsList.innerHTML = '';
        
        // æŒ‰æ—¶é—´æ’åºï¼Œä»æ–°åˆ°æ—§ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
        const sortedMoments = [...moments].sort((a, b) => {
            return new Date(b.time) - new Date(a.time);
        });

        // æ€§èƒ½ä¼˜åŒ–ï¼šåœ¨å¾ªç¯å¼€å§‹å‰è·å–æ¨¡å‹ä¿¡æ¯ï¼Œé¿å…åœ¨å¾ªç¯ä¸­é‡å¤è°ƒç”¨
        const currentModelForVision = await getCurrentModel();
        const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModelForVision) || false;

        for (const moment of sortedMoments) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';
            
            // å¤„ç†ä½œè€…å¤´åƒ - æ”¯æŒæ–°çš„æ–‡ä»¶ç³»ç»Ÿæ ¼å¼
            let avatarContent = '';
            const author = window.contacts ? window.contacts.find(c => c.name === moment.authorName) : null;
            
            try {
                if (author) {
                    // ä½¿ç”¨getAvatarHTMLè·å–è”ç³»äººå¤´åƒ
                    const avatarHTML = await getAvatarHTML(author, 'contact', '');
                    if (avatarHTML.includes('<img')) {
                        const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                        if (srcMatch) {
                            avatarContent = `<img src="${srcMatch[1]}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                        }
                    }
                } else if (moment.authorName === userProfile.name) {
                    // å¦‚æœæ˜¯å½“å‰ç”¨æˆ·çš„åŠ¨æ€ï¼Œä½¿ç”¨getAvatarHTMLè·å–ç”¨æˆ·å¤´åƒ
                    const avatarHTML = await getAvatarHTML(userProfile, 'user', '');
                    if (avatarHTML.includes('<img')) {
                        const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                        if (srcMatch) {
                            avatarContent = `<img src="${srcMatch[1]}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰å¤´åƒæˆ–å¤´åƒè·å–å¤±è´¥ï¼Œä½¿ç”¨æ–‡å­—å¤´åƒ
                if (!avatarContent) {
                    avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
                }
            } catch (error) {
                console.warn('è·å–æœ‹å‹åœˆå¤´åƒå¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘:', error);
                // å›é€€åˆ°æ—§çš„é€»è¾‘
                if (author && author.avatar) {
                    avatarContent = `<img src="${author.avatar}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                } else if (moment.authorName === userProfile.name && userProfile.avatar) {
                    avatarContent = `<img src="${userProfile.avatar}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                } else {
                    avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
                }
            }
            
            // å¤„ç†å›¾ç‰‡å†…å®¹ - ä¼˜å…ˆå¤„ç†Unsplashå›¾ç‰‡ï¼Œç„¶åæ˜¯ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡
            let imageContent = '';

            // ä¼˜å…ˆå¤„ç†Unsplashå›¾ç‰‡ï¼ˆç›´æ¥ä½¿ç”¨URLï¼Œä¸éœ€è¦visionæŒ‡ç¤ºå™¨å› ä¸ºå·²æœ‰æè¿°ï¼‰
            if (moment.isUnsplashImage && moment.image) {
                imageContent = `<div class="moment-images-grid grid-1">
                                  <div class="moment-image-container">
                                      <img src="${moment.image}" class="moment-grid-image" onclick="viewImage('${moment.image}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" alt="Unsplashå›¾ç‰‡">
                                      <div class="moment-image-error" style="display: none;">
                                          <div class="image-error-icon">ğŸ“·</div>
                                          <div class="image-error-text">å›¾ç‰‡åŠ è½½å¤±è´¥</div>
                                      </div>
                                  </div>
                                </div>`;
            }
            // ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡ï¼ˆä»æ–‡ä»¶ç³»ç»ŸåŠ è½½ï¼Œéœ€è¦visionæŒ‡ç¤ºå™¨ï¼‰
            else if (moment.imageFileIds && moment.imageCount > 0 && window.ImageStorageAPI) {
                const visionIndicator = supportsVision ? '<div class="vision-support-indicator">âœ“</div>' : '';
                try {
                    await window.ImageStorageAPI.init();
                    const imageUrls = await window.ImageStorageAPI.getMomentImagesURLs(moment.id, moment.imageCount);
                    if (imageUrls.length > 0) {
                        const gridClass = `grid-${imageUrls.length}`;
                        imageContent = `<div class="moment-images-grid ${gridClass}">`;
                        imageUrls.forEach((imageSrc, imageIndex) => {
                            imageContent += `<div class="moment-image-container">
                                               <img src="${imageSrc}" class="moment-grid-image" onclick="viewImage('${imageSrc}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" alt="å›¾ç‰‡${imageIndex + 1}">
                                               ${visionIndicator}
                                               <div class="moment-image-error" style="display: none;">
                                                   <div class="image-error-icon">ğŸ“·</div>
                                                   <div class="image-error-text">å›¾ç‰‡åŠ è½½å¤±è´¥</div>
                                               </div>
                                             </div>`;
                        });
                        imageContent += '</div>';
                    }
                } catch (error) {
                    console.error('åŠ è½½æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
                }
            }
            // å…¼å®¹æ—§æ•°æ®ç»“æ„ï¼ˆå¯èƒ½æ˜¯å†å²æ•°æ®ï¼Œæ ¹æ®æ˜¯å¦ä¸ºUnsplashå›¾ç‰‡å†³å®šæ˜¯å¦æ˜¾ç¤ºvisionæŒ‡ç¤ºå™¨ï¼‰
            else if (moment.image || moment.images) {
                const images = moment.images || (moment.image ? [moment.image] : []);
                if (images.length > 0) {
                    // åªæœ‰éUnsplashå›¾ç‰‡æ‰æ˜¾ç¤ºvisionæŒ‡ç¤ºå™¨
                    const visionIndicator = (!moment.isUnsplashImage && supportsVision) ? '<div class="vision-support-indicator">âœ“</div>' : '';
                    const gridClass = `grid-${images.length}`;
                    imageContent = `<div class="moment-images-grid ${gridClass}">`;
                    images.forEach((imageSrc, imageIndex) => {
                        imageContent += `<div class="moment-image-container">
                                           <img src="${imageSrc}" class="moment-grid-image" onclick="viewImage('${imageSrc}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" alt="å›¾ç‰‡${imageIndex + 1}">
                                           ${visionIndicator}
                                           <div class="moment-image-error" style="display: none;">
                                               <div class="image-error-icon">ğŸ“·</div>
                                               <div class="image-error-text">å›¾ç‰‡åŠ è½½å¤±è´¥</div>
                                           </div>
                                         </div>`;
                    });
                    imageContent += '</div>';
                }
            }
            
            // å¤„ç†è¯„è®ºå†…å®¹ - å‘ç°é¡µé¢ä¿æŒç®€æ´æ ·å¼
            let commentsContent = '';
            if (moment.comments && moment.comments.length > 0) {
                // å…¼å®¹æ€§å¤„ç†æœ‹å‹åœˆè¯„è®ºï¼šæ”¯æŒæ–°æ—§å­—æ®µå
                // æ–°ä»£ç åº”ä½¿ç”¨ç»Ÿä¸€å­—æ®µï¼šcommenter_name, comment_content, timestamp
                const commentsList = moment.comments
                    .filter(comment => (comment.comment_content || comment.content) && (comment.comment_content || comment.content).trim())
                    .map(comment => {
                        const safeContent = (comment.comment_content || comment.content).replace(/'/g, '&#39;');
                        const authorName = comment.commenter_name || comment.author;
                        return `<div onclick="showMomentReplyToComment('${moment.id}', '${authorName}')" style="font-size: 13px; color: #576b95; margin-bottom: 4px; cursor: pointer; padding: 4px; border-radius: 4px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='transparent'">
                            <span onclick="event.stopPropagation(); handleCommentAuthorClick('${authorName}')" style="cursor: pointer; color: #576b95; font-weight: bold;">${authorName}:</span>
                            <span class="moment-comment">${safeContent}</span>
                        </div>`;
                    }).join('');
                commentsContent = `<div style="margin-top: 10px; padding-top: 10px; border-top: 0.5px solid #eee;">${commentsList}</div>`;
            }
            
            // å¤„ç†ç‚¹èµä¿¡æ¯
            const likes = moment.likes || [];
            let likedUsers = [];
            
            // è·å–ç‚¹èµç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…æ‹¬ç‹¬ç«‹ç‚¹èµå’Œè¯„è®ºç‚¹èµï¼‰
            if (likes.length > 0) {
                likedUsers = [...likes];
            }
            
            if (moment.comments && moment.comments.length > 0) {
                // å…¼å®¹æ€§å¤„ç†ï¼šç‚¹èµè¯„è®ºç”¨æˆ·åˆ—è¡¨
                const commentLikedUsers = moment.comments
                    .filter(comment => comment.like === true)
                    .map(comment => comment.commenter_name || comment.author)
                    .filter(author => !likedUsers.includes(author)); // é¿å…é‡å¤
                
                likedUsers = [...likedUsers, ...commentLikedUsers];
            }
            
            const likesContent = likedUsers.length > 0 ? 
                `<div style="font-size: 13px; color: #576b95; margin-bottom: 4px;">â¤ï¸ ${likedUsers.join(', ')}</div>` : '';
            
            // æ˜¾ç¤ºåç§° - å¦‚æœæ˜¯å½“å‰ç”¨æˆ·ï¼Œä½¿ç”¨æœ€æ–°çš„ç”¨æˆ·å
            const isCurrentUser = moment.authorName === userProfile.name;
            const displayName = isCurrentUser ? userProfile.name : moment.authorName;
            
            // ä¸‰ç‚¹èœå•æŒ‰é’®
            const menuButton = `<div class="moment-menu-btn" onclick="event.stopPropagation(); toggleMomentMenu('${moment.id}')" title="æ›´å¤šé€‰é¡¹">â‹¯</div>`;
            
            // èœå•å†…å®¹
            const menuContent = `
                <div class="moment-menu" id="momentMenu-${moment.id}" style="display: none;">
                    <div class="moment-menu-item" onclick="event.stopPropagation(); editMomentLocation('${moment.id}')">ä¿®æ”¹ä½ç½®</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); regenerateMomentImage('${moment.id}')">é‡æ–°ç”Ÿæˆå›¾ç‰‡</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); removeMomentImage('${moment.id}')">åˆ é™¤å›¾ç‰‡</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); regenerateComments('${moment.id}')">é‡æ–°ç”Ÿæˆè¯„è®º</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); deleteMoment('${moment.id}')">åˆ é™¤</div>
                </div>
            `;
            
            // åˆ›å»ºç‚¹å‡»å¤´åƒçš„äº‹ä»¶å¤„ç†å‡½æ•°
            const avatarClickHandler = `onclick="handleMomentAvatarClick('${moment.authorName.replace(/'/g, "\\'")}')"`;
            
            // æ·»åŠ æŠ˜å èœå•
            const actionsMenu = `
                <div class="moment-actions-container">
                    <button class="moment-collapse-btn" onclick="toggleMomentActions('${moment.id}')">â¤/ğŸ’¬</button>
                    <div class="moment-actions-menu" id="momentActions-${moment.id}">
                        <button class="moment-action-btn" onclick="likeMoment('${moment.id}')" title="ç‚¹èµ">â¤</button>
                        <button class="moment-action-btn" onclick="showMomentComment('${moment.id}')" title="è¯„è®º">ğŸ’¬</button>
                    </div>
                </div>
            `;
            
            momentDiv.innerHTML = `
                <div class="moment-header" style="display: flex; align-items: flex-start; margin-bottom: 8px;">
                    <div ${avatarClickHandler} style="cursor: pointer; margin-right: 12px; flex-shrink: 0;">${avatarContent}</div>
                    <div style="flex: 1; min-width: 0;">
                        <div class="moment-name" style="font-weight: 600; color: #576b95; font-size: 16px; line-height: 1.2; margin: 0;">${displayName}</div>
                    </div>
                    <div style="margin-left: auto;">
                        ${menuButton}
                        ${menuContent}
                    </div>
                </div>
                <div class="moment-content">${moment.content}</div>
                ${imageContent}
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0px;">
                    <div class="moment-time-location">
                        <span>${formatContactListTime(moment.time)}</span>
                        ${moment.location ? `<span class="moment-location">ğŸ“ ${moment.location}</span>` : ''}
                    </div>
                    ${actionsMenu}
                </div>
                ${likesContent}
                ${commentsContent}
                <div class="moment-reply-input-container" id="momentMainReply-${moment.id}">
                    <textarea class="moment-reply-input" placeholder="å†™è¯„è®º..."></textarea>
                    <div class="moment-reply-actions">
                        <button class="moment-reply-btn moment-reply-cancel" onclick="hideMomentComment('${moment.id}')">å–æ¶ˆ</button>
                        <button class="moment-reply-btn moment-reply-submit" onclick="submitMomentComment('${moment.id}')">å‘é€</button>
                    </div>
                </div>
            `;
            momentsList.appendChild(momentDiv);
        }
    }
}

/**
 * æ€§èƒ½ä¼˜åŒ–ï¼šæ›´æ–°å•ä¸ªæœ‹å‹åœˆå…ƒç´ è€Œéé‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
 * @param {string} momentId - è¦æ›´æ–°çš„æœ‹å‹åœˆID
 * @param {string} updateType - æ›´æ–°ç±»å‹ï¼š'location', 'content', 'comments', 'likes'
 */
async function updateMomentElement(momentId, updateType = 'location') {
    const moment = moments.find(m => m.id === momentId);
    if (!moment) {
        console.warn(`æœªæ‰¾åˆ°IDä¸º ${momentId} çš„æœ‹å‹åœˆ`);
        return;
    }

    // æŸ¥æ‰¾å¯¹åº”çš„DOMå…ƒç´ 
    const momentElement = document.querySelector(`#momentMenu-${momentId}`)?.closest('.moment-item');
    if (!momentElement) {
        console.warn(`æœªæ‰¾åˆ°æœ‹å‹åœˆ ${momentId} å¯¹åº”çš„DOMå…ƒç´ `);
        return;
    }

    try {
        switch (updateType) {
            case 'location':
                await updateMomentLocation(momentElement, moment);
                break;
            case 'content':
                await updateMomentContent(momentElement, moment);
                break;
            case 'comments':
                await updateMomentComments(momentElement, moment);
                break;
            case 'likes':
                await updateMomentLikes(momentElement, moment);
                break;
            default:
                console.warn(`æœªçŸ¥çš„æ›´æ–°ç±»å‹: ${updateType}`);
        }
    } catch (error) {
        console.error(`æ›´æ–°æœ‹å‹åœˆå…ƒç´ å¤±è´¥ (${updateType}):`, error);
        // å¦‚æœå±€éƒ¨æ›´æ–°å¤±è´¥ï¼Œå›é€€åˆ°å…¨é‡æ¸²æŸ“
        await renderMomentsList();
    }

    console.log(`ğŸš€ æ€§èƒ½ä¼˜åŒ–å®Œæˆ: ${updateType}æ›´æ–°`);
}

/**
 * æ›´æ–°æœ‹å‹åœˆä½ç½®æ˜¾ç¤º
 */
async function updateMomentLocation(momentElement, moment) {
    const timeLocationContainer = momentElement.querySelector('.moment-time-location');
    if (!timeLocationContainer) {
        console.warn('æœªæ‰¾åˆ°æ—¶é—´ä½ç½®å®¹å™¨');
        return;
    }

    // æ›´æ–°æ—¶é—´å’Œä½ç½®æ˜¾ç¤º
    timeLocationContainer.innerHTML = `
        <span>${formatContactListTime(moment.time)}</span>
        ${moment.location ? `<span class="moment-location">ğŸ“ ${moment.location}</span>` : ''}
    `;

    console.log(`âœ… ä½ç½®æ›´æ–°å®Œæˆ: ${moment.location || 'å·²æ¸…é™¤'}`);
}

/**
 * æ›´æ–°æœ‹å‹åœˆå†…å®¹æ˜¾ç¤º
 */
async function updateMomentContent(momentElement, moment) {
    const contentElement = momentElement.querySelector('.moment-content');
    if (contentElement) {
        contentElement.textContent = moment.content;
    }

    console.log(`âœ… å†…å®¹æ›´æ–°å®Œæˆ`);
}

/**
 * æ›´æ–°æœ‹å‹åœˆè¯„è®ºæ˜¾ç¤º
 */
async function updateMomentComments(momentElement, moment) {
    // æŸ¥æ‰¾è¯„è®ºå®¹å™¨ - ä½¿ç”¨æ›´é€šç”¨çš„é€‰æ‹©å™¨
    let commentsContainer = momentElement.querySelector('.moment-comments');
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°.moment-commentsï¼ŒæŸ¥æ‰¾åŒ…å«è¯„è®ºçš„divï¼ˆé€šè¿‡æ ·å¼ç‰¹å¾ï¼‰
    if (!commentsContainer) {
        commentsContainer = momentElement.querySelector('div[style*="margin-top: 10px"][style*="padding-top: 10px"][style*="border-top"]');
    }
    
    // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼ŒæŸ¥æ‰¾æœ€åä¸€ä¸ªåŒ…å«è¯„è®ºç›¸å…³å†…å®¹çš„div
    if (!commentsContainer) {
        const allDivs = momentElement.querySelectorAll('div');
        for (let i = allDivs.length - 1; i >= 0; i--) {
            if (allDivs[i].innerHTML.includes('moment-comment') || allDivs[i].querySelector('.moment-comment')) {
                commentsContainer = allDivs[i];
                break;
            }
        }
    }

    // ç”Ÿæˆæ–°çš„è¯„è®ºå†…å®¹ - ä½¿ç”¨ä¸ renderMomentsList ç›¸åŒçš„é€»è¾‘
    let newCommentsContent = '';
    if (moment.comments && moment.comments.length > 0) {
        // å…¼å®¹æ€§å¤„ç†æœ‹å‹åœˆè¯„è®ºï¼šæ”¯æŒæ–°æ—§å­—æ®µå
        // æ–°ä»£ç åº”ä½¿ç”¨ç»Ÿä¸€å­—æ®µï¼šcommenter_name, comment_content, timestamp
        const commentsList = moment.comments
            .filter(comment => (comment.comment_content || comment.content) && (comment.comment_content || comment.content).trim())
            .map(comment => {
                const safeContent = (comment.comment_content || comment.content).replace(/'/g, '&#39;');
                const authorName = comment.commenter_name || comment.author;
                return `<div onclick="showMomentReplyToComment('${moment.id}', '${authorName}')" style="font-size: 13px; color: #576b95; margin-bottom: 4px; cursor: pointer; padding: 4px; border-radius: 4px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='transparent'">
                            <span onclick="event.stopPropagation(); handleCommentAuthorClick('${authorName}')" style="cursor: pointer; color: #576b95; font-weight: bold;">${authorName}:</span>
                            <span class="moment-comment">${safeContent}</span>
                        </div>`;
            }).join('');
        newCommentsContent = `<div class="moment-comments" style="margin-top: 10px; padding-top: 10px; border-top: 0.5px solid #eee;">${commentsList}</div>`;
    }

    if (commentsContainer) {
        // å¦‚æœæ‰¾åˆ°äº†è¯„è®ºå®¹å™¨ï¼Œç›´æ¥æ›¿æ¢
        if (newCommentsContent) {
            commentsContainer.outerHTML = newCommentsContent;
        } else {
            // å¦‚æœæ²¡æœ‰è¯„è®ºï¼Œç§»é™¤è¯„è®ºå®¹å™¨
            commentsContainer.remove();
        }
        console.log(`âœ… è¯„è®ºæ›´æ–°å®Œæˆ`);
    } else {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¯„è®ºå®¹å™¨ï¼Œä½†æœ‰æ–°è¯„è®ºè¦æ˜¾ç¤ºï¼Œåˆ™æ·»åŠ åˆ°momentå†…å®¹åŒºåŸŸæœ«å°¾
        if (newCommentsContent) {
            const replyContainer = momentElement.querySelector('.moment-reply-input-container');
            if (replyContainer) {
                replyContainer.insertAdjacentHTML('beforebegin', newCommentsContent);
                console.log(`âœ… è¯„è®ºæ’å…¥å®Œæˆ`);
            } else {
                // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šæ·»åŠ åˆ°moment-itemçš„æœ«å°¾
                momentElement.insertAdjacentHTML('beforeend', newCommentsContent);
                console.log(`âœ… è¯„è®ºæ·»åŠ å®Œæˆï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰`);
            }
        } else {
            console.log(`â„¹ï¸ æ— è¯„è®ºéœ€è¦æ˜¾ç¤º`);
        }
    }
}

/**
 * æ›´æ–°æœ‹å‹åœˆç‚¹èµæ˜¾ç¤º
 */
async function updateMomentLikes(momentElement, moment) {
    // æŸ¥æ‰¾ç‚¹èµå®¹å™¨ - ä½¿ç”¨æ›´é€šç”¨çš„é€‰æ‹©å™¨
    let likesContainer = momentElement.querySelector('.moment-likes');
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ° .moment-likesï¼ŒæŸ¥æ‰¾åŒ…å«ç‚¹èµå†…å®¹çš„divï¼ˆé€šè¿‡å†…å®¹ç‰¹å¾ï¼‰
    if (!likesContainer) {
        const allDivs = momentElement.querySelectorAll('div[style*="font-size: 13px"][style*="color: #576b95"]');
        for (const div of allDivs) {
            if (div.innerHTML.includes('â¤ï¸')) {
                likesContainer = div;
                break;
            }
        }
    }

    // ç”Ÿæˆæ–°çš„ç‚¹èµå†…å®¹ - ä½¿ç”¨ä¸ renderMomentsList ç›¸åŒçš„é€»è¾‘
    const likes = moment.likes || [];
    let likedUsers = [];
    
    // è·å–ç‚¹èµç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…æ‹¬ç‹¬ç«‹ç‚¹èµå’Œè¯„è®ºç‚¹èµï¼‰
    if (likes.length > 0) {
        likedUsers = [...likes];
    }
    
    if (moment.comments && moment.comments.length > 0) {
        const commentLikedUsers = moment.comments
            .filter(comment => comment.like === true)
            .map(comment => comment.commenter_name  || comment.author)
            .filter(author => !likedUsers.includes(author)); // é¿å…é‡å¤
        
        likedUsers = [...likedUsers, ...commentLikedUsers];
    }
    
    const newLikesContent = likedUsers.length > 0 ? 
        `<div class="moment-likes" style="font-size: 13px; color: #576b95; margin-bottom: 4px;">â¤ï¸ ${likedUsers.join(', ')}</div>` : '';

    if (likesContainer) {
        // å¦‚æœæ‰¾åˆ°äº†ç‚¹èµå®¹å™¨ï¼Œç›´æ¥æ›¿æ¢
        if (newLikesContent) {
            likesContainer.outerHTML = newLikesContent;
        } else {
            // å¦‚æœæ²¡æœ‰ç‚¹èµï¼Œç§»é™¤ç‚¹èµå®¹å™¨
            likesContainer.remove();
        }
        console.log(`âœ… ç‚¹èµæ›´æ–°å®Œæˆ`);
    } else {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç‚¹èµå®¹å™¨ï¼Œä½†æœ‰æ–°ç‚¹èµè¦æ˜¾ç¤ºï¼Œåˆ™æ·»åŠ åˆ°åˆé€‚ä½ç½®
        if (newLikesContent) {
            // æŸ¥æ‰¾è¯„è®ºå®¹å™¨ï¼Œåœ¨å…¶å‰é¢æ’å…¥ç‚¹èµ
            const commentsContainer = momentElement.querySelector('.moment-comments') || 
                                    momentElement.querySelector('div[style*="margin-top: 10px"][style*="border-top"]');
            
            if (commentsContainer) {
                commentsContainer.insertAdjacentHTML('beforebegin', newLikesContent);
                console.log(`âœ… ç‚¹èµæ’å…¥å®Œæˆï¼ˆè¯„è®ºå‰ï¼‰`);
            } else {
                // å¦‚æœæ²¡æœ‰è¯„è®ºå®¹å™¨ï¼Œåœ¨å›å¤è¾“å…¥æ¡†å‰æ’å…¥
                const replyContainer = momentElement.querySelector('.moment-reply-input-container');
                if (replyContainer) {
                    replyContainer.insertAdjacentHTML('beforebegin', newLikesContent);
                    console.log(`âœ… ç‚¹èµæ’å…¥å®Œæˆï¼ˆå›å¤æ¡†å‰ï¼‰`);
                } else {
                    // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šæ·»åŠ åˆ°moment-itemçš„æœ«å°¾
                    momentElement.insertAdjacentHTML('beforeend', newLikesContent);
                    console.log(`âœ… ç‚¹èµæ·»åŠ å®Œæˆï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰`);
                }
            }
        } else {
            console.log(`â„¹ï¸ æ— ç‚¹èµéœ€è¦æ˜¾ç¤º`);
        }
    }
}

// å›¾ç‰‡æŸ¥çœ‹åŠŸèƒ½
function viewImage(imageSrc) {
    // åˆ›å»ºå…¨å±å›¾ç‰‡æŸ¥çœ‹å™¨
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.9); z-index: 10000; 
        display: flex; align-items: center; justify-content: center;
        cursor: pointer;
    `;
    
    const img = document.createElement('img');
    img.src = imageSrc;
    img.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain;';
    
    overlay.appendChild(img);
    overlay.onclick = () => document.body.removeChild(overlay);
    document.body.appendChild(overlay);
}


// åˆ é™¤æœ‹å‹åœˆ
async function deleteMoment(momentId) {
    showConfirmDialog('åˆ é™¤ç¡®è®¤', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æœ‹å‹åœˆå—ï¼Ÿ', async () => {
        try {
            // ä»æ•°ç»„ä¸­åˆ é™¤
            const momentIndex = moments.findIndex(m => m.id === momentId);
            if (momentIndex !== -1) {
                moments.splice(momentIndex, 1);
                await saveDataToDB();
                isMomentsDataModified = true; // æ ‡è®°æ•°æ®å·²ä¿®æ”¹
                await renderMomentsList();
                showToast('æœ‹å‹åœˆå·²åˆ é™¤');
            } else {
                showToast('æœªæ‰¾åˆ°è¦åˆ é™¤çš„æœ‹å‹åœˆ');
            }
        } catch (error) {
            console.error('åˆ é™¤æœ‹å‹åœˆå¤±è´¥:', error);
            isMomentsDataModified = true; // å³ä½¿å¤±è´¥ä¹Ÿæ ‡è®°ï¼Œç¡®ä¿ä¸‹æ¬¡åˆ‡æ¢é¡µé¢æ—¶åˆ·æ–°
            showToast('åˆ é™¤å¤±è´¥: ' + error.message);
        }
    });
}

// --- éŸ³ä¹æ’­æ”¾å™¨ (æ‡’åŠ è½½) ---
function lazyInitMusicPlayer() {
    // ç¡®ä¿åªåˆå§‹åŒ–ä¸€æ¬¡
    if (isMusicPlayerInitialized) return;
    isMusicPlayerInitialized = true;

    initMusicPlayer();
}

async function initMusicPlayer() {
    try {
        // DBå·²ç»ç”±init()æ‰“å¼€ï¼Œè¿™é‡Œä¸éœ€è¦å†æ¬¡æ‰“å¼€
        await loadPlaylistFromDB();
    } catch (error) {
        console.error("Failed to initialize music player:", error);
        showToast("æ— æ³•åŠ è½½éŸ³ä¹åº“");
    }

    document.getElementById('closeMusicModal').addEventListener('click', closeMusicModal);
    document.getElementById('progressBar').addEventListener('click', seekMusic);
    window.addEventListener('click', (event) => { if (event.target === document.getElementById('musicModal')) closeMusicModal(); });
    
    audio = new Audio();
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('ended', onSongEnded);
    audio.addEventListener('loadedmetadata', onMetadataLoaded);
}

async function loadPlaylistFromDB() {
    return new Promise((resolve, reject) => {
        if (!window.isIndexedDBReady) { // ç¡®ä¿DBå·²å‡†å¤‡å¥½
            reject('IndexedDB not ready');
            return;
        }
        const transaction = window.db.transaction(['songs'], 'readonly');
        const store = transaction.objectStore('songs');
        const request = store.getAll();

        request.onsuccess = () => {
            playlist = request.result.map(song => ({
                id: song.id,
                name: song.name,
                lyrics: song.lyrics,
            }));
            renderPlaylist();
            resolve();
        };

        request.onerror = (event) => {
            console.error('Failed to load playlist from DB:', event.target.error);
            reject('Failed to load playlist');
        };
    });
}

async function saveSong() {
    const nameInput = document.getElementById('songName');
    const musicFileInput = document.getElementById('musicFileUpload');
    const lrcFileInput = document.getElementById('lrcFile');

    const musicFile = musicFileInput.files[0];
    const lrcFile = lrcFileInput.files[0];

    if (!musicFile) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªéŸ³ä¹æ–‡ä»¶');
        return;
    }

    const songName = nameInput.value.trim() || musicFile.name.replace(/\.[^/.]+$/, "");

    let lyrics = [];
    if (lrcFile) {
        try {
            const lrcText = await lrcFile.text();
            lyrics = parseLRC(lrcText);
        } catch (e) {
            showToast('æ­Œè¯æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œå°†ä¸å¸¦æ­Œè¯ä¿å­˜ã€‚');
        }
    }
    
    const songRecord = {
        name: songName,
        music: musicFile, 
        lyrics: lyrics
    };

    if (!window.isIndexedDBReady) {
        showToast('æ•°æ®åº“æœªå‡†å¤‡å¥½ï¼Œæ— æ³•ä¿å­˜æ­Œæ›²ã€‚');
        return;
    }

    const transaction = window.db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');
    const request = store.add(songRecord);

    request.onsuccess = async () => {
        showToast(`æ­Œæ›² "${songName}" å·²æˆåŠŸä¿å­˜åˆ°æœ¬åœ°`);
        clearAddForm();
        await loadPlaylistFromDB(); 
    };

    request.onerror = (event) => {
        console.error('Failed to save song to DB:', event.target.error);
        showToast('ä¿å­˜æ­Œæ›²å¤±è´¥');
    };
}

async function playSong(index) {
    if (index < 0 || index >= playlist.length) return;
    
    const songInfo = playlist[index];
    currentSongIndex = index;

    if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
        currentObjectUrl = null;
    }

    if (!window.isIndexedDBReady) {
        showToast('æ•°æ®åº“æœªå‡†å¤‡å¥½ï¼Œæ— æ³•æ’­æ”¾æ­Œæ›²ã€‚');
        return;
    }

    const transaction = window.db.transaction(['songs'], 'readonly');
    const store = transaction.objectStore('songs');
    const request = store.get(songInfo.id);

    request.onsuccess = (event) => {
        const songRecord = event.target.result;
        if (songRecord && songRecord.music) {
            currentObjectUrl = URL.createObjectURL(songRecord.music);
            audio.src = currentObjectUrl;
            audio.play().then(() => {
                isPlaying = true;
                updatePlayButton();
                document.getElementById('currentSongInfo').style.display = 'block';
                document.getElementById('currentSongName').textContent = songRecord.name;
                currentLyrics = songRecord.lyrics || [];
                currentLyricIndex = -1;
                if (currentLyrics.length > 0) startLyricSync();
                else document.getElementById('currentLyric').textContent = 'æš‚æ— æ­Œè¯';
                renderPlaylist();
            }).catch(error => showToast('æ’­æ”¾å¤±è´¥: ' + error.message));
        } else {
            showToast('æ— æ³•ä»æ•°æ®åº“ä¸­æ‰¾åˆ°æ­Œæ›²æ–‡ä»¶');
        }
    };

    request.onerror = (event) => {
        console.error("Error fetching song from DB:", event.target.error);
        showToast('æ’­æ”¾æ­Œæ›²æ—¶å‡ºé”™');
    };
}

async function deleteSong(index) {
    showConfirmDialog('åˆ é™¤ç¡®è®¤', 'ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™é¦–æ­Œå—ï¼Ÿ', async () => {
        const songInfo = playlist[index];
        
        if (!window.isIndexedDBReady) {
            showToast('æ•°æ®åº“æœªå‡†å¤‡å¥½ï¼Œæ— æ³•åˆ é™¤æ­Œæ›²ã€‚');
            return;
        }

        const transaction = window.db.transaction(['songs'], 'readwrite');
        const store = transaction.objectStore('songs');
        const request = store.delete(songInfo.id);

        request.onsuccess = async () => {
            showToast(`æ­Œæ›² "${songInfo.name}" å·²åˆ é™¤`);
            if (index === currentSongIndex) {
                stopMusic();
                currentSongIndex = -1;
                document.getElementById('currentSongInfo').style.display = 'none';
            }
            await loadPlaylistFromDB();
        };

        request.onerror = (event) => {
            console.error('Failed to delete song from DB:', event.target.error);
            showToast('åˆ é™¤æ­Œæ›²å¤±è´¥');
        };
    });
}

function showMusicModal() {
    lazyInitMusicPlayer(); // ç¬¬ä¸€æ¬¡ç‚¹å‡»æ—¶æ‰åˆå§‹åŒ–
    document.getElementById('musicModal').style.display = 'block';
    renderPlaylist();
}

function closeMusicModal() {
    document.getElementById('musicModal').style.display = 'none';
}

function renderPlaylist() {
    const container = document.getElementById('playlistContainer');
    if (!playlist || playlist.length === 0) { 
        container.innerHTML = '<p style="text-align: center; color: #999;">æš‚æ— æ­Œæ›²ï¼Œè¯·ä»ä¸‹æ–¹ä¸Šä¼ </p>'; 
        return; 
    }
    container.innerHTML = '';
    playlist.forEach((song, index) => {
        const songDiv = document.createElement('div');
        songDiv.className = 'song-item';
        if (index === currentSongIndex) songDiv.classList.add('active');
        songDiv.innerHTML = `<span onclick="playSong(${index})" style="flex: 1;">${song.name}</span><span class="delete-song" onclick="deleteSong(${index})">Ã—</span>`;
        container.appendChild(songDiv);
    });
}

function parseLRC(lrcContent) {
    const lines = lrcContent.split(/\r?\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?\]/g;
    lines.forEach(line => {
        if (!line.trim()) return;
        let match;
        let lastIndex = 0;
        const times = [];
        while ((match = timeRegex.exec(line)) !== null) {
            const totalSeconds = parseInt(match[1]) * 60 + parseInt(match[2]) + (match[3] ? parseInt(match[3].padEnd(3, '0')) / 1000 : 0);
            times.push(totalSeconds);
            lastIndex = match.index + match[0].length;
        }
        if (times.length > 0) {
            const text = line.substring(lastIndex).trim();
            if (text) times.forEach(time => lyrics.push({ time, text }));
        }
    });
    lyrics.sort((a, b) => a.time - b.time);
    return lyrics;
}

function startLyricSync() {
    stopLyricSync();
    lyricTimer = setInterval(() => { if (!audio.paused && currentLyrics.length > 0) updateLyrics(); }, 100);
}

function stopLyricSync() {
    if (lyricTimer) clearInterval(lyricTimer);
    lyricTimer = null;
}

function updateLyrics() {
    const currentTime = audio.currentTime;
    let newIndex = -1;
    for (let i = currentLyrics.length - 1; i >= 0; i--) {
        if (currentTime >= currentLyrics[i].time) { newIndex = i; break; }
    }
    if (newIndex !== currentLyricIndex && newIndex >= 0) {
        currentLyricIndex = newIndex;
        const lyricText = currentLyrics[newIndex].text;
        document.getElementById('currentLyric').textContent = lyricText;
        sendLyricToAI(lyricText);
    }
}

function sendLyricToAI(lyricText) {
    if (currentSongIndex > -1) {
         window.currentMusicInfo = { songName: playlist[currentSongIndex]?.name || '', lyric: lyricText, isPlaying };
    }
}

function togglePlay() {
    if (audio.src) {
        if (audio.paused) { audio.play(); isPlaying = true; startLyricSync(); }
        else { audio.pause(); isPlaying = false; stopLyricSync(); }
        updatePlayButton();
    }
}

function stopMusic() {
    audio.pause();
    audio.currentTime = 0;
    isPlaying = false;
    currentLyricIndex = -1;
    stopLyricSync();
    updatePlayButton();
    document.getElementById('currentLyric').textContent = 'ç­‰å¾…æ­Œè¯...';
    window.currentMusicInfo = null;
    if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
        currentObjectUrl = null;
    }
}

function updatePlayButton() {
    document.getElementById('playPauseBtn').textContent = isPlaying ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ æ’­æ”¾';
}

function updateProgress() {
    if (audio.duration) {
        document.getElementById('progressFill').style.width = (audio.currentTime / audio.duration) * 100 + '%';
        document.getElementById('currentTime').textContent = formatMusicTime(audio.currentTime);
    }
}

function onMetadataLoaded() {
    document.getElementById('totalTime').textContent = formatMusicTime(audio.duration);
}

function onSongEnded() {
    isPlaying = false;
    updatePlayButton();
    stopLyricSync();
    window.currentMusicInfo = null;
}

function seekMusic(event) {
    if (audio.duration) {
        const rect = event.currentTarget.getBoundingClientRect();
        audio.currentTime = ((event.clientX - rect.left) / rect.width) * audio.duration;
    }
}

function toggleLyricsDisplay() {
    document.getElementById('floatingLyrics').style.display = document.getElementById('showLyrics').checked ? 'block' : 'none';
}

function clearAddForm() {
    document.getElementById('songName').value = '';
    document.getElementById('musicFileUpload').value = '';
    document.getElementById('lrcFile').value = '';
}

// formatMusicTime and formatTime functions moved to utils/formatUtils.js

// --- UI æ›´æ–° & äº¤äº’ ---
function updateContextIndicator() {
    const indicator = document.getElementById('contextIndicator');
    if (indicator) indicator.innerHTML = `ä¸Šä¸‹æ–‡: ${apiSettings.contextMessageCount}æ¡`;
}

function updateContextValue(value) {
    document.getElementById('contextValue').textContent = value + 'æ¡';
}


// ä¸“é—¨ç”¨äºæ˜¾ç¤ºä¸Šä¼ é”™è¯¯çš„å‡½æ•°
// showUploadError function moved to utils/uiUtils.js

// å¤„ç†APIé”™è¯¯çš„ä¸“ç”¨å‡½æ•°ï¼Œä¸ƒå¤•èŠ‚ç‰¹æ®ŠåŠŸèƒ½ï¼šæ‰€æœ‰APIå¤±è´¥éƒ½æ˜¾ç¤ºé‡è¯•ç¡®è®¤å¯¹è¯æ¡†
// showApiError function moved to utils/uiUtils.js

// === localStorageæ¸…ç©ºåŠŸèƒ½ ===
function showClearLocalStorageConfirmation() {
    showModal('clearLocalStorageModal');
    console.log('æ˜¾ç¤ºlocalStorageæ¸…ç©ºç¡®è®¤å¯¹è¯æ¡†');
}

function executeLocalStorageClear() {
    try {
        // è®°å½•æ¸…ç©ºå‰çš„localStorageé¡¹ç›®æ•°é‡
        const itemCount = localStorage.length;
        console.log(`å‡†å¤‡æ¸…ç©ºlocalStorageï¼Œå½“å‰æœ‰${itemCount}ä¸ªé¡¹ç›®`);
        
        // è·å–æ‰€æœ‰localStorageé”®åï¼ˆç”¨äºæ—¥å¿—è®°å½•ï¼‰
        const allKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            allKeys.push(localStorage.key(i));
        }
        
        console.log('localStorageæ¸…ç©ºå‰çš„æ‰€æœ‰é”®å:', allKeys);
        
        // æ‰§è¡Œæ¸…ç©ºæ“ä½œ
        localStorage.clear();
        
        // å…³é—­å¯¹è¯æ¡†
        closeModal('clearLocalStorageModal');
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        showToast(`âœ… localStorageå·²æ¸…ç©ºï¼å·²åˆ é™¤${itemCount}ä¸ªé¡¹ç›®`, 3000);
        
        // è®°å½•æ“ä½œåˆ°æ§åˆ¶å°
        console.log('âœ… localStorageæ¸…ç©ºæ“ä½œå®Œæˆ', {
            timestamp: new Date().toISOString(),
            clearedItemsCount: itemCount,
            clearedKeys: allKeys,
            currentItemsCount: localStorage.length
        });
        
        // å¯é€‰ï¼šå»¶è¿Ÿåˆ·æ–°é¡µé¢è®©ç”¨æˆ·çœ‹åˆ°ç»“æœ
        setTimeout(() => {
            if (confirm('localStorageå·²æ¸…ç©ºã€‚æ˜¯å¦è¦åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿æ‰€æœ‰ç»„ä»¶æ­£ç¡®é‡ç½®ï¼Ÿ')) {
                window.location.reload();
            }
        }, 2000);
        
    } catch (error) {
        console.error('æ¸…ç©ºlocalStorageæ—¶å‘ç”Ÿé”™è¯¯:', error);
        showToast(`âŒ æ¸…ç©ºå¤±è´¥: ${error.message}`, 3000);
        closeModal('clearLocalStorageModal');
    }
}

// === ä¸ƒå¤•èŠ‚ç‰¹æ®ŠåŠŸèƒ½ï¼šAIç©ºå›å¤é‡è¯• ===
let qixiRetryContext = null; // å­˜å‚¨é‡è¯•ä¸Šä¸‹æ–‡

function showQixiRetryModal(prefixOrError, error, errorMessage, prefix) {
    // æ£€æŸ¥æ¨¡æ€æ¡†å…ƒç´ æ˜¯å¦å­˜åœ¨
    const modal = document.getElementById('qixiRetryModal');
    if (!modal) {
        // å¦‚æœæ¨¡æ€æ¡†ä¸å­˜åœ¨ï¼Œç›´æ¥æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†ä½œä¸ºfallback
        const shouldRetry = confirm(`æ“ä½œå¤±è´¥ï¼š${errorMessage}\n\næ˜¯å¦è¦é‡æ–°å°è¯•ï¼Ÿ`);
        if (shouldRetry) {
            // ä¿å­˜é‡è¯•ä¸Šä¸‹æ–‡
            if (typeof prefixOrError === 'string' && error) {
                qixiRetryContext = { type: 'dual-param', prefix: prefixOrError, error: error, errorMessage, fullPrefix: prefix };
            } else {
                qixiRetryContext = { type: 'single-param', error: prefixOrError, errorMessage, fullPrefix: prefix };
            }
            handleQixiRetry();
        }
        return;
    }
    
    // ä¿å­˜é‡è¯•ä¸Šä¸‹æ–‡ï¼Œæ”¯æŒå•å‚æ•°å’ŒåŒå‚æ•°è°ƒç”¨
    if (typeof prefixOrError === 'string' && error) {
        qixiRetryContext = { type: 'dual-param', prefix: prefixOrError, error: error, errorMessage, fullPrefix: prefix };
    } else {
        qixiRetryContext = { type: 'single-param', error: prefixOrError, errorMessage, fullPrefix: prefix };
    }
    
    // æ›´æ–°æ¨¡æ€æ¡†ä¸­çš„é”™è¯¯ä¿¡æ¯æ˜¾ç¤º
    const errorDiv = document.querySelector('#qixiRetryModal .qixi-retry-message');
    if (errorDiv) {
        errorDiv.innerHTML = `
            <p><strong>æ“ä½œå¤±è´¥</strong></p>
            <p>${errorMessage}</p>
            <p>æ˜¯å¦è¦é‡æ–°å°è¯•ï¼Ÿ</p>
        `;
    }
    
    showModal('qixiRetryModal');
}

async function handleQixiRetry() {
    closeModal('qixiRetryModal');
    
    if (!qixiRetryContext) {
        showToast('é‡è¯•ä¸Šä¸‹æ–‡ä¸¢å¤±ï¼Œè¯·é‡æ–°æ“ä½œ');
        return;
    }
    
    try {
        showToast('ğŸŒ¹ æ­£åœ¨é‡æ–°å°è¯•...');
        
        // æ ¹æ®å½“å‰åœºæ™¯é‡æ–°æ‰§è¡Œç›¸åº”çš„æ“ä½œ
        if (currentContact) {
            // é‡æ–°å‘é€æ¶ˆæ¯
            let apiCallInfo;
            try {
                apiCallInfo = await getApiCallInfo();
            } catch (error) {
                showToast('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
                return;
            }
            
            showTypingIndicator();
            
            try {
                let replies;
                if (currentContact.type === 'group') {
                    const result = await callChatAPIWithPriority(currentContact, [], true);
                    replies = result.replies;
                } else {
                    const result = await callChatAPIWithPriority(currentContact, [], true);
                    replies = result.replies;
                }
                
                hideTypingIndicator();
                
                if (!replies || replies.length === 0) {
                    showToast('é‡è¯•åä»æœªè·å¾—æœ‰æ•ˆå›å¤');
                    return;
                }
                
                // å¤„ç†AIå›å¤
                for (let i = 0; i < replies.length; i++) {
                    const response = replies[i];
                    const isLastReply = i === replies.length - 1;
                    
                    await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
                    
                    let rawMessageContent = removeThinkingChain(response.content);
                    const voiceParsed = parseVoiceMessage(rawMessageContent);

                    const aiMessage = { 
                        role: 'assistant', 
                        content: voiceParsed.content,
                        type: response.type, 
                        time: new Date().toISOString(), 
                        senderId: currentContact.id,
                        isVoice: voiceParsed.isVoice
                    };

                    currentContact.messages.push(aiMessage);

                    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                        currentlyDisplayedMessageCount++;
                    }
                    
                    await addSingleMessage(aiMessage, true);
                    
                    if (isLastReply) {
                        currentContact.lastMessage = response.type === 'text' ? response.content.substring(0, 20) + '...' : (response.type === 'emoji' ? '[è¡¨æƒ…]' : '[çº¢åŒ…]');
                        currentContact.lastTime = formatContactListTime(new Date().toISOString());
                        await renderContactList();
                        await saveDataToDB();
                    }
                }
                
                showToast('é‡è¯•æˆåŠŸ');
                
            } catch (retryError) {
                hideTypingIndicator();
                console.error('é‡è¯•å¤±è´¥:', retryError);
                
                showToast('é‡è¯•å¤±è´¥: ' + retryError.message);
            }
        } else {
            showToast('æ²¡æœ‰å½“å‰èŠå¤©å¯¹è±¡ï¼Œæ— æ³•é‡è¯•');
        }
        
    } catch (error) {
        console.error('å¤„ç†é‡è¯•æ—¶å‘ç”Ÿé”™è¯¯:', error);
        showToast('é‡è¯•è¿‡ç¨‹å‡ºç°é”™è¯¯: ' + error.message);
    } finally {
        // æ¸…ç†é‡è¯•ä¸Šä¸‹æ–‡
        qixiRetryContext = null;
    }
}

// === è¡¨æƒ…å›¾ç‰‡ç®¡ç†å‡½æ•° ===
async function renderEmojiContent(emojiContent, isInline = false) {
    // å¤„ç†æ–°æ ¼å¼ [emoji:tag]
    if (emojiContent.startsWith('[emoji:') && emojiContent.endsWith(']')) {
        const tag = emojiContent.slice(7, -1);
        const imageData = await getEmojiImage(tag);
        if (imageData) {
            const style = isInline ? 'max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;' : '';
            const className = isInline ? '' : 'class="message-emoji"';
            return `<img src="${imageData}" ${className} style="${style}">`;
        } else {
            // å¦‚æœæ‰¾ä¸åˆ°å›¾ç‰‡ï¼Œæ˜¾ç¤ºæ ‡ç­¾
            return `[è¡¨æƒ…:${tag}]`;
        }
    }
    
    // å¤„ç†æ—§æ ¼å¼çš„base64æˆ–URL
    if (emojiContent.startsWith('data:image/') || emojiContent.startsWith('http')) {
        const style = isInline ? 'max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;' : '';
        const className = isInline ? '' : 'class="message-emoji"';
        return `<img src="${emojiContent}" ${className} style="${style}">`;
    }
    
    return emojiContent; // è¿”å›åŸå†…å®¹
}

// åˆ é™¤AIå›å¤ä¸­çš„æ€ç»´é“¾æ ‡ç­¾
// removeThinkingChain function moved to utils/formatUtils.js

async function processTextWithInlineEmojis(textContent) {
    const emojiTagRegex = /\[(?:emoji|å‘é€äº†è¡¨æƒ…)[:ï¼š]([^\]]+)\]/g;
    const standaloneEmojiMatch = textContent.trim().match(/^\[(?:emoji|å‘é€äº†è¡¨æƒ…)[:ï¼š]([^\]]+)\]$/);
    
    if (standaloneEmojiMatch) {
        // å¤„ç†ç‹¬ç«‹è¡¨æƒ…æ¶ˆæ¯
        const emojiName = standaloneEmojiMatch[1];
        const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
        if (foundEmoji && foundEmoji.tag) {
            return await renderEmojiContent(`[emoji:${foundEmoji.tag}]`);
        } else if (foundEmoji && foundEmoji.url) {
            // æ—§æ ¼å¼å…¼å®¹
            return `<img src="${foundEmoji.url}" class="message-emoji">`;
        } else {
            return `<div class="message-content">${textContent}</div>`;
        }
    } else {
        // å¤„ç†åŒ…å«å†…è”è¡¨æƒ…çš„æ–‡æœ¬
        let processedContent = textContent.replace(/\n/g, '<br>');
        
        // ä½¿ç”¨å¼‚æ­¥æ›¿æ¢å¤„ç†å†…è”è¡¨æƒ…
        const emojiMatches = [...processedContent.matchAll(emojiTagRegex)];
        for (const match of emojiMatches) {
            const fullMatch = match[0];
            const emojiName = match[1];
            const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
            
            let replacement = fullMatch; // é»˜è®¤ä¿æŒåŸæ ·
            if (foundEmoji && foundEmoji.tag) {
                const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                replacement = emojiHtml;
            } else if (foundEmoji && foundEmoji.url) {
                // æ—§æ ¼å¼å…¼å®¹
                replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
            }
            
            processedContent = processedContent.replace(fullMatch, replacement);
        }
        
        return `<div class="message-content">${processedContent}</div>`;
    }
}
async function saveEmojiImage(tag, base64Data) {
    if (!window.isIndexedDBReady) {
        console.warn('IndexedDB æœªå‡†å¤‡å¥½ï¼Œæ— æ³•ä¿å­˜è¡¨æƒ…å›¾ç‰‡ã€‚');
        return;
    }
    
    // å¦‚æœ emojiImages å­˜å‚¨ä¸å­˜åœ¨ï¼Œæç¤ºç”¨æˆ·åˆ·æ–°é¡µé¢
    if (!window.db.objectStoreNames.contains('emojiImages')) {
        console.log('æ£€æµ‹åˆ° emojiImages å­˜å‚¨ä¸å­˜åœ¨ï¼Œéœ€è¦å‡çº§æ•°æ®åº“');
        if (typeof showToast === 'function') {
            showToast('æ£€æµ‹åˆ°æ•°æ®åº“éœ€è¦å‡çº§ï¼Œè¯·åˆ·æ–°é¡µé¢');
        }
        return;
    }
    
    try {
        const transaction = window.db.transaction(['emojiImages'], 'readwrite');
        const store = transaction.objectStore('emojiImages');
        await promisifyRequest(store.put({ tag: tag, data: base64Data }));
    } catch (error) {
        console.error('ä¿å­˜è¡¨æƒ…å›¾ç‰‡å¤±è´¥:', error);
        throw error;
    }
}

async function getEmojiImage(tag) {
    if (!window.isIndexedDBReady) {
        console.warn('IndexedDB æœªå‡†å¤‡å¥½ï¼Œæ— æ³•è·å–è¡¨æƒ…å›¾ç‰‡ã€‚');
        return null;
    }
    
    try {
        // é¦–å…ˆå°è¯•ä»æ–°çš„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿè·å–
        if (window.ImageStorageAPI) {
            try {
                await window.ImageStorageAPI.init();
                const url = await window.ImageStorageAPI.getEmojiURL(tag);
                if (url) {
                    return url;
                }
            } catch (error) {
                console.warn('ä»æ–°æ–‡ä»¶å­˜å‚¨è·å–è¡¨æƒ…å¤±è´¥ï¼Œå›é€€åˆ°æ—§ç³»ç»Ÿ:', error);
            }
        }
        
        // å›é€€åˆ°æ—§çš„ emojiImages å­˜å‚¨
        if (!window.db.objectStoreNames.contains('emojiImages')) {
            console.log('æ£€æµ‹åˆ° emojiImages å­˜å‚¨ä¸å­˜åœ¨ï¼Œéœ€è¦å‡çº§æ•°æ®åº“');
            if (typeof showToast === 'function') {
                showToast('æ£€æµ‹åˆ°æ•°æ®åº“éœ€è¦å‡çº§ï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            return null;
        }
        
        const transaction = window.db.transaction(['emojiImages'], 'readonly');
        const store = transaction.objectStore('emojiImages');
        const result = await promisifyRequest(store.get(tag));
        return result ? result.data : null;
        
    } catch (error) {
        console.error('è·å–è¡¨æƒ…å›¾ç‰‡å¤±è´¥:', error);
        return null;
    }
}

async function deleteEmojiImage(tag) {
    if (!window.isIndexedDBReady) {
        console.warn('IndexedDB æœªå‡†å¤‡å¥½ï¼Œæ— æ³•åˆ é™¤è¡¨æƒ…å›¾ç‰‡ã€‚');
        return;
    }
    
    // å¦‚æœ emojiImages å­˜å‚¨ä¸å­˜åœ¨ï¼Œæç¤ºç”¨æˆ·åˆ·æ–°é¡µé¢
    if (!window.db.objectStoreNames.contains('emojiImages')) {
        console.log('æ£€æµ‹åˆ° emojiImages å­˜å‚¨ä¸å­˜åœ¨ï¼Œéœ€è¦å‡çº§æ•°æ®åº“');
        if (typeof showToast === 'function') {
            showToast('æ£€æµ‹åˆ°æ•°æ®åº“éœ€è¦å‡çº§ï¼Œè¯·åˆ·æ–°é¡µé¢');
        }
        return;
    }
    
    try {
        const transaction = window.db.transaction(['emojiImages'], 'readwrite');
        const store = transaction.objectStore('emojiImages');
        await promisifyRequest(store.delete(tag));
    } catch (error) {
        console.error('åˆ é™¤è¡¨æƒ…å›¾ç‰‡å¤±è´¥:', error);
        throw error;
    }
}


// æ•°æ®åº“ä¼˜åŒ–å‡½æ•°ï¼šå°†ç°æœ‰base64è¡¨æƒ…è½¬æ¢ä¸ºæ ‡ç­¾æ ¼å¼
async function optimizeEmojiDatabase() {
    if (!window.isIndexedDBReady) {
        showToast('æ•°æ®åº“æœªå‡†å¤‡å¥½ï¼Œæ— æ³•æ‰§è¡Œä¼˜åŒ–');
        return;
    }
    
    try {
        showToast('å¼€å§‹ä¼˜åŒ–æ•°æ®åº“...');
        let optimizedCount = 0;
        let processedContacts = 0;
        
        // å¤„ç†æ‰€æœ‰è”ç³»äººçš„æ¶ˆæ¯
        for (const contact of contacts) {
            let contactModified = false;
            
            for (const message of contact.messages) {
                // æŸ¥æ‰¾åŒ…å«base64å›¾ç‰‡çš„æ¶ˆæ¯
                if (message.content && typeof message.content === 'string') {
                    const base64Regex = /data:image\/[^,\s]+,[A-Za-z0-9+/=]+/g;
                    const matches = message.content.match(base64Regex);
                    
                    if (matches) {
                        let newContent = message.content;
                        
                        for (const base64Url of matches) {
                            // æŸ¥æ‰¾å¯¹åº”çš„è¡¨æƒ…
                            const emoji = emojis.find(e => e.url === base64Url || (e.url && e.url === base64Url));
                            if (emoji && emoji.meaning) {
                                // å¦‚æœè¿˜æ²¡æœ‰ä¿å­˜è¿‡è¿™ä¸ªè¡¨æƒ…çš„å›¾ç‰‡ï¼Œä¿å­˜åˆ°emojiImages
                                const existingImage = await getEmojiImage(emoji.meaning);
                                if (!existingImage) {
                                    await saveEmojiImage(emoji.meaning, base64Url);
                                }
                                
                                // æ›´æ–°è¡¨æƒ…æ•°æ®ç»“æ„
                                if (!emoji.tag) {
                                    emoji.tag = emoji.meaning;
                                }
                                
                                // æ›¿æ¢æ¶ˆæ¯ä¸­çš„base64ä¸ºæ ‡ç­¾æ ¼å¼
                                newContent = newContent.replace(base64Url, `[emoji:${emoji.meaning}]`);
                                optimizedCount++;
                                contactModified = true;
                            } else {
                                // å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”çš„è¡¨æƒ…ï¼Œå¯èƒ½æ˜¯ç‹¬ç«‹çš„base64å›¾ç‰‡ï¼Œåˆ›å»ºä¸€ä¸ªä¸´æ—¶æ ‡ç­¾
                                const tempTag = `temp_${Date.now()}`;
                                await saveEmojiImage(tempTag, base64Url);
                                newContent = newContent.replace(base64Url, `[emoji:${tempTag}]`);
                                
                                // åˆ›å»ºä¸€ä¸ªæ–°çš„è¡¨æƒ…è®°å½•
                                emojis.push({
                                    id: Date.now().toString(),
                                    tag: tempTag,
                                    meaning: tempTag
                                });
                                optimizedCount++;
                                contactModified = true;
                            }
                        }
                        
                        // æ›´æ–°æ¶ˆæ¯å†…å®¹
                        message.content = newContent;
                        
                        // å¦‚æœæ¶ˆæ¯ç±»å‹æ˜¯emojiï¼Œä¹Ÿæ›´æ–°ç±»å‹
                        if (message.type === 'emoji' && matches.length === 1 && newContent.trim().match(/^\[emoji:[^\]]+\]$/)) {
                            // è¿™æ˜¯ä¸€ä¸ªçº¯è¡¨æƒ…æ¶ˆæ¯
                            message.content = newContent.trim();
                        }
                    }
                }
            }
            
            if (contactModified) {
                processedContacts++;
            }
        }
        
        // æ›´æ–°è¡¨æƒ…æ•°æ®ç»“æ„ï¼Œç§»é™¤æ—§çš„urlå­—æ®µ
        for (const emoji of emojis) {
            if (emoji.url && emoji.url.startsWith('data:image/')) {
                // ç¡®ä¿å›¾ç‰‡å·²ä¿å­˜åˆ°emojiImages
                if (emoji.tag || emoji.meaning) {
                    const tag = emoji.tag || emoji.meaning;
                    const existingImage = await getEmojiImage(tag);
                    if (!existingImage) {
                        await saveEmojiImage(tag, emoji.url);
                    }
                    
                    // ç§»é™¤urlå­—æ®µ
                    delete emoji.url;
                    
                    // ç¡®ä¿æœ‰tagå­—æ®µ
                    if (!emoji.tag && emoji.meaning) {
                        emoji.tag = emoji.meaning;
                    }
                }
            }
        }
        
        // ä¿å­˜ä¼˜åŒ–åçš„æ•°æ®
        await saveDataToDB();
        
        showToast(`æ•°æ®åº“ä¼˜åŒ–å®Œæˆï¼å¤„ç†äº† ${optimizedCount} ä¸ªè¡¨æƒ…ï¼Œæ¶‰åŠ ${processedContacts} ä¸ªè”ç³»äºº`);
        
        // åˆ·æ–°è¡¨æƒ…ç½‘æ ¼
        await renderEmojiGrid();
        
        // å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©ï¼Œé‡æ–°æ¸²æŸ“æ¶ˆæ¯
        if (currentContact) {
            await renderMessages(true);
        }
        
    } catch (error) {
        console.error('æ•°æ®åº“ä¼˜åŒ–å¤±è´¥:', error);
        showToast(`ä¼˜åŒ–å¤±è´¥: ${error.message}`);
    }
}

// showTopNotification function moved to utils/uiUtils.js



// æ¸…ç†è¡¨æƒ…åŒ…ä¸Šä¼ ä¸´æ—¶æ•°æ®çš„å‡½æ•°
function cleanupEmojiUploadData() {
    try {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if (window.ImageUploadHandlers.tempEmojiFile) {
            window.ImageUploadHandlers.tempEmojiFile = null;
        }
        
        // æ¸…ç†ä¸´æ—¶URL
        const emojiUrlInput = document.getElementById('emojiUrl');
        if (emojiUrlInput && emojiUrlInput.value.startsWith('temp:')) {
            const tempUrl = emojiUrlInput.value.substring(5);
            URL.revokeObjectURL(tempUrl);
            emojiUrlInput.value = '';
        }
        
        // æ¸…ç†æ–‡ä»¶è¾“å…¥
        const fileInput = document.getElementById('emojiUploadInput');
        if (fileInput) {
            fileInput.value = '';
        }
        
        // æ¸…ç†çŠ¶æ€æç¤º
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = '';
            statusElement.style.color = '';
        }
        
        // æ¸…ç†æ„æ€è¾“å…¥æ¡†
        const meaningInput = document.getElementById('emojiMeaning');
        if (meaningInput) {
            meaningInput.value = '';
        }
        
        console.log('è¡¨æƒ…åŒ…ä¸Šä¼ ä¸´æ—¶æ•°æ®å·²æ¸…ç†');
    } catch (error) {
        console.error('æ¸…ç†è¡¨æƒ…åŒ…ä¸Šä¼ æ•°æ®æ—¶å‡ºé”™:', error);
    }
}

function showAddContactModal() {
    editingContact = null;
    window.editingContact = null;
    document.getElementById('contactModalTitle').textContent = 'æ·»åŠ AIåŠ©æ‰‹';
    
    // æ¸…é™¤æ‰€æœ‰è¾“å…¥æ¡†å’ŒçŠ¶æ€æç¤º
    document.getElementById('contactName').value = '';
    document.getElementById('contactAvatar').value = '';
    document.getElementById('contactPersonality').value = '';
    document.getElementById('customPrompts').value = '';
    document.getElementById('contactVoiceId').value = '';
    
    // æ¸…é™¤æ–‡ä»¶è¾“å…¥å’ŒçŠ¶æ€æç¤º
    const fileInput = document.getElementById('avatarUploadInput');
    const statusElement = document.getElementById('avatarUploadStatus');
    if (fileInput) fileInput.value = '';
    if (statusElement) statusElement.textContent = '';
    
    showModal('addContactModal');
}

function showEditContactModal() {
    if (!currentContact) { showToast('è¯·å…ˆé€‰æ‹©è”ç³»äºº'); return; }
    editingContact = currentContact;
    window.editingContact = editingContact;
    document.getElementById('contactModalTitle').textContent = 'ç¼–è¾‘AIåŠ©æ‰‹';
    document.getElementById('contactName').value = currentContact.name;
    
    // å¤„ç†å¤´åƒæ˜¾ç¤ºå’ŒçŠ¶æ€
    const avatarInput = document.getElementById('contactAvatar');
    const fileInput = document.getElementById('avatarUploadInput');
    const statusElement = document.getElementById('avatarUploadStatus');
    
    // è®¾ç½®éšè—çš„URLè¾“å…¥æ¡†
    if (currentContact.avatarFileId) {
        avatarInput.value = `file:${currentContact.avatarFileId}`;
        // æ˜¾ç¤ºå·²ä¸Šä¼ çŠ¶æ€
        if (statusElement) {
            statusElement.textContent = 'å·²ä¸Šä¼ ';
            statusElement.style.color = '#07c160';
        }
    } else {
        avatarInput.value = currentContact.avatar || '';
        // æ¸…é™¤çŠ¶æ€æç¤º
        if (statusElement) {
            statusElement.textContent = '';
        }
    }
    
    // æ¸…é™¤file inputä»¥é¿å…æ˜¾ç¤ºä¸Šæ¬¡çš„æ–‡ä»¶
    if (fileInput) {
        fileInput.value = '';
    }
    
    document.getElementById('contactPersonality').value = currentContact.personality;
    document.getElementById('customPrompts').value = currentContact.customPrompts || '';
    // åŠ è½½å½“å‰è”ç³»äººçš„è¯­éŸ³ID
    document.getElementById('contactVoiceId').value = currentContact.voiceId || '';
    showModal('addContactModal');
}

// APIåŠ è½½ç­‰å¾…ç›¸å…³å˜é‡
let apiLoadingTimerId = null;
let apiLoadingStartTime = null;
let apiLoadingCancelled = false;

// æ˜¾ç¤ºAPIåŠ è½½ç­‰å¾…æ¡†
function showApiLoadingModal() {
    apiLoadingCancelled = false;
    apiLoadingStartTime = Date.now();
    showModal('apiLoadingModal');
    
    // å¼€å§‹å€’è®¡æ—¶
    apiLoadingTimerId = setInterval(() => {
        if (apiLoadingCancelled) {
            clearInterval(apiLoadingTimerId);
            return;
        }
        
        const elapsed = Math.floor((Date.now() - apiLoadingStartTime) / 1000);
        const countdownElement = document.getElementById('loadingCountdown');
        if (countdownElement) {
            countdownElement.textContent = elapsed + 's';
        }
    }, 1000);
}

// éšè—APIåŠ è½½ç­‰å¾…æ¡†
function hideApiLoadingModal() {
    if (apiLoadingTimerId) {
        clearInterval(apiLoadingTimerId);
        apiLoadingTimerId = null;
    }
    closeModal('apiLoadingModal');
}

// å–æ¶ˆAPIåŠ è½½
function cancelApiLoading() {
    apiLoadingCancelled = true;
    hideApiLoadingModal();
    showToast('å·²å–æ¶ˆæ¨¡å‹åŠ è½½');
}

async function showApiSettingsModal() {
    try {
        console.log('æ˜¾ç¤ºAPIé…ç½®ç®¡ç†æ¨¡æ€æ¡†');
        
        // æ˜¾ç¤ºç­‰å¾…æç¤ºæ¡†
        showApiLoadingModal();
        
        try {
            // åˆå§‹åŒ–é…ç½®é€‰æ‹©å™¨
            await loadConfigSelector();
            
            // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
            if (apiLoadingCancelled) return;
            
            // åŠ è½½å½“å‰é…ç½®åˆ°è¡¨å•
            await loadCurrentConfigToForm();
            
            // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
            if (apiLoadingCancelled) return;
            
            // åŠ è½½æ¨¡å‹é€‰æ‹©å™¨çš„APIé…ç½®åˆ—è¡¨
            await loadApiConfigSelectorsForModels();
            
            // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
            if (apiLoadingCancelled) return;
            
        } finally {
            // æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥éƒ½è¦éšè—ç­‰å¾…æ¡†
            hideApiLoadingModal();
        }
        
        // åªæœ‰åœ¨æ²¡æœ‰è¢«å–æ¶ˆæ—¶æ‰æ˜¾ç¤ºAPIè®¾ç½®æ¨¡æ€æ¡†
        if (!apiLoadingCancelled) {
            showModal('apiSettingsModal');
            console.log('APIè®¾ç½®æ¨¡æ€æ¡†å·²æ˜¾ç¤º');
            
            // ç¡®ä¿API keyçŠ¶æ€æ­£ç¡®æ˜¾ç¤º
            setTimeout(() => {
                updateAllKeyStates();
                // æ›´æ–°UIæç¤ºçŠ¶æ€
                updateUIHintStatus();
            }, 200); // å»¶è¿Ÿç¡®ä¿DOMå·²å®Œå…¨æ¸²æŸ“
        }
        
    } catch (error) {
        console.error('æ˜¾ç¤ºAPIè®¾ç½®æ¨¡æ€æ¡†å¤±è´¥:', error);
        hideApiLoadingModal();
        showToast('æ‰“å¼€è®¾ç½®å¤±è´¥: ' + error.message);
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯ç”¨
window.showApiSettingsModal = showApiSettingsModal;

// æ·»åŠ APIè®¾ç½®æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨ï¼ˆå®‰å…¨çš„å»¶è¿Ÿç»‘å®šï¼‰
document.addEventListener('DOMContentLoaded', function() {
    const apiSettingsIcon = document.getElementById('apiSettingsIcon');
    if (apiSettingsIcon) {
        apiSettingsIcon.addEventListener('click', showApiSettingsModal);
        apiSettingsIcon.setAttribute('data-umami-event', 'API Settings Open');
    }
});

function showBackgroundModal() {
    // å¼‚æ­¥åŒ…è£…å‡½æ•°
    showBackgroundModalAsync().catch(error => {
        console.error('æ˜¾ç¤ºèƒŒæ™¯è®¾ç½®ç•Œé¢é”™è¯¯:', error);
    });
}

async function showBackgroundModalAsync() {
    if (!currentContact) { showToast('è¯·å…ˆé€‰æ‹©è”ç³»äºº'); return; }
    
    // å¤„ç†èƒŒæ™¯URLæ˜¾ç¤º
    let displayUrl = '';
    const backgroundUrl = backgrounds[currentContact.id];
    if (backgroundUrl) {
        if (backgroundUrl.startsWith('file:')) {
            // å¦‚æœæ˜¯æ–°çš„æ–‡ä»¶å­˜å‚¨æ ¼å¼ï¼Œæ˜¾ç¤ºæ–‡ä»¶å­˜å‚¨æ ‡è¯†
            displayUrl = '(å·²ä½¿ç”¨æ–‡ä»¶å­˜å‚¨)';
        } else {
            displayUrl = backgroundUrl;
        }
    }
    
    document.getElementById('backgroundUrl').value = displayUrl;
    showModal('backgroundModal');
}

function showAddEmojiModal() {
    showModal('addEmojiModal');
    toggleEmojiPanel(true);
}

function showRedPacketModal() {
    showModal('redPacketModal');
}

function showEditProfileModal() {
    document.getElementById('profileNameInput').value = userProfile.name;
    
    // å¤„ç†å¤´åƒæ˜¾ç¤ºå’ŒçŠ¶æ€
    const avatarInput = document.getElementById('profileAvatarInput');
    const fileInput = document.getElementById('profileUploadInput');
    const statusElement = document.getElementById('profileUploadStatus');
    
    // è®¾ç½®éšè—çš„URLè¾“å…¥æ¡†
    if (userProfile.avatarFileId) {
        avatarInput.value = `file:${userProfile.avatarFileId}`;
        // æ˜¾ç¤ºå·²ä¸Šä¼ çŠ¶æ€
        if (statusElement) {
            statusElement.textContent = 'å·²ä¸Šä¼ ';
            statusElement.style.color = '#07c160';
        }
    } else {
        avatarInput.value = userProfile.avatar || '';
        // æ¸…é™¤çŠ¶æ€æç¤º
        if (statusElement) {
            statusElement.textContent = '';
        }
    }
    
    // æ¸…é™¤file inputä»¥é¿å…æ˜¾ç¤ºä¸Šæ¬¡çš„æ–‡ä»¶
    if (fileInput) {
        fileInput.value = '';
    }
    
    document.getElementById('profilePersonality').value = userProfile.personality || '';
    showModal('editProfileModal');
}

function showCreateGroupModal() {
    // å¼‚æ­¥åŒ…è£…å‡½æ•°
    showCreateGroupModalAsync().catch(error => {
        console.error('æ˜¾ç¤ºç¾¤èŠåˆ›å»ºç•Œé¢é”™è¯¯:', error);
    });
}

async function showCreateGroupModalAsync() {
    const memberList = document.getElementById('groupMemberList');
    memberList.innerHTML = '';
    
    for (const contact of contacts) {
        if (contact.type !== 'group') {
            const item = document.createElement('div');
            item.className = 'group-member-item';
            
            const avatarHTML = await getAvatarHTML(contact, 'contact') || contact.name[0];
            item.innerHTML = `<div class="group-member-avatar">${avatarHTML}</div><div class="group-member-name">${contact.name}</div><div class="group-member-checkbox">âœ“</div>`;
            item.onclick = () => {
                item.classList.toggle('selected');
                item.querySelector('.group-member-checkbox').classList.toggle('selected');
            };
            memberList.appendChild(item);
        }
    }
    showModal('createGroupModal');
}

// --- æ•°æ®ä¿å­˜ä¸å¤„ç† ---
async function saveContact(event) {
    event.preventDefault();
    const avatarValue = document.getElementById('contactAvatar').value;

    // å¤„ç†ä¸´æ—¶URLçš„æƒ…å†µï¼šå¦‚æœæ˜¯ä¸´æ—¶URLä½†è¿˜æœ‰ä¸´æ—¶æ–‡ä»¶ï¼Œå…ˆè½¬æ¢å­˜å‚¨
    if (avatarValue.startsWith('temp:') && window.tempContactAvatarFile) {
        try {
            const statusElement = document.getElementById('avatarUploadStatus');
            if (statusElement) {
                statusElement.textContent = 'æ­£åœ¨å­˜å‚¨å¤´åƒ...';
                statusElement.style.color = '#999';
            }

            // é¢„ç”Ÿæˆè”ç³»äººIDç”¨äºå­˜å‚¨ï¼ˆä¸åé¢åˆ›å»ºè”ç³»äººæ—¶çš„IDä¿æŒä¸€è‡´ï¼‰
            const newContactId = Date.now().toString();
            window.preGeneratedContactId = newContactId;  // å­˜å‚¨ä»¥ä¾¿åç»­ä½¿ç”¨

            // ä½¿ç”¨ImageStorageAPIå­˜å‚¨å¤´åƒ
            await window.ImageStorageAPI.init();
            const fileId = await window.ImageStorageAPI.storeAvatar(window.tempContactAvatarFile, 'contact', newContactId);

            // æ¸…ç†ä¸´æ—¶æ•°æ®
            const tempUrl = avatarValue.substring(5);
            URL.revokeObjectURL(tempUrl);
            window.tempContactAvatarFile = null;

            // æ›´æ–°URLè¾“å…¥æ¡†ä¸ºfileIdæ ¼å¼
            document.getElementById('contactAvatar').value = `file:${fileId}`;

            if (statusElement) {
                statusElement.textContent = 'å¤´åƒå­˜å‚¨æˆåŠŸ';
                statusElement.style.color = '#07c160';
            }
        } catch (error) {
            console.error('ä¸´æ—¶å¤´åƒæ–‡ä»¶è½¬æ¢å¤±è´¥:', error);
            showToast('å¤´åƒå­˜å‚¨å¤±è´¥ï¼Œè¯·é‡è¯•');
            return;
        }
    }

    // é‡æ–°è·å–å¤„ç†åçš„å¤´åƒå€¼
    const finalAvatarValue = document.getElementById('contactAvatar').value;

    // å¤„ç†å¤´åƒæ•°æ®ï¼šå¦‚æœæ˜¯æ–°çš„fileIdæ ¼å¼ï¼Œåˆ†åˆ«ä¿å­˜åˆ°avatarå’ŒavatarFileIdå­—æ®µ
    const contactData = {
        name: document.getElementById('contactName').value,
        personality: document.getElementById('contactPersonality').value,
        customPrompts: document.getElementById('customPrompts').value,
        // ä¿å­˜è¯­éŸ³ID
        voiceId: document.getElementById('contactVoiceId').value.trim()
    };

    // å¤„ç†å¤´åƒå­—æ®µ
    if (finalAvatarValue.startsWith('file:')) {
        // æ–°çš„fileSystemæ ¼å¼
        contactData.avatarFileId = finalAvatarValue.substring(5); // ç§»é™¤ "file:" å‰ç¼€
        // ä¿ç•™åŸavatarå­—æ®µä¸ºç©ºæˆ–åˆ é™¤ï¼Œç¡®ä¿å‘åå…¼å®¹
        contactData.avatar = '';
    } else if (finalAvatarValue.startsWith('temp:')) {
        showToast('å¤´åƒå°šæœªæ­£ç¡®å­˜å‚¨ï¼Œè¯·é‡æ–°ä¸Šä¼ ');
        return;
    } else {
        // ä¼ ç»Ÿçš„URLæˆ–base64æ ¼å¼
        contactData.avatar = finalAvatarValue;
        // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„avatarFileId
        contactData.avatarFileId = null;
    }
    if (editingContact) {
        Object.assign(editingContact, contactData);
        showToast('ä¿®æ”¹æˆåŠŸ');
    } else {
        // ä½¿ç”¨é¢„ç”Ÿæˆçš„IDï¼ˆå¦‚æœæœ‰å¤´åƒä¸Šä¼ ï¼‰ï¼Œå¦åˆ™ç”Ÿæˆæ–°ID
        const contactId = window.preGeneratedContactId || Date.now().toString();
        window.preGeneratedContactId = null; // æ¸…ç†

        const contact = {
            id: contactId,
            ...contactData,
            messages: [],
            lastMessage: 'ç‚¹å‡»å¼€å§‹èŠå¤©',
            lastTime: formatContactListTime(new Date().toISOString()),
            type: 'private',
            memoryTableContent: defaultMemoryTable,
            // äº’åŠ¨ç•Œé¢ç›¸å…³å­—æ®µ
            interactiveBackgroundFileId: '',
            touchZones: [],
            theme: 'theme-pink-white',
            ttsEnabled: false,
            diaryEntries: {},
            interactiveChatHistory: []
        };
        contacts.unshift(contact);
        showToast('æ·»åŠ æˆåŠŸ');
    }
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    await renderContactList();
    if (editingContact && currentContact && editingContact.id === currentContact.id) {
        await renderMessages(false);
    }
    closeModal('addContactModal');
    
    // æ¸…ç†è‡ªå®šä¹‰çŠ¶æ€æç¤º
    const statusElement = document.getElementById('avatarUploadStatus');
    if (statusElement) statusElement.textContent = '';
    
    event.target.reset();
}

async function createGroup(event) {
    event.preventDefault();
    const groupName = document.getElementById('groupName').value;
    if (!groupName) { showToast('è¯·è¾“å…¥ç¾¤èŠåç§°'); return; }
    const selectedItems = document.querySelectorAll('.group-member-item.selected');
    if (selectedItems.length < 2) { showToast('è¯·è‡³å°‘é€‰æ‹©ä¸¤ä¸ªæˆå‘˜'); return; }
    const memberIds = [];
    selectedItems.forEach(item => {
        const name = item.querySelector('.group-member-name').textContent;
        const contact = contacts.find(c => c.name === name && c.type === 'private');
        if (contact) memberIds.push(contact.id);
    });
    const group = { id: 'group_' + Date.now().toString(), name: groupName, members: memberIds, messages: [], lastMessage: 'ç¾¤èŠå·²åˆ›å»º', lastTime: formatContactListTime(new Date().toISOString()), type: 'group', memoryTableContent: defaultMemoryTable };
    contacts.unshift(group);
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    await renderContactList();
    closeModal('createGroupModal');
    showToast('ç¾¤èŠåˆ›å»ºæˆåŠŸ');
}

function importPrompts(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            document.getElementById('customPrompts').value = JSON.stringify(JSON.parse(e.target.result), null, 2);
            showToast('å¯¼å…¥æˆåŠŸ');
        } catch (error) {
            showToast('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼é”™è¯¯');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

async function saveProfile(event) {
    event.preventDefault();
    const avatarValue = document.getElementById('profileAvatarInput').value;
    
    userProfile.name = document.getElementById('profileNameInput').value;
    userProfile.personality = document.getElementById('profilePersonality').value;
    
    // å¤„ç†å¤´åƒå­—æ®µ
    if (avatarValue.startsWith('file:')) {
        // æ–°çš„fileSystemæ ¼å¼
        userProfile.avatarFileId = avatarValue.substring(5); // ç§»é™¤ "file:" å‰ç¼€
        // ä¿ç•™åŸavatarå­—æ®µä¸ºç©ºï¼Œç¡®ä¿å‘åå…¼å®¹
        userProfile.avatar = '';
    } else {
        // ä¼ ç»Ÿçš„URLæˆ–base64æ ¼å¼
        userProfile.avatar = avatarValue;
        // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„avatarFileId
        userProfile.avatarFileId = null;
    }
    
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    await updateUserProfileUI();
    
    // æ¸…ç†è‡ªå®šä¹‰çŠ¶æ€æç¤º
    const statusElement = document.getElementById('profileUploadStatus');
    if (statusElement) statusElement.textContent = '';
    
    closeModal('editProfileModal');
    showToast('ä¿å­˜æˆåŠŸ');
}

async function updateUserProfileUI() {
    const userAvatar = document.getElementById('userAvatar');
    const userName = document.getElementById('userName');
    userName.textContent = userProfile.name;
    
    // ä½¿ç”¨getAvatarHTMLæ”¯æŒæ–‡ä»¶å­˜å‚¨
    const avatarHTML = await getAvatarHTML(userProfile, 'user');
    userAvatar.innerHTML = avatarHTML || (userProfile.name[0] || 'æˆ‘');
}

async function renderContactList() {
    const contactList = document.getElementById('contactList');
    contactList.innerHTML = '';
    
    for (const contact of contacts) {
        const item = document.createElement('div');
        item.className = 'contact-item';
        item.setAttribute('data-contact-id', contact.id);
        
        if (contact.type === 'group') {
            const groupAvatarContent = await getGroupAvatarContent(contact);
            item.innerHTML = `<div class="group-avatar"><div class="group-avatar-inner">${groupAvatarContent}</div></div><div class="contact-info"><div class="contact-name">${contact.name}</div><div class="contact-message">${contact.lastMessage}</div></div><div class="contact-time">${contact.lastTime}</div>`;
        } else {
            // ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬æ”¯æŒæ–‡ä»¶å­˜å‚¨
            const avatarHTML = await getAvatarHTML(contact, 'contact');
            item.innerHTML = `<div class="contact-avatar">${avatarHTML || contact.name[0]}</div><div class="contact-info"><div class="contact-name">${contact.name}</div><div class="contact-message">${contact.lastMessage}</div></div><div class="contact-time">${contact.lastTime}</div>`;
        }
        item.onclick = () => openChat(contact);

        // æ·»åŠ é•¿æŒ‰äº‹ä»¶ç›‘å¬å™¨æ¥åˆ é™¤è”ç³»äºº/ç¾¤èŠ
        let pressTimer;
        item.addEventListener('touchstart', () => {
            pressTimer = setTimeout(() => {
                showConfirmDialog('åˆ é™¤ç¡®è®¤', `ç¡®å®šè¦åˆ é™¤ "${contact.name}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, () => {
                    deleteContact(contact.id);
                });
            }, 700); // é•¿æŒ‰700æ¯«ç§’è§¦å‘
        });
        item.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
        });
        item.addEventListener('touchmove', () => {
            clearTimeout(pressTimer);
        });
        // å¯¹äºéè§¦æ‘¸è®¾å¤‡ï¼Œä¹Ÿå¯ä»¥æ·»åŠ å³é”®èœå•
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showConfirmDialog('åˆ é™¤ç¡®è®¤', `ç¡®å®šè¦åˆ é™¤ "${contact.name}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, () => {
                deleteContact(contact.id);
            });
        });

        contactList.appendChild(item);
    }
}

/**
 * æ›´æ–°è”ç³»äººåˆ—è¡¨çš„æ—¶é—´æ˜¾ç¤º
 * æ¯åˆ†é’Ÿè°ƒç”¨ä¸€æ¬¡ï¼Œé‡æ–°è®¡ç®—ç›¸å¯¹æ—¶é—´
 * ä½¿ç”¨ç›´æ¥DOMæ›´æ–°ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
 */
function updateContactListTimes() {
    // æ£€æŸ¥æ˜¯å¦åœ¨è”ç³»äººåˆ—è¡¨é¡µé¢
    const contactListPage = document.getElementById('contactListPage');
    if (!contactListPage || !contactListPage.classList.contains('active')) {
        return; // å¦‚æœä¸åœ¨è”ç³»äººåˆ—è¡¨é¡µé¢ï¼Œç›´æ¥è¿”å›
    }
    
    let updateCount = 0;
    
    // æ›´æ–°æ¯ä¸ªè”ç³»äººçš„æ—¶é—´æ˜¾ç¤º
    contacts.forEach(contact => {
        if (contact.messages && contact.messages.length > 0) {
            const lastMsg = contact.messages[contact.messages.length - 1];
            const newTime = formatContactListTime(lastMsg.time);
            
            // åªæœ‰æ—¶é—´æ˜¾ç¤ºçœŸçš„æ”¹å˜äº†æ‰æ›´æ–°DOM
            if (contact.lastTime !== newTime) {
                contact.lastTime = newTime;
                
                // æ‰¾åˆ°å¯¹åº”çš„DOMå…ƒç´ å¹¶ç›´æ¥æ›´æ–°æ—¶é—´æ˜¾ç¤º
                const contactItem = document.querySelector(`[data-contact-id="${contact.id}"]`);
                if (contactItem) {
                    const timeElement = contactItem.querySelector('.contact-time');
                    if (timeElement) {
                        timeElement.textContent = newTime;
                        updateCount++;
                    }
                }
            }
        }
    });
    
}

/**
 * å¯åŠ¨è”ç³»äººæ—¶é—´å®šæ—¶æ›´æ–°å™¨
 */
function startContactTimeUpdater() {
    // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡æ—¶é—´æ˜¾ç¤º
    setInterval(updateContactListTimes, 60000); // 60ç§’ = 1åˆ†é’Ÿ
}

async function getGroupAvatarContent(group) {
    const memberAvatars = group.members.slice(0, 4).map(id => contacts.find(c => c.id === id)).filter(Boolean);
    let avatarContent = '';
    
    for (let i = 0; i < 4; i++) {
        if (i < memberAvatars.length) {
            const member = memberAvatars[i];
            const avatarHTML = await getAvatarHTML(member, 'contact');
            avatarContent += `<div class="group-avatar-item">${avatarHTML || member.name[0]}</div>`;
        } else {
            avatarContent += `<div class="group-avatar-item"></div>`;
        }
    }
    return avatarContent;
}

// --- èŠå¤©æ ¸å¿ƒé€»è¾‘ ---
async function openChat(contact) {
    // ç¡®ä¿ä»æ•°æ®åº“è·å–æœ€æ–°çš„è”ç³»äººæ•°æ®ï¼Œè§£å†³voiceIdåŒæ­¥é—®é¢˜
    try {
        const dbContact = await ensureDBReady(async () => {
            const transaction = window.db.transaction(['contacts'], 'readonly');
            const store = transaction.objectStore('contacts');

            return await promisifyRequest(store.get(contact.id), 'è·å–è”ç³»äººæ•°æ®');
        }, 'è·å–è”ç³»äººæ•°æ®');
        
        // åŒæ­¥voiceIdå’Œå…¶ä»–å­—æ®µåˆ°å†…å­˜å¯¹è±¡
        if (dbContact) {
            const fieldsToSync = ['voiceId', 'personality', 'customPrompts'];
            let syncedFields = [];
            
            for (const field of fieldsToSync) {
                if (dbContact[field] !== contact[field]) {
                    contact[field] = dbContact[field];
                    syncedFields.push(field);
                }
            }
            
        }
    } catch (error) {
        console.error('[openChat] æ•°æ®åº“åŒæ­¥å¤±è´¥ï¼Œä½¿ç”¨å†…å­˜æ•°æ®:', error);
    }
    
    currentContact = contact;
    window.currentContact = contact;
    window.memoryTableManager.setCurrentContact(contact);
    document.getElementById('chatTitle').textContent = contact.name;
    showPage('chatPage');
    
    // é‡ç½®æ¶ˆæ¯åŠ è½½çŠ¶æ€
    currentlyDisplayedMessageCount = 0; 
    
    // æ£€æŸ¥å¹¶åŠ è½½æœ€æ–°çš„æ°”æ³¡æ ·å¼ï¼ˆæ¯æ¬¡è¿›å…¥èŠå¤©éƒ½æ£€æŸ¥ï¼‰
    await loadCustomBubbleStyle();
    
    await renderMessages(true); // åˆå§‹åŠ è½½
    
    updateContextIndicator();
    const chatMessagesEl = document.getElementById('chatMessages');
    // å¤„ç†èƒŒæ™¯å›¾ç‰‡ - æ”¯æŒæ–°çš„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
    if (backgrounds[contact.id]) {
        const backgroundUrl = backgrounds[contact.id];
        if (backgroundUrl.startsWith('file:')) {
            // æ–°çš„æ–‡ä»¶å­˜å‚¨æ ¼å¼: file:fileId
            const fileId = backgroundUrl.substring(5); // ç§»é™¤ 'file:' å‰ç¼€
            if (window.ImageStorageAPI) {
                try {
                    await window.ImageStorageAPI.init();
                    const url = await window.ImageStorageAPI.getBackgroundURL(contact.id);
                    chatMessagesEl.style.backgroundImage = `url(${url})`;
                } catch (error) {
                    console.warn('è·å–èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
                    chatMessagesEl.style.backgroundImage = 'none';
                }
            } else {
                chatMessagesEl.style.backgroundImage = 'none';
            }
        } else {
            // æ—§æ ¼å¼ - ç›´æ¥ä½¿ç”¨URL
            chatMessagesEl.style.backgroundImage = `url(${backgroundUrl})`;
        }
    } else {
        chatMessagesEl.style.backgroundImage = 'none';
    }
    
    // ç§»é™¤æ—§çš„ç›‘å¬å™¨
    chatMessagesEl.onscroll = null; 
    // æ·»åŠ æ–°çš„æ»šåŠ¨ç›‘å¬å™¨
    chatMessagesEl.onscroll = () => {
        if (chatMessagesEl.scrollTop === 0 && !isLoadingMoreMessages && currentContact.messages.length > currentlyDisplayedMessageCount) {
            loadMoreMessages();
        }
    };

    toggleMemoryPanel(true);
}

function closeChatPage() {
    showPage('contactListPage');
    
    // æ¸…ç†å·¥ä½œ
    const chatMessagesEl = document.getElementById('chatMessages');
    chatMessagesEl.onscroll = null; // ç§»é™¤ç›‘å¬å™¨
    currentContact = null;
    window.currentContact = null;
    toggleEmojiPanel(true);
    closeContactSettingsPage();
    toggleMemoryPanel(true);
}

async function renderMessages(isInitialLoad = false, hasNewMessage = false) {
    if (!currentContact) return;
    const chatMessages = document.getElementById('chatMessages');
    const allMessages = currentContact.messages;
    
    // é¿å…åœ¨å¾ªç¯ä¸­é‡å¤è®¿é—®localStorage
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    // å®šä¹‰ä¸ä½¿ç”¨æ°”æ³¡æ ·å¼çš„æ¶ˆæ¯ç±»å‹
    const BUBBLE_EXCLUDED_TYPES = ['emoji', 'red_packet', 'image'];

    // æ€§èƒ½ä¼˜åŒ–ï¼šåœ¨å¾ªç¯å¼€å§‹å‰è·å–æ¨¡å‹ä¿¡æ¯ï¼Œé¿å…åœ¨å¾ªç¯ä¸­é‡å¤è°ƒç”¨
    const currentModel = await getCurrentModel();
    const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModel) || false;

    if (isInitialLoad) {
        currentlyDisplayedMessageCount = Math.min(allMessages.length, MESSAGES_PER_PAGE);
    }
    const messagesToRender = allMessages.slice(allMessages.length - currentlyDisplayedMessageCount);

    const oldScrollHeight = chatMessages.scrollHeight;
    
    chatMessages.innerHTML = '';

    if (allMessages.length > currentlyDisplayedMessageCount) {
        const loadMoreDiv = document.createElement('div');
        loadMoreDiv.className = 'load-more-messages';
        loadMoreDiv.textContent = 'åŠ è½½æ›´æ—©çš„æ¶ˆæ¯...';
        loadMoreDiv.onclick = loadMoreMessages;
        chatMessages.appendChild(loadMoreDiv);
    }
    
    if (currentContact.type === 'group') {
        const hint = document.createElement('div');
        hint.className = 'group-info-hint';
        hint.textContent = `ç¾¤èŠæˆå‘˜: ${getGroupMembersText()}`;
        chatMessages.appendChild(hint);
    }

    let lastTimestamp = null;
    for (const [index, msg] of messagesToRender.entries()) {
        const originalIndex = allMessages.length - currentlyDisplayedMessageCount + index;
        const currentMsgTime = new Date(msg.time);

        if (!lastTimestamp || currentMsgTime - lastTimestamp > 5 * 60 * 1000) {
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = formatChatTimestamp(msg.time);
            chatMessages.appendChild(timestampDiv);
            lastTimestamp = currentMsgTime;
        }

        const msgDiv = document.createElement('div');
        if (msg.role === 'system') continue;
        
        const isLastMessage = index === messagesToRender.length - 1;
        const isNewMsg = hasNewMessage && isLastMessage;
        msgDiv.className = `message ${msg.role === 'user' ? 'sent' : 'received'}${isNewMsg ? ' new-message' : ''}`;
        msgDiv.dataset.messageIndex = originalIndex;

        let contentHtml = '';
        if (msg.type === 'emoji') {
            contentHtml = await renderEmojiContent(msg.content);
        } else if (msg.type === 'red_packet') {
            const packet = JSON.parse(msg.content);
            contentHtml = `<div class="message-content red-packet" onclick="showToast('çº¢åŒ…é‡‘é¢: ${packet.amount}')"><div class="red-packet-body"><svg class="red-packet-icon" viewBox="0 0 1024 1024"><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32zM731.2 565.2H603.9c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8zM419.8 565.2H292.5c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8z" fill="#FEFEFE"></path><path d="M872.4 240H151.6c-17.7 0-32 14.3-32 32v64h784v-64c0-17.7-14.3-32-32-32z" fill="#FCD4B3"></path><path d="M512 432c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88z m0 152c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64-64z" fill="#FCD4B3"></path><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32z m-32 552H215.6V368h624.8v488z" fill="#F37666"></path><path d="M512 128c-112.5 0-204 91.5-204 204s91.5 204 204 204 204-91.5 204-204-91.5-204-204-204z m0 384c-99.4 0-180-80.6-180-180s80.6-180 180-180 180 80.6 180 180-80.6 180-180 180z" fill="#F37666"></path><path d="M512 456c-35.3 0-64 28.7-64 64s28.7 64 64 64 64 28.7 64 64-28.7-64-64-64z m16.4 76.4c-2.3 2.3-5.4 3.6-8.5 3.6h-15.8c-3.1 0-6.2-1.3-8.5-3.6s-3.6-5.4-3.6-8.5v-27.8c0-6.6 5.4-12 12-12h16c6.6 0 12 5.4 12 12v27.8c0.1 3.1-1.2 6.2-3.5 8.5z" fill="#F37666"></path></svg><div class="red-packet-text"><div>${packet.message || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼'}</div><div>é¢†å–çº¢åŒ…</div></div></div><div class="red-packet-footer">AIçº¢åŒ…</div></div>`;
        } else if (msg.type === 'image') {
            contentHtml = await renderImageContent(msg, supportsVision);
        } else {
            contentHtml = await processTextWithInlineEmojis(msg.content);
        }


        let avatarContent = '';
        if (msg.role === 'user') {
            avatarContent = await getAvatarHTML(userProfile, 'user') || (userProfile.name[0] || 'æˆ‘');
        } else {
            const sender = contacts.find(c => c.id === msg.senderId);
            if (sender) {
                avatarContent = await getAvatarHTML(sender, 'contact') || sender.name[0];
            } else {
                avatarContent = '?';
            }
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰æ°”æ³¡æ ·å¼ï¼ˆæ ¹æ®æ¶ˆæ¯è§’è‰²é€‰æ‹©ä¸åŒæ ·å¼ï¼‰
        let bubbleHtml = '';
        const currentBubbleStyle = msg.role === 'user' ? 
            (window.customBubbleStyleSelf || window.customBubbleStyle) : 
            (window.customBubbleStyleKare || window.customBubbleStyle);
            
        if (currentBubbleStyle && currentBubbleStyle.html && !BUBBLE_EXCLUDED_TYPES.includes(msg.type)) {
            // ä½¿ç”¨è‡ªå®šä¹‰æ°”æ³¡æ ·å¼ - è·å–åŸå§‹å†…å®¹ï¼Œä¸åŒ…è£… message-content
            console.log(`åº”ç”¨${msg.role === 'user' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}è‡ªå®šä¹‰æ°”æ³¡æ ·å¼`);
            
            let rawContent = '';
            if (msg.type === 'emoji') {
                rawContent = await renderEmojiContent(msg.content);
            } else if (msg.type === 'red_packet') {
                // çº¢åŒ…ä¿æŒåŸæœ‰æ ¼å¼
                rawContent = contentHtml;
            } else {
                // å¤„ç†æ–‡æœ¬ï¼Œä½†ä¸åŒ…è£… message-content
                rawContent = msg.content.replace(/\n/g, '<br>');
                
                // å¤„ç†å†…è”è¡¨æƒ…
                const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
                const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
                for (const match of emojiMatches) {
                    const fullMatch = match[0];
                    const emojiName = match[1];
                    const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                    
                    if (foundEmoji && foundEmoji.tag) {
                        const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                        rawContent = rawContent.replace(fullMatch, emojiHtml);
                    } else if (foundEmoji && foundEmoji.url) {
                        const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                        rawContent = rawContent.replace(fullMatch, replacement);
                    }
                }
            }
            
            bubbleHtml = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', rawContent);
            
            // å¤„ç†HTMLä¸­çš„file:æ ¼å¼å›¾ç‰‡
            bubbleHtml = await processFileUrlsInHtml(bubbleHtml);
            
            // æ¸…ç† HTML ä¸­çš„è½¬ä¹‰æ¢è¡Œç¬¦ï¼Œé¿å…æ˜¾ç¤º \n
            bubbleHtml = bubbleHtml.replace(/\\n/g, '');
            // console.log('ç”Ÿæˆçš„è‡ªå®šä¹‰æ°”æ³¡ HTML:', bubbleHtml);
        } else {
            // ä½¿ç”¨é»˜è®¤æ°”æ³¡æ ·å¼
            console.log('ä½¿ç”¨é»˜è®¤æ°”æ³¡æ ·å¼ï¼Œè‡ªå®šä¹‰æ ·å¼çŠ¶æ€:', {
                hasCustomStyle: !!window.customBubbleStyle,
                hasHtml: !!window.customBubbleStyle?.html
            });
            bubbleHtml = `<div class="message-bubble">${contentHtml}</div>`;
        }

        if (currentContact.type === 'group' && msg.role !== 'user') {
            const sender = contacts.find(c => c.id === msg.senderId);
            const senderName = sender ? sender.name : 'æœªçŸ¥';
            if (currentBubbleStyle && currentBubbleStyle.html && !BUBBLE_EXCLUDED_TYPES.includes(msg.type)) {
                // å¯¹äºç¾¤èŠæ¶ˆæ¯ï¼Œåœ¨è‡ªå®šä¹‰æ°”æ³¡å‰æ·»åŠ å‘é€è€…ä¿¡æ¯
                const groupHeader = `<div class="group-message-header"><div class="group-message-name">${senderName}</div></div>`;
                
                // è·å–åŸå§‹å†…å®¹ï¼ˆä¸ä¸Šé¢ç›¸åŒçš„é€»è¾‘ï¼‰
                let rawContent = '';
                if (msg.type === 'emoji') {
                    rawContent = await renderEmojiContent(msg.content);
                } else if (msg.type === 'red_packet') {
                    rawContent = contentHtml;
                } else {
                    rawContent = msg.content.replace(/\n/g, '<br>');
                    const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
                    const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
                    for (const match of emojiMatches) {
                        const fullMatch = match[0];
                        const emojiName = match[1];
                        const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                        
                        if (foundEmoji && foundEmoji.tag) {
                            const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                            rawContent = rawContent.replace(fullMatch, emojiHtml);
                        } else if (foundEmoji && foundEmoji.url) {
                            const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                            rawContent = rawContent.replace(fullMatch, replacement);
                        }
                    }
                }
                
                let customBubbleWithHeader = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', groupHeader + rawContent);
                
                // å¤„ç†HTMLä¸­çš„file:æ ¼å¼å›¾ç‰‡
                customBubbleWithHeader = await processFileUrlsInHtml(customBubbleWithHeader);
                
                // æ¸…ç† HTML ä¸­çš„è½¬ä¹‰æ¢è¡Œç¬¦ï¼Œé¿å…æ˜¾ç¤º \n
                customBubbleWithHeader = customBubbleWithHeader.replace(/\\n/g, '');
                msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${customBubbleWithHeader}`;
            } else {
                msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div><div class="message-bubble"><div class="group-message-header"><div class="group-message-name">${senderName}</div></div>${contentHtml}</div>`;
            }
        } else {
            msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${bubbleHtml}`;
        }
        
        // è°ƒè¯•ï¼šè¾“å‡ºæœ€ç»ˆçš„ HTML ç»“æ„
        // if (currentBubbleStyle && currentBubbleStyle.html) {
        //     console.log('æœ€ç»ˆæ¶ˆæ¯ HTML ç»“æ„:', msgDiv.innerHTML);
        // }
        
        // ä½¿ç”¨é¢„å…ˆè¯»å–çš„å€¼
        if (msg.isVoice && currentContact.voiceId && minimaxGroupId && minimaxApiKey) {
            // å…¼å®¹è‡ªå®šä¹‰æ°”æ³¡å’Œé»˜è®¤æ°”æ³¡
            const bubble = msgDiv.querySelector('.message-bubble') || 
                          msgDiv.querySelector('.custom-bubble-container') || 
                          msgDiv.querySelector('.chat-bubble');
            if (bubble) {
                const messageUniqueId = `${currentContact.id}-${msg.time}`; // ä½¿ç”¨æ—¶é—´æˆ³ä¿è¯å”¯ä¸€æ€§
                
                // ç»™æ°”æ³¡æ·»åŠ è¯­éŸ³æ¶ˆæ¯æ ‡è¯†
                bubble.classList.add('voice-message');
                bubble.dataset.voiceMessageId = `voice-${messageUniqueId}`;
                
                // åœ¨æ¶ˆæ¯å†…å®¹å‰æ·»åŠ è¯­éŸ³ç¬¦å·
                // ä¼˜å…ˆæŸ¥æ‰¾.message-contentï¼Œå¦‚æœæ²¡æœ‰åˆ™ç›´æ¥åœ¨æ°”æ³¡å†…æ·»åŠ 
                const textContentDiv = bubble.querySelector('.message-content') || bubble;
                if (textContentDiv && !textContentDiv.querySelector('.voice-icon')) {
                    const voiceIcon = document.createElement('span');
                    voiceIcon.className = 'voice-icon';
                    voiceIcon.innerHTML = createVoiceIcon(); // SVGéŸ³é¢‘æ³¢å½¢å›¾æ ‡
                    
                    // å°†è¯­éŸ³ç¬¦å·æ’å…¥åˆ°æ–‡æœ¬å†…å®¹çš„æœ€å‰é¢
                    if (textContentDiv === bubble) {
                        // å¦‚æœæ˜¯ç›´æ¥åœ¨æ°”æ³¡å†…ï¼Œéœ€è¦åœ¨æ–‡æœ¬èŠ‚ç‚¹å‰æ’å…¥
                        const firstTextNode = Array.from(textContentDiv.childNodes).find(node => 
                            node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ''
                        );
                        if (firstTextNode) {
                            textContentDiv.insertBefore(voiceIcon, firstTextNode);
                        } else {
                            textContentDiv.insertBefore(voiceIcon, textContentDiv.firstChild);
                        }
                    } else {
                        textContentDiv.insertBefore(voiceIcon, textContentDiv.firstChild);
                    }
                }
                
                // ç»™æ•´ä¸ªæ°”æ³¡æ·»åŠ ç‚¹å‡»äº‹ä»¶æ¥æ’­æ”¾è¯­éŸ³
                bubble.style.cursor = 'pointer';
                
                // ç§»é™¤ä»»ä½•å·²å­˜åœ¨çš„è¯­éŸ³æ’­æ”¾äº‹ä»¶ç›‘å¬å™¨
                const existingHandler = bubble._voiceClickHandler;
                if (existingHandler) {
                    bubble.removeEventListener('click', existingHandler);
                }
                
                // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å™¨
                const voiceClickHandler = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('è¯­éŸ³æ°”æ³¡è¢«ç‚¹å‡»ï¼Œå¼€å§‹æ’­æ”¾:', { text: msg.content, voiceId: currentContact.voiceId });
                    playVoiceMessage(bubble, msg.content, currentContact.voiceId);
                };
                
                // ä¿å­˜å¤„ç†å™¨å¼•ç”¨å¹¶æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                bubble._voiceClickHandler = voiceClickHandler;
                bubble.addEventListener('click', voiceClickHandler);
            }
        }


        if (isMultiSelectMode) {
            msgDiv.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleMessageSelection(originalIndex);
            });
            if (selectedMessages.has(originalIndex)) {
                msgDiv.classList.add('message-selected');
            }
        } else {
            addMessageActionListeners(msgDiv, originalIndex);
        }
        
        chatMessages.appendChild(msgDiv);
    }

    if (isInitialLoad) {
        // åªæœ‰åœ¨åˆå§‹åŒ–åŠ è½½ä¸”æ²¡æœ‰æ–°æ¶ˆæ¯æ—¶æ‰æ»šåŠ¨åˆ°åº•éƒ¨
        // è¿™æ ·å¯ä»¥é¿å…æ¯æ¬¡é‡æ–°æ¸²æŸ“éƒ½æ»šåŠ¨åˆ°é¡¶éƒ¨çš„é—®é¢˜
        if (!hasNewMessage) {
            setTimeout(() => {
                chatMessages.scrollTo({
                    top: chatMessages.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
        }
    } else {
        // éåˆå§‹åŒ–åŠ è½½æ—¶ä¿æŒå½“å‰æ»šåŠ¨ä½ç½®
        const newScrollHeight = chatMessages.scrollHeight;
        chatMessages.scrollTop = chatMessages.scrollTop + (newScrollHeight - oldScrollHeight);
    }
}


async function loadMoreMessages() {
    if (isLoadingMoreMessages) return;
    isLoadingMoreMessages = true;

    const chatMessages = document.getElementById('chatMessages');
    const loadMoreButton = chatMessages.querySelector('.load-more-messages');
    if (loadMoreButton) {
        loadMoreButton.textContent = 'æ­£åœ¨åŠ è½½...';
    }

    setTimeout(async () => {
        const allMessages = currentContact.messages;
        const newCount = Math.min(allMessages.length, currentlyDisplayedMessageCount + MESSAGES_PER_PAGE);
        
        if (newCount > currentlyDisplayedMessageCount) {
            currentlyDisplayedMessageCount = newCount;
            await renderMessages(false); // é‡æ–°æ¸²æŸ“ï¼Œéåˆå§‹åŠ è½½
        }
        
        isLoadingMoreMessages = false;
    }, 500);
}

function getGroupMembersText() {
    if (!currentContact || currentContact.type !== 'group') return '';
    return currentContact.members.map(id => contacts.find(c => c.id === id)?.name || 'æœªçŸ¥').join('ã€');
}

async function sendUserMessage() {
    if (!currentContact) return;
    const input = document.getElementById('chatInput');
    const content = input.value.trim();
    if (!content) return;
    const userMessage = { role: 'user', content, type: 'text', time: new Date().toISOString(), senderId: 'user' };
    currentContact.messages.push(userMessage);
    
    // å¦‚æœæ¶ˆæ¯æ€»æ•°è¶…è¿‡äº†å½“å‰æ˜¾ç¤ºçš„æ¡æ•°ï¼Œå¢åŠ æ˜¾ç¤ºæ¡æ•°ä»¥åŒ…å«æ–°æ¶ˆæ¯
    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
        currentlyDisplayedMessageCount++;
    }

    currentContact.lastMessage = content;
    currentContact.lastTime = formatContactListTime(new Date().toISOString());
    input.value = '';
    input.style.height = 'auto';
    await addSingleMessage(userMessage, true); // å•ç‹¬æ·»åŠ ç”¨æˆ·æ¶ˆæ¯ï¼Œä½¿ç”¨åŠ¨ç”»
    await renderContactList();
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    window.UIManager.safeFocus(input);
}

async function sendMessage() {
    if (!currentContact) return;
    const input = document.getElementById('chatInput');
    const content = input.value.trim();
    if (content) await sendUserMessage();
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
        return;
    }
    if (currentContact.messages.length === 0 && !content) return;
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.disabled = true;
    try {
        if (currentContact.type === 'group') {
            await sendGroupMessage();
        } else {
            showTypingIndicator();
            const { replies } = await callChatAPIWithPriority(currentContact, [], true);
            hideTypingIndicator();
            
            // å¼‚æ­¥æ›´æ–°è®°å¿†è¡¨æ ¼ï¼ˆä½¿ç”¨APIé˜Ÿåˆ—ï¼Œä¸é˜»å¡ç”¨æˆ·æ“ä½œï¼‰
            if (window.updateMemoryTableWithSecondaryModel) {
                window.updateMemoryTableWithSecondaryModel(currentContact, true);
            }
            if (!replies || replies.length === 0) { showTopNotification('AIæ²¡æœ‰è¿”å›æœ‰æ•ˆå›å¤'); return; }
            
            // æ‰¹é‡å¤„ç†AIå›å¤ï¼Œé¿å…æ¯æ¡æ¶ˆæ¯éƒ½é‡æ–°æ¸²æŸ“
            for (let i = 0; i < replies.length; i++) {
                const response = replies[i];
                const isLastReply = i === replies.length - 1;
                
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
                
                let rawMessageContent = removeThinkingChain(response.content);
                const voiceParsed = parseVoiceMessage(rawMessageContent);

                const aiMessage = { 
                    role: 'assistant', 
                    content: voiceParsed.content,
                    type: response.type, 
                    time: new Date().toISOString(), 
                    senderId: currentContact.id,
                    isVoice: voiceParsed.isVoice
                };

                currentContact.messages.push(aiMessage);
                if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                    currentlyDisplayedMessageCount++;
                }
                
                // å•ç‹¬æ·»åŠ è¿™æ¡æ–°æ¶ˆæ¯ï¼Œè€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªç•Œé¢
                await addSingleMessage(aiMessage, true); // trueè¡¨ç¤ºè¿™æ˜¯AIå›å¤çš„æ–°æ¶ˆæ¯
                
                // åªåœ¨æœ€åä¸€æ¡æ¶ˆæ¯æ—¶æ›´æ–°è”ç³»äººåˆ—è¡¨å’Œä¿å­˜æ•°æ®
                if (isLastReply) {
                    currentContact.lastMessage = response.type === 'text' ? response.content.substring(0, 20) + '...' : (response.type === 'emoji' ? '[è¡¨æƒ…]' : '[çº¢åŒ…]');
                    currentContact.lastTime = formatContactListTime(new Date().toISOString());
                    await renderContactList();
                    await saveDataToDB();
                }
            }
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°è®°å¿†ï¼ˆæ–°é€»è¾‘ï¼šç”¨æˆ·å‘é€2æ¡æ¶ˆæ¯å°±è§¦å‘ï¼‰
            
            if (window.characterMemoryManager && window.contacts && Array.isArray(window.contacts)) {
                try {
                    await window.characterMemoryManager.checkAndUpdateMemory(currentContact.id, currentContact);
                } catch (error) {
                    console.error('æ£€æŸ¥æ›´æ–°è®°å¿†å¤±è´¥:', error);
                }
            } else {
            }
        }
    } catch (error) {
        console.error('å‘é€æ¶ˆæ¯é”™è¯¯:', error);
        console.error('é”™è¯¯è¯¦æƒ…:', {
            name: error.name,
            message: error.message,
            timestamp: new Date().toISOString(),
            url: window.location.href
        });
        // APIé”™è¯¯å·²åœ¨callAPIå†…éƒ¨å¤„ç†ï¼Œè¿™é‡Œåªéœ€è¦æ¸…ç†UIçŠ¶æ€
        hideTypingIndicator();
    } finally {
        sendBtn.disabled = false;
    }
}

// === èŠå¤©å›¾ç‰‡å‘é€åŠŸèƒ½ ===

/**
 * è§¦å‘å›¾ç‰‡ä¸Šä¼ é€‰æ‹©
 */
function triggerImageUpload() {
    const chatImageInput = document.getElementById('chatImageInput');
    if (chatImageInput) {
        chatImageInput.click();
    }
}

/**
 * å¤„ç†èŠå¤©å›¾ç‰‡ä¸Šä¼ 
 * @param {Event} event - æ–‡ä»¶é€‰æ‹©äº‹ä»¶
 */
async function handleChatImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        // æ£€æŸ¥æ–‡ä»¶ç±»å‹
        if (!file.type.startsWith('image/')) {
            showToast('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
            return;
        }

        // æ£€æŸ¥æ–‡ä»¶å¤§å° (10MB)
        const maxSize = 10 * 1024 * 1024;
        if (file.size > maxSize) {
            showToast('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB', 'error');
            return;
        }

        // æ˜¾ç¤ºä¸Šä¼ è¿›åº¦
        showToast('æ­£åœ¨ä¸Šä¼ å›¾ç‰‡...', 'info');

        // ç”Ÿæˆå”¯ä¸€çš„å›¾ç‰‡ID - ä½¿ç”¨crypto.randomUUID()æé«˜å¥å£®æ€§
        const imageId = `chat_img_${crypto.randomUUID()}`;

        // å­˜å‚¨å›¾ç‰‡åˆ°æ–‡ä»¶ç³»ç»Ÿ - ä½¿ç”¨UnifiedDBManager
        const result = await window.unifiedDB.storeFile(file, {
            type: 'chat_image',
            imageId: imageId
        });

        // åˆ›å»ºæ–‡ä»¶å¼•ç”¨
        await window.unifiedDB.createFileReference(
            result.fileId,
            'chat_image',
            imageId,
            {
                storedAt: new Date().toISOString(),
                fileName: file.name,
                fileSize: file.size
            }
        );

        // è®¾ç½®å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ® - ä½¿ç”¨ç»Ÿä¸€çš„generalåˆ†ç±»
        await window.unifiedDB.setImageUsageMetadata(result.fileId, 'general', {
            category: 'chat',
            tags: ['èŠå¤©å›¾ç‰‡', getCurrentContactId()],
            size: file.size,
            fileName: file.name,
            createdAt: new Date().toISOString()
        });

        // å‘é€å›¾ç‰‡æ¶ˆæ¯
        await sendImageMessage(imageId, result.fileId, file.name);

        // æ£€æµ‹å½“å‰æ¨¡å‹æ˜¯å¦æ”¯æŒå›¾åƒï¼Œæ˜¾ç¤ºç›¸åº”æç¤º
        const currentModel = await getCurrentModel();
        const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModel) || false;
        if (supportsVision) {
            showToast(`ğŸ–¼ï¸ ${currentModel} æ”¯æŒå›¾åƒåˆ†æï¼ŒAIå¯ä»¥çœ‹åˆ°å›¾ç‰‡å†…å®¹`, 'success');
        } else {
            showToast(`ğŸ“ ${currentModel} ä¸æ”¯æŒå›¾åƒåˆ†æï¼ŒAIå°†çœ‹åˆ°æ–‡å­—æè¿°`, 'warning');
        }

    } catch (error) {
        console.error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥:', error);
        showToast('å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'), 'error');
    } finally {
        // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
        event.target.value = '';
    }
}

/**
 * æ˜¾ç¤ºå›¾ç‰‡å¤„ç†é”™è¯¯çš„æç¤º
 * @param {string} fileName - æ–‡ä»¶å
 * @param {string} errorMessage - é”™è¯¯ä¿¡æ¯
 */
function showImageProcessingError(fileName, errorMessage) {
    showToast(`å›¾ç‰‡å¤„ç†å¤±è´¥: ${fileName} - ${errorMessage}`, 'error');
}

// å°†å‡½æ•°æš´éœ²åˆ°å…¨å±€ï¼Œä¾›PromptBuilderä½¿ç”¨
window.showImageProcessingError = showImageProcessingError;

/**
 * ç”Ÿæˆå›¾ç‰‡æ¶ˆæ¯çš„æ˜¾ç¤ºå†…å®¹
 * @param {string} fileName - æ–‡ä»¶å
 * @returns {string} - æ ¼å¼åŒ–çš„å›¾ç‰‡æ¶ˆæ¯å†…å®¹
 */
function formatImageMessageContent(fileName) {
    return `[å›¾ç‰‡: ${fileName}]`;
}

/**
 * å‘é€å›¾ç‰‡æ¶ˆæ¯
 * @param {string} imageId - å›¾ç‰‡ID
 * @param {string} fileId - æ–‡ä»¶ID
 * @param {string} fileName - æ–‡ä»¶å
 */
async function sendImageMessage(imageId, fileId, fileName) {
    const currentContact = getCurrentContact();
    if (!currentContact) {
        throw new Error('æœªé€‰æ‹©è”ç³»äºº');
    }

    // ç”Ÿæˆä¸€è‡´çš„å›¾ç‰‡æ¶ˆæ¯å†…å®¹
    const messageContent = formatImageMessageContent(fileName);

    // åˆ›å»ºå›¾ç‰‡æ¶ˆæ¯å¯¹è±¡ - ä½¿ç”¨crypto.randomUUID()ç”Ÿæˆæ›´å¥å£®çš„ID
    const imageMessage = {
        id: `msg_${crypto.randomUUID()}`,
        type: 'image',
        content: messageContent,
        imageId: imageId,
        fileId: fileId,
        fileName: fileName,
        time: new Date().toISOString(), // ä½¿ç”¨ time å­—æ®µè€Œä¸æ˜¯ timestamp
        role: 'user' // ä½¿ç”¨ role å­—æ®µè€Œä¸æ˜¯ sender
    };

    // æ·»åŠ åˆ°èŠå¤©è®°å½•
    if (!currentContact.messages) {
        currentContact.messages = [];
    }
    currentContact.messages.push(imageMessage);

    // æ›´æ–°è”ç³»äººçš„æœ€åæ¶ˆæ¯ä¿¡æ¯ - ä½¿ç”¨ç›¸åŒçš„å†…å®¹ç¡®ä¿ä¸€è‡´æ€§
    currentContact.lastMessage = messageContent;
    currentContact.lastTime = formatContactListTime(imageMessage.time);

    // ä¿å­˜åˆ°æ•°æ®åº“
    await saveDataToDB();

    // åˆ·æ–°èŠå¤©æ˜¾ç¤º
    await renderMessages(false, true); // æ ‡è®°ä¸ºæ–°æ¶ˆæ¯

    // åˆ·æ–°è”ç³»äººåˆ—è¡¨
    await renderContactList();

    console.log('å›¾ç‰‡æ¶ˆæ¯å‘é€æˆåŠŸ:', imageMessage);
}

/**
 * è·å–å½“å‰è”ç³»äººID
 */
function getCurrentContactId() {
    const currentContact = getCurrentContact();
    return currentContact ? currentContact.id : 'unknown';
}

/**
 * è·å–å½“å‰è”ç³»äºº
 */
function getCurrentContact() {
    return window.currentContact || null;
}

/**
 * æ¸²æŸ“å›¾ç‰‡æ¶ˆæ¯å†…å®¹
 * @param {Object} msg - å›¾ç‰‡æ¶ˆæ¯å¯¹è±¡
 */
async function renderImageContent(msg, supportsVision = false) {
    try {
        // è·å–å›¾ç‰‡URL
        let imageUrl = '';
        
        if (msg.fileId) {
            // æ–°çš„æ–‡ä»¶ç³»ç»Ÿæ ¼å¼ - ä»æ–‡ä»¶IDè·å–URL
            const reference = await window.unifiedDB.getFileReference('chat_image', msg.imageId);
            if (reference && reference.fileId) {
                imageUrl = await window.unifiedDB.createFileURL(reference.fileId);
            }
        }

        if (!imageUrl) {
            // å›é€€ï¼šæ˜¾ç¤ºå ä½ç¬¦
            return `
                <div class="message-content chat-image-placeholder">
                    <div class="image-placeholder">
                        <span>ğŸ“·</span>
                        <div>å›¾ç‰‡åŠ è½½å¤±è´¥</div>
                    </div>
                </div>
            `;
        }

    // ä½¿ç”¨ä¼ å…¥çš„ supportsVision å‚æ•°ï¼Œé¿å…é‡å¤è°ƒç”¨ getCurrentModel
    const visionIndicator = supportsVision ? '<div class="vision-support-indicator">âœ“</div>' : '';

        // ç”Ÿæˆå›¾ç‰‡HTML
        return `
            <div class="message-content chat-image">
                <div class="image-container">
                    <img src="${imageUrl}" 
                         alt="${msg.fileName || 'èŠå¤©å›¾ç‰‡'}" 
                         class="chat-image-content"
                         onclick="showImagePreview('${imageUrl}', '${msg.fileName || 'èŠå¤©å›¾ç‰‡'}')"
                         onerror="const errDiv = document.createElement('div'); errDiv.className = 'image-error'; errDiv.textContent = 'ğŸ“· å›¾ç‰‡åŠ è½½å¤±è´¥'; this.parentElement.replaceWith(errDiv);"
                         loading="lazy">
                    ${visionIndicator}
                </div>
            </div>
        `;

    } catch (error) {
        console.error('æ¸²æŸ“å›¾ç‰‡æ¶ˆæ¯å¤±è´¥:', error);
        return `
            <div class="message-content chat-image-error">
                <span>ğŸ“·</span>
                <div>å›¾ç‰‡æ˜¾ç¤ºå‡ºé”™</div>
            </div>
        `;
    }
}

async function sendGroupMessage() {
    if (!currentContact || currentContact.type !== 'group') return;
    
    showTypingIndicator();
    try {
        // ä¸€æ¬¡æ€§è°ƒç”¨APIè·å–æ‰€æœ‰ç¾¤æˆå‘˜çš„å›å¤
        const { replies } = await callChatAPIWithPriority(currentContact, [], true);
        hideTypingIndicator();
        
        if (!replies || replies.length === 0) {
            showTopNotification('ç¾¤èŠAIæ²¡æœ‰è¿”å›æœ‰æ•ˆå›å¤');
            return;
        }
        
        // è§£æJSONæ ¼å¼çš„ç¾¤èŠå›å¤
        let groupMessages = [];
        try {
            // å‡è®¾ç¬¬ä¸€ä¸ªreplyåŒ…å«æ‰€æœ‰ç¾¤æˆå‘˜çš„å›å¤
            const firstReply = replies[0];
            let responseText = removeThinkingChain(firstReply.content);
            
            // å°è¯•è§£æJSONæ ¼å¼çš„å›å¤ï¼ˆæ”¯æŒçº¯JSONã€Markdownä»£ç å—ç­‰æ ¼å¼ï¼‰
            if (responseText.includes('{') && responseText.includes('}')) {
                try {
                    // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
                    const cleanedJson = window.apiService.extractJSON(responseText);
                    const parsedResponse = JSON.parse(cleanedJson);
                    
                    if (parsedResponse.messages && Array.isArray(parsedResponse.messages)) {
                        groupMessages = parsedResponse.messages;
                    }
                } catch (jsonError) {
                    console.error('ç¾¤èŠJSONæå–å¤±è´¥:', jsonError);
                    
                    // ç»§ç»­ä½¿ç”¨åŸæœ‰é€»è¾‘ä½œä¸ºå¤‡ç”¨
                    const jsonStart = responseText.indexOf('{');
                    const jsonEnd = responseText.lastIndexOf('}') + 1;
                    const jsonText = responseText.substring(jsonStart, jsonEnd);
                    
                    const parsedResponse = JSON.parse(jsonText);
                    if (parsedResponse.messages && Array.isArray(parsedResponse.messages)) {
                        groupMessages = parsedResponse.messages;
                    }
                }
            }
        } catch (error) {
            console.error('è§£æç¾¤èŠJSONå›å¤å¤±è´¥:', error);
            console.error('é”™è¯¯è¯¦æƒ…:', {
                error: error.message,
                firstReply: replies[0],
                repliesLength: replies.length
            });
            // æ˜¾ç¤ºå…·ä½“çš„é”™è¯¯ä¿¡æ¯è€Œä¸æ˜¯æ³›æ³›çš„"æ— æ³•è§£æAPIå›å¤"
            showTopNotification(`æ— æ³•è§£æAPIå›å¤: ${error.message}`);
            return;
        }
        
        if (groupMessages.length === 0) {
            showTopNotification('æœªèƒ½è§£æå‡ºæœ‰æ•ˆçš„ç¾¤èŠå›å¤');
            return;
        }
        
        // é€ä¸ªæ˜¾ç¤ºç¾¤æˆå‘˜çš„å‘è¨€
        for (let i = 0; i < groupMessages.length; i++) {
            const message = groupMessages[i];
            
            // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜
            const member = contacts.find(c => c.name === message.speaker && currentContact.members.includes(c.id));
            if (!member) {
                console.warn(`æœªæ‰¾åˆ°ç¾¤æˆå‘˜: ${message.speaker}`);
                continue;
            }
            
            await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
            
            const voiceParsed = parseVoiceMessage(message.content);
            
            const aiMessage = {
                role: 'assistant',
                content: voiceParsed.content,
                type: 'text',
                time: new Date().toISOString(),
                senderId: member.id,
                isVoice: voiceParsed.isVoice
            };
            
            currentContact.messages.push(aiMessage);
            if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                currentlyDisplayedMessageCount++;
            }
            
            // å•ç‹¬æ·»åŠ ç¾¤æˆå‘˜æ¶ˆæ¯
            await addSingleMessage(aiMessage, true);
            
            // å¼‚æ­¥æ›´æ–°è¯¥æˆå‘˜çš„è®°å¿†
            if (window.characterMemoryManager) {
                setTimeout(async () => {
                    try {
                        await window.characterMemoryManager.checkAndUpdateMemory(member.id, currentContact);
                    } catch (error) {
                        console.error(`ç¾¤èŠæˆå‘˜è®°å¿†æ›´æ–°å¤±è´¥ - ${member.name}:`, error);
                    }
                }, 1000);
            }
        }
        
        // æ›´æ–°ç¾¤èŠæœ€åæ¶ˆæ¯å’Œæ—¶é—´
        if (groupMessages.length > 0) {
            const lastMessage = groupMessages[groupMessages.length - 1];
            currentContact.lastMessage = `${lastMessage.speaker}: ${lastMessage.content.substring(0, 15)}...`;
            currentContact.lastTime = formatContactListTime(new Date().toISOString());
            await renderContactList();
            await saveDataToDB();
        }
        
    } catch (error) {
        console.error('ç¾¤èŠæ¶ˆæ¯å‘é€é”™è¯¯:', error);
        console.error('ç¾¤èŠé”™è¯¯è¯¦æƒ…:', {
            groupInfo: {
                id: currentContact.id,
                name: currentContact.name,
                membersCount: currentContact.members ? currentContact.members.length : 0
            },
            errorName: error.name,
            errorMessage: error.message,
            timestamp: new Date().toISOString()
        });
        hideTypingIndicator();
        showTopNotification(`ç¾¤èŠå›å¤å¤±è´¥: ${error.message}`);
    }
}

async function showTypingIndicator(contact = null) {
    const chatMessages = document.getElementById('chatMessages');
    let indicator = document.getElementById('typingIndicator');
    if (indicator) indicator.remove();
    indicator = document.createElement('div');
    indicator.className = 'message received';
    indicator.id = 'typingIndicator';
    chatMessages.appendChild(indicator);
    const displayContact = contact || currentContact;
    
    let avatarContent = '';
    if (displayContact) {
        avatarContent = await getAvatarHTML(displayContact, 'contact') || displayContact.name[0];
    }
    
    indicator.innerHTML = `<div class="message-avatar">${avatarContent}</div><div class="message-bubble"><div class="typing-indicator"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div></div>`;
    // å»¶æ—¶æ»šåŠ¨ï¼Œè®©æ‰“å­—æŒ‡ç¤ºå™¨çš„åŠ¨ç”»å…ˆå¼€å§‹
    setTimeout(() => {
        chatMessages.scrollTo({
            top: chatMessages.scrollHeight,
            behavior: 'smooth'
        });
    }, 100); // ç¨å¾®å»¶é•¿å»¶æ—¶ï¼Œè®©åŠ¨ç”»æ›´æ˜æ˜¾
}

function hideTypingIndicator() {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) indicator.remove();
}

/**
 * å•ç‹¬æ·»åŠ ä¸€æ¡æ–°æ¶ˆæ¯ï¼Œè€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©ç•Œé¢
 */
async function addSingleMessage(message, isNewMessage = false) {
    const chatMessages = document.getElementById('chatMessages');
    
    // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
    const msgDiv = document.createElement('div');
    if (message.role === 'system') return;
    
    msgDiv.className = `message ${message.role === 'user' ? 'sent' : 'received'}${isNewMessage ? ' new-message' : ''}`;
    // è®¾ç½®æ­£ç¡®çš„æ¶ˆæ¯ç´¢å¼•
    const messageIndex = currentContact.messages.findIndex(m => m === message);
    msgDiv.dataset.messageIndex = messageIndex >= 0 ? messageIndex : currentContact.messages.length - 1;

    let contentHtml = '';
    if (message.type === 'emoji') {
        contentHtml = await renderEmojiContent(message.content);
    } else if (message.type === 'red_packet') {
        const packet = JSON.parse(message.content);
        contentHtml = `<div class="message-content red-packet" onclick="showToast('çº¢åŒ…é‡‘é¢: ${packet.amount}')"><div class="red-packet-body"><svg class="red-packet-icon" viewBox="0 0 1024 1024"><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32zM731.2 565.2H603.9c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8zM419.8 565.2H292.5c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8z" fill="#FEFEFE"></path><path d="M872.4 240H151.6c-17.7 0-32 14.3-32 32v64h784v-64c0-17.7-14.3-32-32-32z" fill="#FCD4B3"></path><path d="M512 432c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88z m0 152c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64-64z" fill="#FCD4B3"></path><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32z m-32 552H215.6V368h624.8v488z" fill="#F37666"></path><path d="M512 128c-112.5 0-204 91.5-204 204s91.5 204 204 204 204-91.5 204-204-91.5-204-204-204z m0 384c-99.4 0-180-80.6-180-180s80.6-180 180-180 180 80.6 180 180-80.6 180-180 180z" fill="#F37666"></path><path d="M512 456c-35.3 0-64 28.7-64 64s28.7 64 64 64 64 28.7 64 64-28.7-64-64-64z m16.4 76.4c-2.3 2.3-5.4 3.6-8.5 3.6h-15.8c-3.1 0-6.2-1.3-8.5-3.6s-3.6-5.4-3.6-8.5v-27.8c0-6.6 5.4-12 12-12h16c6.6 0 12 5.4 12 12v27.8c0.1 3.1-1.2 6.2-3.5 8.5z" fill="#F37666"></path></svg><div class="red-packet-text"><div>${packet.message || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼'}</div><div>é¢†å–çº¢åŒ…</div></div></div><div class="red-packet-footer">AIçº¢åŒ…</div></div>`;
    } else {
        contentHtml = await processTextWithInlineEmojis(message.content);
    }

    let avatarContent = '';
    if (message.role === 'assistant') {
        if (currentContact.type === 'group') {
            // ä¿®å¤ï¼šä»contactsæ•°ç»„ä¸­æŸ¥æ‰¾æˆå‘˜ï¼Œè€Œä¸æ˜¯ä»membersæ•°ç»„ï¼ˆmembersåªå­˜å‚¨IDï¼‰
            const member = contacts.find(c => c.id === message.senderId);
            avatarContent = member ? (await getAvatarHTML(member, 'contact') || member.name[0]) : 'ğŸ¤–';
        } else {
            avatarContent = await getAvatarHTML(currentContact, 'contact') || currentContact.name[0];
        }
    } else {
        avatarContent = await getAvatarHTML(userProfile, 'user') || userProfile?.name?.[0] || 'æˆ‘';
    }

    // åº”ç”¨è‡ªå®šä¹‰æ°”æ³¡æ ·å¼ï¼ˆä¸renderMessagesä¸­çš„é€»è¾‘ä¿æŒä¸€è‡´ï¼‰
    const currentBubbleStyle = message.role === 'user' ? 
        (window.customBubbleStyleSelf || window.customBubbleStyle) : 
        (window.customBubbleStyleKare || window.customBubbleStyle);
        
    let bubbleHtml = '';
    if (currentBubbleStyle && currentBubbleStyle.html && message.type !== 'emoji' && message.type !== 'red_packet') {
        // ä½¿ç”¨è‡ªå®šä¹‰æ°”æ³¡æ ·å¼ - è·å–åŸå§‹å†…å®¹ï¼Œä¸åŒ…è£… message-content
        console.log(`åº”ç”¨${message.role === 'user' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}è‡ªå®šä¹‰æ°”æ³¡æ ·å¼`);
        
        let rawContent = '';
        if (message.type === 'emoji') {
            rawContent = await renderEmojiContent(message.content);
        } else if (message.type === 'red_packet') {
            // çº¢åŒ…ä¿æŒåŸæœ‰æ ¼å¼
            rawContent = contentHtml;
        } else {
            // å¤„ç†æ–‡æœ¬ï¼Œä½†ä¸åŒ…è£… message-content
            rawContent = message.content.replace(/\n/g, '<br>');
            
            // å¤„ç†å†…è”è¡¨æƒ…
            const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
            const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
            for (const match of emojiMatches) {
                const fullMatch = match[0];
                const emojiName = match[1];
                const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                
                if (foundEmoji && foundEmoji.tag) {
                    const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                    rawContent = rawContent.replace(fullMatch, emojiHtml);
                } else if (foundEmoji && foundEmoji.url) {
                    const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                    rawContent = rawContent.replace(fullMatch, replacement);
                }
            }
        }
        
        bubbleHtml = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', rawContent);
        
        // å¤„ç†HTMLä¸­çš„file:æ ¼å¼å›¾ç‰‡
        bubbleHtml = await processFileUrlsInHtml(bubbleHtml);
        
        // æ¸…ç† HTML ä¸­çš„è½¬ä¹‰æ¢è¡Œç¬¦ï¼Œé¿å…æ˜¾ç¤º \n
        bubbleHtml = bubbleHtml.replace(/\\n/g, '');
        // console.log('ç”Ÿæˆçš„è‡ªå®šä¹‰æ°”æ³¡ HTML:', bubbleHtml);
    } else {
        // ä½¿ç”¨é»˜è®¤æ°”æ³¡æ ·å¼
        console.log('ä½¿ç”¨é»˜è®¤æ°”æ³¡æ ·å¼ï¼Œè‡ªå®šä¹‰æ ·å¼çŠ¶æ€:', {
            hasCustomStyle: !!window.customBubbleStyle,
            hasHtml: !!window.customBubbleStyle?.html
        });
        bubbleHtml = `<div class="message-bubble">${contentHtml}</div>`;
    }

    if (currentContact.type === 'group' && message.role === 'assistant') {
        // ä¿®å¤ï¼šä»contactsæ•°ç»„ä¸­æŸ¥æ‰¾æˆå‘˜
        const member = contacts.find(c => c.id === message.senderId);
        const memberName = member ? member.name : 'æœªçŸ¥æˆå‘˜';
        
        if (currentBubbleStyle && currentBubbleStyle.html && message.type !== 'emoji' && message.type !== 'red_packet') {
            // å¯¹äºç¾¤èŠæ¶ˆæ¯ï¼Œåœ¨è‡ªå®šä¹‰æ°”æ³¡å‰æ·»åŠ å‘é€è€…ä¿¡æ¯
            const groupHeader = `<div class="group-message-header"><div class="group-message-name">${memberName}</div></div>`;
            
            // è·å–åŸå§‹å†…å®¹ï¼ˆä¸ä¸Šé¢ç›¸åŒçš„é€»è¾‘ï¼‰
            let rawContent = '';
            if (message.type === 'emoji') {
                rawContent = await renderEmojiContent(message.content);
            } else if (message.type === 'red_packet') {
                rawContent = contentHtml;
            } else {
                rawContent = message.content.replace(/\n/g, '<br>');
                const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
                const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
                for (const match of emojiMatches) {
                    const fullMatch = match[0];
                    const emojiName = match[1];
                    const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                    
                    if (foundEmoji && foundEmoji.tag) {
                        const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                        rawContent = rawContent.replace(fullMatch, emojiHtml);
                    } else if (foundEmoji && foundEmoji.url) {
                        const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                        rawContent = rawContent.replace(fullMatch, replacement);
                    }
                }
            }
            
            let customBubbleWithHeader = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', groupHeader + rawContent);
            
            // å¤„ç†HTMLä¸­çš„file:æ ¼å¼å›¾ç‰‡
            customBubbleWithHeader = await processFileUrlsInHtml(customBubbleWithHeader);
            
            // æ¸…ç† HTML ä¸­çš„è½¬ä¹‰æ¢è¡Œç¬¦ï¼Œé¿å…æ˜¾ç¤º \n
            customBubbleWithHeader = customBubbleWithHeader.replace(/\\n/g, '');
            msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${customBubbleWithHeader}`;
        } else {
            msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div><div class="message-bubble"><div class="group-message-header"><div class="group-message-name">${memberName}</div></div>${contentHtml}</div>`;
        }
    } else {
        msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${bubbleHtml}`;
    }

    // æ·»åŠ é•¿æŒ‰äº‹ä»¶ç›‘å¬å™¨ - ä¿®å¤æ–°æ¶ˆæ¯æ— æ³•é•¿æŒ‰å¼¹å‡ºèœå•çš„é—®é¢˜
    if (!isMultiSelectMode) {
        const originalIndex = parseInt(msgDiv.dataset.messageIndex);
        addMessageActionListeners(msgDiv, originalIndex);
    }

    // æ·»åŠ åˆ°èŠå¤©ç•Œé¢
    chatMessages.appendChild(msgDiv);

    // å¤„ç†è¯­éŸ³æ¶ˆæ¯UI
    setupVoiceMessageUI(msgDiv, message, currentContact);

    // åªæœ‰æ–°æ¶ˆæ¯æ‰æ»šåŠ¨åˆ°åº•éƒ¨ï¼Œé¿å…æ¯æ¬¡æ·»åŠ æ¶ˆæ¯éƒ½é‡æ–°æ»šåŠ¨
    if (isNewMessage) {
        setTimeout(() => {
            chatMessages.scrollTo({
                top: chatMessages.scrollHeight,
                behavior: 'smooth'
            });
        }, 150); // æ–°æ¶ˆæ¯å»¶æ—¶150msï¼Œè®©æ»‘å…¥åŠ¨ç”»æ›´æ˜æ˜¾
    }
}

/**
 * æ£€æµ‹æ¶ˆæ¯æ•°ç»„ä¸­æ˜¯å¦åŒ…å«å›¾åƒæ¶ˆæ¯
 * @param {array} messages - æ¶ˆæ¯æ•°ç»„
 * @returns {boolean} æ˜¯å¦åŒ…å«å›¾åƒæ¶ˆæ¯
 */
function _hasImageMessages(messages) {
    return messages.some(msg => 
        Array.isArray(msg.content) && 
        msg.content.some(part => part.type === 'image_url')
    );
}

/**
 * é€šè¿‡æˆ‘ä»¬çš„ Netlify Function ä»£ç†æ¥è°ƒç”¨ APIã€‚
 * @param {object} contact The contact object.
 * @param {array} turnContext Additional messages for group chat context.
 * @returns {object} The API response containing replies and the new memory table.
 */
async function callAPI(contact, turnContext = []) {
    try {
        // è·å–å®Œæ•´APIè°ƒç”¨ä¿¡æ¯ï¼ˆåŒ…å«æ¨¡å‹ï¼‰
        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            throw new Error('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
        }

        // 1. æ£€æµ‹å½“å‰æ¨¡å‹æ˜¯å¦æ”¯æŒå›¾åƒ
        const currentModelForVision = await getCurrentModel();
        const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModelForVision) || false;
        console.log(`[callAPI] å½“å‰æ¨¡å‹ ${currentModelForVision} å›¾åƒæ”¯æŒ: ${supportsVision}`);

        // 2. æ„å»ºç³»ç»Ÿæç¤ºè¯
        const systemPrompt = await window.promptBuilder.buildChatPrompt(
            contact,
            userProfile,
            currentContact,
            apiCallInfo,
            emojis,
            window,
            turnContext
        );

        // 3. æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆç°åœ¨æ”¯æŒå›¾åƒï¼‰
        const messages = [{ role: 'system', content: systemPrompt }];
        const messageHistory = await window.promptBuilder.buildMessageHistory(
            currentContact,
            apiCallInfo,
            userProfile,
            contacts,
            contact,
            emojis,
            turnContext,
            supportsVision // ä¼ é€’å›¾åƒæ”¯æŒæ ‡å¿—
        );

        messages.push(...messageHistory);

        // 4. å¦‚æœæ¨¡å‹ä¸æ”¯æŒå›¾åƒä½†æ¶ˆæ¯ä¸­åŒ…å«å›¾åƒï¼Œè®°å½•è­¦å‘Š
        if (!supportsVision && _hasImageMessages(messageHistory)) {
            console.warn('[callAPI] å½“å‰æ¨¡å‹ä¸æ”¯æŒå›¾åƒåˆ†æï¼Œå›¾ç‰‡æ¶ˆæ¯å·²è½¬ä¸ºæ–‡æœ¬æè¿°');
        }

        // 5. è°ƒç”¨API
        console.log(`[å¤škeyè°ƒè¯•] callAPIè¢«è°ƒç”¨ï¼Œå½“å‰ä½¿ç”¨çš„API Key: ${apiCallInfo.key ? apiCallInfo.key.substring(0, 10) + '...' : 'null'}`);

        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            messages,
            {},
            (apiCallInfo.timeout || 60) * 1000
        );
        

        // 4. å¤„ç†å“åº”
        if (!data) {
            throw new Error('APIè¿”å›æ•°æ®ä¸ºç©º');
        }

        let fullResponseText;
        if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
            // æ ‡å‡†OpenAIæ ¼å¼
            fullResponseText = data.choices[0].message.content;
        } else if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0]) {
            // Gemini API æ ¼å¼
            fullResponseText = data.candidates[0].content.parts[0].text;
        } else if (data.content) {
            // å¯èƒ½çš„æ›¿ä»£æ ¼å¼
            fullResponseText = data.content;
        } else if (data.message) {
            // å¦ä¸€ç§å¯èƒ½çš„æ ¼å¼
            fullResponseText = data.message;
        } else {
            // æ£€æŸ¥æ˜¯å¦æ˜¯å› ä¸ºæ²¡æœ‰ç”Ÿæˆå†…å®¹
            if (data.choices && data.choices[0] && data.choices[0].finish_reason === 'content_filter') {
                throw new Error('AIæ¨¡å‹æ²¡æœ‰ç”Ÿæˆå›å¤ï¼Œå¯èƒ½æ˜¯å†…å®¹è¢«è¿‡æ»¤ï¼Œè¯·æ£€æŸ¥è¾“å…¥æˆ–ç¨åé‡è¯•');
            }
            console.error('APIå“åº”æ ¼å¼ä¸æ”¯æŒ:', data);
            throw new Error('APIå“åº”æ ¼å¼ä¸æ”¯æŒï¼Œæ— æ³•æå–å›å¤å†…å®¹');
        }

        // æ£€æŸ¥å†…å®¹æ˜¯å¦æœ‰æ•ˆ
        if (!fullResponseText || fullResponseText.trim() === '') {
            throw new Error('AIå›å¤å†…å®¹ä¸ºç©ºï¼Œè¯·ç¨åé‡è¯•');
        }
        
        
        let chatRepliesText = fullResponseText;

        // ç¾¤èŠæ¨¡å¼ï¼šå¦‚æœæ˜¯ç¾¤èŠï¼Œç›´æ¥è¿”å›å®Œæ•´å†…å®¹ï¼Œä¸è¿›è¡Œåˆ†å‰²
        let replies;
        if (currentContact && currentContact.type === 'group') {
            replies = [chatRepliesText.trim()];
        } else {
            // å¤„ç†å›å¤åˆ†å‰²ï¼ˆä»…ç”¨äºç§èŠï¼‰
            // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰ ||| åˆ†éš”ç¬¦
            if (chatRepliesText.includes('|||')) {
                replies = chatRepliesText.split('|||').map(r => r.trim()).filter(r => r);
            } 
            // å¦‚æœæ²¡æœ‰ |||ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ || åˆ†éš”ç¬¦
            else if (chatRepliesText.includes('||')) {
                replies = chatRepliesText.split('||').map(r => r.trim()).filter(r => r);
            }
            // å¦‚æœéƒ½æ²¡æœ‰ï¼ŒæŒ‰æ¢è¡Œç¬¦åˆ†å‰²
            else {
                replies = chatRepliesText.split('\n').map(r => r.trim()).filter(r => r);
            }
        }
        const processedReplies = [];
        
        // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆè¡¨æƒ…ã€çº¢åŒ…ç­‰ï¼‰
        const emojiNameRegex = /^\[(?:emoji|å‘é€äº†è¡¨æƒ…)[:ï¼š]([^\]]+)\]$/;
        const redPacketRegex = /^\[red_packet:({.*})\]$/;

        for (const reply of replies) {
            const emojiMatch = reply.match(emojiNameRegex);
            const redPacketMatch = reply.match(redPacketRegex);

            if (emojiMatch) {
                const emojiName = emojiMatch[1];
                const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                if (foundEmoji) {
                    const content = foundEmoji.tag ? `[emoji:${foundEmoji.tag}]` : foundEmoji.url;
                    processedReplies.push({ type: 'emoji', content: content });
                } else {
                    processedReplies.push({ type: 'text', content: reply });
                }
            } else if (redPacketMatch) {
                try {
                    const packetData = JSON.parse(redPacketMatch[1]);
                    if (typeof packetData.amount === 'number' && typeof packetData.message === 'string') {
                         processedReplies.push({ type: 'red_packet', content: JSON.stringify(packetData) });
                    } else {
                         processedReplies.push({ type: 'text', content: reply });
                    }
                } catch (e) {
                    processedReplies.push({ type: 'text', content: reply });
                }
            } else {
                processedReplies.push({ type: 'text', content: reply });
            }
        }
        
        
        return { replies: processedReplies };

    } catch (error) {
        // å°è¯•è·å–æ›´å¯é çš„apiCallInfoç”¨äºæ—¥å¿—ï¼Œè€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨è¿‡æ—¶çš„window.apiSettings
        let apiCallInfoForLog = { url: 'not set', hasKey: false, model: 'not set' };
        try {
            const info = await getApiCallInfo();
            apiCallInfoForLog = {
                url: info?.url ? (info.url.substring(0, 50) + '...') : 'not set',
                hasKey: !!info?.key,
                model: info?.model || 'not set'
            };
        } catch (e) {
            // å¦‚æœè·å–å¤±è´¥ï¼Œå°è¯•ä»å…¼å®¹å¯¹è±¡è¯»å–ï¼Œä¿æŒæ—§æ—¥å¿—ç»“æ„
            apiCallInfoForLog = {
                url: (window.apiSettings && window.apiSettings.url) ? (window.apiSettings.url.substring(0,50) + '...') : 'not set',
                hasKey: !!(window.apiSettings && window.apiSettings.key),
                model: (window.modelSettings && window.modelSettings.primaryModel) ? window.modelSettings.primaryModel : 'not set'
            };
        }

        // è·å–å½“å‰æ¨¡å‹çš„å¯è¯»åç§°ä½œä¸ºè¡¥å……ä¿¡æ¯
        let currentModelName = 'not set';
        try {
            currentModelName = await getCurrentModel() || currentModelName;
        } catch (e) {
            console.warn('Failed to get current model name for error logging:', e);
        }

        console.error('callAPIé”™è¯¯è¯¦æƒ…:', {
            errorName: error.name,
            errorMessage: error.message,
            errorStack: error.stack,
            contact: contact ? {
                id: contact.id,
                name: contact.name,
                type: contact.type
            } : null,
            turnContextLength: turnContext ? turnContext.length : 0,
            apiSettings: apiCallInfoForLog,
            currentModel: currentModelName,
            timestamp: new Date().toISOString(),
            networkStatus: navigator.onLine ? 'online' : 'offline'
        });

        // ä¸å†æŠ›å‡ºé”™è¯¯ï¼Œè®©showApiErrorå¤„ç†é‡è¯•é€»è¾‘
        showApiError(error);
        return null; // è¿”å›nullè¡¨ç¤ºAPIè°ƒç”¨å¤±è´¥
    }
}


async function testApiConnection() {
    // å£°æ˜å˜é‡ï¼Œä½¿å…¶åœ¨try-catchå—å¤–å¯è®¿é—®
    let enabledKey = '';
    let keyElement = null; // å­˜å‚¨å¯¹åº”çš„DOMå…ƒç´ 
    
    try {
        const url = document.getElementById('apiUrl')?.value?.trim();
        
        if (!url) {
            showToast('è¯·å¡«å†™API URL');
            return;
        }
        
        // æ£€æŸ¥ä¸»keyæ˜¯å¦æœ‰å€¼
        const mainKey = document.getElementById('apiKey')?.value?.trim();
        if (mainKey) {
            enabledKey = mainKey; // é»˜è®¤ä½¿ç”¨ä¸»key
            keyElement = document.getElementById('apiKey');
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰é¢å¤–keyè¢«å¯ç”¨
        const enabledButtons = document.querySelectorAll('.key-enable-btn[data-enabled="true"]');
        if (enabledButtons.length > 0) {
            const enabledButton = enabledButtons[0];
            const row = enabledButton.closest('.api-provider-row');
            const keyInput = row?.querySelector('.api-key-input');
            if (keyInput && keyInput.value.trim()) {
                enabledKey = keyInput.value.trim();
                keyElement = keyInput;
            }
        }
        
        if (!enabledKey) {
            showToast('è¯·å¡«å†™è‡³å°‘ä¸€ä¸ªAPI Key');
            return;
        }
        
        console.log('æµ‹è¯•è¿æ¥ä½¿ç”¨çš„keyå‰8ä½:', enabledKey.substring(0, 8) + '...');

        // æµ‹è¯•è¿æ¥
        console.log(`[æµ‹è¯•è¿æ¥] window.apiServiceå­˜åœ¨: ${!!window.apiService}`);
        console.log(`[æµ‹è¯•è¿æ¥] window.apiService.testConnectionç±»å‹: ${typeof window.apiService?.testConnection}`);
        
        if (!window.apiService) {
            // å°è¯•é‡æ–°åˆå§‹åŒ–APIService
            if (typeof APIService !== 'undefined') {
                console.log('[æµ‹è¯•è¿æ¥] é‡æ–°åˆå§‹åŒ–APIService');
                window.apiService = new APIService();
            } else {
                throw new Error('APIServiceç±»æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥api.jsæ˜¯å¦æ­£ç¡®åŠ è½½');
            }
        }
        
        if (typeof window.apiService.testConnection !== 'function') {
            console.error('window.apiServiceå¯¹è±¡:', window.apiService);
            console.error('å¯ç”¨æ–¹æ³•:', Object.getOwnPropertyNames(window.apiService));
            throw new Error('testConnectionæ–¹æ³•ä¸å­˜åœ¨');
        }
        
        const data = await window.apiService.testConnection(url, enabledKey);
        const models = data.data ? data.data.map(m => m.id).sort() : [];

        // è¿æ¥æˆåŠŸï¼Œä½†ä¸é‡å†™æ¨¡å‹é€‰æ‹©æ¡†
        if (models.length === 0) {
            showToast('è¿æ¥æˆåŠŸï¼Œä½†æœªæ‰¾åˆ°å¯ç”¨æ¨¡å‹');
        } else {
            showToast(`è¿æ¥æˆåŠŸï¼Œæ‰¾åˆ° ${models.length} ä¸ªå¯ç”¨æ¨¡å‹`);
        }
        
        // åªç¼“å­˜æ¨¡å‹åˆ—è¡¨ï¼Œä¸æ›´æ–°UI
        if (models && models.length > 0 && window.apiConfigManager) {
            const activeConfig = await window.apiConfigManager.getActiveConfig();
            if (activeConfig) {
                window.apiConfigManager.availableModels.set(activeConfig.id, models);
                console.log(`[æµ‹è¯•è¿æ¥] å·²ç¼“å­˜ ${models.length} ä¸ªæ¨¡å‹åˆ°é…ç½® ${activeConfig.id}`);
            }
        }

    } catch (error) {
        console.error('æµ‹è¯•è¿æ¥å¤±è´¥:', error);
        
        // æ ‡è®°æµ‹è¯•å¤±è´¥çš„keyä¸ºå¤±è´¥çŠ¶æ€ï¼Œå¹¶ä¼ é€’å…·ä½“é”™è¯¯ä¿¡æ¯
        if (keyElement) {
            console.log('æ ‡è®°keyä¸ºå¤±è´¥çŠ¶æ€:', keyElement.id || 'secondary key');
            markKeyAsFailed(keyElement, 'è¿æ¥å¤±è´¥: ' + error.message);
        } else {
            console.error('æ— æ³•æ ‡è®°keyä¸ºå¤±è´¥çŠ¶æ€: keyElementä¸ºnull');
            showToast('è¿æ¥å¤±è´¥: ' + error.message);
        }
    }
}

function handlePrimaryModelChange() {
    const primaryModel = document.getElementById('primaryModelSelect').value;
    const secondarySelect = document.getElementById('secondaryModelSelect');
    
    // ç«‹å³æ›´æ–°å…¨å±€æ¨¡å‹è®¾ç½®
        if (window.modelSettings) {
            window.modelSettings.primaryModel = primaryModel;
        console.log('ä¸»æ¨¡å‹å·²æ›´æ–°ä¸º:', primaryModel);
    }
    
    // å¦‚æœæ¬¡è¦æ¨¡å‹è®¾ç½®ä¸º"åŒæ­¥"ï¼Œåˆ™åœ¨æ•°æ®å±‚é¢æ›´æ–°å®ƒ
    if (window.modelSettings && window.modelSettings.secondaryModel === 'sync_with_primary') {
        // ä¸éœ€è¦ç›´æ¥ä¿®æ”¹UIï¼Œä¿å­˜æ—¶ä¼šå¤„ç†
    }
}

async function saveApiConfig(event) {
    event.preventDefault();
    
    try {
        if (!window.apiConfigManager) {
            throw new Error('é…ç½®ç®¡ç†å™¨æœªåˆå§‹åŒ–');
        }
        
        // è·å–è¡¨å•æ•°æ®
        const getElementValue = (id, defaultValue = '') => {
            const element = document.getElementById(id);
            return element ? element.value.trim() : defaultValue;
        };
        
        const configName = getElementValue('configName');
        const apiUrl = getElementValue('apiUrl');
        const apiKey = getElementValue('apiKey');
        const timeout = parseInt(getElementValue('apiTimeout')) || 60;
        
        // éªŒè¯å¿…å¡«å­—æ®µ
        if (!configName) {
            showToast('è¯·è¾“å…¥é…ç½®åç§°');
            return;
        }
        
        if (!apiUrl || !apiKey) {
            showToast('è¯·è¾“å…¥API URLå’ŒAPI Key');
            return;
        }
        
        // æ„å»ºå®Œæ•´çš„API Keysæ•°ç»„ï¼ˆåŒ…æ‹¬ä¸»keyå’Œæ‰€æœ‰å‰¯keyï¼‰
        const allApiKeys = [];
        
        // é¦–å…ˆæ·»åŠ ä¸»keyï¼ˆå§‹ç»ˆåœ¨index 0ï¼‰
        const mainKeyStatus = document.querySelector('.main-key-status');
        const mainKeyEnabled = mainKeyStatus ? (mainKeyStatus.dataset.enabled === 'true' && mainKeyStatus.dataset.status === 'enabled') : true;
        
        allApiKeys.push({
            key: apiKey,
            name: 'ä¸»Key',
            enabled: mainKeyEnabled,
            index: 0
        });
        
        // ç„¶åæ·»åŠ æ‰€æœ‰å‰¯key
        const providerRows = document.querySelectorAll('.api-provider-row');
        providerRows.forEach((row, index) => {
            const keyInput = row.querySelector('.api-key-input');
            const enableButton = row.querySelector('.key-enable-btn');
            if (keyInput && keyInput.value.trim()) {
                allApiKeys.push({
                    key: keyInput.value.trim(),
                    name: `Key ${index + 1}`,
                    enabled: enableButton ? (enableButton.dataset.enabled === 'true' && enableButton.dataset.status === 'enabled') : false,
                    index: index + 1
                });
            }
        });
        
        // è·å–æ¨¡å‹é€‰æ‹©
        const primaryModel = getElementValue('primaryModelSelect');
        const secondaryModel = getElementValue('secondaryModelSelect');
        
        // è·å–ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é‡
        const contextMessageCount = parseInt(getElementValue('contextSlider')) || 10;
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºæ–°é…ç½®ï¼ˆé€šè¿‡æŒ‰é’®çŠ¶æ€æˆ–å…¶ä»–æ ‡è¯†åˆ¤æ–­ï¼‰
        const isNewConfig = window.currentConfigState === 'new';
        const configSelector = document.getElementById('configSelector');
        const currentConfigId = isNewConfig ? null : configSelector?.value || null;
        
        // æ„å»ºé…ç½®æ•°æ® - ä¿æŒåŸæœ‰keyç»“æ„ï¼Œåªæ›´æ–°å¯ç”¨çŠ¶æ€
        const configData = {
            configId: currentConfigId,
            configName,
            url: apiUrl,
            key: apiKey, // ä¿æŒä¸»keyä¸å˜
            model: primaryModel,
            secondaryModel: secondaryModel,
            contextMessageCount,
            timeout,
            apiKeys: allApiKeys // ä½¿ç”¨å®Œæ•´çš„apiKeysç»“æ„
        };
        
        console.log('[APIé…ç½®ä¿å­˜] å‡†å¤‡ä¿å­˜çš„é…ç½®æ•°æ®:', {
            key: apiKey.substring(0, 10) + '...',
            apiKeysCount: allApiKeys.length,
            enabledKeys: allApiKeys.filter(k => k.enabled).map(k => ({
                index: k.index, 
                keyPrefix: k.key.substring(0, 10) + '...'
            }))
        });
        
        // ä¿å­˜é…ç½®
        const savedConfig = await window.apiConfigManager.saveConfig(configData);
        
        // å¦‚æœæ˜¯æ–°é…ç½®ï¼Œåˆ‡æ¢åˆ°æ–°é…ç½®
        if (!currentConfigId || currentConfigId === '') {
            await window.apiConfigManager.switchToConfig(savedConfig.id);
        }
        
        // é‡æ–°åŠ è½½é…ç½®é€‰æ‹©å™¨
        await loadConfigSelector();
        
        // è®¾ç½®é€‰ä¸­çš„é…ç½®
        if (configSelector) {
            configSelector.value = savedConfig.id;
        }
        
        // é‡ç½®æ–°é…ç½®çŠ¶æ€
        window.currentConfigState = null;
        
        showToast('APIé…ç½®ä¿å­˜æˆåŠŸ');
        
        // æ˜¾ç¤ºæˆåŠŸæç¤ºå¹¶éšè—æµç¨‹æé†’
        showConfigSaveSuccess();
        
        // ç«‹å³æ›´æ–°å…¨å±€APIè®¾ç½®
        await ensureApiConfigIsUpdated();
        
    } catch (error) {
        console.error('ä¿å­˜APIé…ç½®å¤±è´¥:', error);
        showToast('ä¿å­˜APIé…ç½®å¤±è´¥: ' + error.message);
    }
}

async function saveAppSettings(event) {
    event.preventDefault();
    
    // éªŒè¯ç”¨æˆ·æµç¨‹å®Œæ•´æ€§
    if (!validateUserFlow()) {
        return;
    }
    
    try {
        // è·å–è¡¨å•æ•°æ®
        const getElementValue = (id, defaultValue = '') => {
            const element = document.getElementById(id);
            return element ? element.value.trim() : defaultValue;
        };
        
        const primaryConfig = getElementValue('primaryConfigSelect');
        const primaryModel = getElementValue('primaryModelSelect');
        const secondaryConfig = getElementValue('secondaryConfigSelect', 'sync_with_primary');
        const secondaryModel = getElementValue('secondaryModelSelect', 'sync_with_primary');
        const contextMessageCount = parseInt(getElementValue('contextSlider')) || 10;
        const minimaxGroupId = getElementValue('minimaxGroupId');
        const minimaxApiKey = getElementValue('minimaxApiKey');
        const unsplashKey = getElementValue('unsplashApiKey');
        
        // ä¿å­˜åº”ç”¨è®¾ç½®åˆ°localStorageï¼ˆè¿™äº›ä¸å±äºAPIé…ç½®ï¼‰
        localStorage.setItem('primaryModelConfig', primaryConfig);
        localStorage.setItem('primaryModel', primaryModel);
        localStorage.setItem('secondaryModelConfig', secondaryConfig);
        localStorage.setItem('secondaryModel', secondaryModel);
        localStorage.setItem('contextMessageCount', contextMessageCount.toString());
        localStorage.setItem('minimaxGroupId', minimaxGroupId);
        localStorage.setItem('minimaxApiKey', minimaxApiKey);
        
        // ä¿å­˜ Unsplash API Key
        if (unsplashKey) {
            localStorage.setItem('forumUnsplashApiKey', unsplashKey);
            localStorage.setItem('unsplashApiKey', unsplashKey);
        } else {
            localStorage.removeItem('forumUnsplashApiKey');
            localStorage.removeItem('unsplashApiKey');
        }
        
        // é‡æ–°åˆå§‹åŒ–å›¾ç‰‡å…³é”®è¯ç”Ÿæˆå™¨
        if (window.imageKeywordGenerator && window.apiService) {
            window.imageKeywordGenerator.init(window.apiSettings, window.apiService);
            console.log('å›¾ç‰‡å…³é”®è¯ç”Ÿæˆå™¨å·²æ›´æ–°é…ç½®');
        }
        
        updateContextIndicator();
        showToast('åº”ç”¨è®¾ç½®ä¿å­˜æˆåŠŸ');
        
        // æ˜¾ç¤ºæµç¨‹å®Œæˆæ¶ˆæ¯
        showFlowCompletionMessage();
        
    } catch (error) {
        console.error('ä¿å­˜åº”ç”¨è®¾ç½®å¤±è´¥:', error);
        showToast('ä¿å­˜åº”ç”¨è®¾ç½®å¤±è´¥: ' + error.message);
    }
}

async function loadApiConfigSelectorsForModels() {
    try {
        if (!window.apiConfigManager) return;
        
        const configs = await window.apiConfigManager.getAllConfigs();
        
        // ä¸ºä¸»è¦æ¨¡å‹å’Œæ¬¡è¦æ¨¡å‹çš„é…ç½®é€‰æ‹©å™¨æ·»åŠ é€‰é¡¹
        const primaryConfigSelect = document.getElementById('primaryConfigSelect');
        const secondaryConfigSelect = document.getElementById('secondaryConfigSelect');
        
        if (primaryConfigSelect) {
            primaryConfigSelect.innerHTML = '<option value="">é€‰æ‹©APIé…ç½®</option>';
            configs.forEach(config => {
                const option = document.createElement('option');
                option.value = config.id;
                option.textContent = config.configName;
                primaryConfigSelect.appendChild(option);
            });
        }
        
        if (secondaryConfigSelect) {
            secondaryConfigSelect.innerHTML = '<option value="">é€‰æ‹©APIé…ç½®</option><option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>';
            configs.forEach(config => {
                const option = document.createElement('option');
                option.value = config.id;
                option.textContent = config.configName;
                secondaryConfigSelect.appendChild(option);
            });
        }
        
        // åŠ è½½ä¿å­˜çš„é€‰æ‹©
        const savedPrimaryConfig = localStorage.getItem('primaryModelConfig');
        const savedPrimaryModel = localStorage.getItem('primaryModel');
        const savedSecondaryConfig = localStorage.getItem('secondaryModelConfig');
        const savedSecondaryModel = localStorage.getItem('secondaryModel');
        
        if (savedPrimaryConfig && primaryConfigSelect) {
            primaryConfigSelect.value = savedPrimaryConfig;
            await loadModelsForConfig('primaryConfigSelect', 'primaryModelSelect');
            if (savedPrimaryModel) {
                const primaryModelSelect = document.getElementById('primaryModelSelect');
                if (primaryModelSelect) {
                    primaryModelSelect.value = savedPrimaryModel;
                }
            }
        }
        
        if (savedSecondaryConfig && secondaryConfigSelect) {
            secondaryConfigSelect.value = savedSecondaryConfig;
            if (savedSecondaryConfig !== 'sync_with_primary') {
                await loadModelsForConfig('secondaryConfigSelect', 'secondaryModelSelect');
                if (savedSecondaryModel) {
                    const secondaryModelSelect = document.getElementById('secondaryModelSelect');
                    if (secondaryModelSelect) {
                        secondaryModelSelect.value = savedSecondaryModel;
                    }
                }
            }
        }
        
    } catch (error) {
        console.error('åŠ è½½APIé…ç½®é€‰æ‹©å™¨å¤±è´¥:', error);
    }
}

// æ£€æŸ¥API Keyæ˜¯å¦é‡å¤
function checkKeyDuplicate(keyValue, excludeInput = null) {
    // è·å–ä¸»key
    const mainKeyInput = document.getElementById('apiKey');
    if (mainKeyInput !== excludeInput && mainKeyInput.value.trim() === keyValue) {
        return true;
    }
    
    // è·å–æ‰€æœ‰å‰¯key
    const secondaryKeyInputs = document.querySelectorAll('.api-provider-row .api-key-input');
    for (const input of secondaryKeyInputs) {
        if (input !== excludeInput && input.value.trim() === keyValue) {
            return true;
        }
    }
    
    return false;
}

// å¤„ç†API Keyè¾“å…¥ï¼Œæ£€æŸ¥é‡å¤
function handleApiKeyInput(input, event) {
    const keyValue = input.value.trim();
    
    if (keyValue && checkKeyDuplicate(keyValue, input)) {
        // å¦‚æœæœ‰é‡å¤ï¼Œæ˜¾ç¤ºè­¦å‘Š
        input.style.borderColor = '#dc3545';
        showToast('API Keyä¸èƒ½é‡å¤ï¼', 'warning');
        
        // å¯é€‰ï¼šæ¸…é™¤é‡å¤çš„å€¼
        // input.value = '';
    } else {
        // æ²¡æœ‰é‡å¤ï¼Œæ¢å¤æ­£å¸¸è¾¹æ¡†
        input.style.borderColor = '';
    }
}

// æ£€æŸ¥æ‰€æœ‰API Keyæ˜¯å¦æœ‰é‡å¤
function checkAllApiKeysForDuplicates() {
    const allKeyInputs = document.querySelectorAll('.api-key-input');
    const keyMap = new Map(); // å­˜å‚¨keyå€¼å’Œå¯¹åº”çš„è¾“å…¥æ¡†
    
    // é‡ç½®æ‰€æœ‰è¾¹æ¡†
    allKeyInputs.forEach(input => {
        input.style.borderColor = '';
    });
    
    // æ£€æŸ¥é‡å¤
    let hasDuplicates = false;
    allKeyInputs.forEach(input => {
        const keyValue = input.value.trim();
        if (!keyValue) return;
        
        if (keyMap.has(keyValue)) {
            // å‘ç°é‡å¤
            hasDuplicates = true;
            input.style.borderColor = '#dc3545';
            keyMap.get(keyValue).style.borderColor = '#dc3545';
        } else {
            keyMap.set(keyValue, input);
        }
    });
    
    if (hasDuplicates) {
        showToast('æ£€æµ‹åˆ°é‡å¤çš„API Keysï¼Œè¯·æ£€æŸ¥ï¼', 'warning');
    }
}

function addProviderRow() {
    try {
        console.log('æ·»åŠ æ–°çš„API Keyè¡Œ');
        
        // æ‰¾åˆ°APIé…ç½®è¡¨å•ä¸­çš„åŸºæœ¬è®¾ç½®éƒ¨åˆ†
        const configSection = document.querySelector('.config-section');
        if (!configSection) {
            console.error('æœªæ‰¾åˆ°é…ç½®éƒ¨åˆ†å®¹å™¨');
            showToast('æ— æ³•æ·»åŠ æ–°è¡Œï¼šæœªæ‰¾åˆ°é…ç½®å®¹å™¨');
            return;
        }
        
        // è®¡ç®—è¿™æ˜¯ç¬¬å‡ ä¸ªKeyï¼ˆä»1å¼€å§‹ï¼Œ0æ˜¯ä¸»Keyï¼‰
        const existingRows = document.querySelectorAll('.api-provider-row').length;
        const keyIndex = existingRows + 1;
        
        // åˆ›å»ºæ–°çš„API Keyè¡Œ
        const newKeyRow = document.createElement('div');
        newKeyRow.className = 'form-group api-provider-row';
        newKeyRow.innerHTML = `
            <div class="key-header">
                <label class="form-label">API Key ${keyIndex}</label>
                <button type="button" class="remove-provider-btn" onclick="removeProviderRow(this, event)" title="ç§»é™¤æ­¤Key">Ã—</button>
            </div>
            <div class="compact-key-row additional-key-row">
                <input type="password" class="form-input api-key-input compact-key-input" placeholder="è¾“å…¥API Key" oninput="updateKeyStats(this); handleApiKeyInput(this, event)">
                <button type="button" class="key-enable-btn" onclick="toggleKeyEnable(this)" data-enabled="false" data-status="disabled" title="ç‚¹å‡»å¯ç”¨æ­¤Key">âšª</button>
                <div class="key-stats-compact">
                    <div class="key-masked-compact">æœªè®¾ç½®</div>
                    <div class="stats-compact">
                        <span class="calls-count">0æ¬¡</span>/<span class="success-rate">0%</span>
                    </div>
                </div>
            </div>
        `;
        
        // æ‰¾åˆ°ç°æœ‰API Keyè¾“å…¥æ¡†çš„çˆ¶å®¹å™¨ï¼Œåœ¨å…¶åæ’å…¥æ–°è¡Œ
        const apiKeyGroup = document.querySelector('#apiKey').closest('.form-group');
        if (apiKeyGroup && apiKeyGroup.parentNode) {
            apiKeyGroup.parentNode.insertBefore(newKeyRow, apiKeyGroup.nextSibling);
            console.log('æˆåŠŸæ·»åŠ æ–°çš„API Keyè¡Œ');
        } else {
            console.error('æœªæ‰¾åˆ°API Keyè¾“å…¥æ¡†å®¹å™¨');
            showToast('æ— æ³•æ·»åŠ æ–°è¡Œï¼šæœªæ‰¾åˆ°API Keyå®¹å™¨');
        }
        
    } catch (error) {
        console.error('æ·»åŠ API Keyè¡Œå¤±è´¥:', error);
        showToast('æ·»åŠ æ–°è¡Œå¤±è´¥: ' + error.message);
    }
}

function removeProviderRow(button, event) {
    try {
        // é˜»æ­¢äº‹ä»¶å†’æ³¡
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        
        const row = button.closest('.api-provider-row');
        if (row) {
            row.remove();
            console.log('ç§»é™¤API Keyè¡ŒæˆåŠŸ');
            showToast('å·²ç§»é™¤API Keyè¡Œ');
        }
    } catch (error) {
        console.error('ç§»é™¤API Keyè¡Œå¤±è´¥:', error);
        showToast('ç§»é™¤è¡Œå¤±è´¥: ' + error.message);
    }
}

// æ ‡è®°API Keyä¸ºå¤±è´¥çŠ¶æ€
async function markKeyAsFailed(keyElement, errorMessage = null) {
    try {
        if (!keyElement) {
            console.error('markKeyAsFailed: keyElementä¸ºnull');
            return;
        }
        
        console.log('markKeyAsFailed: å¼€å§‹å¤„ç†key', keyElement.id || 'secondary key');
        
        // åˆ¤æ–­æ˜¯ä¸»keyè¿˜æ˜¯é¢å¤–key
        if (keyElement.id === 'apiKey') {
            // ä¸»key - ä½¿ç”¨ä¸»keyçŠ¶æ€æŒ‰é’®
            const mainKeyStatusBtn = document.querySelector('.main-key-status');
            if (mainKeyStatusBtn) {
                console.log('markKeyAsFailed: æ‰¾åˆ°ä¸»keyçŠ¶æ€æŒ‰é’®ï¼Œè®¾ç½®ä¸ºå¤±è´¥çŠ¶æ€');
                mainKeyStatusBtn.dataset.status = 'failed';
                mainKeyStatusBtn.dataset.enabled = 'false';
                mainKeyStatusBtn.style.backgroundColor = 'white'; // ç™½è‰²èƒŒæ™¯
                mainKeyStatusBtn.textContent = 'ğŸ”´'; // çº¢è‰²åœ†åœˆ
                // æ›´æ–°å…¨å±€è®¾ç½®
                if (window.apiConfigManager) {
                    await window.apiConfigManager.setKeyEnabled('', false); // æ¸…é™¤å¯ç”¨çš„key
                }
            } else {
                console.error('markKeyAsFailed: æœªæ‰¾åˆ°ä¸»keyçŠ¶æ€æŒ‰é’®(.main-key-status)');
            }
        } else {
            // é¢å¤–key - æ‰¾åˆ°å¯¹åº”çš„çŠ¶æ€æŒ‰é’®
            const row = keyElement.closest('.api-provider-row');
            if (row) {
                const statusBtn = row.querySelector('.key-enable-btn');
                if (statusBtn) {
                    console.log('markKeyAsFailed: æ‰¾åˆ°å‰¯keyçŠ¶æ€æŒ‰é’®ï¼Œè®¾ç½®ä¸ºå¤±è´¥çŠ¶æ€');
                    statusBtn.dataset.status = 'failed';
                    statusBtn.dataset.enabled = 'false';
                    statusBtn.style.backgroundColor = 'white'; // ç™½è‰²èƒŒæ™¯
                    statusBtn.textContent = 'ğŸ”´'; // çº¢è‰²åœ†åœˆ
                    // å¦‚æœè¿™ä¸ªkeyæ˜¯å¯ç”¨çŠ¶æ€ï¼Œéœ€è¦æ›´æ–°é…ç½®
                    const keyValue = keyElement.value.trim();
                    if (keyValue && window.apiConfigManager) {
                        try {
                            // è·å–å½“å‰é…ç½®
                            const currentConfig = await window.apiConfigManager.getActiveConfig();
                            if (currentConfig) {
                                const currentEnabled = window.apiConfigManager.getEnabledKey(currentConfig);
                                if (currentEnabled === keyValue) {
                                    // å¦‚æœè¢«æ ‡è®°å¤±è´¥çš„æ˜¯å½“å‰å¯ç”¨çš„keyï¼Œæ¸…é™¤å¯ç”¨çŠ¶æ€
                                    if (keyElement.id === 'apiKey') {
                                        // ä¸»keyï¼Œä¸éœ€è¦ç‰¹æ®Šå¤„ç†
                                    } else {
                                        // å‰¯keyï¼Œç¦ç”¨å®ƒ
                                        statusBtn.dataset.enabled = 'false';
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn('æ›´æ–°é…ç½®çŠ¶æ€å¤±è´¥:', error);
                        }
                    }
                } else {
                    console.error('markKeyAsFailed: åœ¨rowä¸­æœªæ‰¾åˆ°.key-enable-btnæŒ‰é’®');
                }
            } else {
                console.error('markKeyAsFailed: æœªæ‰¾åˆ°keyçš„çˆ¶è¡Œ(.api-provider-row)');
            }
        }
        
        // æ˜¾ç¤ºå…·ä½“çš„é”™è¯¯ä¿¡æ¯ï¼Œè€Œä¸æ˜¯é€šç”¨çš„å¤±è´¥æ¶ˆæ¯
        if (errorMessage) {
            showToast(errorMessage);
        }
        
    } catch (error) {
        console.error('æ ‡è®°Keyå¤±è´¥çŠ¶æ€å‡ºé”™:', error);
    }
}

async function toggleKeyEnable(button) {
    try {
        const currentStatus = button.dataset.status || 'disabled';
        const row = button.closest('.api-provider-row');
        const keyInput = row.querySelector('.api-key-input');
        const keyValue = keyInput ? keyInput.value.trim() : '';
        
        if (!keyValue) {
            showToast('è¯·å…ˆå¡«å†™API Key');
            return;
        }
        
        // çŠ¶æ€åˆ‡æ¢é€»è¾‘ï¼šdisabled -> enabled -> disabled -> failed -> enabled
        let newStatus, newIcon, newTitle, newColor;
        
        console.log(`[å¤škeyè°ƒè¯•] toggleKeyEnableè¢«è°ƒç”¨: å½“å‰çŠ¶æ€=${currentStatus}, keyå‰ç¼€=${keyValue.substring(0, 10)}...`);
        
        switch (currentStatus) {
            case 'disabled':
                // ç¦ç”¨ -> å¯ç”¨
                newStatus = 'enabled';
                newIcon = 'ğŸŸ¢';
                newTitle = 'å·²å¯ç”¨ (ç‚¹å‡»ç¦ç”¨)';
                newColor = '#28a745';
                
                // ç¦ç”¨æ‰€æœ‰å…¶ä»–key
                await disableAllOtherKeys();
                
                // å¯ç”¨è¿™ä¸ªkey
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('å·²å¯ç”¨æ­¤API Key');
                break;
                
            case 'enabled':
                // å¯ç”¨ -> ç¦ç”¨
                newStatus = 'disabled';
                newIcon = 'âšª';
                newTitle = 'å·²ç¦ç”¨ (ç‚¹å‡»å¯ç”¨)';
                newColor = '#6c757d';
                button.dataset.enabled = 'false';
                
                // å›é€€åˆ°ä¸»key
                await enableMainKey();
                showToast('å·²ç¦ç”¨æ­¤API Key');
                break;
                
            case 'failed':
                // å¤±è´¥ -> å¯ç”¨
                newStatus = 'enabled';
                newIcon = 'ğŸŸ¢';
                newTitle = 'å·²å¯ç”¨ (ç‚¹å‡»ç¦ç”¨)';
                newColor = '#28a745';
                
                // ç¦ç”¨æ‰€æœ‰å…¶ä»–key
                await disableAllOtherKeys();
                
                // å¯ç”¨è¿™ä¸ªkey
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('å·²é‡æ–°å¯ç”¨æ­¤API Key');
                break;
        }
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        button.dataset.status = newStatus;
        button.innerHTML = newIcon;
        button.title = newTitle;
        button.style.backgroundColor = newColor;
        
        // æ›´æ–°å¯¹åº”è¡Œçš„æ ·å¼
        if (newStatus === 'enabled') {
            row.classList.add('enabled');
        } else {
            row.classList.remove('enabled');
        }
        
        // ç»Ÿä¸€æ›´æ–°æ‰€æœ‰keyçš„çŠ¶æ€
        setTimeout(() => {
            updateAllKeyStates();
        }, 100);
        
    } catch (error) {
        console.error('åˆ‡æ¢KeyçŠ¶æ€å¤±è´¥:', error);
        showToast('æ“ä½œå¤±è´¥: ' + error.message);
    }
}

async function toggleMainKeyStatus(button) {
    try {
        const currentStatus = button.dataset.status || 'enabled';
        const keyInput = document.getElementById('apiKey');
        const keyValue = keyInput ? keyInput.value.trim() : '';
        
        if (!keyValue) {
            showToast('è¯·å…ˆå¡«å†™ä¸»API Key');
            return;
        }
        
        let newStatus, newIcon, newTitle, newColor;
        
        switch (currentStatus) {
            case 'enabled':
                // å¯ç”¨ -> ç¦ç”¨ï¼ˆç”¨æˆ·ç‚¹å‡»åªèƒ½ç¦ç”¨ï¼Œä¸èƒ½ç›´æ¥æ ‡è®°ä¸ºå¤±è´¥ï¼‰
                newStatus = 'disabled';
                newIcon = 'âšª';
                newTitle = 'ä¸»Keyæœªå¯ç”¨ (ç‚¹å‡»å¯ç”¨)';
                newColor = '#6c757d';
                button.dataset.enabled = 'false';
                showToast('å·²ç¦ç”¨ä¸»API Key');
                break;
                
            case 'failed':
                // å¤±è´¥ -> å¯ç”¨
                newStatus = 'enabled';
                newIcon = 'ğŸŸ¢';
                newTitle = 'ä¸»Keyå·²å¯ç”¨ (ç‚¹å‡»ç¦ç”¨)';
                newColor = '#28a745';
                
                // ç¦ç”¨æ‰€æœ‰å‰¯key
                await disableAllOtherKeys();
                
                // å¯ç”¨ä¸»key
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('å·²é‡æ–°å¯ç”¨ä¸»API Key');
                break;
                
            case 'disabled':
                // ç¦ç”¨ -> å¯ç”¨ï¼ˆå½“å‰¯keyè¢«å¯ç”¨æ—¶ä¸»keyä¼šå˜ä¸ºç¦ç”¨çŠ¶æ€ï¼‰
                newStatus = 'enabled';
                newIcon = 'ğŸŸ¢';
                newTitle = 'ä¸»Keyå·²å¯ç”¨ (ç‚¹å‡»ç¦ç”¨)';
                newColor = '#28a745';
                
                // ç¦ç”¨æ‰€æœ‰å‰¯key
                await disableAllOtherKeys();
                
                // å¯ç”¨ä¸»key
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('å·²å¯ç”¨ä¸»API Key');
                break;
        }
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        button.dataset.status = newStatus;
        button.innerHTML = newIcon;
        button.title = newTitle;
        // ä¸»keyæŒ‰é’®ä¸è®¾ç½®èƒŒæ™¯è‰²ï¼Œä¿æŒé€æ˜
        
        // æ›´æ–°ä¸»keyè¡Œçš„æ ·å¼
        const mainKeyRow = document.querySelector('.main-key-row');
        if (mainKeyRow) {
            if (newStatus === 'enabled') {
                mainKeyRow.classList.add('enabled');
            } else {
                mainKeyRow.classList.remove('enabled');
            }
        }
        
        // ç»Ÿä¸€æ›´æ–°æ‰€æœ‰keyçš„çŠ¶æ€
        setTimeout(() => {
            updateAllKeyStates();
        }, 100);
        
    } catch (error) {
        console.error('åˆ‡æ¢ä¸»KeyçŠ¶æ€å¤±è´¥:', error);
        showToast('æ“ä½œå¤±è´¥: ' + error.message);
    }
}

// è¾…åŠ©å‡½æ•°ï¼šå¯ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„å‰¯key
async function enableFirstAvailableSecondaryKey() {
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    for (const btn of allSecondaryButtons) {
        const row = btn.closest('.api-provider-row');
        const keyInput = row.querySelector('.api-key-input');
        const keyValue = keyInput ? keyInput.value.trim() : '';
        
        if (keyValue && btn.dataset.status !== 'failed') {
            // å¯ç”¨è¿™ä¸ªkey
            btn.dataset.status = 'enabled';
            btn.dataset.enabled = 'true';
            btn.innerHTML = 'ğŸŸ¢';
            btn.style.backgroundColor = '#28a745';
            btn.title = 'å·²å¯ç”¨ (ç‚¹å‡»ç¦ç”¨)';
            
            await updateGlobalApiKey(keyValue);
            console.log('å·²è‡ªåŠ¨å¯ç”¨å‰¯key:', keyValue.substring(0, 10) + '...');
            return;
        }
    }
    
    // å¦‚æœæ²¡æœ‰å¯ç”¨çš„å‰¯keyï¼Œæç¤ºç”¨æˆ·
    showToast('æ²¡æœ‰å¯ç”¨çš„å¤‡ç”¨Key');
}

// è¾…åŠ©å‡½æ•°ï¼šç¦ç”¨æ‰€æœ‰å…¶ä»–key
async function disableAllOtherKeys() {
    // ç¦ç”¨æ‰€æœ‰å‰¯key
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    allSecondaryButtons.forEach(btn => {
        btn.dataset.enabled = 'false';
        btn.dataset.status = btn.dataset.status === 'failed' ? 'failed' : 'disabled';
        btn.innerHTML = btn.dataset.status === 'failed' ? 'ğŸ”´' : 'âšª';
        btn.style.backgroundColor = btn.dataset.status === 'failed' ? 'white' : '#6c757d';
        btn.title = btn.dataset.status === 'failed' ? 'æ ‡è®°å¤±è´¥ (ç‚¹å‡»é‡æ–°å¯ç”¨)' : 'ç‚¹å‡»å¯ç”¨æ­¤Key';
    });
    
    // ä»…åœ¨å‰¯keyè¢«å¯ç”¨æ—¶ï¼Œæ‰å°†ä¸»keyè®¾ä¸ºè§†è§‰ä¸Šçš„ç¦ç”¨çŠ¶æ€
    const mainKeyStatus = document.querySelector('.main-key-status');
    if (mainKeyStatus) {
        mainKeyStatus.dataset.enabled = 'false';
        mainKeyStatus.dataset.status = mainKeyStatus.dataset.status === 'failed' ? 'failed' : 'disabled';
        mainKeyStatus.innerHTML = mainKeyStatus.dataset.status === 'failed' ? 'ğŸ”´' : 'âšª';
        mainKeyStatus.style.backgroundColor = mainKeyStatus.dataset.status === 'failed' ? 'white' : '#6c757d';
        mainKeyStatus.title = mainKeyStatus.dataset.status === 'failed' ? 'ä¸»Keyæ ‡è®°å¤±è´¥ (ç‚¹å‡»é‡æ–°å¯ç”¨)' : 'ä¸»Key (ç‚¹å‡»å¯ç”¨)';
    }
}

// è¾…åŠ©å‡½æ•°ï¼šå¯ç”¨ä¸»key
async function enableMainKey() {
    const mainKeyStatus = document.querySelector('.main-key-status');
    const mainKeyInput = document.getElementById('apiKey');
    const mainKeyRow = document.querySelector('.main-key-row');
    
    if (mainKeyStatus && mainKeyInput && mainKeyRow) {
        const keyValue = mainKeyInput.value.trim();
        if (keyValue) {
            // ç¦ç”¨æ‰€æœ‰å‰¯key
            await disableAllSecondaryKeys();
            
            mainKeyStatus.dataset.enabled = 'true';
            mainKeyStatus.dataset.status = 'enabled';
            mainKeyStatus.innerHTML = 'ğŸŸ¢';
            mainKeyStatus.title = 'ä¸»Keyå·²å¯ç”¨ (ç‚¹å‡»è®¾ä¸ºå¤±è´¥)';
            mainKeyRow.classList.add('enabled');
            
            await updateGlobalApiKey(keyValue);
        }
    }
}

// æ–°å¢ï¼šä»…ç¦ç”¨å‰¯keyçš„å‡½æ•°
async function disableAllSecondaryKeys() {
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    allSecondaryButtons.forEach(btn => {
        btn.dataset.enabled = 'false';
        btn.dataset.status = btn.dataset.status === 'failed' ? 'failed' : 'disabled';
        btn.innerHTML = btn.dataset.status === 'failed' ? 'ğŸ”´' : 'âšª';
        btn.style.backgroundColor = btn.dataset.status === 'failed' ? 'white' : '#6c757d';
        btn.title = btn.dataset.status === 'failed' ? 'æ ‡è®°å¤±è´¥ (ç‚¹å‡»é‡æ–°å¯ç”¨)' : 'ç‚¹å‡»å¯ç”¨æ­¤Key';
    });
}

// æ–°å¢ï¼šç»Ÿä¸€æ›´æ–°æ‰€æœ‰keyçš„è§†è§‰çŠ¶æ€
function updateAllKeyStates() {
    // æ£€æŸ¥å“ªä¸ªkeyå½“å‰æ˜¯å¯ç”¨çš„
    const mainKeyStatus = document.querySelector('.main-key-status');
    const mainKeyRow = document.querySelector('.main-key-row');
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    const allSecondaryRows = document.querySelectorAll('.api-provider-row');
    
    let hasEnabledSecondaryKey = false;
    
    // é¦–å…ˆé‡ç½®æ‰€æœ‰å‰¯keyè¡Œçš„æ ·å¼
    allSecondaryRows.forEach(row => {
        row.classList.remove('enabled');
    });
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å‰¯keyè¢«å¯ç”¨ï¼Œå¹¶è®¾ç½®å¯¹åº”è¡Œçš„æ ·å¼
    allSecondaryButtons.forEach(btn => {
        const row = btn.closest('.api-provider-row');
        if (btn.dataset.enabled === 'true' && btn.dataset.status === 'enabled') {
            hasEnabledSecondaryKey = true;
            if (row) {
                row.classList.add('enabled');
            }
        }
    });
    
    // å¤„ç†ä¸»keyçš„çŠ¶æ€å’Œæ ·å¼
    if (mainKeyStatus && mainKeyRow) {
        const mainKeyInput = document.getElementById('apiKey');
        const keyValue = mainKeyInput ? mainKeyInput.value.trim() : '';
        
        // å¦‚æœæ²¡æœ‰å‰¯keyè¢«å¯ç”¨ï¼Œä¸”ä¸»keyä¸æ˜¯å¤±è´¥çŠ¶æ€ï¼Œåˆ™ä¸»keyåº”è¯¥æ˜¯å¯ç”¨çš„
        if (!hasEnabledSecondaryKey && keyValue && mainKeyStatus.dataset.status !== 'failed') {
            mainKeyStatus.dataset.enabled = 'true';
            mainKeyStatus.dataset.status = 'enabled';
            mainKeyStatus.innerHTML = 'ğŸŸ¢';
            mainKeyStatus.title = 'ä¸»Keyå·²å¯ç”¨ (ç‚¹å‡»è®¾ä¸ºå¤±è´¥)';
            mainKeyRow.classList.add('enabled');
        } else {
            // ä¸»keyæœªå¯ç”¨ï¼Œç§»é™¤å¯ç”¨æ ·å¼
            mainKeyRow.classList.remove('enabled');
        }
    }
}


// è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°å…¨å±€API Key
async function updateGlobalApiKey(keyValue) {
    if (keyValue && window.apiSettings) {
        const oldKey = window.apiSettings.key;
        window.apiSettings.key = keyValue;
        console.log(`[å¤škeyè°ƒè¯•] å·²æ›´æ–°å…¨å±€API Key: ${oldKey ? oldKey.substring(0, 8) + '...' : 'empty'} -> ${keyValue.substring(0, 8) + '...'}`);
        
        try {
            if (window.apiConfigManager && window.apiConfigManager.activeConfigId) {
                const config = await window.apiConfigManager.getConfigById(window.apiConfigManager.activeConfigId);
                if (config && config.apiKeys) {
                    const keyIndex = config.apiKeys.findIndex(k => k.key === keyValue);
                    if (keyIndex !== -1) {
                        await window.apiConfigManager.setKeyEnabled(window.apiConfigManager.activeConfigId, keyIndex, true);
                    }
                }
            }
        } catch (error) {
            console.warn('æ›´æ–°é…ç½®ç®¡ç†å™¨çŠ¶æ€å¤±è´¥:', error);
        }
    }
}

async function updateConfigKeyInDB(newKey) {
    try {
        if (!window.apiConfigManager || !window.apiConfigManager.activeConfigId) {
            console.error('æ— æ³•æ›´æ–°é…ç½®ï¼šé…ç½®ç®¡ç†å™¨æœªåˆå§‹åŒ–æˆ–æ— æ¿€æ´»é…ç½®');
            return;
        }
        
        // è·å–å½“å‰æ¿€æ´»çš„é…ç½®
        const configId = window.apiConfigManager.activeConfigId;
        const config = await window.apiConfigManager.getConfigById(configId);
        
        if (!config) {
            console.error('æ— æ³•è·å–å½“å‰é…ç½®');
            return;
        }
        
        // æ›´æ–°é…ç½®ä¸­çš„ä¸»keyå­—æ®µ
        config.key = newKey;
        config.updatedAt = Date.now();
        
        // å¦‚æœæœ‰apiKeysæ•°ç»„ï¼Œä¹Ÿè¦æ›´æ–°å¯¹åº”keyçš„å¯ç”¨çŠ¶æ€
        if (config.apiKeys && Array.isArray(config.apiKeys)) {
            // å°†æ‰€æœ‰keyè®¾ä¸ºæœªå¯ç”¨
            config.apiKeys.forEach(keyObj => {
                keyObj.enabled = false;
            });
            
            // æ‰¾åˆ°æ–°å¯ç”¨çš„keyå¹¶è®¾ä¸ºå¯ç”¨çŠ¶æ€
            const enabledKeyObj = config.apiKeys.find(keyObj => keyObj.key === newKey);
            if (enabledKeyObj) {
                enabledKeyObj.enabled = true;
            }
        }
        
        // ä¿å­˜é…ç½®åˆ°IndexedDB
        await window.apiConfigManager.saveConfig(config);
        
        console.log('å·²æ›´æ–°IndexedDBä¸­çš„é…ç½®key:', newKey.substring(0, 8) + '...');
        
    } catch (error) {
        console.error('æ›´æ–°IndexedDBé…ç½®å¤±è´¥:', error);
        showToast('æ›´æ–°é…ç½®å¤±è´¥: ' + error.message);
    }
}

function updateKeyStats(input) {
    try {
        let keyValue = input.value;
        
        // ç¡®ä¿keyValueæ˜¯å­—ç¬¦ä¸²
        if (typeof keyValue === 'object') {
            keyValue = keyValue.key || keyValue.toString();
        }
        
        keyValue = keyValue ? keyValue.trim() : '';
        
        const row = input.closest('.api-provider-row');
        const maskedDisplay = row.querySelector('.key-masked-compact');
        const callsCount = row.querySelector('.calls-count');
        const successRate = row.querySelector('.success-rate');
        
        if (!keyValue) {
            if (maskedDisplay) maskedDisplay.textContent = 'æœªè®¾ç½®';
            if (callsCount) callsCount.textContent = '0æ¬¡';
            if (successRate) successRate.textContent = '0%';
            return;
        }
        
        // æ˜¾ç¤ºæ©ç Key
        if (window.apiConfigManager) {
            if (maskedDisplay) {
                maskedDisplay.textContent = window.apiConfigManager.maskKey(keyValue);
            }
            
            // è·å–ç»Ÿè®¡ä¿¡æ¯
            const configId = window.apiConfigManager.activeConfigId || 'unknown';
            const keyIndex = Array.from(document.querySelectorAll('.api-provider-row')).indexOf(row) + 1;
            const stats = window.apiConfigManager.getKeyStats(configId, keyIndex, keyValue);
            
            if (callsCount) callsCount.textContent = `${stats.recentCalls}æ¬¡`;
            if (successRate) successRate.textContent = `${stats.successRate}%`;
        }
        
    } catch (error) {
        console.error('æ›´æ–°Keyç»Ÿè®¡å¤±è´¥:', error);
    }
}

function updateMainKeyStats(input) {
    try {
        const keyValue = input.value.trim();
        const maskedDisplay = document.getElementById('mainKeyMask');
        const callsCount = document.getElementById('mainKeyCalls');
        const successRate = document.getElementById('mainKeySuccess');
        
        if (!maskedDisplay || !callsCount || !successRate) return;
        
        if (!keyValue) {
            maskedDisplay.textContent = 'æœªè®¾ç½®';
            callsCount.textContent = '0æ¬¡';
            successRate.textContent = '0%';
            return;
        }
        
        // æ˜¾ç¤ºæ©ç Key
        if (window.apiConfigManager) {
            maskedDisplay.textContent = window.apiConfigManager.maskKey(keyValue);
            
            // è·å–ç»Ÿè®¡ä¿¡æ¯ï¼ˆä¸»keyçš„ç´¢å¼•æ˜¯0ï¼‰
            const configId = window.apiConfigManager.activeConfigId || 'unknown';
            const stats = window.apiConfigManager.getKeyStats(configId, 0, keyValue);
            
            callsCount.textContent = `${stats.recentCalls}æ¬¡`;
            successRate.textContent = `${stats.successRate}%`;
        }
        
    } catch (error) {
        console.error('æ›´æ–°ä¸»Keyç»Ÿè®¡å¤±è´¥:', error);
    }
}

async function loadModelsForConfig(configSelectId, modelSelectId) {
    try {
        const configSelect = document.getElementById(configSelectId);
        const modelSelect = document.getElementById(modelSelectId);
        
        if (!configSelect || !modelSelect) return;
        
        const configId = configSelect.value;
        
        // æ¸…ç©ºæ¨¡å‹é€‰æ‹©å™¨
        modelSelect.innerHTML = '';
        
        if (!configId) {
            modelSelect.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©APIé…ç½®</option>';
            return;
        }
        
        if (configId === 'sync_with_primary') {
            modelSelect.innerHTML = '<option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>';
            return;
        }
        
        // è·å–æŒ‡å®šé…ç½®çš„æ¨¡å‹åˆ—è¡¨
        if (!window.apiConfigManager) {
            modelSelect.innerHTML = '<option value="">é…ç½®ç®¡ç†å™¨æœªåˆå§‹åŒ–</option>';
            return;
        }
        
        const config = await window.apiConfigManager.getConfigById(configId);
        if (!config) {
            modelSelect.innerHTML = '<option value="">é…ç½®ä¸å­˜åœ¨</option>';
            return;
        }
        
        // åˆ›å»ºä¸´æ—¶çš„APIè¿æ¥æ¥è·å–æ¨¡å‹åˆ—è¡¨
        modelSelect.innerHTML = '<option value="">åŠ è½½ä¸­...</option>';
        
        const tempApiService = {
            baseURL: config.url,
            apiKey: config.key,
            timeout: config.timeout
        };
        
        try {
            const response = await fetch(`${config.url}/models`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${config.key}`,
                    'Content-Type': 'application/json'
                },
                timeout: config.timeout * 1000
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            const models = data.data || [];
            
            modelSelect.innerHTML = '';
            
            if (models.length === 0) {
                modelSelect.innerHTML = '<option value="">æ— å¯ç”¨æ¨¡å‹</option>';
                return;
            }
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.id;
                modelSelect.appendChild(option);
            });
            
            // ä¿å­˜é…ç½®é€‰æ‹©
            const type = configSelectId.includes('primary') ? 'primary' : 'secondary';
            if (type === 'primary') {
                localStorage.setItem('primaryModelConfig', configId);
                console.log(`[æ¨¡å‹é…ç½®] å·²ä¿å­˜ä¸»è¦é…ç½®é€‰æ‹©: ${configId}`);
            } else {
                localStorage.setItem('secondaryModelConfig', configId);
                console.log(`[æ¨¡å‹é…ç½®] å·²ä¿å­˜æ¬¡è¦é…ç½®é€‰æ‹©: ${configId}`);
            }
            
        } catch (error) {
            console.error('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error);
            modelSelect.innerHTML = '<option value="">è·å–æ¨¡å‹å¤±è´¥</option>';
        }
        
    } catch (error) {
        console.error('loadModelsForConfig å¤±è´¥:', error);
    }
}

/**
 * ä¿å­˜æ¨¡å‹é€‰æ‹©åˆ°localStorage
 * @param {string} type - 'primary' æˆ– 'secondary'
 */
/**
 * è·å–å½“å‰ä½¿ç”¨çš„æ¨¡å‹åç§°ï¼ˆä¸»è¦æ¨¡å‹ï¼‰
 */
async function getCurrentModel() {
    try {
        if (window.modelSettings && window.modelSettings.primaryModel) {
            return window.modelSettings.primaryModel;
        }

        const modelConfig = await window.apiConfigManager.getGlobalModelConfig();
        return modelConfig.primaryModel || '';
    } catch (error) {
        console.error('è·å–å½“å‰æ¨¡å‹å¤±è´¥:', error);
        return '';
    }
}

/**
 * è·å–å½“å‰ä½¿ç”¨çš„æ¬¡è¦æ¨¡å‹åç§°
 */
async function getCurrentSecondaryModel() {
    try {
        if (window.modelSettings && window.modelSettings.secondaryModel) {
            return window.modelSettings.secondaryModel;
        }

        const modelConfig = await window.apiConfigManager.getGlobalModelConfig();
        return modelConfig.secondaryModel || '';
    } catch (error) {
        console.error('è·å–å½“å‰æ¬¡è¦æ¨¡å‹å¤±è´¥:', error);
        return '';
    }
}

/**
 * è·å–å®Œæ•´çš„APIè°ƒç”¨ä¿¡æ¯ï¼ˆåŒ…å«è¿æ¥ä¿¡æ¯å’Œæ¨¡å‹ä¿¡æ¯ï¼‰
 */
async function getApiCallInfo() {
    try {
        const connection = await window.apiConfigManager.getCurrentApiConnection();
        return {
            url: connection.url,
            key: connection.key,
            model: connection.primaryModel,
            secondaryModel: connection.secondaryModel,
            timeout: connection.timeout,
            contextMessageCount: connection.contextMessageCount
        };
    } catch (error) {
        console.error('è·å–APIè°ƒç”¨ä¿¡æ¯å¤±è´¥:', error);
        throw error;
    }
}

async function saveModelSelection(type) {
    try {
        const configSelectId = type === 'primary' ? 'primaryConfigSelect' : 'secondaryConfigSelect';
        const modelSelectId = type === 'primary' ? 'primaryModelSelect' : 'secondaryModelSelect';

        const configSelect = document.getElementById(configSelectId);
        const modelSelect = document.getElementById(modelSelectId);

        if (configSelect && modelSelect) {
            const configId = configSelect.value;
            const modelId = modelSelect.value;

            // è·å–å½“å‰çš„å…¨å±€æ¨¡å‹é…ç½®
            const currentModelConfig = await window.apiConfigManager.getGlobalModelConfig();

            if (type === 'primary') {
                // ä¿å­˜åˆ°å…¨å±€æ¨¡å‹é…ç½®
                await window.apiConfigManager.saveGlobalModelConfig({
                    apiConfigId: configId,
                    primaryModel: modelId,
                    secondaryModel: currentModelConfig.secondaryModel || '' // ä¿æŒæ¬¡è¦æ¨¡å‹ä¸å˜
                });
                console.log(`[æ¨¡å‹é€‰æ‹©] å·²ä¿å­˜ä¸»è¦æ¨¡å‹: é…ç½®=${configId}, æ¨¡å‹=${modelId}`);
            } else {
                // ä¿å­˜åˆ°å…¨å±€æ¨¡å‹é…ç½®
                await window.apiConfigManager.saveGlobalModelConfig({
                    apiConfigId: currentModelConfig.apiConfigId || configId, // ä½¿ç”¨å½“å‰APIé…ç½®ID
                    primaryModel: currentModelConfig.primaryModel || '', // ä¿æŒä¸»è¦æ¨¡å‹ä¸å˜
                    secondaryModel: modelId
                });
                console.log(`[æ¨¡å‹é€‰æ‹©] å·²ä¿å­˜æ¬¡è¦æ¨¡å‹: é…ç½®=${configId}, æ¨¡å‹=${modelId}`);
            }

            // TODO: å…¼å®¹æ€§ä»£ç å— - éœ€è¦é€æ­¥è¿ç§»
            // è¿™ä¸ªä»£ç å—æ˜¯ä¸ºäº†åœ¨é‡æ„æœŸé—´ä¿æŒå‘åå…¼å®¹æ€§è€Œæ·»åŠ çš„ã€‚
            // å®ƒæ›´æ–°å…¨å±€ window.apiSettings ä»¥ç¡®ä¿ä¾èµ–æ—§APIçš„ä»£ç æ­£å¸¸å·¥ä½œã€‚
            //
            // è¿ç§»è®¡åˆ’ï¼š
            // 1. é¦–å…ˆè¿ç§» utils/ ç›®å½•ä¸‹çš„æ–‡ä»¶ï¼Œä½¿ç”¨ getApiCallInfo() æ›¿ä»£ç›´æ¥è®¿é—® window.apiSettings
            // 2. ç„¶åè¿ç§» script.js ä¸­çš„å…¶ä»–å‡½æ•°
            // 3. æœ€åç§»é™¤è¿™ä¸ªå…¼å®¹æ€§ä»£ç å—
            //
            // ç›¸å…³ä¾èµ–ä½ç½®ï¼š
            // - utils/characterMemory.js (7å¤„å¼•ç”¨)
            // - utils/memoryTable.js (5å¤„å¼•ç”¨)
            // - utils/uiUtils.js (3å¤„å¼•ç”¨)
            // - utils/apiConfigManager.js (3å¤„å¼•ç”¨)
            // - script.js (11å¤„å¼•ç”¨)
            if (type === 'primary' && window.apiSettings) {
                // è·å–å®Œæ•´çš„APIè¿æ¥ä¿¡æ¯
                const connection = await window.apiConfigManager.getCurrentApiConnection();
                Object.assign(window.apiSettings, {
                    url: connection.url,
                    key: connection.key,
                    timeout: connection.timeout,
                    contextMessageCount: connection.contextMessageCount
                });
                // æ¨¡å‹ä¿¡æ¯ç°åœ¨å­˜å‚¨åœ¨window.modelSettingsä¸­
                console.log('å…¨å±€APIè®¾ç½®å·²æ›´æ–° - è¿™æ˜¯ä¸´æ—¶å…¼å®¹æ€§ä»£ç ï¼Œå°†æ¥ä¼šè¢«ç§»é™¤');
            }
        }
    } catch (error) {
        console.error('ä¿å­˜æ¨¡å‹é€‰æ‹©å¤±è´¥:', error);
    }
}

async function getApiConnectionForModel(modelType) {
    try {
        if (modelType === 'primary') {
            const configId = localStorage.getItem('primaryModelConfig');
            const modelId = localStorage.getItem('primaryModel');
            
            if (!configId || !modelId) {
                throw new Error('ä¸»è¦æ¨¡å‹é…ç½®æœªè®¾ç½®');
            }
            
            const config = await window.apiConfigManager.getConfigById(configId);
            if (!config) {
                throw new Error('APIé…ç½®ä¸å­˜åœ¨');
            }
            
            return {
                baseURL: config.url,
                apiKey: config.key,
                timeout: config.timeout,
                model: modelId,
                configId: configId
            };
            
        } else if (modelType === 'secondary') {
            const configId = localStorage.getItem('secondaryModelConfig');
            const modelId = localStorage.getItem('secondaryModel');
            
            if (!configId || configId === 'sync_with_primary' || !modelId || modelId === 'sync_with_primary') {
                // ä½¿ç”¨ä¸»è¦æ¨¡å‹çš„é…ç½®
                return await getApiConnectionForModel('primary');
            }
            
            const config = await window.apiConfigManager.getConfigById(configId);
            if (!config) {
                throw new Error('æ¬¡è¦æ¨¡å‹APIé…ç½®ä¸å­˜åœ¨');
            }
            
            return {
                baseURL: config.url,
                apiKey: config.key,
                timeout: config.timeout,
                model: modelId,
                configId: configId
            };
        }
        
        throw new Error('æœªçŸ¥çš„æ¨¡å‹ç±»å‹');
        
    } catch (error) {
        console.error('è·å–APIè¿æ¥ä¿¡æ¯å¤±è´¥:', error);
        throw error;
    }
}

// APIé…ç½®ç®¡ç†é¡µé¢å‡½æ•°
async function loadApiConfigManagementPage() {
    try {
        if (!window.apiConfigManager) return;
        
        const configs = await window.apiConfigManager.getAllConfigs();
        const configList = document.getElementById('apiConfigList');
        
        if (!configList) return;
        
        if (configs.length === 0) {
            configList.innerHTML = `
                <div class="config-list-empty">
                    <div class="empty-icon">âš™ï¸</div>
                    <div class="empty-text">æš‚æ— APIé…ç½®</div>
                    <button class="empty-action-btn" onclick="showNewApiConfigForm()">æ·»åŠ ç¬¬ä¸€ä¸ªé…ç½®</button>
                </div>
            `;
        } else {
            configList.innerHTML = configs.map(config => `
                <div class="config-item" onclick="editApiConfigInPage('${config.id}')">
                    <div class="config-item-header">
                        <div class="config-item-name">${config.configName}</div>
                        <div class="config-item-actions">
                            <button class="config-item-btn config-item-edit" onclick="event.stopPropagation(); editApiConfigInPage('${config.id}')" title="ç¼–è¾‘">âœï¸</button>
                            <button class="config-item-btn config-item-delete" onclick="event.stopPropagation(); deleteApiConfigInPage('${config.id}')" title="åˆ é™¤">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div class="config-item-url">${config.url}</div>
                    <div class="config-item-status active">å·²é…ç½®</div>
                </div>
            `).join('');
        }
        
    } catch (error) {
        console.error('åŠ è½½APIé…ç½®åˆ—è¡¨å¤±è´¥:', error);
    }
}

function showNewApiConfigForm() {
    // æ¸…ç©ºè¡¨å•
    document.getElementById('pageConfigName').value = 'æ–°é…ç½® ' + Date.now().toString().slice(-6);
    document.getElementById('pageApiUrl').value = '';
    document.getElementById('pageApiKey').value = '';
    document.getElementById('pageApiTimeout').value = '60';
    
    // è®¾ç½®è¡¨å•æ ‡é¢˜å’ŒçŠ¶æ€
    document.getElementById('configFormTitle').textContent = 'æ–°å¢APIé…ç½®';
    window.currentEditingConfigId = null;
    
    // æ˜¾ç¤ºè¡¨å•
    document.getElementById('apiConfigForm').style.display = 'block';
}

function closeApiConfigForm() {
    document.getElementById('apiConfigForm').style.display = 'none';
    window.currentEditingConfigId = null;
}

async function editApiConfigInPage(configId) {
    try {
        const config = await window.apiConfigManager.getConfigById(configId);
        if (!config) return;
        
        // å¡«å……è¡¨å•
        document.getElementById('pageConfigName').value = config.configName || '';
        document.getElementById('pageApiUrl').value = config.url || '';
        document.getElementById('pageApiKey').value = config.key || '';
        document.getElementById('pageApiTimeout').value = config.timeout || 60;
        
        // è®¾ç½®è¡¨å•æ ‡é¢˜å’ŒçŠ¶æ€
        document.getElementById('configFormTitle').textContent = 'ç¼–è¾‘APIé…ç½®';
        window.currentEditingConfigId = configId;
        
        // æ˜¾ç¤ºè¡¨å•
        document.getElementById('apiConfigForm').style.display = 'block';
        
    } catch (error) {
        console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
        showToast('åŠ è½½é…ç½®å¤±è´¥: ' + error.message);
    }
}

async function deleteApiConfigInPage(configId) {
    try {
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªAPIé…ç½®å—ï¼Ÿ')) return;
        
        await window.apiConfigManager.deleteConfig(configId);
        showToast('é…ç½®åˆ é™¤æˆåŠŸ');
        
        // é‡æ–°åŠ è½½åˆ—è¡¨
        await loadApiConfigManagementPage();
        
    } catch (error) {
        console.error('åˆ é™¤é…ç½®å¤±è´¥:', error);
        showToast('åˆ é™¤é…ç½®å¤±è´¥: ' + error.message);
    }
}

async function saveApiConfigInPage(event) {
    event.preventDefault();
    
    try {
        const configData = {
            configId: window.currentEditingConfigId,
            configName: document.getElementById('pageConfigName').value.trim(),
            url: document.getElementById('pageApiUrl').value.trim(),
            key: document.getElementById('pageApiKey').value.trim(),
            timeout: parseInt(document.getElementById('pageApiTimeout').value) || 60
        };
        
        if (!configData.configName || !configData.url || !configData.key) {
            showToast('è¯·å¡«å†™å®Œæ•´çš„é…ç½®ä¿¡æ¯');
            return;
        }
        
        await window.apiConfigManager.saveConfig(configData);
        showToast(window.currentEditingConfigId ? 'é…ç½®æ›´æ–°æˆåŠŸ' : 'é…ç½®ä¿å­˜æˆåŠŸ');
        
        // å…³é—­è¡¨å•å¹¶é‡æ–°åŠ è½½åˆ—è¡¨
        closeApiConfigForm();
        await loadApiConfigManagementPage();
        
        // è‡ªåŠ¨å…³é—­APIé…ç½®ç®¡ç†é¡µé¢ï¼Œè¿”å›åˆ°æˆ‘çš„ç•Œé¢
        setTimeout(() => {
            showPage('profilePage');
        }, 1000); // å»¶è¿Ÿ1ç§’è®©ç”¨æˆ·çœ‹åˆ°æˆåŠŸæç¤º
        
    } catch (error) {
        console.error('ä¿å­˜é…ç½®å¤±è´¥:', error);
        showToast('ä¿å­˜é…ç½®å¤±è´¥: ' + error.message);
    }
}

async function testApiConnectionInPage(event) {
    try {
        const url = document.getElementById('pageApiUrl').value.trim();
        const key = document.getElementById('pageApiKey').value.trim();
        const timeout = parseInt(document.getElementById('pageApiTimeout').value) || 60;
        
        if (!url || !key) {
            showToast('è¯·å…ˆå¡«å†™API URLå’ŒAPI Key');
            return;
        }
        
        const button = event.target;
        button.disabled = true;
        button.textContent = 'æµ‹è¯•ä¸­...';
        
        const response = await fetch(`${url}/models`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
            },
            timeout: timeout * 1000
        });
        
        if (response.ok) {
            const data = await response.json();
            showToast(`è¿æ¥æˆåŠŸï¼æ‰¾åˆ° ${data.data?.length || 0} ä¸ªæ¨¡å‹`);
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
    } catch (error) {
        console.error('æµ‹è¯•è¿æ¥å¤±è´¥:', error);
        showToast('è¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message);
    } finally {
        const button = event.target;
        button.disabled = false;
        button.textContent = 'æµ‹è¯•è¿æ¥';
    }
}

async function setBackground(event) {
    event.preventDefault();
    if (!currentContact) return;
    const url = document.getElementById('backgroundUrl').value;
    if (url) backgrounds[currentContact.id] = url;
    else delete backgrounds[currentContact.id];
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    openChat(currentContact);
    closeModal('backgroundModal');
    showToast('èƒŒæ™¯è®¾ç½®æˆåŠŸ');
}

async function addEmoji(event) {
    event.preventDefault();
    const meaning = document.getElementById('emojiMeaning').value.trim();
    if (emojis.some(e => e.tag === meaning)) {
        showToast('è¯¥è¡¨æƒ…æ ‡ç­¾å·²å­˜åœ¨ï¼Œè¯·ä½¿ç”¨å…¶ä»–æ ‡ç­¾ã€‚');
        return;
    }
    
    const imageUrl = document.getElementById('emojiUrl').value;
    
    // å¤„ç†ä¸´æ—¶URLçš„æƒ…å†µï¼šå¦‚æœæ˜¯ä¸´æ—¶URLä½†è¿˜æœ‰ä¸´æ—¶æ–‡ä»¶ï¼Œå…ˆè½¬æ¢å­˜å‚¨
    if (imageUrl.startsWith('temp:') && window.ImageUploadHandlers.tempEmojiFile) {
        try {
            const statusElement = document.getElementById('emojiUploadStatus');
            await window.ImageUploadHandlers.storeEmojiWithMeaning(window.ImageUploadHandlers.tempEmojiFile, meaning, statusElement);
            
            // æ¸…ç†ä¸´æ—¶æ•°æ®
            const tempUrl = imageUrl.substring(5);
            URL.revokeObjectURL(tempUrl);
            window.ImageUploadHandlers.tempEmojiFile = null;
            
            // è·å–æ–°çš„fileId URL
            const newImageUrl = document.getElementById('emojiUrl').value;
            
            if (!newImageUrl.startsWith('file:')) {
                showToast('æ–‡ä»¶å­˜å‚¨å¤±è´¥ï¼Œè¯·é‡è¯•');
                return;
            }
        } catch (error) {
            console.error('ä¸´æ—¶æ–‡ä»¶è½¬æ¢å¤±è´¥:', error);
            showToast('æ–‡ä»¶å­˜å‚¨å¤±è´¥ï¼Œè¯·é‡è¯•');
            return;
        }
    }
    
    const finalImageUrl = document.getElementById('emojiUrl').value;
    
    // å¤„ç†ä¸åŒæ ¼å¼çš„å›¾ç‰‡
    let imageData = finalImageUrl;
    if (finalImageUrl.startsWith('file:')) {
        // æ–°çš„fileSystemæ ¼å¼ - è¡¨æƒ…åŒ…å·²ç»åœ¨ä¸Šä¼ æ—¶ä¿å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿ
        // åªéœ€è¦ä¿å­˜emojiè®°å½•å³å¯ï¼Œä¸éœ€è¦é¢å¤–å¤„ç†
        imageData = finalImageUrl; // ä¿ç•™file:fileIdæ ¼å¼ç”¨äºå¼•ç”¨
    } else if (finalImageUrl.startsWith('data:image/')) {
        // ä¼ ç»Ÿçš„base64æ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼Œä½†æ–°ç‰ˆæœ¬åº”è¯¥ä¸ä¼šç”¨åˆ°ï¼‰
        await saveEmojiImage(meaning, finalImageUrl);
        imageData = `[emoji:${meaning}]`; // å†…éƒ¨å­˜å‚¨æ ¼å¼
    } else if (finalImageUrl.startsWith('temp:')) {
        showToast('æ–‡ä»¶å°šæœªæ­£ç¡®å­˜å‚¨ï¼Œè¯·é‡æ–°ä¸Šä¼ ');
        return;
    } else {
        showToast('æ— æ•ˆçš„å›¾ç‰‡æ ¼å¼ï¼Œè¯·é‡æ–°ä¸Šä¼ ');
        return;
    }
    
    const emoji = { 
        id: Date.now().toString(), 
        tag: meaning,  // ä½¿ç”¨tagè€Œä¸æ˜¯meaning
        meaning: meaning, // ä¿ç•™meaningç”¨äºæ˜¾ç¤º
        // æ–°å¢ï¼šå¦‚æœæ˜¯fileIdæ ¼å¼ï¼Œä¿å­˜fileIdå­—æ®µ
        ...(finalImageUrl.startsWith('file:') ? { fileId: finalImageUrl.substring(5) } : {})
    };
    emojis.push(emoji);
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    renderEmojiGrid();
    closeModal('addEmojiModal');
    showToast('è¡¨æƒ…æ·»åŠ æˆåŠŸ');
    event.target.reset();
}

async function deleteEmoji(emojiId) {
    showConfirmDialog('åˆ é™¤ç¡®è®¤', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè¡¨æƒ…å—ï¼Ÿ', async () => {
        const emojiToDelete = emojis.find(e => e.id === emojiId);
        if (emojiToDelete && emojiToDelete.tag) {
            // åˆ é™¤å¯¹åº”çš„å›¾ç‰‡æ•°æ®
            await deleteEmojiImage(emojiToDelete.tag);
        }
        emojis = emojis.filter(e => e.id !== emojiId);
        await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
        renderEmojiGrid();
        showToast('è¡¨æƒ…å·²åˆ é™¤');
    });
}

async function renderEmojiGrid() {
    const grid = document.getElementById('emojiGrid');
    grid.innerHTML = '';
    
    for (const emoji of emojis) {
        const item = document.createElement('div');
        item.className = 'emoji-item';
        
        // è·å–è¡¨æƒ…å›¾ç‰‡
        let imageSrc;
        if (emoji.tag) {
            // æ–°æ ¼å¼ï¼šä»emojiImageså­˜å‚¨è·å–
            imageSrc = await getEmojiImage(emoji.tag);
        } else if (emoji.url) {
            // æ—§æ ¼å¼ï¼šç›´æ¥ä½¿ç”¨URL
            imageSrc = emoji.url;
        }
        
        if (imageSrc) {
            item.innerHTML = `<img src="${imageSrc}"><div class="emoji-delete-btn" onclick="event.stopPropagation(); deleteEmoji('${emoji.id}')">Ã—</div>`;
            item.onclick = () => sendEmoji(emoji);
        } else {
            // å¦‚æœæ²¡æœ‰å›¾ç‰‡æ•°æ®ï¼Œæ˜¾ç¤ºå ä½ç¬¦
            item.innerHTML = `<div style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; width: 80px; height: 80px; border-radius: 8px;">${emoji.meaning || emoji.tag || '?'}</div><div class="emoji-delete-btn" onclick="event.stopPropagation(); deleteEmoji('${emoji.id}')">Ã—</div>`;
            item.onclick = () => sendEmoji(emoji);
        }
        
        grid.appendChild(item);
    }
    
    const addBtn = document.createElement('div');
    addBtn.className = 'add-emoji-btn';
    addBtn.textContent = '+ æ·»åŠ è¡¨æƒ…';
    addBtn.onclick = showAddEmojiModal;
    grid.appendChild(addBtn);
}

async function sendRedPacket(event) {
    event.preventDefault();
    if (!currentContact) return;
    const amount = document.getElementById('redPacketAmount').value;
    const message = document.getElementById('redPacketMessage').value || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼';
    if (amount <= 0) { showToast('çº¢åŒ…é‡‘é¢å¿…é¡»å¤§äº0'); return; }
    const packetData = { amount: parseFloat(amount).toFixed(2), message };
    const packetMessage = { role: 'user', content: JSON.stringify(packetData), type: 'red_packet', time: new Date().toISOString(), senderId: 'user' };
    currentContact.messages.push(packetMessage);
    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
        currentlyDisplayedMessageCount++;
    }
    currentContact.lastMessage = '[çº¢åŒ…]';
    currentContact.lastTime = formatContactListTime(new Date().toISOString());
    // ä½¿ç”¨addSingleMessageæ·»åŠ æ¶ˆæ¯åˆ°ç•Œé¢ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
    await addSingleMessage(packetMessage, true);
    await renderContactList();
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    closeModal('redPacketModal');
    await sendMessage();
}

async function sendEmoji(emoji) {
    if (!currentContact) return;
    // ä½¿ç”¨æ–°çš„[emoji:tag]æ ¼å¼å­˜å‚¨
    const content = emoji.tag ? `[emoji:${emoji.tag}]` : emoji.url;
    const emojiMessage = { role: 'user', content: content, type: 'emoji', time: new Date().toISOString(), senderId: 'user' };
    currentContact.messages.push(emojiMessage);
    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
        currentlyDisplayedMessageCount++;
    }
    currentContact.lastMessage = '[è¡¨æƒ…]';
    currentContact.lastTime = formatContactListTime(new Date().toISOString());
    // ä½¿ç”¨addSingleMessageæ·»åŠ æ¶ˆæ¯åˆ°ç•Œé¢ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
    await addSingleMessage(emojiMessage, true);
    await renderContactList();
    await saveDataToDB(); // ä½¿ç”¨IndexedDBä¿å­˜
    toggleEmojiPanel(true);
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
        return;
    }
    showTypingIndicator();
    try {
        const { replies } = await callAPI(currentContact);
        hideTypingIndicator();
        
        // å¼‚æ­¥æ›´æ–°è®°å¿†è¡¨æ ¼ï¼ˆä½¿ç”¨APIé˜Ÿåˆ—ï¼Œä¸é˜»å¡ç”¨æˆ·æ“ä½œï¼‰
        if (window.updateMemoryTableWithSecondaryModel) {
            window.updateMemoryTableWithSecondaryModel(currentContact, true);
        }
        if (!replies || replies.length === 0) { showTopNotification('AIæ²¡æœ‰è¿”å›æœ‰æ•ˆå›å¤'); return; }
        for (const response of replies) {
            await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
            const aiMessage = { role: 'assistant', content: removeThinkingChain(response.content), type: response.type, time: new Date().toISOString(), senderId: currentContact.id };
            currentContact.messages.push(aiMessage);
            if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                currentlyDisplayedMessageCount++;
            }
            currentContact.lastMessage = response.type === 'text' ? response.content.substring(0, 20) + '...' : '[è¡¨æƒ…]';
            currentContact.lastTime = formatContactListTime(new Date().toISOString());
            // ä½¿ç”¨addSingleMessageæ·»åŠ AIå›å¤æ¶ˆæ¯ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await addSingleMessage(aiMessage, true);
            await renderContactList();
            await saveDataToDB();
        }
    } catch (error) {
        hideTypingIndicator();
        console.error('AIå›å¤é”™è¯¯:', error);
        showApiError(error);
    }
}

function toggleEmojiPanel(forceClose = false) {
    const panel = document.getElementById('emojiPanel');
    if (forceClose) {
        panel.style.display = 'none';
        return;
    }
    const isVisible = panel.style.display === 'block';
    // æ‡’åŠ è½½ï¼šç¬¬ä¸€æ¬¡æ‰“å¼€æ—¶æ‰æ¸²æŸ“
    if (!isVisible && !isEmojiGridRendered) {
        renderEmojiGrid();
        isEmojiGridRendered = true;
    }
    panel.style.display = isVisible ? 'none' : 'block';
}

// æ‰“å¼€è”ç³»äººè®¾ç½®é¡µé¢
// é¡µé¢å¯¼èˆªå†å²ç®¡ç†å™¨
class PageNavigationManager {
    constructor() {
        this.navigationHistory = [];
        this.currentPage = null;
    }
    
    /**
     * è®°å½•é¡µé¢åˆ‡æ¢
     * @param {string} fromPage - æºé¡µé¢ID
     * @param {string} toPage - ç›®æ ‡é¡µé¢ID
     */
    navigateTo(fromPage, toPage) {
        if (fromPage && fromPage !== toPage) {
            // é¿å…é‡å¤è®°å½•ç›¸åŒçš„å¯¼èˆª
            const lastEntry = this.navigationHistory[this.navigationHistory.length - 1];
            if (!lastEntry || lastEntry.from !== fromPage || lastEntry.to !== toPage) {
                this.navigationHistory.push({
                    from: fromPage,
                    to: toPage,
                    timestamp: Date.now()
                });
            }
        }
        this.currentPage = toPage;
    }
    
    /**
     * è·å–å‰ä¸€ä¸ªé¡µé¢ID
     * @param {string} currentPageId - å½“å‰é¡µé¢ID
     * @returns {string|null} å‰ä¸€ä¸ªé¡µé¢IDï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›é»˜è®¤é¡µé¢
     */
    getPreviousPage(currentPageId = null) {
        const pageId = currentPageId || this.currentPage;
        
        // ä»å†å²è®°å½•ä¸­æŸ¥æ‰¾æœ€åä¸€æ¬¡è¿›å…¥å½“å‰é¡µé¢çš„æ¥æº
        for (let i = this.navigationHistory.length - 1; i >= 0; i--) {
            const entry = this.navigationHistory[i];
            if (entry.to === pageId) {
                return entry.from;
            }
        }
        
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å†å²è®°å½•ï¼Œè¿”å›é»˜è®¤é¡µé¢
        return this.getDefaultReturnPage(pageId);
    }
    
    /**
     * è·å–é»˜è®¤è¿”å›é¡µé¢
     * @param {string} currentPageId - å½“å‰é¡µé¢ID
     * @returns {string} é»˜è®¤é¡µé¢ID
     */
    getDefaultReturnPage(currentPageId) {
        const pageDefaults = {
            'contactSettingsPage': 'chatPage',
            'userProfilePage': 'chatPage',
            'momentsPage': 'chatPage',
            'weiboPage': 'chatPage'
        };
        
        return pageDefaults[currentPageId] || 'chatPage';
    }
    
    /**
     * æ¸…ç†è¿‡æœŸçš„å¯¼èˆªå†å²ï¼ˆä¿ç•™æœ€è¿‘50æ¡è®°å½•ï¼‰
     */
    cleanupHistory() {
        if (this.navigationHistory.length > 50) {
            this.navigationHistory = this.navigationHistory.slice(-50);
        }
    }
    
    /**
     * è·å–å½“å‰æ¿€æ´»çš„é¡µé¢ID
     * @returns {string|null}
     */
    getCurrentActivePage() {
        const activePages = document.querySelectorAll('.main-container > div.active');
        if (activePages.length > 0) {
            return activePages[0].id;
        }
        return null;
    }
}

/**
 * é€šç”¨é¡µé¢åˆ‡æ¢å‡½æ•°
 * @param {string} fromPageId - æºé¡µé¢ID
 * @param {string} toPageId - ç›®æ ‡é¡µé¢ID
 * @param {Object} options - åˆ‡æ¢é€‰é¡¹
 * @param {boolean} options.recordHistory - æ˜¯å¦è®°å½•å¯¼èˆªå†å²ï¼Œé»˜è®¤true
 * @param {number} options.animationDelay - åŠ¨ç”»å»¶è¿Ÿæ—¶é—´ï¼Œé»˜è®¤300ms
 */
function navigateToPage(fromPageId, toPageId, options = {}) {
    const {
        recordHistory = true,
        animationDelay = 300
    } = options;
    
    const fromPage = document.getElementById(fromPageId);
    const toPage = document.getElementById(toPageId);
    
    if (!toPage) {
        console.error(`ç›®æ ‡é¡µé¢ ${toPageId} ä¸å­˜åœ¨`);
        return false;
    }
    
    // è®°å½•å¯¼èˆªå†å²
    if (recordHistory && fromPageId && fromPageId !== toPageId) {
        pageNavManager.navigateTo(fromPageId, toPageId);
    }
    
    // å¦‚æœæœ‰æºé¡µé¢ï¼Œå…ˆæ‰§è¡Œé€€å‡ºåŠ¨ç”»
    if (fromPage && fromPage.classList.contains('active')) {
        fromPage.classList.remove('active');
        
        setTimeout(() => {
            fromPage.style.display = 'none';
            showTargetPage();
        }, animationDelay);
    } else {
        showTargetPage();
    }
    
    function showTargetPage() {
        // éšè—æ‰€æœ‰å…¶ä»–æ´»è·ƒé¡µé¢
        const allPages = document.querySelectorAll('.main-container > div.active');
        allPages.forEach(page => {
            if (page.id !== toPageId) {
                page.classList.remove('active');
            }
        });
        
        // æ˜¾ç¤ºç›®æ ‡é¡µé¢
        toPage.style.display = 'block';
        requestAnimationFrame(() => {
            toPage.classList.add('active');
        });
    }
    
    return true;
}

/**
 * æ™ºèƒ½å…³é—­å½“å‰é¡µé¢å¹¶è¿”å›åˆ°ä¹‹å‰é¡µé¢
 * @param {string} currentPageId - å½“å‰é¡µé¢ID
 * @param {Object} options - é€‰é¡¹
 */
function smartClosePage(currentPageId, options = {}) {
    const returnPageId = pageNavManager.getPreviousPage(currentPageId);
    return navigateToPage(currentPageId, returnPageId, options);
}

// è°ƒè¯•å’Œæµ‹è¯•å·¥å…·å‡½æ•°
const NavigationDebugger = {
    /**
     * è·å–å½“å‰å¯¼èˆªçŠ¶æ€ä¿¡æ¯
     */
    getNavigationState() {
        return {
            currentPage: pageNavManager.currentPage,
            activePage: pageNavManager.getCurrentActivePage(),
            historyLength: pageNavManager.navigationHistory.length,
            recentHistory: pageNavManager.navigationHistory.slice(-5),
            lastNavigation: pageNavManager.navigationHistory[pageNavManager.navigationHistory.length - 1]
        };
    },
    
    /**
     * æ‰“å°å¯¼èˆªå†å²åˆ°æ§åˆ¶å°
     */
    printNavigationHistory() {
        console.group('ğŸ§­ é¡µé¢å¯¼èˆªå†å²');
        console.log('å½“å‰é¡µé¢:', pageNavManager.currentPage);
        console.log('DOMæ´»è·ƒé¡µé¢:', pageNavManager.getCurrentActivePage());
        console.log('å†å²è®°å½•æ€»æ•°:', pageNavManager.navigationHistory.length);
        
        console.group('æœ€è¿‘5æ¬¡å¯¼èˆª:');
        pageNavManager.navigationHistory.slice(-5).forEach((entry, index) => {
            const time = new Date(entry.timestamp).toLocaleTimeString();
            console.log(`${index + 1}. ${time}: ${entry.from} â†’ ${entry.to}`);
        });
        console.groupEnd();
        
        console.groupEnd();
    },
    
    /**
     * æ¨¡æ‹Ÿæµ‹è¯•å¯¼èˆªæµç¨‹
     */
    testNavigationFlow() {
        console.group('ğŸ§ª å¯¼èˆªç³»ç»Ÿæµ‹è¯•');
        
        // æµ‹è¯•åœºæ™¯1ï¼šchatPage â†’ contactSettingsPage â†’ è¿”å›
        console.log('æµ‹è¯•åœºæ™¯1: èŠå¤©é¡µé¢ â†’ è®¾ç½®é¡µé¢ â†’ æ™ºèƒ½è¿”å›');
        pageNavManager.navigateTo('chatPage', 'contactSettingsPage');
        const returnPage1 = pageNavManager.getPreviousPage('contactSettingsPage');
        console.log(`æœŸæœ›è¿”å›: chatPage, å®é™…è¿”å›: ${returnPage1}`);
        
        // æµ‹è¯•åœºæ™¯2ï¼šmomentsPage â†’ contactSettingsPage â†’ è¿”å›
        console.log('æµ‹è¯•åœºæ™¯2: æœ‹å‹åœˆé¡µé¢ â†’ è®¾ç½®é¡µé¢ â†’ æ™ºèƒ½è¿”å›');
        pageNavManager.navigateTo('momentsPage', 'contactSettingsPage');
        const returnPage2 = pageNavManager.getPreviousPage('contactSettingsPage');
        console.log(`æœŸæœ›è¿”å›: momentsPage, å®é™…è¿”å›: ${returnPage2}`);
        
        // æµ‹è¯•åœºæ™¯3ï¼šæ²¡æœ‰å†å²è®°å½•æ—¶çš„é»˜è®¤è¿”å›
        pageNavManager.navigationHistory.length = 0; // æ¸…ç©ºå†å²
        const returnPage3 = pageNavManager.getPreviousPage('contactSettingsPage');
        console.log(`æ— å†å²è®°å½•æ—¶è¿”å›: ${returnPage3} (åº”ä¸ºé»˜è®¤é¡µé¢)`);
        
        console.groupEnd();
    }
};

// åœ¨å¼€å‘ç¯å¢ƒä¸‹æš´éœ²è°ƒè¯•å·¥å…·åˆ°å…¨å±€
if (typeof window !== 'undefined') {
    window.NavigationDebugger = NavigationDebugger;
    
    // æ·»åŠ å¿«æ·é”®ç”¨äºè°ƒè¯• (Ctrl+Shift+N)
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'N') {
            NavigationDebugger.printNavigationHistory();
        }
    });
}

// å…¨å±€é¡µé¢å¯¼èˆªç®¡ç†å™¨å®ä¾‹
const pageNavManager = new PageNavigationManager();

function openContactSettingsPage() {
    showContactSettingsPage();
}

// å·²ç§»é™¤åºŸå¼ƒçš„ toggleSettingsMenu å‡½æ•°ï¼Œè¯·ç›´æ¥ä½¿ç”¨ï¼š
// - openContactSettingsPage() æ‰“å¼€è®¾ç½®é¡µé¢
// - closeContactSettingsPage() å…³é—­è®¾ç½®é¡µé¢

function showContactSettingsPage() {
    if (!currentContact) {
        showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè”ç³»äºº');
        return;
    }
    
    const settingsPage = document.getElementById('contactSettingsPage');
    const settingsTitle = document.getElementById('contactSettingsTitle');
    
    // è®°å½•å½“å‰æ´»è·ƒé¡µé¢ï¼Œç”¨äºè¿”å›æ—¶å¯¼èˆª
    const currentActivePage = pageNavManager.getCurrentActivePage();
    if (currentActivePage && currentActivePage !== 'contactSettingsPage') {
        pageNavManager.navigateTo(currentActivePage, 'contactSettingsPage');
    }
    
    // è®¾ç½®æ ‡é¢˜ä¸ºå½“å‰è”ç³»äººåç§°
    settingsTitle.textContent = `${currentContact.name} - è®¾ç½®`;
    
    // æ˜¾ç¤ºé¡µé¢
    settingsPage.style.display = 'block';
    
    // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿æ ·å¼ç”Ÿæ•ˆåå†æ·»åŠ  active ç±»
    requestAnimationFrame(() => {
        settingsPage.classList.add('active');
    });
    
    // éšè—å…¶ä»–é¡µé¢
    const allPages = document.querySelectorAll('.main-container > div');
    allPages.forEach(page => {
        if (page.id !== 'contactSettingsPage') {
            page.classList.remove('active');
        }
    });
    
    // å®šæœŸæ¸…ç†å¯¼èˆªå†å²
    pageNavManager.cleanupHistory();
}

function closeContactSettingsPage() {
    const settingsPage = document.getElementById('contactSettingsPage');
    
    if (settingsPage.classList.contains('active')) {
        // è·å–åº”è¯¥è¿”å›åˆ°çš„é¡µé¢
        const returnPageId = pageNavManager.getPreviousPage('contactSettingsPage');
        let returnPage = document.getElementById(returnPageId);
        
        if (!returnPage) {
            console.warn(`è¿”å›é¡µé¢ ${returnPageId} ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤é¡µé¢ chatPage`);
            const chatPage = document.getElementById('chatPage');
            if (chatPage) {
                returnPage = chatPage;
            } else {
                console.error('chatPage ä¹Ÿä¸å­˜åœ¨ï¼Œæ— æ³•è¿”å›');
                return;
            }
        }
        
        // ç§»é™¤ active ç±»è§¦å‘æ»‘å‡ºåŠ¨ç”»
        settingsPage.classList.remove('active');
        
        // è®°å½•å¯¼èˆªå†å²
        pageNavManager.navigateTo('contactSettingsPage', returnPage.id);
        
        // ç­‰å¾…åŠ¨ç”»å®Œæˆåéšè—é¡µé¢å¹¶æ˜¾ç¤ºç›®æ ‡é¡µé¢
        setTimeout(() => {
            settingsPage.style.display = 'none';
            returnPage.classList.add('active');
        }, 300);
    }
}


async function clearMessages() {
    if (!currentContact) {
        showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©');
        return;
    }
    showConfirmDialog('æ¸…ç©ºèŠå¤©è®°å½•', 'ç¡®å®šè¦æ¸…ç©ºå½“å‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚', async () => {
        currentContact.messages = [];
        currentlyDisplayedMessageCount = 0; // é‡ç½®è®¡æ•°
        currentContact.lastMessage = 'æš‚æ— æ¶ˆæ¯';
        currentContact.lastTime = formatContactListTime(new Date().toISOString());
        renderMessages(false); // é‡æ–°æ¸²æŸ“ï¼Œä½†ä¸æ»šåŠ¨åˆ°åº•éƒ¨
        await renderContactList();
        await saveDataToDB();
        
        // æ¸…ç©ºè¯¥è§’è‰²çš„è®°å¿†æ•°æ®
        if (window.clearCharacterMemory) {
            await window.clearCharacterMemory(currentContact.id);
            console.log(`[æ¸…ç©ºèŠå¤©] å·²æ¸…ç©ºè§’è‰² ${currentContact.id} çš„è®°å¿†æ•°æ®`);
        }
        
        showToast('å·²æ¸…ç©ºèŠå¤©è®°å½•');
        closeContactSettingsPage(); // å…³é—­è®¾ç½®é¡µé¢
    });
}

/**
 * åˆ é™¤æŒ‡å®šç´¢å¼•çš„æ¶ˆæ¯
 * @param {number} messageIndex è¦åˆ é™¤çš„æ¶ˆæ¯çš„ç´¢å¼• (ç»å¯¹ç´¢å¼•)
 */
async function deleteMessage(messageIndex) {
    if (!currentContact || messageIndex === undefined || messageIndex < 0 || messageIndex >= currentContact.messages.length) {
        showToast('æ— æ•ˆçš„æ¶ˆæ¯ç´¢å¼•æˆ–æœªé€‰æ‹©èŠå¤©');
        return;
    }
    
    // ä¿å­˜è¢«åˆ é™¤çš„æ¶ˆæ¯ï¼Œç”¨äºè®°å¿†æ›´æ–°
    const deletedMessage = currentContact.messages[messageIndex];
    
    currentContact.messages.splice(messageIndex, 1);

    // å¦‚æœåˆ é™¤çš„æ˜¯å·²æ˜¾ç¤ºçš„æ¶ˆæ¯ï¼Œåˆ™æ›´æ–°è®¡æ•°
    const displayedMessagesStartRange = currentContact.messages.length - currentlyDisplayedMessageCount;
    if (messageIndex >= displayedMessagesStartRange) {
        currentlyDisplayedMessageCount = Math.max(0, currentlyDisplayedMessageCount - 1);
    }
    
    if (currentContact.messages.length > 0) {
        const lastMsg = currentContact.messages[currentContact.messages.length - 1];
        currentContact.lastMessage = lastMsg.type === 'text' ? lastMsg.content.substring(0, 20) + '...' : (lastMsg.type === 'emoji' ? '[è¡¨æƒ…]' : '[çº¢åŒ…]');
        currentContact.lastTime = formatContactListTime(lastMsg.time);
    } else {
        currentContact.lastMessage = 'æš‚æ— æ¶ˆæ¯';
        currentContact.lastTime = formatContactListTime(new Date().toISOString());
    }

    renderMessages(false); // é‡æ–°æ¸²æŸ“ï¼Œä½†ä¸æ»šåŠ¨åˆ°åº•éƒ¨
    await renderContactList();
    await saveDataToDB();
    
    // æ£€æŸ¥å¹¶æ›´æ–°è®°å¿†
    if (window.checkAndUpdateMemoryAfterDeletion && deletedMessage) {
        try {
            await window.checkAndUpdateMemoryAfterDeletion(currentContact.id, [deletedMessage], currentContact);
        } catch (error) {
            console.error('åˆ é™¤æ¶ˆæ¯åæ›´æ–°è®°å¿†å¤±è´¥:', error);
        }
    }
    
    showToast('æ¶ˆæ¯å·²åˆ é™¤');
}


/**
 * åˆ é™¤å½“å‰èŠå¤©å¯¹è±¡ï¼ˆè”ç³»äººæˆ–ç¾¤èŠï¼‰
 */
async function deleteCurrentContact() {
    if (!currentContact) {
        showToast('æ²¡æœ‰é€‰ä¸­ä»»ä½•èŠå¤©å¯¹è±¡');
        return;
    }
    showConfirmDialog('åˆ é™¤èŠå¤©å¯¹è±¡', `ç¡®å®šè¦åˆ é™¤ "${currentContact.name}" å—ï¼Ÿæ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰èŠå¤©è®°å½•ï¼Œä¸å¯æ’¤é”€ã€‚`, async () => {
        await deleteContact(currentContact.id);
        showToast('èŠå¤©å¯¹è±¡å·²åˆ é™¤');
        closeChatPage(); // å…³é—­èŠå¤©é¡µé¢å¹¶è¿”å›è”ç³»äººåˆ—è¡¨
        closeContactSettingsPage(); // åªåœ¨ç¡®è®¤åˆ é™¤åå…³é—­è®¾ç½®èœå•
    });
}

/**
 * ä»contactsæ•°ç»„å’ŒIndexedDBä¸­åˆ é™¤æŒ‡å®šIDçš„è”ç³»äººæˆ–ç¾¤èŠ
 * @param {string} contactId è¦åˆ é™¤çš„è”ç³»äºº/ç¾¤èŠçš„ID
 */
async function deleteContact(contactId) {
    if (!window.isIndexedDBReady) {
        showToast('æ•°æ®åº“æœªå‡†å¤‡å¥½ï¼Œæ— æ³•åˆ é™¤ã€‚');
        return;
    }

    const initialContactsLength = contacts.length;
    contacts = contacts.filter(c => c.id !== contactId);

    if (contacts.length === initialContactsLength) {
        // å¦‚æœé•¿åº¦æ²¡å˜ï¼Œè¯´æ˜æ²¡æ‰¾åˆ°è¯¥IDçš„è”ç³»äºº
        console.warn(`æœªæ‰¾åˆ°IDä¸º ${contactId} çš„è”ç³»äºº/ç¾¤èŠè¿›è¡Œåˆ é™¤ã€‚`);
        showToast('æœªæ‰¾åˆ°è¦åˆ é™¤çš„èŠå¤©å¯¹è±¡');
        return;
    }

    try {
        const transaction = window.db.transaction(['contacts'], 'readwrite');
        const store = transaction.objectStore('contacts');
        await promisifyRequest(store.delete(contactId)); // ä»IndexedDBåˆ é™¤

        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ­£åœ¨èŠå¤©çš„å¯¹è±¡ï¼Œéœ€è¦é‡ç½®currentContact
        if (currentContact && currentContact.id === contactId) {
            currentContact = null;
    window.currentContact = null;
        }

        await renderContactList(); // é‡æ–°æ¸²æŸ“è”ç³»äººåˆ—è¡¨
        await saveDataToDB(); // é‡æ–°ä¿å­˜contactsæ•°ç»„åˆ°IndexedDBï¼Œç¡®ä¿æ•°æ®åŒæ­¥
        
        // æ¸…ç©ºè¯¥è§’è‰²çš„è®°å¿†æ•°æ®
        if (window.clearCharacterMemory) {
            await window.clearCharacterMemory(contactId);
            console.log(`[åˆ é™¤è”ç³»äºº] å·²æ¸…ç©ºè§’è‰² ${contactId} çš„è®°å¿†æ•°æ®`);
        }
        
        showToast('èŠå¤©å¯¹è±¡å·²åˆ é™¤');
    } catch (error) {
        console.error('åˆ é™¤è”ç³»äºº/ç¾¤èŠå¤±è´¥:', error);
        showToast('åˆ é™¤å¤±è´¥ï¼š' + error.message);
    }
}

/**
 * æ˜¾ç¤ºè‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡†
 * @param {string} title å¯¹è¯æ¡†æ ‡é¢˜
 * @param {string} message å¯¹è¯æ¡†æ¶ˆæ¯
 * @param {function} onConfirm ç”¨æˆ·ç‚¹å‡»ç¡®è®¤æŒ‰é’®æ—¶æ‰§è¡Œçš„å›è°ƒ
 */
// showConfirmDialog function moved to utils/uiUtils.js

/**
 * æ˜¾ç¤ºæ¶ˆæ¯æ“ä½œèœå•ï¼ˆç¼–è¾‘/åˆ é™¤ï¼‰
 * @param {number} messageIndex æ¶ˆæ¯ç´¢å¼•
 * @param {HTMLElement} messageElement æ¶ˆæ¯DOMå…ƒç´ 
 */
/**
 * ä¸ºæ¶ˆæ¯å…ƒç´ æ·»åŠ é•¿æŒ‰å’Œå³é”®èœå•äº‹ä»¶ç›‘å¬å™¨
 * @param {HTMLElement} msgDiv - æ¶ˆæ¯å…ƒç´ 
 * @param {number} originalIndex - æ¶ˆæ¯åœ¨æ•°ç»„ä¸­çš„åŸå§‹ç´¢å¼•
 */
function addMessageActionListeners(msgDiv, originalIndex) {
    let msgPressTimer;
    msgDiv.addEventListener('touchstart', () => { 
        msgPressTimer = setTimeout(() => { 
            showMessageActionMenu(originalIndex, msgDiv); 
        }, 700); 
    });
    msgDiv.addEventListener('touchend', () => clearTimeout(msgPressTimer));
    msgDiv.addEventListener('touchmove', () => clearTimeout(msgPressTimer));
    msgDiv.addEventListener('contextmenu', (e) => { 
        e.preventDefault(); 
        showMessageActionMenu(originalIndex, msgDiv); 
    });
}

function showMessageActionMenu(messageIndex, messageElement) {
    const menuId = 'messageActionMenu';
    let menu = document.getElementById(menuId);
    
    if (!menu) {
        menu = document.createElement('div');
        menu.id = menuId;
        menu.className = 'modal';
        menu.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">æ¶ˆæ¯æ“ä½œ</div>
                    <div class="modal-close" onclick="closeModal('${menuId}')">å–æ¶ˆ</div>
                </div>
                <div class="modal-body">
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <button class="form-submit" style="background-color: #576b95;" id="editMessageBtn">ç¼–è¾‘</button>
                        <button class="form-submit" style="background-color: #ffa500;" id="multiSelectBtn">å¤šé€‰</button>
                        <button class="form-submit delete-button" id="deleteMessageBtn">åˆ é™¤</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(menu);
    }
    
    // è®¾ç½®æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('editMessageBtn').onclick = () => {
        closeModal(menuId);
        startEditMessage(messageIndex, messageElement);
    };
    
    document.getElementById('deleteMessageBtn').onclick = () => {
        closeModal(menuId);
        showConfirmDialog('åˆ é™¤æ¶ˆæ¯', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚', () => deleteMessage(messageIndex));
    };
    
    document.getElementById('multiSelectBtn').onclick = () => {
        closeModal(menuId);
        enterMultiSelectMode();
    };
    
    showModal(menuId);
}

/**
 * å¼€å§‹ç¼–è¾‘æ¶ˆæ¯
 * @param {number} messageIndex æ¶ˆæ¯ç´¢å¼•
 * @param {HTMLElement} messageElement æ¶ˆæ¯DOMå…ƒç´ 
 */
function startEditMessage(messageIndex, messageElement) {
    if (!currentContact || messageIndex === undefined || messageIndex < 0 || messageIndex >= currentContact.messages.length) {
        showToast('æ— æ•ˆçš„æ¶ˆæ¯ç´¢å¼•æˆ–æœªé€‰æ‹©èŠå¤©');
        return;
    }
    
    const message = currentContact.messages[messageIndex];
    
    // åˆ›å»ºç¼–è¾‘ç•Œé¢
    const editId = 'messageEditModal';
    let editModal = document.getElementById(editId);
    
    if (!editModal) {
        editModal = document.createElement('div');
        editModal.id = editId;
        editModal.className = 'modal';
        editModal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">ç¼–è¾‘æ¶ˆæ¯</div>
                    <div class="modal-close" onclick="closeModal('${editId}')">å–æ¶ˆ</div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">æ¶ˆæ¯å†…å®¹</label>
                        <textarea id="editMessageTextarea" class="form-textarea" placeholder="è¾“å…¥æ¶ˆæ¯å†…å®¹..." rows="6"></textarea>
                    </div>
                    <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 20px;">
                        <button class="form-submit" style="background-color: #ccc; flex: 1;" onclick="closeModal('${editId}')">å–æ¶ˆ</button>
                        <button class="form-submit" style="flex: 1;" id="saveEditedMessageBtn">ä¿å­˜</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(editModal);
    }
    
    // å¡«å……å½“å‰æ¶ˆæ¯å†…å®¹
    document.getElementById('editMessageTextarea').value = message.content;
    
    // è®¾ç½®ä¿å­˜æŒ‰é’®äº‹ä»¶
    document.getElementById('saveEditedMessageBtn').onclick = () => {
        const newContent = document.getElementById('editMessageTextarea').value.trim();
        if (!newContent) {
            showToast('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
            return;
        }
        saveEditedMessage(messageIndex, newContent);
        closeModal(editId);
    };
    
    showModal(editId);
    
    // èšç„¦åˆ°æ–‡æœ¬åŸŸå¹¶é€‰ä¸­å…¨éƒ¨æ–‡æœ¬
    setTimeout(() => {
        const textarea = document.getElementById('editMessageTextarea');
        textarea.focus();
        textarea.select();
    }, 300);
}

/**
 * ä¿å­˜ç¼–è¾‘åçš„æ¶ˆæ¯
 * @param {number} messageIndex æ¶ˆæ¯ç´¢å¼•
 * @param {string} newContent æ–°çš„æ¶ˆæ¯å†…å®¹
 */
async function saveEditedMessage(messageIndex, newContent) {
    if (!currentContact || messageIndex === undefined || messageIndex < 0 || messageIndex >= currentContact.messages.length) {
        showToast('æ— æ•ˆçš„æ¶ˆæ¯ç´¢å¼•æˆ–æœªé€‰æ‹©èŠå¤©');
        return;
    }
    
    // æ›´æ–°æ¶ˆæ¯å†…å®¹
    currentContact.messages[messageIndex].content = newContent;
    currentContact.messages[messageIndex].edited = true;
    currentContact.messages[messageIndex].editTime = new Date().toISOString();
    
    // é‡æ–°æ¸²æŸ“æ¶ˆæ¯
    renderMessages(false);
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await saveDataToDB();
    
    showToast('æ¶ˆæ¯å·²æ›´æ–°');
}

// formatContactListTime function moved to utils/formatUtils.js

// formatChatTimestamp function moved to utils/formatUtils.js

// --- äº‹ä»¶ç›‘å¬ ---
document.getElementById('chatInput').addEventListener('keypress', async (e) => { // Make it async
    if (e.key === 'Enter' && !e.shiftKey) { 
        e.preventDefault(); 
        await sendUserMessage(); // Await the user message
    } 
});

document.addEventListener('click', (e) => {
    const settingsPage = document.getElementById('contactSettingsPage');
    
    // æ£€æŸ¥æ–°çš„è®¾ç½®é¡µé¢ - å¦‚æœç‚¹å‡»çš„æ˜¯é¡µé¢å¤–éƒ¨ä¸”ä¸æ˜¯è§¦å‘æŒ‰é’®ï¼Œåˆ™å…³é—­
    if (settingsPage && settingsPage.classList.contains('active') && 
        !settingsPage.contains(e.target) && !e.target.closest('.chat-more')) {
        // ä½†æ˜¯ä¸è¦åœ¨ç‚¹å‡»æ¨¡æ€æ¡†æ—¶å…³é—­è®¾ç½®é¡µé¢
        if (!e.target.closest('.modal')) {
            closeContactSettingsPage();
        }
    }
});

// --- 1. ä¿®æ”¹ä½ çš„ DOMContentLoaded äº‹ä»¶ç›‘å¬å™¨ ---
// æ‰¾åˆ°æ–‡ä»¶æœ«å°¾çš„è¿™ä¸ªäº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨ä¸‹é¢çš„ä»£ç æ›¿æ¢å®ƒ

document.addEventListener('DOMContentLoaded', async () => {
    // ç«‹å³è®¾ç½®ä¸»åº”ç”¨åˆå§‹åŒ–æ ‡å¿—ï¼Œé€šçŸ¥æ‰©å±•æ¨¡å—
    window.mainAppInitializing = true;
    window.mainAppInitStartTime = Date.now();
    
    // æ˜¾ç¤ºåˆå§‹åŒ–æç¤º
    showInitializationProgress('æ­£åœ¨å¯åŠ¨åº”ç”¨...', 'system');
    
    try {
        // éªŒè¯å’Œåˆå§‹åŒ–APIService
        console.log('=== é¡µé¢åˆå§‹åŒ–å¼€å§‹ ===');
        showInitializationProgress('æ­£åœ¨æ£€æŸ¥APIæœåŠ¡...', 'api');
        console.log('APIServiceçŠ¶æ€:', !!window.apiService);
        
        if (!window.apiService && typeof APIService !== 'undefined') {
            console.log('é‡æ–°åˆå§‹åŒ–APIService...');
            window.apiService = new APIService();
            console.log('APIServiceé‡æ–°åˆå§‹åŒ–å®Œæˆ');
        }
        
        // åˆå§‹åŒ–æ¨¡å‹èƒ½åŠ›æ£€æµ‹å™¨
        if (!window.modelCapabilityDetector && typeof ModelCapabilityDetector !== 'undefined') {
            console.log('åˆå§‹åŒ–æ¨¡å‹èƒ½åŠ›æ£€æµ‹å™¨...');
            window.modelCapabilityDetector = new ModelCapabilityDetector();
            console.log('æ¨¡å‹èƒ½åŠ›æ£€æµ‹å™¨åˆå§‹åŒ–å®Œæˆ');
        }
        
        console.log('æœ€ç»ˆAPIServiceçŠ¶æ€:', !!window.apiService);
        console.log('========================');
        
        // æ³¨å†ŒService Worker
        showInitializationProgress('æ­£åœ¨æ³¨å†ŒService Worker...', 'worker');
        if (window.SystemUtils && typeof window.SystemUtils.registerServiceWorker === 'function') {
            console.log('SystemUtils.registerServiceWorker disabled in single-file mode');
        }
              
        // æ£€æŸ¥URLä¸­æ˜¯å¦æœ‰å¯¼å…¥ID
        showInitializationProgress('æ­£åœ¨æ£€æŸ¥URLå‚æ•°...', 'url');
        const urlParams = new URLSearchParams(window.location.search);
        const importId = urlParams.get('importId');

        if (importId) {
            // å¦‚æœæœ‰IDï¼Œåˆ™æ‰§è¡Œè‡ªåŠ¨å¯¼å…¥æµç¨‹
            showInitializationProgress('æ­£åœ¨æ‰§è¡Œè‡ªåŠ¨å¯¼å…¥...', 'import');
            await handleAutoImport(importId);
        } else {
            // å¦åˆ™ï¼Œæ­£å¸¸åˆå§‹åŒ–åº”ç”¨
            showInitializationProgress('æ­£åœ¨åˆå§‹åŒ–æ•°æ®åº“...', 'database');
            await init();
        }
        
        // åˆå§‹åŒ–å®Œæˆ
        const initTime = Date.now() - window.mainAppInitStartTime;
        console.log(`[ä¸»åº”ç”¨] åˆå§‹åŒ–å®Œæˆï¼Œè€—æ—¶: ${initTime}ms`);
        
        // å‘é€åˆå§‹åŒ–å®Œæˆäº‹ä»¶
        if (typeof window.dispatchEvent === 'function') {
            window.dispatchEvent(new CustomEvent('mainAppInitComplete', {
                detail: { 
                    initTime: initTime,
                    timestamp: Date.now()
                }
            }));
        }
        
        // éšè—åˆå§‹åŒ–æç¤º
        hideInitializationProgress();
        
    } catch (error) {
        console.error('[ä¸»åº”ç”¨] åˆå§‹åŒ–å¤±è´¥:', error);
        showInitializationProgress('åº”ç”¨å¯åŠ¨å¤±è´¥: ' + error.message, 'error');
        setTimeout(() => hideInitializationProgress(), 5000);
    } finally {
        window.mainAppInitializing = false;
        
        // å¯åŠ¨è”ç³»äººæ—¶é—´å®šæ—¶æ›´æ–°å™¨
        startContactTimeUpdater();
    }
});

// å…¨å±€é”™è¯¯å¤„ç†å™¨
window.addEventListener('error', (event) => {
    console.error('å…¨å±€JavaScripté”™è¯¯:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error ? {
            name: event.error.name,
            message: event.error.message,
        } : null,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
    });
});

// å¤„ç†Promise rejectionsï¼ˆé‡å¤çš„ç›‘å¬å™¨ï¼Œåº”è¯¥ç»Ÿä¸€å¤„ç†ï¼‰
// window.addEventListener('unhandledrejection', (event) => {
//     console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', {
//         reason: event.reason,
//         promise: event.promise,
//         timestamp: new Date().toISOString(),
//         userAgent: navigator.userAgent,
//         url: window.location.href
//     });
//     event.preventDefault(); // é˜»æ­¢é»˜è®¤æµè§ˆå™¨æç¤ºæ¡†
// });
// æ³¨é‡Šæ‰é‡å¤çš„ç›‘å¬å™¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå·²ç»æœ‰preventDefaultçš„ç›‘å¬å™¨

// --- æ–°å¢ï¼šå¸–å­é€‰æ‹©å’Œæ‰‹åŠ¨å‘å¸–åŠŸèƒ½ ---

function showPostChoiceModal() {
    showModal('postChoiceModal');
}

function selectPostType(type) {
    closeModal('postChoiceModal');
    
    if (type === 'manual') {
        showManualPostModal();
    } else if (type === 'generate') {
        showGeneratePostModal();
    }
}

function showManualPostModal() {
    // è®¾ç½®é»˜è®¤å‘å¸–äººä¸ºç”¨æˆ·
    document.getElementById('manualPostAuthor').value = userProfile.name;
    document.getElementById('manualPostTag').value = 'ç¢ç¢å¿µ';
    document.getElementById('manualPostContent').value = '';
    document.getElementById('manualPostImageDesc').value = '';
    
    // manualPostUnsplashKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œä¸å†æ¢å¤Unsplash API Key
    
    showModal('manualPostModal');
}

async function handleManualPost(event) {
    event.preventDefault();
    
    const authorName = document.getElementById('manualPostAuthor').value;
    const relationTag = document.getElementById('manualPostTag').value.trim();
    const postContent = document.getElementById('manualPostContent').value.trim();
    const imageDescription = document.getElementById('manualPostImageDesc').value.trim();
    // manualPostUnsplashKeyå…ƒç´ å·²ä»HTMLä¸­ç§»é™¤ï¼Œä»localStorageç›´æ¥è·å–
    const unsplashKey = localStorage.getItem('forumUnsplashApiKey') || '';
    
    if (!postContent) {
        showToast('è¯·å¡«å†™å¸–å­å†…å®¹');
        return;
    }
    
    if (!relationTag) {
        showToast('è¯·å¡«å†™è¯é¢˜æ ‡ç­¾');
        return;
    }
    
    // Unsplash API Keyå·²ä»localStorageè·å–ï¼Œæ— éœ€é‡å¤ä¿å­˜
    
    closeModal('manualPostModal');
    
    // ç”Ÿæˆæ‰‹åŠ¨å¸–å­
    await generateManualPost(authorName, relationTag, postContent, imageDescription, unsplashKey);
}

async function generateManualPost(authorName, relationTag, postContent, imageDescription, unsplashKey = null) {
    const now = Date.now();
    const postCreatedAt = new Date(now - (Math.random() * 3 + 2) * 60 * 1000);
    
    // å…ˆåˆ›å»ºä¸å¸¦è¯„è®ºçš„å¸–å­å¹¶ç«‹å³æ˜¾ç¤º
    const weiboData = {
        relation_tag: relationTag,
        posts: [{
            author_type: 'User', // ç”¨æˆ·è‡ªå·±å‘çš„å¸–å­
            post_content: postContent,
            image_description: imageDescription || 'æš‚æ— å›¾ç‰‡æè¿°',
            comments: [], // å…ˆæ˜¾ç¤ºç©ºè¯„è®ºï¼Œåé¢å†æ·»åŠ 
            timestamp: postCreatedAt.toISOString()
        }]
    };
    
    // ä¸ºæ‰‹åŠ¨å¸–å­ç”Ÿæˆå›¾ç‰‡
    if (unsplashKey && imageDescription && imageDescription.trim()) {
        try {
            const imageUrl = await fetchMatchingImageForPublish(imageDescription, unsplashKey);
            if (imageUrl) {
                // å°†å›¾ç‰‡æè¿°æ›¿æ¢ä¸ºå®é™…å›¾ç‰‡HTML
                weiboData.posts[0].actual_image_url = imageUrl;
                // ä¿ç•™åŸå§‹æè¿°ç”¨äºå¤‡ä»½
                weiboData.posts[0].original_image_description = imageDescription;
                weiboData.posts[0].image_description = `<img src="${imageUrl}" alt="${imageDescription}" style="width: 100%; max-width: 300px; border-radius: 8px;">`;
            }
        } catch (imageError) {
            console.warn(`ä¸ºæ‰‹åŠ¨å¸–å­ç”Ÿæˆå›¾ç‰‡å¤±è´¥: ${imageError.message}`);
            // å›¾ç‰‡ç”Ÿæˆå¤±è´¥æ—¶ä¿æŒåŸå§‹æ–‡å­—æè¿°
        }
    }
    
    const newPost = {
        id: Date.now(),
        contactId: null, // ç”¨æˆ·è‡ªå·±å‘çš„å¸–å­
        relations: relationTag,
        relationDescription: relationTag,
        hashtag: relationTag,
        data: weiboData,
        createdAt: postCreatedAt.toISOString()
    };

    // ä¿å­˜å¹¶ç«‹å³æ˜¾ç¤ºå¸–å­
    await saveWeiboPost(newPost);
    weiboPosts.push(newPost);
    renderAllWeiboPosts();
    showToast('å¸–å­å‘å¸ƒæˆåŠŸï¼');

    // æ£€æŸ¥å¹¶æ›´æ–°å…¨å±€è®°å¿†ï¼ˆç”¨æˆ·å‘å¸–å†…å®¹ï¼‰
    if (window.characterMemoryManager) {
        const forumContent = `ç”¨æˆ·å‘å¸–ï¼š\næ ‡é¢˜ï¼š${relationTag}\nå†…å®¹ï¼š${postContent}${imageDescription ? '\nå›¾ç‰‡æè¿°ï¼š' + imageDescription : ''}`;
        window.characterMemoryManager.checkAndUpdateGlobalMemory(forumContent);
    }

    // è·å–APIè°ƒç”¨ä¿¡æ¯ï¼Œå¦‚æœæœªé…ç½®åˆ™ä¸ç”Ÿæˆè¯„è®º
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('æœªé…ç½®APIæˆ–æ¨¡å‹ï¼Œä»…å‘å¸ƒå¸–å­ï¼Œæ— è¯„è®ºç”Ÿæˆ');
        return;
    }
    
    // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
    const container = document.getElementById('weiboContainer');
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'loading-text';
    loadingIndicator.textContent = 'æ­£åœ¨ç”Ÿæˆè¯„è®º...';
    loadingIndicator.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; z-index: 1000;';
    document.body.appendChild(loadingIndicator);
    
    try {
        // è°ƒç”¨æ–°çš„æ‰‹åŠ¨å¸–å­æç¤ºè¯æ„å»ºæ–¹æ³•
        const systemPrompt = await window.promptBuilder.buildManualPostPrompt(
            authorName,
            relationTag,
            postContent,
            imageDescription,
            userProfile,
            contacts,
            emojis
        );
        
        const payload = {
            model: apiCallInfo.model,
            messages: [{ role: 'user', content: systemPrompt }],
            response_format: { type: "json_object" },
            temperature: 0.8
        };

        const apiUrl = `${apiCallInfo.url}/chat/completions`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiCallInfo.key}`
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('ERROR: æœ‹å‹åœˆå›¾ç‰‡ç”ŸæˆAPIå¤±è´¥ - å®Œæ•´è¿”å›:', errorText);
            throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        let rawText = data.choices[0].message.content;
        
        if (!rawText) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(data, null, 2));
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆå†…å®¹");
        }
        
        // ä½¿ç”¨ç»Ÿä¸€çš„JSONæå–å‡½æ•°æ¸…ç†markdownè¯­æ³•
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSONæå–å¤±è´¥ - APIå®Œæ•´è¿”å›:', rawText);
            console.error('ERROR: JSONæå–å¤±è´¥ - é”™è¯¯è¯¦æƒ…:', extractError);
            throw new Error(`JSONæå–å¤±è´¥: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        
        let lastCommentTime = postCreatedAt.getTime();
        
        // ä¸ºæ¯ä¸ªè¯„è®ºæ·»åŠ æ—¶é—´æˆ³
        const comments = commentsData.comments.map(comment => {
            const newCommentTimestamp = lastCommentTime + (Math.random() * 2 * 60 * 1000);
            lastCommentTime = newCommentTimestamp;
            return formatCommentForDataModel({
                ...comment,
                timestamp: new Date(Math.min(newCommentTimestamp, now)).toISOString()
            });
        });

        // æ›´æ–°å¸–å­æ•°æ®ï¼Œæ·»åŠ è¯„è®º
        newPost.data.posts[0].comments = comments;
        
        // æ›´æ–°æ•°æ®åº“
        await updateWeiboPost(newPost);
        
        // ä¹Ÿéœ€è¦æ›´æ–°å†…å­˜ä¸­çš„æ•°ç»„
        const postIndex = weiboPosts.findIndex(p => p.id === newPost.id);
        if (postIndex !== -1) {
            weiboPosts[postIndex] = newPost;
        }
        
        // é‡æ–°æ¸²æŸ“é¡µé¢
        renderAllWeiboPosts();
        showToast('è¯„è®ºç”Ÿæˆå®Œæˆï¼');

    } catch (error) {
        console.error('ç”Ÿæˆè¯„è®ºå¤±è´¥:', error);
        showApiError(error);
    } finally {
        loadingIndicator.remove();
    }
}

// --- æ‰¹é‡åˆ é™¤æ¶ˆæ¯åŠŸèƒ½ ---

/**
 * è¿›å…¥å¤šé€‰æ¨¡å¼
 */
function enterMultiSelectMode() {
    if (!currentContact) return;
    
    isMultiSelectMode = true;
    selectedMessages.clear();
    
    // é‡æ–°æ¸²æŸ“æ¶ˆæ¯ä»¥æ˜¾ç¤ºå¤šé€‰çŠ¶æ€
    renderMessages(false);
    
    // æ˜¾ç¤ºæ“ä½œæŒ‰é’®
    showMultiSelectButtons();
    
    showToast('å¤šé€‰æ¨¡å¼å·²å¼€å¯ï¼Œç‚¹å‡»æ¶ˆæ¯è¿›è¡Œé€‰æ‹©');
}

/**
 * é€€å‡ºå¤šé€‰æ¨¡å¼
 */
function exitMultiSelectMode() {
    isMultiSelectMode = false;
    selectedMessages.clear();
    
    // é‡æ–°æ¸²æŸ“æ¶ˆæ¯
    renderMessages(false);
    
    // éšè—æ“ä½œæŒ‰é’®
    hideMultiSelectButtons();
}

/**
 * æ˜¾ç¤ºå¤šé€‰æ“ä½œæŒ‰é’®
 */
function showMultiSelectButtons() {
    let buttonsDiv = document.getElementById('multiSelectButtons');
    if (!buttonsDiv) {
        buttonsDiv = document.createElement('div');
        buttonsDiv.id = 'multiSelectButtons';
        buttonsDiv.className = 'multi-select-buttons';
        buttonsDiv.innerHTML = `
            <button class="multi-select-btn cancel-btn" onclick="exitMultiSelectMode()">å–æ¶ˆ</button>
            <button class="multi-select-btn delete-btn" onclick="deleteSelectedMessages()">åˆ é™¤</button>
        `;
        document.body.appendChild(buttonsDiv);
    }
    buttonsDiv.style.display = 'flex';
    
    // éšè—åº•éƒ¨å¯¼èˆªæ 
    const bottomNav = document.querySelector('.bottom-nav');
    if (bottomNav) {
        bottomNav.style.display = 'none';
    }
}

/**
 * éšè—å¤šé€‰æ“ä½œæŒ‰é’®
 */
function hideMultiSelectButtons() {
    const buttonsDiv = document.getElementById('multiSelectButtons');
    if (buttonsDiv) {
        buttonsDiv.style.display = 'none';
    }
    
    // æ˜¾ç¤ºåº•éƒ¨å¯¼èˆªæ 
    const bottomNav = document.querySelector('.bottom-nav');
    if (bottomNav) {
        bottomNav.style.display = 'flex';
    }
}

/**
 * åˆ‡æ¢æ¶ˆæ¯çš„é€‰ä¸­çŠ¶æ€
 */
function toggleMessageSelection(messageIndex) {
    if (selectedMessages.has(messageIndex)) {
        selectedMessages.delete(messageIndex);
    } else {
        selectedMessages.add(messageIndex);
    }
    
    // æ›´æ–°è¯¥æ¶ˆæ¯çš„è§†è§‰æ•ˆæœ
    updateMessageSelectStyle(messageIndex);
}

/**
 * æ›´æ–°æ¶ˆæ¯çš„é€‰ä¸­æ ·å¼
 */
function updateMessageSelectStyle(messageIndex) {
    const messageElements = document.querySelectorAll('.message');
    const messageElement = Array.from(messageElements).find(el => 
        parseInt(el.dataset.messageIndex) === messageIndex
    );
    
    if (messageElement) {
        if (selectedMessages.has(messageIndex)) {
            messageElement.classList.add('message-selected');
        } else {
            messageElement.classList.remove('message-selected');
        }
    }
}

/**
 * åˆ é™¤é€‰ä¸­çš„æ¶ˆæ¯
 */
function deleteSelectedMessages() {
    if (selectedMessages.size === 0) {
        showToast('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ¶ˆæ¯');
        return;
    }
    
    const selectedCount = selectedMessages.size;
    showConfirmDialog('æ‰¹é‡åˆ é™¤ç¡®è®¤', `å³å°†æ‰¹é‡åˆ é™¤æ‰€é€‰æ¶ˆæ¯ï¼ˆ${selectedCount}æ¡ï¼‰ï¼Œæ˜¯å¦ç¡®è®¤ï¼Ÿ`, async () => {
        try {
            // å°†é€‰ä¸­çš„ç´¢å¼•è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åºï¼ˆä»å¤§åˆ°å°ï¼Œé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–ï¼‰
            const sortedIndexes = Array.from(selectedMessages).sort((a, b) => b - a);
            
            // ä¿å­˜è¢«åˆ é™¤çš„æ¶ˆæ¯ï¼Œç”¨äºè®°å¿†æ›´æ–°
            const deletedMessages = [];
            for (const messageIndex of sortedIndexes) {
                if (messageIndex < currentContact.messages.length) {
                    deletedMessages.push(currentContact.messages[messageIndex]);
                }
            }
            
            // é€ä¸ªåˆ é™¤æ¶ˆæ¯
            for (const messageIndex of sortedIndexes) {
                if (messageIndex < currentContact.messages.length) {
                    currentContact.messages.splice(messageIndex, 1);
                }
            }
            
            // æ›´æ–°è”ç³»äººæœ€åæ¶ˆæ¯ä¿¡æ¯
            if (currentContact.messages.length > 0) {
                const lastMsg = currentContact.messages[currentContact.messages.length - 1];
                currentContact.lastMessage = lastMsg.type === 'text' ? lastMsg.content.substring(0, 20) + '...' : 
                                           (lastMsg.type === 'emoji' ? '[è¡¨æƒ…]' : '[çº¢åŒ…]');
                currentContact.lastTime = formatContactListTime(lastMsg.time);
            } else {
                currentContact.lastMessage = 'æš‚æ— æ¶ˆæ¯';
                currentContact.lastTime = formatContactListTime(new Date().toISOString());
            }
            
            // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„æ¶ˆæ¯æ•°é‡
            if (currentlyDisplayedMessageCount > currentContact.messages.length) {
                currentlyDisplayedMessageCount = currentContact.messages.length;
            }
            
            // é€€å‡ºå¤šé€‰æ¨¡å¼
            exitMultiSelectMode();
            
            // é‡æ–°æ¸²æŸ“
            await renderContactList();
            await saveDataToDB();
            
            // æ£€æŸ¥å¹¶æ›´æ–°è®°å¿†
            if (window.checkAndUpdateMemoryAfterDeletion && deletedMessages.length > 0) {
                try {
                    await window.checkAndUpdateMemoryAfterDeletion(currentContact.id, deletedMessages, currentContact);
                } catch (error) {
                    console.error('æ‰¹é‡åˆ é™¤æ¶ˆæ¯åæ›´æ–°è®°å¿†å¤±è´¥:', error);
                }
            }
            
            showToast(`å·²æˆåŠŸåˆ é™¤ ${selectedCount} æ¡æ¶ˆæ¯`);
            
        } catch (error) {
            console.error('æ‰¹é‡åˆ é™¤æ¶ˆæ¯å¤±è´¥:', error);
            showToast('åˆ é™¤å¤±è´¥ï¼š' + error.message);
        }
    });
}

// === è®°å¿†ç®¡ç†ç³»ç»Ÿ ===
class MemoryManager {
    constructor() {
        // ä¸å†ä½¿ç”¨localStorageå­˜å‚¨ï¼Œç›´æ¥ä½¿ç”¨indexedDB
        this.currentMemoryType = 'global';
        this.currentCharacter = null;
        this.selectedMemoryId = null;
    }

    // è·å–å…¨å±€è®°å¿†ï¼ˆä»indexedDBè¯»å–ï¼‰
    async getGlobalMemories() {
        if (!window.characterMemoryManager) {
            return [];
        }
        
        const globalMemory = await window.characterMemoryManager.getGlobalMemory();
        if (!globalMemory || !globalMemory.trim()) {
            return [];
        }
        
        // å°†å…¨å±€è®°å¿†è½¬æ¢ä¸ºè®°å¿†æ•°ç»„æ ¼å¼
        const memoryItems = this.parseMemoryItems(globalMemory);
        return [{
            id: 'global-memory',
            content: globalMemory,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            items: memoryItems
        }];
    }

    // è·å–è§’è‰²è®°å¿†ï¼ˆä»indexedDBè¯»å–ï¼‰
    async getCharacterMemories(characterId) {
        if (!window.characterMemoryManager) {
            return [];
        }
        
        const characterMemory = await window.characterMemoryManager.getCharacterMemory(characterId);
        if (!characterMemory || !characterMemory.trim()) {
            return [];
        }
        
        // å°†è§’è‰²è®°å¿†è½¬æ¢ä¸ºè®°å¿†æ•°ç»„æ ¼å¼
        const memoryItems = this.parseMemoryItems(characterMemory);
        return [{
            id: `character-memory-${characterId}`,
            content: characterMemory,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            items: memoryItems
        }];
    }

    // æ·»åŠ å…¨å±€è®°å¿†ï¼ˆç›´æ¥ä¿å­˜åˆ°indexedDBï¼‰
    async addGlobalMemory(content) {
        // æ¸…ç†å†…å®¹ï¼Œåªä¿ç•™æœ‰æ•ˆçš„markdownåˆ—è¡¨é¡¹
        const cleanedContent = this.cleanAndValidateMemoryContent(content);
        
        if (!cleanedContent) {
            throw new Error('æ— æ•ˆçš„è®°å¿†æ ¼å¼ï¼è¯·ä½¿ç”¨ "- è®°å¿†å†…å®¹" çš„æ ¼å¼');
        }
        
        if (!window.characterMemoryManager) {
            throw new Error('è®°å¿†ç®¡ç†ç³»ç»Ÿæœªåˆå§‹åŒ–');
        }
        
        // è·å–ç°æœ‰å…¨å±€è®°å¿†
        const existingMemory = await window.characterMemoryManager.getGlobalMemory();
        let combinedMemory;
        
        if (existingMemory && existingMemory.trim()) {
            combinedMemory = existingMemory + '\n' + cleanedContent;
        } else {
            combinedMemory = cleanedContent;
        }
        
        // ç›´æ¥ä¿å­˜åˆ°indexedDB
        const success = await window.characterMemoryManager.saveGlobalMemory(combinedMemory);
        
        if (!success) {
            throw new Error('ä¿å­˜å…¨å±€è®°å¿†å¤±è´¥');
        }
        
        const memory = {
            id: Date.now().toString(),
            content: cleanedContent,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        return memory;
    }

    // æ·»åŠ è§’è‰²è®°å¿†ï¼ˆç›´æ¥ä¿å­˜åˆ°indexedDBï¼‰
    async addCharacterMemory(characterId, content) {
        // æ¸…ç†å†…å®¹ï¼Œåªä¿ç•™æœ‰æ•ˆçš„markdownåˆ—è¡¨é¡¹
        const cleanedContent = this.cleanAndValidateMemoryContent(content);
        
        if (!cleanedContent) {
            throw new Error('æ— æ•ˆçš„è®°å¿†æ ¼å¼ï¼è¯·ä½¿ç”¨ "- è®°å¿†å†…å®¹" çš„æ ¼å¼');
        }
        
        if (!window.characterMemoryManager) {
            throw new Error('è®°å¿†ç®¡ç†ç³»ç»Ÿæœªåˆå§‹åŒ–');
        }
        
        // è·å–ç°æœ‰è§’è‰²è®°å¿†
        const existingMemory = await window.characterMemoryManager.getCharacterMemory(characterId);
        let combinedMemory;
        
        if (existingMemory && existingMemory.trim()) {
            combinedMemory = existingMemory + '\n' + cleanedContent;
        } else {
            combinedMemory = cleanedContent;
        }
        
        // ç›´æ¥ä¿å­˜åˆ°indexedDB
        const success = await window.characterMemoryManager.saveCharacterMemory(characterId, combinedMemory);
        
        if (!success) {
            throw new Error('ä¿å­˜è§’è‰²è®°å¿†å¤±è´¥');
        }
        
        const memory = {
            id: Date.now().toString(),
            content: cleanedContent,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        return memory;
    }

    // æ›´æ–°è®°å¿†ï¼ˆç›´æ¥æ›´æ–°indexedDBï¼‰
    async updateMemory(memoryId, content, isCharacter = false, characterId = null) {
        // æ¸…ç†å†…å®¹ï¼Œåªä¿ç•™æœ‰æ•ˆçš„markdownåˆ—è¡¨é¡¹
        const cleanedContent = this.cleanAndValidateMemoryContent(content);
        
        if (!cleanedContent) {
            throw new Error('æ— æ•ˆçš„è®°å¿†æ ¼å¼ï¼è¯·ä½¿ç”¨ "- è®°å¿†å†…å®¹" çš„æ ¼å¼');
        }
        
        if (!window.characterMemoryManager) {
            throw new Error('è®°å¿†ç®¡ç†ç³»ç»Ÿæœªåˆå§‹åŒ–');
        }
        
        let success = false;
        
        if (isCharacter && characterId) {
            // ç›´æ¥æ›¿æ¢è§’è‰²è®°å¿†å†…å®¹
            success = await window.characterMemoryManager.saveCharacterMemory(characterId, cleanedContent);
        } else {
            // ç›´æ¥æ›¿æ¢å…¨å±€è®°å¿†å†…å®¹
            success = await window.characterMemoryManager.saveGlobalMemory(cleanedContent);
        }
        
        if (!success) {
            throw new Error('æ›´æ–°è®°å¿†å¤±è´¥');
        }
        
        const memory = {
            id: memoryId,
            content: cleanedContent,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        return memory;
    }

    // åˆ é™¤è®°å¿†ï¼ˆç›´æ¥ä» indexedDB åˆ é™¤ï¼‰
    async deleteMemory(memoryId, isCharacter = false, characterId = null) {
        if (!window.characterMemoryManager) {
            throw new Error('è®°å¿†ç®¡ç†ç³»ç»Ÿæœªåˆå§‹åŒ–');
        }
        
        let success = false;
        
        if (isCharacter && characterId) {
            // æ¸…ç©ºè§’è‰²è®°å¿†
            success = await window.characterMemoryManager.saveCharacterMemory(characterId, '');
        } else {
            // æ¸…ç©ºå…¨å±€è®°å¿†
            success = await window.characterMemoryManager.saveGlobalMemory('');
        }
        
        return success;
    }

    // æ³¨æ„ï¼šè¿™äº›åŒæ­¥æ–¹æ³•å·²è¢«ä¸Šé¢çš„å¼‚æ­¥æ–¹æ³•æ›¿ä»£
    // å¦‚æœä»£ç ä¸­æœ‰åŒæ­¥è°ƒç”¨ï¼Œä¼šå‡ºç°é”™è¯¯ï¼Œéœ€è¦æ”¹ä¸ºå¼‚æ­¥è°ƒç”¨

    // æ¸…ç†å’ŒéªŒè¯è®°å¿†å†…å®¹ï¼Œåªä¿ç•™æœ‰æ•ˆçš„markdownåˆ—è¡¨é¡¹
    cleanAndValidateMemoryContent(content) {
        if (!content || typeof content !== 'string') {
            return '';
        }
        
        const lines = content.split('\n');
        const validLines = [];
        
        lines.forEach(line => {
            const trimmedLine = line.trim();
            // åªä¿ç•™ä»¥ "- " å¼€å¤´çš„è¡Œ
            if (trimmedLine.startsWith('- ') && trimmedLine.length > 2) {
                validLines.push(trimmedLine);
            }
        });
        
        return validLines.join('\n');
    }
    
    // å°†è®°å¿†å†…å®¹åˆ†è§£ä¸ºå•ç‹¬çš„è®°å¿†é¡¹åˆ—è¡¨
    parseMemoryItems(content) {
        const cleanContent = this.cleanAndValidateMemoryContent(content);
        if (!cleanContent) return [];
        
        return cleanContent.split('\n').map(line => {
            // ç§»é™¤å‰é¢çš„ "- " å¾—åˆ°çº¯å†…å®¹
            return line.replace(/^- /, '').trim();
        }).filter(item => item.length > 0);
    }
    
    // ä»è®°å¿†é¡¹åˆ—è¡¨é‡å»ºmarkdownå†…å®¹
    buildMemoryContent(items) {
        if (!Array.isArray(items) || items.length === 0) {
            return '';
        }
        
        return items.map(item => `- ${item.trim()}`).join('\n');
    }
    
    // è§£æMarkdownåˆ°HTMLï¼ˆä»…æ”¯æŒåˆ—è¡¨ï¼‰
    parseMarkdown(content) {
        const cleanContent = this.cleanAndValidateMemoryContent(content);
        if (!cleanContent) return '';
        
        const lines = cleanContent.split('\n');
        const listItems = lines.map(line => {
            const item = line.replace(/^- /, '');
            return `<li>${this.escapeHtml(item)}</li>`;
        }).join('');
        
        return listItems ? `<ul>${listItems}</ul>` : '';
    }
    
    // HTMLè½¬ä¹‰
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// åˆå§‹åŒ–è®°å¿†ç®¡ç†å™¨
const memoryManager = new MemoryManager();

// æ˜¾ç¤ºæ·»åŠ è®°å¿†æ¨¡æ€æ¡†
async function showAddMemoryModal() {
    const modal = document.getElementById('addMemoryModal');
    const memoryType = document.getElementById('memoryType');
    const characterSelectGroup = document.getElementById('characterSelectGroup');
    const memoryCharacterSelect = document.getElementById('memoryCharacterSelect');
    
    // é»˜è®¤è®¾ç½®ä¸ºå…¨å±€è®°å¿†ç±»å‹
    memoryType.value = 'global';
    
    // å¦‚æœæ•°æ®è¿˜æ²¡å‡†å¤‡å¥½ï¼Œç­‰å¾…ä¸€ä¸‹
    if (!window.contacts || !Array.isArray(window.contacts) || window.contacts.length === 0) {
        console.log('æ•°æ®æœªå‡†å¤‡å¥½ï¼Œç­‰å¾…åŠ è½½...');
        await waitForDataReady();
    }
    
    // å¡«å……è§’è‰²é€‰æ‹©å™¨
    memoryCharacterSelect.innerHTML = '<option value="">é€‰æ‹©è§’è‰²...</option>';
    
    // ç¡®ä¿contactsæ•°ç»„å­˜åœ¨
    if (window.contacts && Array.isArray(window.contacts)) {
        let aiCount = 0;
        
        window.contacts.forEach(contact => {
            console.log(`æ£€æŸ¥è”ç³»äºº: ${contact.name}, ç±»å‹: ${contact.type}`);
            if (contact.type === 'private') {
                const option = document.createElement('option');
                option.value = contact.id;
                option.textContent = contact.name;
                memoryCharacterSelect.appendChild(option);
                aiCount++;
            }
        });
        
        if (aiCount === 0) {
            console.warn('æ²¡æœ‰æ‰¾åˆ°ä»»ä½•AIè§’è‰²ï¼Œå¯èƒ½æ•°æ®æœ‰é—®é¢˜');
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'æš‚æ— å¯ç”¨è§’è‰²';
            option.disabled = true;
            memoryCharacterSelect.appendChild(option);
        }
    } else {
        console.warn('contactsæ•°ç»„ä¸å¯ç”¨ï¼Œæ— æ³•å¡«å……è§’è‰²é€‰æ‹©å™¨');
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'æ•°æ®åŠ è½½ä¸­...';
        option.disabled = true;
        memoryCharacterSelect.appendChild(option);
    }
    
    // åˆå§‹åŒ–æ—¶ç¡®ä¿éšè—è§’è‰²é€‰æ‹©ï¼ˆå› ä¸ºé»˜è®¤æ˜¯å…¨å±€è®°å¿†ï¼‰
    characterSelectGroup.classList.add('hidden');
    
    showModal('addMemoryModal');
}

// å¤„ç†è®°å¿†ç±»å‹æ”¹å˜
function handleMemoryTypeChange() {
    const memoryType = document.getElementById('memoryType').value;
    const characterSelectGroup = document.getElementById('characterSelectGroup');
    
    if (memoryType === 'character') {
        characterSelectGroup.classList.remove('hidden');
    } else {
        characterSelectGroup.classList.add('hidden');
    }
}

// å¤„ç†æ·»åŠ è®°å¿†
async function handleAddMemory(event) {
    event.preventDefault();
    
    const memoryType = document.getElementById('memoryType').value;
    let memoryContent = document.getElementById('memoryContent').value.trim();
    const memoryCharacterSelect = document.getElementById('memoryCharacterSelect').value;
    
    // è‡ªåŠ¨ä¸ºæ¯è¡Œæ·»åŠ  - å‰ç¼€
    if (memoryContent) {
        const lines = memoryContent.split('\n');
        const formattedLines = lines.map(line => {
            const trimmedLine = line.trim();
            if (trimmedLine && !trimmedLine.startsWith('- ')) {
                return '- ' + trimmedLine;
            }
            return trimmedLine;
        }).filter(line => line.length > 0);
        memoryContent = formattedLines.join('\n');
    }
    
    if (!memoryContent) {
        showToast('è¯·è¾“å…¥è®°å¿†å†…å®¹');
        return;
    }
    
    if (memoryType === 'character' && !memoryCharacterSelect) {
        console.error('è§’è‰²è®°å¿†ä½†æœªé€‰æ‹©è§’è‰²:', { memoryType, memoryCharacterSelect });
        showToast('è¯·é€‰æ‹©è§’è‰²');
        return;
    }
    
    // éªŒè¯é€‰æ‹©çš„è§’è‰²æ˜¯å¦å­˜åœ¨ï¼ˆè§’è‰²è®°å¿†æ¨¡å¼ï¼‰
    if (memoryType === 'character') {
        const selectedContact = window.contacts && window.contacts.find(c => c.id === memoryCharacterSelect);
        if (!selectedContact) {
            console.error('é€‰æ‹©çš„è§’è‰²ä¸å­˜åœ¨:', memoryCharacterSelect);
            showToast('é€‰æ‹©çš„è§’è‰²ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°é€‰æ‹©');
            return;
        }
    }
    
    try {
        if (memoryType === 'global') {
            await memoryManager.addGlobalMemory(memoryContent);
            showToast('å…¨å±€è®°å¿†æ·»åŠ æˆåŠŸ');
            if (memoryManager.currentMemoryType === 'global') {
                loadGlobalMemories();
            }
        } else {
            await memoryManager.addCharacterMemory(memoryCharacterSelect, memoryContent);
            showToast('è§’è‰²è®°å¿†æ·»åŠ æˆåŠŸ');
            if (memoryManager.currentMemoryType === 'character' && memoryManager.currentCharacter === memoryCharacterSelect) {
                loadCharacterMemories();
            }
        }
        
        closeModal('addMemoryModal');
        document.getElementById('memoryContent').value = '';
    } catch (error) {
        console.error('æ·»åŠ è®°å¿†å¤±è´¥:', error);
        showToast('æ·»åŠ è®°å¿†å¤±è´¥');
    }
}

// åˆ‡æ¢è®°å¿†æ ‡ç­¾
function switchMemoryTab(type) {
    const globalTab = document.querySelector('.memory-tab:first-child');
    const characterTab = document.querySelector('.memory-tab:last-child');
    const globalSection = document.getElementById('globalMemorySection');
    const characterSection = document.getElementById('characterMemorySection');
    
    // æ›´æ–°æ ‡ç­¾æ ·å¼
    globalTab.classList.toggle('active', type === 'global');
    characterTab.classList.toggle('active', type === 'character');
    
    // æ˜¾ç¤ºå¯¹åº”å†…å®¹
    globalSection.classList.toggle('hidden', type !== 'global');
    characterSection.classList.toggle('hidden', type !== 'character');
    
    memoryManager.currentMemoryType = type;
    
    if (type === 'global') {
        loadGlobalMemories();
    } else {
        // åˆ‡æ¢åˆ°è§’è‰²è®°å¿†æ—¶é‡æ–°åŠ è½½è§’è‰²é€‰æ‹©å™¨
        loadCharacterSelector();
        
        // å¦‚æœè§’è‰²é€‰æ‹©å™¨ä¸ºç©ºï¼Œè¯´æ˜æ•°æ®å¯èƒ½è¿˜æ²¡åŠ è½½å®Œæˆ
        const characterSelector = document.getElementById('characterSelector');
        if (characterSelector && characterSelector.options.length <= 1) {
            waitForDataReady().then(() => {
                loadCharacterSelector();
            });
        }
    }
}

// åŠ è½½å…¨å±€è®°å¿†
async function loadGlobalMemories() {
    const memoryList = document.getElementById('globalMemoryList');
    if (!memoryList) return;
    
    try {
        const memories = await memoryManager.getGlobalMemories();
        
        if (memories.length === 0) {
            memoryList.innerHTML = '<div class="memory-empty">æš‚æ— å…¨å±€è®°å¿†</div>';
            return;
        }
        
        memoryList.innerHTML = memories.map(memory => createMemoryItem(memory, false)).join('');
    } catch (error) {
        console.error('åŠ è½½å…¨å±€è®°å¿†å¤±è´¥:', error);
        memoryList.innerHTML = '<div class="memory-empty">åŠ è½½å¤±è´¥</div>';
    }
}

// åŠ è½½è§’è‰²é€‰æ‹©å™¨
function loadCharacterSelector() {
    const characterSelector = document.getElementById('characterSelector');
    if (!characterSelector) {
        console.error('è§’è‰²é€‰æ‹©å™¨å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    characterSelector.innerHTML = '<option value="">é€‰æ‹©è§’è‰²...</option>';
    
    // ç¡®ä¿contactsæ•°ç»„å­˜åœ¨
    if (!window.contacts || !Array.isArray(window.contacts)) {
        console.warn('contactsæ•°ç»„ä¸å¯ç”¨ï¼Œæ— æ³•åŠ è½½è§’è‰²');
        return;
    }
        
    let aiContactCount = 0;
    let totalContactCount = 0;
    window.contacts.forEach(contact => {
        totalContactCount++;
        if (contact.type === 'private') {
            const option = document.createElement('option');
            option.value = contact.id;
            option.textContent = contact.name;
            characterSelector.appendChild(option);
            aiContactCount++;
        }
    });
    
    
    // å¦‚æœæ²¡æœ‰åŠ è½½åˆ°ä»»ä½•è§’è‰²ï¼Œå¼ºåˆ¶åˆ·æ–°ä¸€æ¬¡
    if (aiContactCount === 0 && totalContactCount > 0) {
        setTimeout(() => {
            loadCharacterSelector();
        }, 1000);
    }
}

// åŠ è½½è§’è‰²è®°å¿†
async function loadCharacterMemories() {
    const characterSelector = document.getElementById('characterSelector');
    const memoryList = document.getElementById('characterMemoryList');
    
    if (!characterSelector || !memoryList) {
        return;
    }
    
    const characterId = characterSelector.value;
    
    if (!characterId) {
        memoryList.innerHTML = '<div class="memory-empty">è¯·å…ˆé€‰æ‹©è§’è‰²</div>';
        return;
    }
    
    // éªŒè¯é€‰æ‹©çš„è§’è‰²æ˜¯å¦å­˜åœ¨
    const selectedContact = window.contacts && window.contacts.find(c => c.id === characterId);
    if (!selectedContact) {
        memoryList.innerHTML = '<div class="memory-empty">é€‰æ‹©çš„è§’è‰²ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°é€‰æ‹©</div>';
        return;
    }
    
    try {
        memoryManager.currentCharacter = characterId;
        const memories = await memoryManager.getCharacterMemories(characterId);
        
        if (memories.length === 0) {
            memoryList.innerHTML = '<div class="memory-empty">è¯¥è§’è‰²æš‚æ— è®°å¿†</div>';
            return;
        }
        
        memoryList.innerHTML = memories.map(memory => createMemoryItem(memory, true, characterId)).join('');
    } catch (error) {
        console.error('åŠ è½½è§’è‰²è®°å¿†å¤±è´¥:', error);
        memoryList.innerHTML = '<div class="memory-empty">åŠ è½½å¤±è´¥</div>';
    }
}

// åˆ›å»ºè®°å¿†é¡¹HTML - æ”¹ä¸ºå•æ¡æ¨¡å¼
function createMemoryItem(memory, isCharacter, characterId = null) {
    const date = new Date(memory.createdAt).toLocaleDateString();
    const memoryItems = memoryManager.parseMemoryItems(memory.content);
    
    // ä¸ºæ¯ä¸ªè®°å¿†é¡¹åˆ›å»ºå•ç‹¬çš„å¡ç‰‡
    return memoryItems.map((item, index) => {
        const itemId = `${memory.id}-${index}`;
        
        return `
            <div class="memory-item single-item" data-id="${itemId}" data-memory-id="${memory.id}" data-item-index="${index}">
                <div class="memory-single-content">
                    <div class="memory-text">${memoryManager.escapeHtml(item)}</div>
                    <div class="memory-meta">
                        <span class="memory-date">${date}</span>
                        <div class="memory-actions">
                            <button class="memory-edit-btn" onclick="editSingleMemoryItem('${memory.id}', ${index}, ${isCharacter}, '${characterId || ''}')">ä¿®æ”¹</button>
                            <button class="memory-edit-btn delete" onclick="deleteSingleMemoryItem('${memory.id}', ${index}, ${isCharacter}, '${characterId || ''}')">åˆ é™¤</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// ç¼–è¾‘å•ä¸ªè®°å¿†é¡¹
async function editSingleMemoryItem(memoryId, itemIndex, isCharacter, characterId) {
    let memory;
    if (isCharacter && characterId) {
        const memories = await memoryManager.getCharacterMemories(characterId);
        if (!Array.isArray(memories)) {
            showToast('è·å–è®°å¿†æ•°æ®å¤±è´¥');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    } else {
        const memories = await memoryManager.getGlobalMemories();
        if (!Array.isArray(memories)) {
            showToast('è·å–è®°å¿†æ•°æ®å¤±è´¥');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    }
    
    if (!memory) {
        showToast('è®°å¿†æœªæ‰¾åˆ°');
        return;
    }
    
    const memoryItems = memoryManager.parseMemoryItems(memory.content);
    if (itemIndex >= memoryItems.length) {
        showToast('è®°å¿†é¡¹æœªæ‰¾åˆ°');
        return;
    }
    
    const currentItem = memoryItems[itemIndex];
    
    // è®¾ç½®ç¼–è¾‘ä¸Šä¸‹æ–‡ä¿¡æ¯
    memoryManager.singleMemoryEditContext = {
        memoryId,
        itemIndex,
        isCharacter,
        characterId,
        memoryItems
    };
    
    // ä½¿ç”¨è‡ªå®šä¹‰æ¨¡æ€çª—å£è¿›è¡Œç¼–è¾‘
    const editSingleContentTextarea = document.getElementById('editSingleMemoryContent');
    editSingleContentTextarea.value = currentItem;
    
    showModal('editSingleMemoryModal');
}

// åˆ é™¤å•ä¸ªè®°å¿†é¡¹
async function deleteSingleMemoryItem(memoryId, itemIndex, isCharacter, characterId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å¿†å—ï¼Ÿ')) {
        return;
    }
    
    let memory;
    if (isCharacter && characterId) {
        const memories = await memoryManager.getCharacterMemories(characterId);
        if (!Array.isArray(memories)) {
            showToast('è·å–è®°å¿†æ•°æ®å¤±è´¥');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    } else {
        const memories = await memoryManager.getGlobalMemories();
        if (!Array.isArray(memories)) {
            showToast('è·å–è®°å¿†æ•°æ®å¤±è´¥');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    }
    
    if (!memory) {
        showToast('è®°å¿†æœªæ‰¾åˆ°');
        return;
    }
    
    const memoryItems = memoryManager.parseMemoryItems(memory.content);
    if (itemIndex >= memoryItems.length) {
        showToast('è®°å¿†é¡¹æœªæ‰¾åˆ°');
        return;
    }
    
    // åˆ é™¤æŒ‡å®šé¡¹
    memoryItems.splice(itemIndex, 1);
    
    if (memoryItems.length === 0) {
        // å¦‚æœæ²¡æœ‰è®°å¿†é¡¹äº†ï¼Œåˆ é™¤æ•´ä¸ªè®°å¿†
        await memoryManager.deleteMemory(memoryId, isCharacter, characterId);
    } else {
        // æ›´æ–°è®°å¿†å†…å®¹
        const updatedContent = memoryManager.buildMemoryContent(memoryItems);
        await updateSingleMemory(memoryId, updatedContent, isCharacter, characterId);
    }
    
    // åˆ·æ–°æ˜¾ç¤º
    if (isCharacter) {
        loadCharacterMemories();
    } else {
        loadGlobalMemories();
    }
    
    showToast('è®°å¿†åˆ é™¤æˆåŠŸ');
}

// æ›´æ–°å•ä¸ªè®°å¿†çš„è¾…åŠ©å‡½æ•°
async function updateSingleMemory(memoryId, content, isCharacter, characterId) {
    try {
        const updated = await memoryManager.updateMemory(memoryId, content, isCharacter, characterId);
        if (updated) {
            // åˆ·æ–°æ˜¾ç¤º
            if (isCharacter) {
                loadCharacterMemories();
            } else {
                loadGlobalMemories();
            }
            showToast('è®°å¿†æ›´æ–°æˆåŠŸ');
        } else {
            showToast('è®°å¿†æ›´æ–°å¤±è´¥');
        }
    } catch (error) {
        console.error('æ›´æ–°è®°å¿†å¤±è´¥:', error);
        showToast('è®°å¿†æ›´æ–°å¤±è´¥: ' + error.message);
    }
}

// ç¼–è¾‘è®°å¿†
async function editMemory(memoryId, isCharacter, characterId) {
    memoryManager.selectedMemoryId = memoryId;
    
    let memory;
    if (isCharacter && characterId) {
        const memories = await memoryManager.getCharacterMemories(characterId);
        if (!Array.isArray(memories)) {
            showToast('è·å–è®°å¿†æ•°æ®å¤±è´¥');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    } else {
        const memories = await memoryManager.getGlobalMemories();
        if (!Array.isArray(memories)) {
            showToast('è·å–è®°å¿†æ•°æ®å¤±è´¥');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    }
    
    if (!memory) {
        showToast('è®°å¿†æœªæ‰¾åˆ°');
        return;
    }
    
    const editContentTextarea = document.getElementById('editMemoryContent');
    editContentTextarea.value = memory.content;
    
    // å­˜å‚¨ç¼–è¾‘ä¸Šä¸‹æ–‡
    memoryManager.editingContext = {
        isCharacter,
        characterId
    };
    
    showModal('editMemoryModal');
}

// å¤„ç†ç¼–è¾‘è®°å¿†
async function handleEditMemory(event) {
    event.preventDefault();
    
    const newContent = document.getElementById('editMemoryContent').value.trim();
    const memoryId = memoryManager.selectedMemoryId;
    const context = memoryManager.editingContext || {};
    
    if (!newContent) {
        showToast('è¯·è¾“å…¥è®°å¿†å†…å®¹');
        return;
    }
    
    if (!memoryId) {
        showToast('è®°å¿†IDä¸¢å¤±');
        return;
    }
    
    try {
        const updated = await memoryManager.updateMemory(memoryId, newContent, context.isCharacter, context.characterId);
        if (updated) {
            showToast('è®°å¿†æ›´æ–°æˆåŠŸ');
            closeModal('editMemoryModal');
            
            // åˆ·æ–°æ˜¾ç¤º
            if (context.isCharacter) {
                loadCharacterMemories();
            } else {
                loadGlobalMemories();
            }
        } else {
            showToast('è®°å¿†æ›´æ–°å¤±è´¥');
        }
    } catch (error) {
        console.error('æ›´æ–°è®°å¿†å¤±è´¥:', error);
        showToast('è®°å¿†æ›´æ–°å¤±è´¥');
    }
}

// å¤„ç†ç¼–è¾‘å•ä¸ªè®°å¿†é¡¹
async function handleEditSingleMemory(event) {
    event.preventDefault();
    
    const newContent = document.getElementById('editSingleMemoryContent').value.trim();
    const context = memoryManager.singleMemoryEditContext;
    
    if (!newContent) {
        showToast('è¯·è¾“å…¥è®°å¿†å†…å®¹');
        return;
    }
    
    if (!context) {
        showToast('ç¼–è¾‘ä¸Šä¸‹æ–‡ä¸¢å¤±');
        return;
    }
    
    try {
        // æ›´æ–°è®°å¿†é¡¹
        context.memoryItems[context.itemIndex] = newContent;
        const updatedContent = memoryManager.buildMemoryContent(context.memoryItems);
        
        // æ›´æ–°è®°å¿†
        await updateSingleMemory(context.memoryId, updatedContent, context.isCharacter, context.characterId);
        
        showToast('è®°å¿†é¡¹æ›´æ–°æˆåŠŸ');
        closeModal('editSingleMemoryModal');
        
        // æ¸…ç†ä¸Šä¸‹æ–‡
        memoryManager.singleMemoryEditContext = null;
        
        // åˆ·æ–°æ˜¾ç¤º
        if (context.isCharacter) {
            loadCharacterMemories();
        } else {
            loadGlobalMemories();
        }
    } catch (error) {
        console.error('æ›´æ–°è®°å¿†é¡¹å¤±è´¥:', error);
        showToast('è®°å¿†é¡¹æ›´æ–°å¤±è´¥');
    }
}

// åˆ é™¤è®°å¿†
async function deleteMemory(memoryId, isCharacter, characterId) {
    const confirmMessage = 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å¿†å—ï¼Ÿ';
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        const deleted = await memoryManager.deleteMemory(memoryId, isCharacter, characterId);
        if (deleted) {
            showToast('è®°å¿†åˆ é™¤æˆåŠŸ');
            
            // åˆ·æ–°æ˜¾ç¤º
            if (isCharacter) {
                loadCharacterMemories();
            } else {
                loadGlobalMemories();
            }
        } else {
            showToast('è®°å¿†åˆ é™¤å¤±è´¥');
        }
    } catch (error) {
        console.error('åˆ é™¤è®°å¿†å¤±è´¥:', error);
        showToast('è®°å¿†åˆ é™¤å¤±è´¥');
    }
}

// åˆå§‹åŒ–è®°å¿†ç®¡ç†é¡µé¢
async function initMemoryManagementPage() {
    
    // ç¡®ä¿æ•°æ®å·²ç»åŠ è½½
    if (!window.contacts || !Array.isArray(window.contacts) || window.contacts.length === 0) {
        console.log('æ•°æ®æœªå‡†å¤‡å¥½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ...');
        const dataReady = await waitForDataReady();
        if (!dataReady) {
            console.warn('æ•°æ®åŠ è½½è¶…æ—¶ï¼Œä½†ç»§ç»­åˆå§‹åŒ–é¡µé¢');
        }
    }
    
    try {
        // ä»ç°æœ‰ç³»ç»ŸåŠ è½½æ•°æ®
        await loadExistingMemories();
        
        // é»˜è®¤åŠ è½½å…¨å±€è®°å¿†
        await loadGlobalMemories();
        loadCharacterSelector();
        
        // æ£€æŸ¥è§’è‰²é€‰æ‹©å™¨æ˜¯å¦æˆåŠŸåŠ è½½
        setTimeout(() => {
            const characterSelector = document.getElementById('characterSelector');
            if (characterSelector && characterSelector.options.length <= 1) {
                loadCharacterSelector();
            }
        }, 500);
        
    } catch (error) {
        console.error('åˆå§‹åŒ–è®°å¿†ç®¡ç†é¡µé¢å¤±è´¥:', error);
        // å³ä½¿åŠ è½½å¤±è´¥ä¹Ÿæ˜¾ç¤ºç•Œé¢
        await loadGlobalMemories();
        loadCharacterSelector();
    }
}

// ä»ç°æœ‰è®°å¿†ç³»ç»ŸåŠ è½½æ•°æ®
async function loadExistingMemories() {
    
    try {
        // åŠ è½½å…¨å±€è®°å¿†
        const existingGlobalMemory = await getExistingGlobalMemory();
        if (existingGlobalMemory && existingGlobalMemory.trim()) {
            // æ¸…ç†ç°æœ‰è®°å¿†å†…å®¹
            const cleanedGlobalMemory = memoryManager.cleanAndValidateMemoryContent(existingGlobalMemory);
            
            if (cleanedGlobalMemory) {
                // ç”±äºç°åœ¨ç›´æ¥ä½¿ç”¨indexedDBï¼Œä¸éœ€è¦æ“ä½œglobalMemoriesæ•°ç»„
                console.log('å…¨å±€è®°å¿†å·²å­˜åœ¨äºindexedDBä¸­ï¼Œè·³è¿‡é‡å¤åŠ è½½');
                
                // å¦‚æœæ¸…ç†åçš„å†…å®¹ä¸åŸå†…å®¹ä¸åŒï¼Œæ›´æ–°åˆ°ç°æœ‰ç³»ç»Ÿ
                if (cleanedGlobalMemory !== existingGlobalMemory) {
                    await saveExistingGlobalMemory(cleanedGlobalMemory);
                }
            }
        }
        
        // åŠ è½½è§’è‰²è®°å¿†
        if (window.contacts && Array.isArray(window.contacts)) {
            for (const contact of window.contacts) {
                if (contact.type === 'private') {
                    const existingCharacterMemory = await getExistingCharacterMemory(contact.id);
                    if (existingCharacterMemory && existingCharacterMemory.trim()) {
                        // æ¸…ç†ç°æœ‰è§’è‰²è®°å¿†å†…å®¹
                        const cleanedCharacterMemory = memoryManager.cleanAndValidateMemoryContent(existingCharacterMemory);
                        
                        if (cleanedCharacterMemory) {
                            // ç”±äºç°åœ¨ç›´æ¥ä½¿ç”¨indexedDBï¼Œä¸éœ€è¦æ“ä½œcharacterMemoriesæ•°ç»„
                            console.log(`è§’è‰²${contact.id}çš„è®°å¿†å·²å­˜åœ¨äºindexedDBä¸­ï¼Œè·³è¿‡é‡å¤åŠ è½½`);
                            
                            // å¦‚æœæ¸…ç†åçš„å†…å®¹ä¸åŸå†…å®¹ä¸åŒï¼Œæ›´æ–°åˆ°ç°æœ‰ç³»ç»Ÿ
                            if (cleanedCharacterMemory !== existingCharacterMemory) {
                                await saveExistingCharacterMemory(contact.id, cleanedCharacterMemory);
                            }
                        }
                    }
                }
            }
        }
        
    } catch (error) {
        console.error('åŠ è½½ç°æœ‰è®°å¿†æ•°æ®å¤±è´¥:', error);
    }
}

// ç­‰å¾…æ•°æ®åŠ è½½å®Œæˆçš„å‡½æ•°
async function waitForDataReady() {
    let attempts = 0;
    const maxAttempts = 20; // æœ€å¤šç­‰å¾…10ç§’
    
    while (attempts < maxAttempts) {
        if (window.contacts && Array.isArray(window.contacts) && window.isIndexedDBReady) {
            console.log(`æ•°æ®å‡†å¤‡å®Œæˆï¼Œcontactsæ•°ç»„é•¿åº¦: ${window.contacts.length}`);
            return true;
        }
        attempts++;
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log(`ç­‰å¾…æ•°æ®åŠ è½½ä¸­... å°è¯• ${attempts}/${maxAttempts}`);
    }
    
    console.warn('ç­‰å¾…æ•°æ®åŠ è½½è¶…æ—¶ï¼Œç»§ç»­åˆå§‹åŒ–è®°å¿†ç®¡ç†é¡µé¢');
    return false;
}

// é¡µé¢æ˜¾ç¤ºæ—¶åˆå§‹åŒ–è®°å¿†ç®¡ç†
document.addEventListener('DOMContentLoaded', function() {
    // å½“æ˜¾ç¤ºè®°å¿†ç®¡ç†é¡µé¢æ—¶åˆå§‹åŒ–
    const originalShowPage = showPage;
    window.showPage = function(pageIdToShow) {
        originalShowPage(pageIdToShow);
        if (pageIdToShow === 'memoryManagementPage') {
            // ç­‰å¾…æ•°æ®å‡†å¤‡å®Œæˆåå†åˆå§‹åŒ–
            waitForDataReady().then((dataReady) => {
                if (dataReady) {
                } else {
                    console.warn('æ•°æ®å‡†å¤‡è¶…æ—¶ï¼Œä½†ä»å°è¯•åˆå§‹åŒ–é¡µé¢');
                }
                initMemoryManagementPage();
            });
        }
    };
});

// é›†æˆç°æœ‰çš„è®°å¿†ç³»ç»Ÿ - æ·»åŠ æ¥å£å‡½æ•°
async function getExistingGlobalMemory() {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.getGlobalMemory();
    }
    return '';
}

async function getExistingCharacterMemory(characterId) {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.getCharacterMemory(characterId);
    }
    return null;
}

async function saveExistingGlobalMemory(content) {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.saveGlobalMemory(content);
    }
    return false;
}

async function saveExistingCharacterMemory(characterId, content) {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.saveCharacterMemory(characterId, content);
    }
    return false;
}

// è¯­éŸ³å›¾æ ‡ç”Ÿæˆå‡½æ•°
function createVoiceIcon(state = 'default') {
    const baseProps = 'width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"';
    
    switch (state) {
        case 'loading':
            return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6"/></svg>`;
        case 'playing':
            return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
        default:
            return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><path d="M3 10v4 M7 7v10 M12 4v16 M17 7v10 M21 10v4" /></svg>`;
    }
}

// ElevenLabs è¯­éŸ³æ’­æ”¾åŠŸèƒ½
/**
 * [MODIFIED] æ’­æ”¾æˆ–åœæ­¢è¯­éŸ³æ¶ˆæ¯ - æ”¯æŒç¼“å­˜çš„ Minimax API
 * @param {HTMLElement} bubbleElement - è¢«ç‚¹å‡»çš„æ°”æ³¡å…ƒç´ 
 * @param {string} text - éœ€è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬
 * @param {string} voiceId - Minimax çš„å£°éŸ³ID
 */
async function playVoiceMessage(bubbleElement, text, voiceId) {
    // 1. ç›´æ¥ä»localStorageè¯»å– Minimax API å‡­è¯
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    if (!minimaxGroupId || !minimaxApiKey) {
        showToast('è¯·åœ¨è®¾ç½®ä¸­å¡«å†™ Minimax Group ID å’Œ API Key');
        return;
    }
    if (!voiceId) {
        showToast('è¯¥è§’è‰²æœªè®¾ç½®è¯­éŸ³ID');
        return;
    }

    // 2. åˆ¤æ–­å½“å‰ç‚¹å‡»çš„æ°”æ³¡æ˜¯å¦æ­£åœ¨æ’­æ”¾
    const wasPlaying = bubbleElement === currentPlayingElement && !voiceAudio.paused;

    // 3. å¦‚æœæœ‰ä»»ä½•éŸ³é¢‘æ­£åœ¨æ’­æ”¾ï¼Œå…ˆåœæ­¢å®ƒ
    if (currentPlayingElement) {
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        const oldVoiceIcon = currentPlayingElement.querySelector('.voice-icon');
        if (oldVoiceIcon) oldVoiceIcon.innerHTML = createVoiceIcon();
        currentPlayingElement.classList.remove('playing', 'loading');
    }

    // 4. å¦‚æœç‚¹å‡»çš„æ˜¯æ­£åœ¨æ’­æ”¾çš„æ°”æ³¡ï¼Œåˆ™ä»…åœæ­¢ï¼Œç„¶åé€€å‡º
    if (wasPlaying) {
        currentPlayingElement = null;
        return;
    }

    // 5. è®¾ç½®å½“å‰æ°”æ³¡ä¸ºæ´»åŠ¨çŠ¶æ€å¹¶æ›´æ–°UI
    currentPlayingElement = bubbleElement;
    const voiceIcon = bubbleElement.querySelector('.voice-icon');

    try {
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        bubbleElement.classList.add('loading');
        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon('loading');

        let audioUrl = null;
        let fromCache = false;

        // 6. é¦–å…ˆæ£€æŸ¥è¯­éŸ³ç¼“å­˜
        if (window.VoiceStorageAPI) {
            try {
                audioUrl = await window.VoiceStorageAPI.getVoiceURL(text, voiceId);
                if (audioUrl) {
                    fromCache = true;
                    console.log('ä½¿ç”¨è¯­éŸ³ç¼“å­˜:', { textLength: text.length, voiceId });
                }
            } catch (error) {
                console.error('æ£€æŸ¥è¯­éŸ³ç¼“å­˜å¤±è´¥:', error);
            }
        }

        // 7. å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰ï¼Œåˆ™è°ƒç”¨ API ç”Ÿæˆè¯­éŸ³
        if (!audioUrl) {
            console.log('è¯­éŸ³ç¼“å­˜æœªå‘½ä¸­ï¼Œè°ƒç”¨APIç”Ÿæˆè¯­éŸ³');
            
            const groupId = minimaxGroupId;
            const apiKey = minimaxApiKey;
            
            // Minimax API URLï¼Œå°† GroupId æ”¾åœ¨æŸ¥è¯¢å‚æ•°ä¸­
            const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`;
            
            // è¯·æ±‚ä½“
            const requestBody = {
                "voice_id": voiceId,
                "text": text,
                "model": "speech-01",
                "speed": 1.0,
                "vol": 1.0,
                "pitch": 0
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    // æˆæƒå¤´ï¼Œæ³¨æ„è¿™é‡Œåªç”¨ API Key
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            console.log('Minimax TTS API Response Status:', response.status);
            console.log('Minimax TTS API Response Headers:', Object.fromEntries(response.headers.entries()));

            // å¤„ç† API å“åº”
            const contentType = response.headers.get('content-type') || '';
            
            // æ£€æŸ¥æ˜¯å¦è¿”å›äº†JSONé”™è¯¯ä¿¡æ¯ï¼ˆå³ä½¿çŠ¶æ€ç æ˜¯200ï¼‰
            if (!response.ok || contentType.includes('application/json')) {
                let errorMsg = `è¯­éŸ³æœåŠ¡é”™è¯¯ (çŠ¶æ€ç : ${response.status})`;
                try {
                    const errorData = await response.json();
                    console.error('ERROR: Minimax TTS API è¿”å›é”™è¯¯ - å®Œæ•´è¿”å›:', errorData);
                    
                    // å°è¯•ä»è¿”å›çš„JSONä¸­è·å–æ›´å…·ä½“çš„é”™è¯¯ä¿¡æ¯
                    if (errorData && errorData.base_resp && errorData.base_resp.status_msg) {
                        errorMsg += `: ${errorData.base_resp.status_msg}`;
                    } else if (errorData && errorData.error) {
                        errorMsg += `: ${errorData.error}`;
                    } else if (errorData && errorData.message) {
                        errorMsg += `: ${errorData.message}`;
                    } else {
                        errorMsg += `: ${JSON.stringify(errorData)}`;
                    }
                } catch (e) {
                    // å¦‚æœè§£æJSONå¤±è´¥ï¼Œåˆ™ç›´æ¥æ˜¾ç¤ºæ–‡æœ¬å“åº”
                    const errorText = await response.text();
                    console.error('ERROR: Minimax TTS API è¿”å›é”™è¯¯ (æ–‡æœ¬) - å®Œæ•´è¿”å›:', errorText);
                    errorMsg += `: ${errorText}`;
                }
                throw new Error(errorMsg);
            }

            // å¤„ç†æˆåŠŸçš„å“åº”
            // æœåŠ¡å™¨è¿”å›çš„æ˜¯éŸ³é¢‘æ•°æ®æµï¼Œæˆ‘ä»¬å°†å…¶è½¬æ¢ä¸º Blob
            const audioBlob = await response.blob();
            
            if (!audioBlob || !audioBlob.type.startsWith('audio/')) {
                console.error("æœåŠ¡å™¨æœªè¿”å›æœ‰æ•ˆçš„éŸ³é¢‘ã€‚Content-Type:", audioBlob.type);
                throw new Error(`æœåŠ¡å™¨è¿”å›äº†éé¢„æœŸçš„å†…å®¹ç±»å‹: ${audioBlob.type}`);
            }

            // 8. ä¿å­˜åˆ°ç¼“å­˜ï¼ˆå¼‚æ­¥è¿›è¡Œï¼Œä¸é˜»å¡æ’­æ”¾ï¼‰
            if (window.VoiceStorageAPI) {
                window.VoiceStorageAPI.storeVoice(audioBlob, text, voiceId, {
                    model: "speech-01",
                    apiSource: "minimax",
                    generatedAt: new Date().toISOString()
                }).then(() => {
                    console.log('è¯­éŸ³å·²ä¿å­˜åˆ°ç¼“å­˜:', { textLength: text.length, voiceId });
                }).catch(error => {
                    console.error('è¯­éŸ³ç¼“å­˜ä¿å­˜å¤±è´¥:', error);
                });
            }

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ URL æŒ‡å‘è¿™ä¸ª Blob æ•°æ®
            audioUrl = URL.createObjectURL(audioBlob);
        }

        // 9. æ’­æ”¾éŸ³é¢‘
        voiceAudio.src = audioUrl;

        // å½“éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºæ—¶é•¿ï¼ˆå¯é€‰ï¼Œè¯­éŸ³å›¾æ ‡æ–¹æ¡ˆå¯ä»¥ä¸æ˜¾ç¤ºæ—¶é•¿ï¼‰
        voiceAudio.onloadedmetadata = () => {
            if (isFinite(voiceAudio.duration)) {
                // åœ¨æ–°çš„è®¾è®¡ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ˜¾ç¤ºæ—¶é•¿ï¼Œå› ä¸ºæ²¡æœ‰durationå…ƒç´ 
                console.log('è¯­éŸ³æ—¶é•¿:', voiceAudio.duration + 'ç§’');
            }
        };

        // æ’­æ”¾éŸ³é¢‘
        await voiceAudio.play();

        // æ›´æ–°UIä¸ºæ’­æ”¾çŠ¶æ€
        bubbleElement.classList.remove('loading');
        bubbleElement.classList.add('playing');
        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon('playing');

        // æ˜¾ç¤ºç¼“å­˜çŠ¶æ€æç¤ºï¼ˆå¯é€‰ï¼‰
        if (fromCache) {
            console.log('è¯­éŸ³æ’­æ”¾æˆåŠŸï¼ˆæ¥è‡ªç¼“å­˜ï¼‰');
        } else {
            console.log('è¯­éŸ³æ’­æ”¾æˆåŠŸï¼ˆæ¥è‡ªAPIï¼‰');
        }

    } catch (error) {
        // 10. ç»Ÿä¸€å¤„ç†æ‰€æœ‰é”™è¯¯
        console.error('è¯­éŸ³æ’­æ”¾å¤±è´¥:', error);
        showToast(`è¯­éŸ³æ’­æ”¾é”™è¯¯: ${error.message}`);
        bubbleElement.classList.remove('loading');
        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
        currentPlayingElement = null; // é‡ç½®å½“å‰æ’­æ”¾å…ƒç´ 
    }
}

// ã€ã€ã€ã€ã€è¿™æ˜¯ä½ è¦åœ¨ script.js æœ«å°¾æ–°å¢çš„å‡½æ•°ã€‘ã€‘ã€‘ã€‘ã€‘

async function handleShareData() {
    const shareBtn = document.getElementById('shareDataBtn');
    shareBtn.disabled = true;
    shareBtn.textContent = 'ç”Ÿæˆä¸­...';

    try {
        // 1. ä½¿ç”¨ä½ å·²æœ‰çš„ IndexedDBManager å¯¼å‡ºæ•´ä¸ªæ•°æ®åº“çš„æ•°æ®
        const exportData = await dbManager.exportDatabase();

        // 2. å°†æ•°æ®å‘é€åˆ°æˆ‘ä»¬çš„Vercelä¸­è½¬ç«™
        const response = await fetch('https://transfer.cdsv.cc/api/transfer-data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(exportData),
        });

        if (!response.ok) {
            throw new Error('åˆ›å»ºåˆ†äº«é“¾æ¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚');
        }

        const result = await response.json();
        if (!result.success || !result.id) {
            throw new Error(result.error || 'æœåŠ¡å™¨è¿”å›æ•°æ®æ ¼å¼é”™è¯¯ã€‚');
        }

        // 3. æ„é€ ç»™Vercelåº”ç”¨ä½¿ç”¨çš„é“¾æ¥
        const vercelAppUrl = 'https://chat.whale-llt.top'; 
        const shareLink = `${vercelAppUrl}/?importId=${result.id}`;

        // 4. æ˜¾ç¤ºåˆ†äº«é“¾æ¥ç»™ç”¨æˆ·
        showShareLinkDialog(shareLink);

    } catch (error) {
        console.error('åˆ†äº«æ•°æ®å¤±è´¥:', error);
        showToast('åˆ†äº«å¤±è´¥: ' + error.message);
    } finally {
        shareBtn.disabled = false;
        shareBtn.textContent = 'ğŸ”— åˆ†äº«åˆ°æ–°è®¾å¤‡';
    }
}

// ä¸€ä¸ªç”¨äºæ˜¾ç¤ºåˆ†äº«é“¾æ¥çš„å¯¹è¯æ¡†å‡½æ•°
function showShareLinkDialog(link) {
    const dialogId = 'shareLinkDialog';
    let dialog = document.getElementById(dialogId);
    if (!dialog) {
        dialog = document.createElement('div');
        dialog.id = dialogId;
        dialog.className = 'modal';
        dialog.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">åˆ†äº«é“¾æ¥å·²ç”Ÿæˆ</div>
                    <div class="modal-close" onclick="closeModal('${dialogId}')">å…³é—­</div>
                </div>
                <div class="modal-body" style="text-align: center;">
                    <p style="margin-bottom: 15px; font-size: 14px; color: #666;">è¯·å¤åˆ¶ä»¥ä¸‹é“¾æ¥ï¼Œåœ¨æ–°è®¾å¤‡æˆ–æµè§ˆå™¨ä¸­æ‰“å¼€å³å¯è‡ªåŠ¨å¯¼å…¥æ•°æ®ã€‚é“¾æ¥15åˆ†é’Ÿå†…æœ‰æ•ˆã€‚</p>
                    <textarea id="shareLinkTextarea" class="form-textarea" rows="3" readonly>${link}</textarea>
                    <button class="form-submit" style="margin-top: 15px;" onclick="copyShareLink()">å¤åˆ¶é“¾æ¥</button>
                </div>
            </div>
        `;
        document.body.appendChild(dialog);
    } else {
        document.getElementById('shareLinkTextarea').value = link;
    }
    showModal(dialogId);
}

/**
 * å¤åˆ¶é“¾æ¥åˆ°å‰ªè´´æ¿çš„è¾…åŠ©å‡½æ•°
 */
function copyShareLink() {
    const textarea = document.getElementById('shareLinkTextarea');
    textarea.select();
    document.execCommand('copy');
    showToast('é“¾æ¥å·²å¤åˆ¶ï¼');
}

/**
 * å¤„ç†ä»URLè‡ªåŠ¨å¯¼å…¥çš„é€»è¾‘
 */
async function handleAutoImport(importId) {
    // 1. æ¸…ç†URLï¼Œé˜²æ­¢åˆ·æ–°é¡µé¢æ—¶é‡å¤å¯¼å…¥
    window.history.replaceState({}, document.title, window.location.pathname);

    // 2. æ˜¾ç¤ºä¸€ä¸ªå‹å¥½çš„åŠ è½½æç¤º
    showToast('æ£€æµ‹åˆ°åˆ†äº«æ•°æ®ï¼Œæ­£åœ¨å¯¼å…¥...');

    try {
        // 3. å»Vercelä¸­è½¬ç«™å–å›æ•°æ®
        const transferUrl = `https://transfer.cdsv.cc/api/transfer-data?id=${importId}`;
        const response = await fetch(transferUrl);

        if (!response.ok) {
            const error = await response.json().catch(() => null);
            throw new Error(error?.error || 'æ•°æ®è·å–å¤±è´¥ï¼Œé“¾æ¥å¯èƒ½å·²å¤±æ•ˆã€‚');
        }

        const result = await response.json();
        if (!result.success || !result.data) {
            throw new Error(result.error || 'æœåŠ¡å™¨è¿”å›æ•°æ®æ ¼å¼é”™è¯¯ã€‚');
        }

        const importData = result.data;

        // ğŸ¯ ç­‰å¾…UnifiedDBå°±ç»ª - è§£å†³å•æ–‡ä»¶æ„å»ºæ—¶åºé—®é¢˜
        await new Promise((resolve, reject) => {
            // æ£€æŸ¥å‡½æ•°æ˜¯å¦å·²ç»å°±ç»ª
            if (window.performImport && typeof window.performImport === 'function') {
                console.log('âœ… [Import] å¯¼å…¥åŠŸèƒ½å·²å°±ç»ªï¼Œç›´æ¥ç»§ç»­');
                resolve();
                return;
            }

            console.log('â³ [Import] ç­‰å¾…å¯¼å…¥åŠŸèƒ½åˆå§‹åŒ–...');

            // è®¾ç½®è¶…æ—¶ä¿æŠ¤
            const timeout = setTimeout(() => {
                reject(new Error('å¯¼å…¥åŠŸèƒ½åˆå§‹åŒ–è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•'));
            }, 8000);

            // ç›‘å¬å°±ç»ªäº‹ä»¶
            const handleReady = (event) => {
                clearTimeout(timeout);
                console.log('âœ… [Import] æ”¶åˆ°å°±ç»ªé€šçŸ¥:', event.detail.message);
                resolve();
            };

            window.addEventListener('unifieddb:ready', handleReady, { once: true });
        });

        // 4. ä½¿ç”¨ä½ å·²æœ‰çš„å¯¼å…¥é€»è¾‘ (dataMigrator.js)
        if (!window.dbManager) {
            window.dbManager = new IndexedDBManager();
        }
        await dbManager.initDB();
        
        // 5. è°ƒç”¨å¯¼å…¥å‡½æ•°ï¼Œç›´æ¥è¦†ç›–
        const importResult = await dbManager.importDatabase(importData, { overwrite: true });

        // ğŸ” å®½å®¹çš„ç»“æœæ£€æŸ¥ - é€šå¸¸åˆ·æ–°åä¼šè‡ªè¡Œä¿®å¤
        if (!importResult) {
            console.warn('âš ï¸ [Import] å¯¼å…¥è¿”å›ç©ºç»“æœï¼Œä½†é€šå¸¸åˆ·æ–°åä¼šæ­£å¸¸');
            alert('å¯¼å…¥åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•ã€‚\n\nï¼ˆè¿™æ˜¯æ­£å¸¸ç°è±¡ï¼Œåˆ·æ–°åé€šå¸¸èƒ½æˆåŠŸå¯¼å…¥ï¼‰');
            return; // é™é»˜å¤±è´¥ï¼Œä¸æŠ›å‡ºé”™è¯¯
        }

        if (importResult.success) {
            alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼é¡µé¢å°†è‡ªåŠ¨åˆ·æ–°ä»¥åº”ç”¨æ–°æ•°æ®ã€‚');
            setTimeout(() => {
                window.location.reload();
            }, 1500);
        } else {
            throw new Error(importResult.error || 'å¯¼å…¥æ•°æ®åº“æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ã€‚');
        }

    } catch (error) {
        console.error('è‡ªåŠ¨å¯¼å…¥å¤±è´¥:', error);
        alert('è‡ªåŠ¨å¯¼å…¥å¤±è´¥: ' + error.message + '\n\nå³å°†æ­£å¸¸åŠ è½½é¡µé¢ã€‚');
        // å¦‚æœå¯¼å…¥å¤±è´¥ï¼Œå°±æ­£å¸¸åˆå§‹åŒ–é¡µé¢
        await init();
    }
}

// === å›¾ç‰‡è¿ç§»åŠŸèƒ½ ===

/**
 * æ£€æŸ¥å›¾ç‰‡è¿ç§»çŠ¶æ€
 */
async function checkImageMigrationStatus() {
    const statusText = document.getElementById('migrationStatusText');
    const statusDetails = document.getElementById('migrationStatusDetails');
    const startMigrationBtn = document.getElementById('startMigrationBtn');
    
    try {
        statusText.textContent = 'æ£€æŸ¥ä¸­...';
        statusDetails.innerHTML = '<div>æ­£åœ¨æ£€æŸ¥å›¾ç‰‡æ•°æ®çŠ¶æ€...</div>';
        
        // ç¡®ä¿è¿ç§»ç®¡ç†å™¨å·²åˆå§‹åŒ–
        if (!window.ImageMigrationManager) {
            throw new Error('å›¾ç‰‡è¿ç§»ç®¡ç†å™¨æœªåŠ è½½');
        }
        
        await window.ImageMigrationManager.init();
        
        // æ£€æŸ¥è¿ç§»çŠ¶æ€
        const migrationStatus = await window.ImageMigrationManager.checkMigrationNeeded();
        
        if (migrationStatus.error) {
            statusText.textContent = 'æ£€æŸ¥å¤±è´¥';
            statusDetails.innerHTML = `<div style="color: #dc3545;">é”™è¯¯: ${migrationStatus.error}</div>`;
            return;
        }
        
        if (!migrationStatus.needed) {
            statusText.textContent = 'âœ… å·²ä¼˜åŒ–';
            statusDetails.innerHTML = '<div style="color: #28a745;">å¤ªæ£’äº†ï¼æ‰€æœ‰å›¾ç‰‡æ•°æ®éƒ½å·²é‡‡ç”¨é«˜æ•ˆçš„å­˜å‚¨æ ¼å¼ã€‚</div>';
            startMigrationBtn.disabled = true;
            startMigrationBtn.textContent = 'âœ… æ— éœ€ä¼˜åŒ–';
            return;
        }
        
        // éœ€è¦è¿ç§»
        statusText.textContent = `${migrationStatus.totalFiles} ä¸ªæ–‡ä»¶å¾…ä¼˜åŒ–`;
        
        let detailsHtml = '<div style="margin-bottom: 8px;"><strong>å‘ç°ä»¥ä¸‹æ•°æ®éœ€è¦ä¼˜åŒ–ï¼š</strong></div>';
        
        if (migrationStatus.details.contacts.needsMigration > 0) {
            detailsHtml += `<div>â€¢ è”ç³»äººå¤´åƒ: ${migrationStatus.details.contacts.needsMigration} ä¸ª</div>`;
        }
        if (migrationStatus.details.userProfile.needsMigration > 0) {
            detailsHtml += `<div>â€¢ ç”¨æˆ·å¤´åƒ: ${migrationStatus.details.userProfile.needsMigration} ä¸ª</div>`;
        }
        if (migrationStatus.details.emojiImages.needsMigration > 0) {
            detailsHtml += `<div>â€¢ è¡¨æƒ…åŒ…: ${migrationStatus.details.emojiImages.needsMigration} ä¸ª</div>`;
        }
        if (migrationStatus.details.backgrounds.needsMigration > 0) {
            detailsHtml += `<div>â€¢ èƒŒæ™¯å›¾ç‰‡: ${migrationStatus.details.backgrounds.needsMigration} ä¸ª</div>`;
        }
        if (migrationStatus.details.moments.needsMigration > 0) {
            detailsHtml += `<div>â€¢ æœ‹å‹åœˆå›¾ç‰‡: ${migrationStatus.details.moments.needsMigration} ä¸ª</div>`;
        }
        
        // ä¼°ç®—å­˜å‚¨ç©ºé—´èŠ‚çœ
        const savings = await window.ImageMigrationManager.estimateStorageSavings(migrationStatus);
        detailsHtml += `<div style="margin-top: 8px; color: #ff9500;"><strong>é¢„è®¡èŠ‚çœå­˜å‚¨ç©ºé—´: ${savings.formattedSavings}</strong></div>`;
        
        statusDetails.innerHTML = detailsHtml;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = 'ğŸš€ å¼€å§‹ä¼˜åŒ–';
        
    } catch (error) {
        console.error('æ£€æŸ¥è¿ç§»çŠ¶æ€å¤±è´¥:', error);
        statusText.textContent = 'æ£€æŸ¥å¤±è´¥';
        statusDetails.innerHTML = `<div style="color: #dc3545;">æ£€æŸ¥å¤±è´¥: ${error.message}</div>`;
    }
}

/**
 * å¼€å§‹å›¾ç‰‡æ•°æ®è¿ç§»
 */
async function startImageMigration() {
    const statusText = document.getElementById('migrationStatusText');
    const statusDetails = document.getElementById('migrationStatusDetails');
    const startMigrationBtn = document.getElementById('startMigrationBtn');
    const migrationProgress = document.getElementById('migrationProgress');
    const progressBar = document.getElementById('migrationProgressBar');
    const progressText = document.getElementById('migrationProgressText');
    
    try {
        // ç¡®è®¤æ“ä½œ
        const confirmed = confirm('å¼€å§‹å›¾ç‰‡å­˜å‚¨ä¼˜åŒ–ï¼Ÿ\n\nè¿™ä¸ªè¿‡ç¨‹å°†ï¼š\nâ€¢ å°†ç°æœ‰base64å›¾ç‰‡è½¬æ¢ä¸ºé«˜æ•ˆçš„æ–‡ä»¶å­˜å‚¨æ ¼å¼\nâ€¢ æ˜¾è‘—å‡å°‘å­˜å‚¨ç©ºé—´å ç”¨\nâ€¢ æå‡åº”ç”¨æ€§èƒ½\n\nä¼˜åŒ–è¿‡ç¨‹ä¸­è¯·å‹¿å…³é—­é¡µé¢ã€‚');
        
        if (!confirmed) {
            return;
        }
        
        // ç¦ç”¨æŒ‰é’®ï¼Œæ˜¾ç¤ºè¿›åº¦
        startMigrationBtn.disabled = true;
        startMigrationBtn.textContent = 'ä¼˜åŒ–ä¸­...';
        migrationProgress.style.display = 'block';
        statusText.textContent = 'ä¼˜åŒ–ä¸­...';
        
        // è¿›åº¦å›è°ƒå‡½æ•°
        const progressCallback = (progress) => {
            const percentage = Math.round((progress.current / progress.total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `æ­£åœ¨ä¼˜åŒ– ${progress.type}: ${progress.item} (${progress.current}/${progress.total})`;
        };
        
        // æ‰§è¡Œè¿ç§»
        const result = await window.ImageMigrationManager.performFullMigration(progressCallback);
        
        if (result.success) {
            // è¿ç§»æˆåŠŸ
            statusText.textContent = 'âœ… ä¼˜åŒ–å®Œæˆ';
            progressBar.style.width = '100%';
            progressText.textContent = 'ä¼˜åŒ–å®Œæˆï¼';
            
            let successHtml = `<div style="color: #28a745; margin-bottom: 8px;"><strong>${result.message}</strong></div>`;
            
            if (result.summary) {
                successHtml += `<div>â€¢ æˆåŠŸä¼˜åŒ–: ${result.summary.totalSuccess} ä¸ªæ–‡ä»¶</div>`;
                if (result.summary.totalFailed > 0) {
                    successHtml += `<div style="color: #dc3545;">â€¢ ä¼˜åŒ–å¤±è´¥: ${result.summary.totalFailed} ä¸ªæ–‡ä»¶</div>`;
                }
            }
            
            successHtml += '<div style="margin-top: 8px; color: #666; font-size: 11px;">å›¾ç‰‡æ•°æ®å·²ä¼˜åŒ–ä¸ºé«˜æ•ˆçš„æ–‡ä»¶å­˜å‚¨æ ¼å¼ï¼Œå­˜å‚¨ç©ºé—´å ç”¨æ˜¾è‘—å‡å°‘ã€‚</div>';
            
            statusDetails.innerHTML = successHtml;
            startMigrationBtn.textContent = 'âœ… ä¼˜åŒ–å®Œæˆ';
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            if (typeof showToast === 'function') {
                showToast('å›¾ç‰‡å­˜å‚¨ä¼˜åŒ–å®Œæˆï¼å­˜å‚¨ç©ºé—´å ç”¨å·²æ˜¾è‘—å‡å°‘ã€‚');
            } else {
                alert('å›¾ç‰‡å­˜å‚¨ä¼˜åŒ–å®Œæˆï¼å­˜å‚¨ç©ºé—´å ç”¨å·²æ˜¾è‘—å‡å°‘ã€‚');
            }
            
        } else {
            // è¿ç§»å¤±è´¥
            statusText.textContent = 'ä¼˜åŒ–å¤±è´¥';
            statusDetails.innerHTML = `<div style="color: #dc3545;">ä¼˜åŒ–å¤±è´¥: ${result.error}</div>`;
            startMigrationBtn.disabled = false;
            startMigrationBtn.textContent = 'ğŸš€ é‡è¯•ä¼˜åŒ–';
            
            console.error('å›¾ç‰‡æ•°æ®è¿ç§»å¤±è´¥:', result);
        }
        
    } catch (error) {
        console.error('æ‰§è¡Œå›¾ç‰‡è¿ç§»å¤±è´¥:', error);
        statusText.textContent = 'ä¼˜åŒ–å¤±è´¥';
        statusDetails.innerHTML = `<div style="color: #dc3545;">ä¼˜åŒ–å¤±è´¥: ${error.message}</div>`;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = 'ğŸš€ é‡è¯•ä¼˜åŒ–';
        
        if (typeof showToast === 'function') {
            showToast('å›¾ç‰‡å­˜å‚¨ä¼˜åŒ–å¤±è´¥: ' + error.message);
        }
    } finally {
        // éšè—è¿›åº¦æ¡
        setTimeout(() => {
            migrationProgress.style.display = 'none';
        }, 3000);
    }
}

// === èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»åŠŸèƒ½ ===

/**
 * æ£€æŸ¥èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»çŠ¶æ€
 */
async function checkChatEmojiMigrationStatus() {
    const statusText = document.getElementById('chatEmojiMigrationStatusText');
    const statusDetails = document.getElementById('chatEmojiMigrationStatusDetails');
    const startMigrationBtn = document.getElementById('startChatEmojiMigrationBtn');
    
    try {
        statusText.textContent = 'æ£€æŸ¥ä¸­...';
        statusDetails.innerHTML = '<div>æ­£åœ¨æ£€æŸ¥èŠå¤©è®°å½•ä¸­çš„è¡¨æƒ…åŒ…çŠ¶æ€...</div>';
        
        // ç¡®ä¿è¿ç§»ç®¡ç†å™¨å·²åˆå§‹åŒ–
        if (!window.ChatEmojiMigrationManager) {
            throw new Error('èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»ç®¡ç†å™¨æœªåŠ è½½');
        }
        
        await window.ChatEmojiMigrationManager.init();
        
        // æ£€æŸ¥è¿ç§»çŠ¶æ€
        const migrationStatus = await window.ChatEmojiMigrationManager.checkChatEmojiMigrationNeeded();
        
        if (migrationStatus.error) {
            statusText.textContent = 'æ£€æŸ¥å¤±è´¥';
            statusDetails.innerHTML = `<div style="color: #dc3545;">é”™è¯¯: ${migrationStatus.error}</div>`;
            return;
        }
        
        if (!migrationStatus.needed) {
            statusText.textContent = 'âœ… å·²ä¼˜åŒ–';
            statusDetails.innerHTML = '<div style="color: #28a745;">å¤ªæ£’äº†ï¼èŠå¤©è®°å½•ä¸­çš„è¡¨æƒ…åŒ…éƒ½å·²é‡‡ç”¨é«˜æ•ˆçš„å­˜å‚¨æ ¼å¼ã€‚</div>';
            startMigrationBtn.disabled = true;
            startMigrationBtn.textContent = 'âœ… æ— éœ€ä¼˜åŒ–';
            return;
        }
        
        // éœ€è¦è¿ç§»
        const totalItems = migrationStatus.details.base64EmojisFound + migrationStatus.details.emojiImagesNeedingMigration;
        statusText.textContent = `${totalItems} ä¸ªè¡¨æƒ…å¾…ä¼˜åŒ–`;
        
        let detailsHtml = '<div style="margin-bottom: 8px;"><strong>å‘ç°ä»¥ä¸‹æ•°æ®éœ€è¦ä¼˜åŒ–ï¼š</strong></div>';
        
        if (migrationStatus.details.base64EmojisFound > 0) {
            detailsHtml += `<div>â€¢ èŠå¤©è®°å½•ä¸­çš„è¡¨æƒ…: ${migrationStatus.details.base64EmojisFound} ä¸ª</div>`;
            detailsHtml += `<div>â€¢ æ¶‰åŠè”ç³»äºº: ${migrationStatus.details.contactsNeedingMigration} ä¸ª</div>`;
        }
        
        if (migrationStatus.details.emojiImagesNeedingMigration > 0) {
            detailsHtml += `<div>â€¢ è¡¨æƒ…å›¾ç‰‡åº“: ${migrationStatus.details.emojiImagesNeedingMigration} ä¸ª</div>`;
        }
        
        // ä¼°ç®—è¿ç§»æ•ˆæœ
        const benefits = await window.ChatEmojiMigrationManager.estimateMigrationBenefits(migrationStatus);
        detailsHtml += `<div style="margin-top: 8px; color: #1890ff;"><strong>é¢„è®¡èŠ‚çœå­˜å‚¨ç©ºé—´: ${benefits.formattedSavings}</strong></div>`;
        detailsHtml += '<div style="color: #666; font-size: 11px;">ä¼˜åŒ–åAPIè°ƒç”¨å°†ä½¿ç”¨[emoji:æ„æ€]æ ¼å¼ï¼Œæå‡å…¼å®¹æ€§</div>';
        
        statusDetails.innerHTML = detailsHtml;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = 'ğŸ’¬ å¼€å§‹ä¼˜åŒ–';
        
    } catch (error) {
        console.error('æ£€æŸ¥èŠå¤©è¡¨æƒ…è¿ç§»çŠ¶æ€å¤±è´¥:', error);
        statusText.textContent = 'æ£€æŸ¥å¤±è´¥';
        statusDetails.innerHTML = `<div style="color: #dc3545;">æ£€æŸ¥å¤±è´¥: ${error.message}</div>`;
    }
}

/**
 * å¼€å§‹èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»
 */
async function startChatEmojiMigration() {
    const statusText = document.getElementById('chatEmojiMigrationStatusText');
    const statusDetails = document.getElementById('chatEmojiMigrationStatusDetails');
    const startMigrationBtn = document.getElementById('startChatEmojiMigrationBtn');
    const migrationProgress = document.getElementById('chatEmojiMigrationProgress');
    const progressBar = document.getElementById('chatEmojiMigrationProgressBar');
    const progressText = document.getElementById('chatEmojiMigrationProgressText');
    
    try {
        // ç¡®è®¤æ“ä½œ
        const confirmed = confirm('å¼€å§‹èŠå¤©è®°å½•è¡¨æƒ…åŒ…ä¼˜åŒ–ï¼Ÿ\n\nè¿™ä¸ªè¿‡ç¨‹å°†ï¼š\nâ€¢ å°†èŠå¤©è®°å½•ä¸­çš„base64è¡¨æƒ…è½¬æ¢ä¸ºé«˜æ•ˆçš„æ–‡ä»¶å­˜å‚¨æ ¼å¼\nâ€¢ ä¿æŒAPIè°ƒç”¨å…¼å®¹æ€§ï¼ˆä½¿ç”¨[emoji:æ„æ€]æ ¼å¼ï¼‰\nâ€¢ æ˜¾è‘—å‡å°‘å­˜å‚¨ç©ºé—´å ç”¨\nâ€¢ æå‡èŠå¤©è®°å½•åŠ è½½æ€§èƒ½\n\nä¼˜åŒ–è¿‡ç¨‹ä¸­è¯·å‹¿å…³é—­é¡µé¢ã€‚');
        
        if (!confirmed) {
            return;
        }
        
        // ç¦ç”¨æŒ‰é’®ï¼Œæ˜¾ç¤ºè¿›åº¦
        startMigrationBtn.disabled = true;
        startMigrationBtn.textContent = 'ä¼˜åŒ–ä¸­...';
        migrationProgress.style.display = 'block';
        statusText.textContent = 'ä¼˜åŒ–ä¸­...';
        
        // è¿›åº¦å›è°ƒå‡½æ•°
        const progressCallback = (progress) => {
            const percentage = Math.round((progress.current / progress.total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `æ­£åœ¨ä¼˜åŒ– ${progress.type}: ${progress.item} (${progress.current}/${progress.total})`;
        };
        
        // æ‰§è¡Œè¿ç§»
        const result = await window.ChatEmojiMigrationManager.performChatEmojiMigration(progressCallback);
        
        if (result.success) {
            // è¿ç§»æˆåŠŸ
            statusText.textContent = 'âœ… ä¼˜åŒ–å®Œæˆ';
            progressBar.style.width = '100%';
            progressText.textContent = 'ä¼˜åŒ–å®Œæˆï¼';
            
            let successHtml = `<div style="color: #28a745; margin-bottom: 8px;"><strong>${result.message}</strong></div>`;
            
            if (result.results) {
                successHtml += `<div>â€¢ ä¼˜åŒ–è”ç³»äºº: ${result.results.contactsMigrated} ä¸ª</div>`;
                successHtml += `<div>â€¢ ä¼˜åŒ–è¡¨æƒ…: ${result.results.base64EmojisMigrated} ä¸ª</div>`;
                successHtml += `<div>â€¢ ä¼˜åŒ–è¡¨æƒ…å›¾ç‰‡: ${result.results.emojiImagesMigrated} ä¸ª</div>`;
                
                if (result.results.errors.length > 0) {
                    successHtml += `<div style="color: #ffc107;">â€¢ ä¼˜åŒ–å¤±è´¥: ${result.results.errors.length} ä¸ª</div>`;
                }
            }
            
            successHtml += '<div style="margin-top: 8px; color: #666; font-size: 11px;">èŠå¤©è®°å½•è¡¨æƒ…åŒ…å·²ä¼˜åŒ–å®Œæˆï¼ŒAPIè°ƒç”¨å°†ä½¿ç”¨[emoji:æ„æ€]æ ¼å¼ã€‚</div>';
            
            statusDetails.innerHTML = successHtml;
            startMigrationBtn.textContent = 'âœ… ä¼˜åŒ–å®Œæˆ';
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            if (typeof showToast === 'function') {
                showToast('èŠå¤©è®°å½•è¡¨æƒ…åŒ…ä¼˜åŒ–å®Œæˆï¼å­˜å‚¨æ ¼å¼å·²ç»Ÿä¸€ã€‚');
            } else {
                alert('èŠå¤©è®°å½•è¡¨æƒ…åŒ…ä¼˜åŒ–å®Œæˆï¼å­˜å‚¨æ ¼å¼å·²ç»Ÿä¸€ã€‚');
            }
            
            // åˆ·æ–°å½“å‰èŠå¤©æ˜¾ç¤º
            if (window.currentContact) {
                await renderMessages(false); // æ˜ç¡®æŒ‡å®šéåˆå§‹åŠ è½½ï¼Œé¿å…æ»šåŠ¨
            }
            
        } else {
            // è¿ç§»å¤±è´¥
            statusText.textContent = 'ä¼˜åŒ–å¤±è´¥';
            statusDetails.innerHTML = `<div style="color: #dc3545;">ä¼˜åŒ–å¤±è´¥: ${result.error}</div>`;
            startMigrationBtn.disabled = false;
            startMigrationBtn.textContent = 'ğŸ’¬ é‡è¯•ä¼˜åŒ–';
            
            console.error('èŠå¤©è¡¨æƒ…è¿ç§»å¤±è´¥:', result);
        }
        
    } catch (error) {
        console.error('æ‰§è¡ŒèŠå¤©è¡¨æƒ…è¿ç§»å¤±è´¥:', error);
        statusText.textContent = 'ä¼˜åŒ–å¤±è´¥';
        statusDetails.innerHTML = `<div style="color: #dc3545;">ä¼˜åŒ–å¤±è´¥: ${error.message}</div>`;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = 'ğŸ’¬ é‡è¯•ä¼˜åŒ–';
        
        if (typeof showToast === 'function') {
            showToast('èŠå¤©è®°å½•è¡¨æƒ…åŒ…ä¼˜åŒ–å¤±è´¥: ' + error.message);
        }
    } finally {
        // éšè—è¿›åº¦æ¡
        setTimeout(() => {
            migrationProgress.style.display = 'none';
        }, 3000);
    }
}

// === è‡ªåŠ¨æ–‡ä»¶å­˜å‚¨è¿ç§»åŠŸèƒ½ï¼ˆç‰ˆæœ¬8â†’9ï¼‰ ===

/**
 * æ‰§è¡Œæ–‡ä»¶å­˜å‚¨è¿ç§»ï¼ˆç‰ˆæœ¬8â†’9å‡çº§æ—¶è‡ªåŠ¨è°ƒç”¨ï¼‰
 */
async function performFileStorageMigration() {
    try {
        console.log('å¼€å§‹æ‰§è¡Œæ–‡ä»¶å­˜å‚¨è‡ªåŠ¨è¿ç§»...');
        
        if (!window.isIndexedDBReady) {
            console.error('æ•°æ®åº“æœªå‡†å¤‡å°±ç»ªï¼Œæ— æ³•æ‰§è¡Œè¿ç§»');
            return;
        }
        
        // ç­‰å¾…æ‰€æœ‰ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
        let attempts = 0;
        const maxAttempts = 10;
        
        while (attempts < maxAttempts) {
            if (window.ImageMigrationManager && window.ChatEmojiMigrationManager) {
                break;
            }
            console.log(`ç­‰å¾…è¿ç§»ç®¡ç†å™¨åˆå§‹åŒ–... (${attempts + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 500));
            attempts++;
        }
        
        if (!window.ImageMigrationManager || !window.ChatEmojiMigrationManager) {
            console.error('è¿ç§»ç®¡ç†å™¨æœªåŠ è½½ï¼Œè·³è¿‡è‡ªåŠ¨è¿ç§»');
            return;
        }
        
        console.log('å¼€å§‹è‡ªåŠ¨è¿ç§»æ­¥éª¤1ï¼šåŸºç¡€å›¾ç‰‡æ•°æ®è¿ç§»');
        
        // æ­¥éª¤1ï¼šé¦–å…ˆæ‰§è¡ŒåŸºç¡€å›¾ç‰‡è¿ç§»ï¼ˆå¤´åƒã€èƒŒæ™¯ã€è¡¨æƒ…åŒ…å›¾ç‰‡ï¼‰
        try {
            await window.ImageMigrationManager.init();
            const imageMigrationStatus = await window.ImageMigrationManager.checkMigrationNeeded();
            
            if (imageMigrationStatus.needed) {
                console.log(`å‘ç° ${imageMigrationStatus.totalFiles} ä¸ªå›¾ç‰‡æ–‡ä»¶éœ€è¦è¿ç§»`);
                
                const imageResult = await window.ImageMigrationManager.performFullMigration((progress) => {
                    console.log(`è¿ç§»è¿›åº¦: ${progress.type} - ${progress.item} (${progress.current}/${progress.total})`);
                });
                
                if (imageResult.success) {
                    console.log('åŸºç¡€å›¾ç‰‡æ•°æ®è¿ç§»å®Œæˆ:', imageResult.summary);
                } else {
                    console.error('åŸºç¡€å›¾ç‰‡æ•°æ®è¿ç§»å¤±è´¥:', imageResult.error);
                }
            } else {
                console.log('æ— éœ€è¿›è¡ŒåŸºç¡€å›¾ç‰‡æ•°æ®è¿ç§»');
            }
        } catch (error) {
            console.error('åŸºç¡€å›¾ç‰‡è¿ç§»è¿‡ç¨‹å‡ºé”™:', error);
        }
        
        console.log('å¼€å§‹è‡ªåŠ¨è¿ç§»æ­¥éª¤2ï¼šèŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»');
        
        // æ­¥éª¤2ï¼šç„¶åæ‰§è¡ŒèŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»
        try {
            await window.ChatEmojiMigrationManager.init();
            const chatEmojiStatus = await window.ChatEmojiMigrationManager.checkChatEmojiMigrationNeeded();
            
            if (chatEmojiStatus.needed) {
                const totalEmojis = chatEmojiStatus.details.base64EmojisFound + chatEmojiStatus.details.emojiImagesNeedingMigration;
                console.log(`å‘ç° ${totalEmojis} ä¸ªèŠå¤©è¡¨æƒ…éœ€è¦è¿ç§»`);
                
                const chatResult = await window.ChatEmojiMigrationManager.performChatEmojiMigration((progress) => {
                    console.log(`èŠå¤©è¡¨æƒ…è¿ç§»è¿›åº¦: ${progress.type} - ${progress.item} (${progress.current}/${progress.total})`);
                });
                
                if (chatResult.success) {
                    console.log('èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»å®Œæˆ:', chatResult.results);
                } else {
                    console.error('èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»å¤±è´¥:', chatResult.error);
                }
            } else {
                console.log('æ— éœ€è¿›è¡ŒèŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»');
            }
        } catch (error) {
            console.error('èŠå¤©è¡¨æƒ…è¿ç§»è¿‡ç¨‹å‡ºé”™:', error);
        }
        
        console.log('æ–‡ä»¶å­˜å‚¨è‡ªåŠ¨è¿ç§»æµç¨‹å®Œæˆ');
        
        // åˆ·æ–°å½“å‰èŠå¤©æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        if (window.currentContact) {
            try {
                await renderMessages(false); // æ˜ç¡®æŒ‡å®šéåˆå§‹åŠ è½½ï¼Œé¿å…æ»šåŠ¨
                console.log('èŠå¤©ç•Œé¢å·²åˆ·æ–°');
            } catch (error) {
                console.warn('åˆ·æ–°èŠå¤©ç•Œé¢å¤±è´¥:', error);
            }
        }
        
    } catch (error) {
        console.error('æ–‡ä»¶å­˜å‚¨è‡ªåŠ¨è¿ç§»å¤±è´¥:', error);
    }
}

// --- ä¸ªäººä¸»é¡µåŠŸèƒ½ ---
let currentUserProfileContact = null;
let userProfilePreviousPage = 'profilePage'; // è®°å½•ä»å“ªä¸ªé¡µé¢è¿›å…¥çš„ä¸ªäººä¸»é¡µ

// æ˜¾ç¤ºç”¨æˆ·ä¸ªäººä¸»é¡µï¼ˆè‡ªå·±çš„ä¸»é¡µï¼‰
async function showUserProfile() {
    currentUserProfileContact = null; // è¡¨ç¤ºæ˜¯è‡ªå·±çš„ä¸»é¡µ
    userProfilePreviousPage = 'profilePage'; // ä»ä¸ªäººä¿¡æ¯é¡µé¢è¿›å…¥
    showPage('userProfilePage');
    
    // ç¡®ä¿æ•°æ®å·²åŠ è½½
    await waitForDataReady();
    await loadUserProfileData();
}

// æ˜¾ç¤ºå…¶ä»–ç”¨æˆ·çš„ä¸ªäººä¸»é¡µ
async function showContactProfile(contact) {
    currentUserProfileContact = contact;
    userProfilePreviousPage = 'momentsPage'; // ä»æœ‹å‹åœˆè¿›å…¥
    showPage('userProfilePage');
    
    // ç¡®ä¿æ•°æ®å·²åŠ è½½
    await waitForDataReady();
    await loadUserProfileData();
}

// ä»ä¸ªäººä¸»é¡µè¿”å›
function goBackFromUserProfile() {
    showPage(userProfilePreviousPage);
}

// åŠ è½½ä¸ªäººä¸»é¡µæ•°æ®
async function loadUserProfileData() {
    try {
        const userProfileBanner = document.getElementById('userProfileBanner');
        const userProfileAvatar = document.getElementById('userProfileAvatar');
        const userProfileName = document.getElementById('userProfileName');
        const userProfileMomentsList = document.getElementById('userProfileMomentsList');
        const userProfileMomentsEmpty = document.querySelector('.user-profile-moments-empty');
        
        
        if (currentUserProfileContact) {
            // æ˜¾ç¤ºè”ç³»äººçš„ä¸»é¡µ
            const contact = currentUserProfileContact;
            
            // è®¾ç½®å¤´åƒ - ä½¿ç”¨getAvatarHTMLè·å–å¤´åƒå†…å®¹
            try {
                const avatarHTML = await getAvatarHTML(contact, 'contact', 'user-profile-avatar-inner');
                if (avatarHTML.includes('<img')) {
                    // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œæå–srcå¹¶è®¾ç½®ä¸ºèƒŒæ™¯å›¾ç‰‡
                    const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        userProfileAvatar.style.backgroundImage = `url(${srcMatch[1]})`;
                        userProfileAvatar.textContent = '';
                    } else {
                        // å›é€€åˆ°æ—§é€»è¾‘
                        userProfileAvatar.style.backgroundImage = '';
                        userProfileAvatar.textContent = contact.name?.charAt(0) || '?';
                    }
                } else {
                    // å¦‚æœæ˜¯æ–‡å­—å¤´åƒ
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = contact.name?.charAt(0) || '?';
                }
            } catch (error) {
                console.warn('è·å–è”ç³»äººå¤´åƒå¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘:', error);
                if (contact.avatar) {
                    userProfileAvatar.style.backgroundImage = `url(${contact.avatar})`;
                    userProfileAvatar.textContent = '';
                } else {
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = contact.name?.charAt(0) || '?';
                }
            }
            
            // è®¾ç½®ç”¨æˆ·åï¼Œå¦‚æœæ˜¯ä¸´æ—¶è”ç³»äººåˆ™æ˜¾ç¤ºç‰¹æ®Šæ ·å¼
            userProfileName.textContent = contact.name || 'æœªçŸ¥ç”¨æˆ·';
            if (contact.isTemporary) {
                userProfileName.style.color = '#ff6b6b';
                userProfileName.style.fontSize = '18px';
            } else {
                userProfileName.style.color = '#fff';
                userProfileName.style.fontSize = '20px';
            }
            
            // è®¾ç½®bannerèƒŒæ™¯ï¼ˆä¸´æ—¶è”ç³»äººä½¿ç”¨ä¸åŒé¢œè‰²ï¼‰
            if (contact.isTemporary) {
                userProfileBanner.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
            } else {
                userProfileBanner.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
            
        } else {
            // æ˜¾ç¤ºè‡ªå·±çš„ä¸»é¡µ
            const userProfile = await getUserProfile();
            
            // è®¾ç½®å¤´åƒ - ä½¿ç”¨getAvatarHTMLè·å–å¤´åƒå†…å®¹ï¼Œæ”¯æŒæ–°çš„æ–‡ä»¶ç³»ç»Ÿ
            try {
                const avatarHTML = await getAvatarHTML(userProfile, 'user', 'user-profile-avatar-inner');
                if (avatarHTML.includes('<img')) {
                    // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œæå–srcå¹¶è®¾ç½®ä¸ºèƒŒæ™¯å›¾ç‰‡
                    const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        userProfileAvatar.style.backgroundImage = `url(${srcMatch[1]})`;
                        userProfileAvatar.textContent = '';
                    } else {
                        // å›é€€åˆ°æ—§é€»è¾‘
                        userProfileAvatar.style.backgroundImage = '';
                        userProfileAvatar.textContent = userProfile.name?.charAt(0) || 'æˆ‘';
                        console.log('è®¾ç½®å¤´åƒæ–‡å­—ï¼ˆè§£æå¤±è´¥ï¼‰:', userProfile.name?.charAt(0) || 'æˆ‘');
                    }
                } else {
                    // å¦‚æœæ˜¯æ–‡å­—å¤´åƒ
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = userProfile.name?.charAt(0) || 'æˆ‘';
                }
            } catch (error) {
                console.warn('è·å–ç”¨æˆ·å¤´åƒå¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘:', error);
                if (userProfile.avatar) {
                    userProfileAvatar.style.backgroundImage = `url(${userProfile.avatar})`;
                    userProfileAvatar.textContent = '';
                    console.log('è®¾ç½®å¤´åƒå›¾ç‰‡ï¼ˆå›é€€ï¼‰:', userProfile.avatar);
                } else {
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = userProfile.name?.charAt(0) || 'æˆ‘';
                    console.log('è®¾ç½®å¤´åƒæ–‡å­—ï¼ˆå›é€€ï¼‰:', userProfile.name?.charAt(0) || 'æˆ‘');
                }
            }
            
            // è®¾ç½®ç”¨æˆ·å
            userProfileName.textContent = userProfile.name || 'æˆ‘çš„æ˜µç§°';
            
            // è®¾ç½®bannerèƒŒæ™¯
            userProfileBanner.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        }
        
        // åŠ è½½æœ‹å‹åœˆåŠ¨æ€
        await loadUserProfileMoments();
        
    } catch (error) {
        console.error('åŠ è½½ä¸ªäººä¸»é¡µæ•°æ®å¤±è´¥:', error);
    }
}

// è·å–æ‰€æœ‰æœ‹å‹åœˆåŠ¨æ€
async function getAllMoments() {
    
    // ç¡®ä¿æ•°æ®å·²åŠ è½½
    if (!window.moments && (!moments || moments.length === 0)) {
        await waitForDataReady();
    }
    
    return window.moments || moments || [];
}

// åŠ è½½ç”¨æˆ·çš„æœ‹å‹åœˆåŠ¨æ€
async function loadUserProfileMoments() {
    try {
        const userProfileMomentsList = document.getElementById('userProfileMomentsList');
        const userProfileMomentsEmpty = document.querySelector('.user-profile-moments-empty');
        
        // è·å–æœ‹å‹åœˆæ•°æ®
        const moments = await getAllMoments();
        
        // è¿‡æ»¤å‡ºå½“å‰ç”¨æˆ·çš„åŠ¨æ€
        let userMoments = [];
        
        if (currentUserProfileContact) {
            // æ˜¾ç¤ºè”ç³»äººçš„åŠ¨æ€
            console.log('ç­›é€‰è”ç³»äººåŠ¨æ€ï¼Œè”ç³»äººå§“å:', currentUserProfileContact.name);
            userMoments = moments.filter(moment => 
                moment.authorName === currentUserProfileContact.name
            );
        } else {
            // æ˜¾ç¤ºè‡ªå·±çš„åŠ¨æ€ï¼ˆä½œè€…æ˜¯"æˆ‘"æˆ–ç”¨æˆ·è®¾ç½®çš„æ˜µç§°ï¼‰
            const userProfile = await getUserProfile();
            const userName = userProfile.name || 'æˆ‘çš„æ˜µç§°';
            userMoments = moments.filter(moment => 
                moment.authorName === 'æˆ‘' || moment.authorName === userName
            );
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œä¹Ÿå°è¯•åŒ¹é…æ‰€æœ‰åŠ¨æ€çš„ä½œè€…å
            if (userMoments.length === 0) {
                moments.forEach((moment, index) => {
                });
            }
        }
        
        if (userMoments.length === 0) {
            userProfileMomentsEmpty.style.display = 'block';
            userProfileMomentsList.style.display = 'none';
        } else {
            userProfileMomentsEmpty.style.display = 'none';
            userProfileMomentsList.style.display = 'block';
            
            // æ¸…ç©ºç°æœ‰å†…å®¹
            userProfileMomentsList.innerHTML = '';
            
            // æ¸²æŸ“æœ‹å‹åœˆåŠ¨æ€
            for (const moment of userMoments) {
                const momentElement = await createUserProfileMomentElement(moment);
                userProfileMomentsList.appendChild(momentElement);
            }
        }
        
    } catch (error) {
        console.error('åŠ è½½ç”¨æˆ·æœ‹å‹åœˆåŠ¨æ€å¤±è´¥:', error);
    }
}

// åˆ‡æ¢æœ‹å‹åœˆèœå•æ˜¾ç¤º/éšè—
function toggleMomentMenu(momentId) {
    const menu = document.getElementById(`momentMenu-${momentId}`);
    const allMenus = document.querySelectorAll('.moment-menu');
    
    // å…³é—­æ‰€æœ‰å…¶ä»–èœå•
    allMenus.forEach(m => {
        if (m !== menu) {
            m.style.display = 'none';
        }
    });
    
    // åˆ‡æ¢å½“å‰èœå•
    if (menu) {
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
}

// é‡æ–°ç”Ÿæˆæœ‹å‹åœˆå›¾ç‰‡
async function regenerateMomentImage(momentId) {
    try {
        // æ£€æŸ¥æœ‹å‹åœˆæ“ä½œæ˜¯å¦è¢«é”å®š
        if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
            return;
        }
        
        // å…³é—­èœå•
        const menu = document.getElementById(`momentMenu-${momentId}`);
        if (menu) menu.style.display = 'none';
        
        // æ‰¾åˆ°å¯¹åº”çš„æœ‹å‹åœˆ
        const moment = moments.find(m => m.id === momentId);
        if (!moment) {
            showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„æœ‹å‹åœˆ');
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰åŸå§‹å†…å®¹å¯ä»¥é‡æ–°ç”Ÿæˆå›¾ç‰‡
        if (!moment.content && !moment.originalContent) {
            showToast('è¯¥æœ‹å‹åœˆæ²¡æœ‰å†…å®¹ï¼Œæ— æ³•ç”Ÿæˆå›¾ç‰‡');
            return;
        }
        
        const unsplashKey = localStorage.getItem('forumUnsplashApiKey') || localStorage.getItem('unsplashApiKey');
        if (!unsplashKey) {
            showToast('è¯·å…ˆé…ç½®Unsplash API Key');
            return;
        }
        
        showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆå›¾ç‰‡...');
        
        // ä½¿ç”¨æœ‹å‹åœˆå†…å®¹ç”Ÿæˆå›¾ç‰‡
        const contentForImage = moment.originalContent || moment.content;
        const imageUrl = await fetchMatchingImageForPublish(contentForImage, unsplashKey);
        
        if (imageUrl) {
            // ç›´æ¥ä¿å­˜Unsplash URLï¼Œä¸å­˜å‚¨åˆ°IndexedDB
            moment.image = imageUrl;
            moment.imageCount = 1;
            moment.isUnsplashImage = true; // æ ‡è®°ä¸ºUnsplashå›¾ç‰‡
            // æ¸…é™¤æœ¬åœ°å­˜å‚¨çš„å›¾ç‰‡IDï¼ˆå¦‚æœä¹‹å‰æœ‰çš„è¯ï¼‰
            delete moment.imageFileIds;
            
            // æ›´æ–°æ•°æ®åº“å¹¶æ ‡è®°æ•°æ®ä¿®æ”¹
            await saveDataToDB();
            isMomentsDataModified = true;
            
            // é‡æ–°æ¸²æŸ“æœ‹å‹åœˆ
            await renderMomentsList();
            
            showToast('å›¾ç‰‡å·²é‡æ–°ç”Ÿæˆï¼');
        } else {
            showToast('å›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
        }
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆæœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
        isMomentsDataModified = true; // å³ä½¿å¤±è´¥ä¹Ÿæ ‡è®°ï¼Œç¡®ä¿ä¸‹æ¬¡åˆ‡æ¢é¡µé¢æ—¶åˆ·æ–°
        showToast('å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
}

// åˆ é™¤æœ‹å‹åœˆå›¾ç‰‡
async function removeMomentImage(momentId) {
    try {
        // å…³é—­èœå•
        const menu = document.getElementById(`momentMenu-${momentId}`);
        if (menu) menu.style.display = 'none';
        
        // æ‰¾åˆ°å¯¹åº”çš„æœ‹å‹åœˆ
        const moment = moments.find(m => m.id === momentId);
        if (!moment) {
            showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„æœ‹å‹åœˆ');
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡å¯ä»¥åˆ é™¤
        if (!moment.image && (!moment.imageFileIds || moment.imageFileIds.length === 0)) {
            showToast('è¯¥æœ‹å‹åœˆæ²¡æœ‰å›¾ç‰‡ï¼Œæ— éœ€åˆ é™¤');
            return;
        }
        
        // åˆ é™¤å›¾ç‰‡ç›¸å…³æ•°æ®
        delete moment.image;
        delete moment.imageFileIds;
        delete moment.isUnsplashImage;
        moment.imageCount = 0;
        
        // æ›´æ–°æ•°æ®åº“
        await saveDataToDB();
        
        // é‡æ–°æ¸²æŸ“æœ‹å‹åœˆ
        await renderMomentsList();
        
        showToast('å›¾ç‰‡å·²åˆ é™¤');
    } catch (error) {
        console.error('åˆ é™¤æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
        showToast('åˆ é™¤å›¾ç‰‡å¤±è´¥: ' + error.message);
    }
}

// é‡æ–°ç”Ÿæˆè¯„è®º
async function regenerateComments(momentId) {
    try {
        // æ£€æŸ¥æœ‹å‹åœˆæ“ä½œæ˜¯å¦è¢«é”å®š
        if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
            return;
        }
        
        // å…³é—­èœå•
        const menu = document.getElementById(`momentMenu-${momentId}`);
        if (menu) menu.style.display = 'none';
        
        // æ‰¾åˆ°å¯¹åº”çš„æœ‹å‹åœˆ
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) {
            showToast('æœªæ‰¾åˆ°è¦é‡æ–°ç”Ÿæˆè¯„è®ºçš„æœ‹å‹åœˆ');
            return;
        }
        
        const moment = moments[momentIndex];
        showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆè¯„è®º...');
        
        // æ¸…ç©ºç°æœ‰è¯„è®ºå’Œç‚¹èµ
        moment.comments = [];
        moment.likes = 0;
        
        // é‡æ–°ç”Ÿæˆè¯„è®º
        const newComments = await generateAICommentsWithCurrentTime(moment.content, { location: moment.location });
        moment.comments = newComments;

        // ä¿å­˜åˆ°æ•°æ®åº“
        await saveDataToDB();
        
        // æ ‡è®°æœ‹å‹åœˆæ•°æ®å·²è¢«ä¿®æ”¹
        isMomentsDataModified = true;
        
        // å°è¯•å±€éƒ¨æ›´æ–°UI
        try {
            await updateMomentElement(momentId, 'comments');
            console.log('âœ… è¯„è®ºå±€éƒ¨æ›´æ–°æˆåŠŸ');
        } catch (updateError) {
            console.warn('âš ï¸ è¯„è®ºå±€éƒ¨æ›´æ–°å¤±è´¥ï¼Œå°è¯•å¼ºåˆ¶åˆ·æ–°æœ‹å‹åœˆåˆ—è¡¨:', updateError);
            
            // å±€éƒ¨æ›´æ–°å¤±è´¥æ—¶ï¼Œå¼ºåˆ¶é‡æ–°æ¸²æŸ“æ•´ä¸ªæœ‹å‹åœˆåˆ—è¡¨
            await renderMomentsList();
            console.log('ğŸ”„ æœ‹å‹åœˆåˆ—è¡¨é‡æ–°æ¸²æŸ“å®Œæˆ');
        }

        showToast('è¯„è®ºé‡æ–°ç”Ÿæˆå®Œæˆï¼');
        
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆè¯„è®ºå¤±è´¥:', error);
        
        // åœ¨å‡ºé”™æ—¶ä¹Ÿæ ‡è®°æ•°æ®ä¿®æ”¹ï¼Œç¡®ä¿ä¸‹æ¬¡é¡µé¢åˆ‡æ¢æ—¶èƒ½åˆ·æ–°
        isMomentsDataModified = true;
        
        // åœ¨å‡ºé”™æ—¶ä¹Ÿå°è¯•åˆ·æ–°UIï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
        try {
            await renderMomentsList();
            console.log('ğŸ”„ é”™è¯¯æ¢å¤ï¼šæœ‹å‹åœˆåˆ—è¡¨å·²åˆ·æ–°');
        } catch (renderError) {
            console.error('ğŸ”´ ä¸¥é‡é”™è¯¯ï¼šæ— æ³•åˆ·æ–°æœ‹å‹åœˆåˆ—è¡¨', renderError);
        }
        
        showApiError(error);
    }
}

// ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹å…³é—­æ‰€æœ‰èœå•
document.addEventListener('click', function(event) {
    if (!event.target.closest('.moment-menu-btn') && !event.target.closest('.moment-menu')) {
        const allMenus = document.querySelectorAll('.moment-menu');
        allMenus.forEach(menu => {
            menu.style.display = 'none';
        });
    }
});

// å¤„ç†æœ‹å‹åœˆå¤´åƒç‚¹å‡»äº‹ä»¶

function toggleMomentActions(momentId) {
    const menu = document.getElementById(`momentActions-${momentId}`);
    if (!menu) {
        console.error('Menu not found for moment:', momentId);
        return;
    }

    const allMenus = document.querySelectorAll('.moment-actions-menu');
    const isActive = menu.classList.contains('active');

    // ç»Ÿä¸€å…ˆå…³é—­æ‰€æœ‰èœå•
    allMenus.forEach(m => {
        m.classList.remove('active');
    });

    if (!isActive) {
        menu.classList.add('active');
    }

    // ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•çš„é€»è¾‘ï¼ˆä¿ç•™ï¼Œä½†å¯ä»¥ç®€åŒ–ï¼‰
    if (!isActive) {
        setTimeout(() => {
            const closeHandler = (e) => {
                if (!e.target.closest('.moment-collapse-btn')) {
                     menu.classList.remove('active');
                     document.removeEventListener('click', closeHandler, true);
                }
            };
            document.addEventListener('click', closeHandler, true);
        }, 0);
    }
}

// ç‚¹èµæœ‹å‹åœˆ
async function likeMoment(momentId) {
    try {
        const userProfile = await getUserProfile();
        const userName = userProfile.name || 'æˆ‘';
        
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // åˆå§‹åŒ–ç‚¹èµåˆ—è¡¨
        if (!moment.likes) {
            moment.likes = [];
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²ç‚¹èµ
        const hasLiked = moment.likes.includes(userName);
        
        if (hasLiked) {
            // å–æ¶ˆç‚¹èµ
            moment.likes = moment.likes.filter(name => name !== userName);
            showToast('å·²å–æ¶ˆç‚¹èµ');
        } else {
            // æ·»åŠ ç‚¹èµ
            moment.likes.push(userName);
            showToast('ç‚¹èµæˆåŠŸ');
        }
        
        // ä¿å­˜å¹¶æ ‡è®°æ•°æ®ä¿®æ”¹
        await saveDataToDB();
        isMomentsDataModified = true;
        
        // æ£€æµ‹å½“å‰åœ¨å“ªä¸ªé¡µé¢
        const userProfilePage = document.getElementById('userProfilePage');
        const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
        
        if (isInUserProfile) {
            // å¦‚æœåœ¨ä¸ªäººä¸»é¡µï¼Œé‡æ–°åŠ è½½ä¸ªäººä¸»é¡µçš„æœ‹å‹åœˆ
            await loadUserProfileMoments();
        } else {
            // å¦‚æœåœ¨å‘ç°é¡µé¢ï¼Œä½¿ç”¨æ€§èƒ½ä¼˜åŒ–çš„å±€éƒ¨æ›´æ–°
            await updateMomentElement(momentId, 'likes');
        }
        
        // å…³é—­èœå•
        const menu = document.getElementById(`momentActions-${momentId}`);
        if (menu) menu.classList.remove('active');
        
    } catch (error) {
        console.error('ç‚¹èµå¤±è´¥:', error);
        isMomentsDataModified = true; // å³ä½¿å¤±è´¥ä¹Ÿæ ‡è®°ï¼Œç¡®ä¿ä¸‹æ¬¡åˆ‡æ¢é¡µé¢æ—¶åˆ·æ–°
        showToast('ç‚¹èµå¤±è´¥');
    }
}

// æ˜¾ç¤ºæœ‹å‹åœˆè¯„è®ºæ¡†
function showMomentComment(momentId) {
    // æ£€æµ‹å½“å‰åœ¨å“ªä¸ªé¡µé¢
    const userProfilePage = document.getElementById('userProfilePage');
    const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
    
    let replyContainer;
    if (isInUserProfile) {
        // åœ¨ä¸ªäººä¸»é¡µï¼ŒæŸ¥æ‰¾ä¸ªäººä¸»é¡µçš„å›å¤å®¹å™¨
        replyContainer = userProfilePage.querySelector(`#momentMainReply-${momentId}`);
    } else {
        // åœ¨å‘ç°é¡µé¢ï¼ŒæŸ¥æ‰¾å‘ç°é¡µé¢çš„å›å¤å®¹å™¨
        replyContainer = document.getElementById(`momentMainReply-${momentId}`);
    }
    
    if (!replyContainer) {
        console.error('Reply container not found for moment:', momentId);
        return;
    }
    
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.add('active');
    window.UIManager.safeFocus(textarea, { delay: 100 });
    
    // å…³é—­èœå•ï¼ˆå‘ç°é¡µé¢æ‰æœ‰èœå•ï¼‰
    if (!isInUserProfile) {
        const menu = document.getElementById(`momentActions-${momentId}`);
        if (menu) menu.classList.remove('active');
    }
}

// éšè—æœ‹å‹åœˆè¯„è®ºæ¡†
function hideMomentComment(momentId) {
    // æ£€æµ‹å½“å‰åœ¨å“ªä¸ªé¡µé¢
    const userProfilePage = document.getElementById('userProfilePage');
    const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
    
    let replyContainer;
    if (isInUserProfile) {
        // åœ¨ä¸ªäººä¸»é¡µï¼ŒæŸ¥æ‰¾ä¸ªäººä¸»é¡µçš„å›å¤å®¹å™¨
        replyContainer = userProfilePage.querySelector(`#momentMainReply-${momentId}`);
    } else {
        // åœ¨å‘ç°é¡µé¢ï¼ŒæŸ¥æ‰¾å‘ç°é¡µé¢çš„å›å¤å®¹å™¨
        replyContainer = document.getElementById(`momentMainReply-${momentId}`);
    }
    
    if (!replyContainer) {
        console.error('Reply container not found for moment:', momentId);
        return;
    }
    
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.remove('active');
    textarea.value = '';
}

// æäº¤æœ‹å‹åœˆè¯„è®º
async function submitMomentComment(momentId) {
    try {
        const userProfile = await getUserProfile();
        const userName = userProfile.name || 'æˆ‘';
        
        // æ£€æµ‹å½“å‰åœ¨å“ªä¸ªé¡µé¢
        const userProfilePage = document.getElementById('userProfilePage');
        const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
        
        let replyContainer;
        if (isInUserProfile) {
            // åœ¨ä¸ªäººä¸»é¡µï¼ŒæŸ¥æ‰¾ä¸ªäººä¸»é¡µçš„å›å¤å®¹å™¨
            replyContainer = userProfilePage.querySelector(`#momentMainReply-${momentId}`);
        } else {
            // åœ¨å‘ç°é¡µé¢ï¼ŒæŸ¥æ‰¾å‘ç°é¡µé¢çš„å›å¤å®¹å™¨
            replyContainer = document.getElementById(`momentMainReply-${momentId}`);
        }
        
        if (!replyContainer) {
            console.error('Reply container not found for moment:', momentId);
            return;
        }
        
        const textarea = replyContainer.querySelector('.moment-reply-input');
        const content = textarea.value.trim();
        
        if (!content) {
            showToast('è¯·è¾“å…¥è¯„è®ºå†…å®¹');
            return;
        }
        
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // æ·»åŠ ç”¨æˆ·è¯„è®º
        const newComment = {
            author: userName,
            content: content,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        if (!moment.comments) {
            moment.comments = [];
        }
        
        moment.comments.push(newComment);
        
        // ä¿å­˜å¹¶æ ‡è®°æ•°æ®ä¿®æ”¹
        await saveDataToDB();
        isMomentsDataModified = true;

        if (isInUserProfile) {
            // å¦‚æœåœ¨ä¸ªäººä¸»é¡µï¼Œé‡æ–°åŠ è½½ä¸ªäººä¸»é¡µçš„æœ‹å‹åœˆ
            await loadUserProfileMoments();
        } else {
            // å¦‚æœåœ¨å‘ç°é¡µé¢ï¼Œä½¿ç”¨æ€§èƒ½ä¼˜åŒ–çš„å±€éƒ¨æ›´æ–°
            await updateMomentElement(momentId, 'comments');
        }

        showToast('è¯„è®ºæˆåŠŸ');
        
        // è§¦å‘æ¥¼ä¸»å›å¤
        setTimeout(() => {
            generateMomentAuthorReply(momentId, userName, content);
        }, 1000);
        
    } catch (error) {
        console.error('è¯„è®ºå¤±è´¥:', error);
        isMomentsDataModified = true; // å³ä½¿å¤±è´¥ä¹Ÿæ ‡è®°ï¼Œç¡®ä¿ä¸‹æ¬¡åˆ‡æ¢é¡µé¢æ—¶åˆ·æ–°
        showToast('è¯„è®ºå¤±è´¥');
    }
}

// æ˜¾ç¤ºè¯„è®ºå›å¤æ¡†
function showCommentReply(commentId, authorName, momentId) {
    const replyContainer = document.getElementById(`${commentId}-reply`);
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.add('active');
    window.UIManager.safeFocus(textarea, { delay: 100 });
    textarea.setAttribute('placeholder', `å›å¤${authorName}...`);
}

// éšè—è¯„è®ºå›å¤æ¡†
function hideCommentReply(commentId) {
    const replyContainer = document.getElementById(`${commentId}-reply`);
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.remove('active');
    textarea.value = '';
}

// æäº¤è¯„è®ºå›å¤
async function submitCommentReply(commentId, replyToAuthor, momentId) {
    try {
        const userProfile = await getUserProfile();
        const userName = userProfile.name || 'æˆ‘';
        
        const replyContainer = document.getElementById(`${commentId}-reply`);
        const textarea = replyContainer.querySelector('.moment-reply-input');
        const content = textarea.value.trim();
        
        if (!content) {
            showToast('è¯·è¾“å…¥å›å¤å†…å®¹');
            return;
        }
        
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // æ·»åŠ ç”¨æˆ·å›å¤
        const newComment = {
            author: userName,
            content: `å›å¤${replyToAuthor}: ${content}`,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        if (!moment.comments) {
            moment.comments = [];
        }
        
        moment.comments.push(newComment);
        
        // ä¿å­˜å¹¶é‡æ–°æ¸²æŸ“
        await saveDataToDB();
        await renderMomentsList();
        
        showToast('å›å¤æˆåŠŸ');
        
        // è§¦å‘è¢«å›å¤äººçš„å›å¤
        setTimeout(() => {
            generateCommentReply(momentId, replyToAuthor, userName, content);
        }, 1000);
        
    } catch (error) {
        console.error('å›å¤å¤±è´¥:', error);
        showToast('å›å¤å¤±è´¥');
    }
}

// ç‚¹å‡»è¯„è®ºä½œè€…å¤´åƒ
function handleCommentAuthorClick(authorName) {
    // å¤ç”¨æœ‹å‹åœˆå¤´åƒç‚¹å‡»é€»è¾‘
    handleMomentAvatarClick(authorName);
}

// æ˜¾ç¤ºæœ‹å‹åœˆè¯„è®ºå›å¤æ¡†ï¼ˆå‘ç°é¡µé¢ç‚¹å‡»è¯„è®ºè¡Œï¼‰
function showMomentReplyToComment(momentId, commentAuthor) {
    // æ˜¾ç¤ºå›å¤æ¡†
    showMomentComment(momentId);
    
    // é¢„å¡«å……@ç”¨æˆ·å
    const replyInput = document.querySelector(`#momentMainReply-${momentId} .moment-reply-input`);
    if (replyInput) {
        const mention = `@${commentAuthor} `;
        const currentText = replyInput.value;
        
        // é¿å…é‡å¤æ·»åŠ @æåŠ
        if (!currentText.includes(mention)) {
            replyInput.value = mention + currentText;
        }
        
        // èšç„¦è¾“å…¥æ¡†å¹¶è®¾ç½®å…‰æ ‡ä½ç½®
        replyInput.focus();
        replyInput.setSelectionRange(replyInput.value.length, replyInput.value.length);
        
        // ç¡®ä¿å›å¤æ¡†æ»šåŠ¨åˆ°å¯è§ä½ç½®
        setTimeout(() => {
            replyInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
    }
}

// ç”Ÿæˆæ¥¼ä¸»å›å¤ç”¨æˆ·è¯„è®º
async function generateMomentAuthorReply(momentId, commenterName, commentContent) {
    try {
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        const authorName = moment.authorName;
        
        // å¦‚æœæ¥¼ä¸»å°±æ˜¯ç”¨æˆ·ï¼Œä¸ç”Ÿæˆå›å¤
        const userProfile = await getUserProfile();
        if (authorName === userProfile.name) return;
        
        // æŸ¥æ‰¾è§’è‰²
        const character = window.contacts?.find(c => c.name === authorName);
        if (!character) return;
        
        // ç”Ÿæˆå›å¤å†…å®¹
        const replyContent = await generateCharacterReply(character, commenterName, commentContent, moment.content);
        
        // æ·»åŠ è§’è‰²å›å¤
        const authorReply = {
            author: authorName,
            content: `å›å¤${commenterName}: ${replyContent}`,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        moments[momentIndex].comments.push(authorReply);
        
        // ä¿å­˜å¹¶é‡æ–°æ¸²æŸ“
        await saveDataToDB();
        await renderMomentsList();
        
    } catch (error) {
        console.error('ç”Ÿæˆæ¥¼ä¸»å›å¤å¤±è´¥:', error);
    }
}

// ç”Ÿæˆè¢«å›å¤äººçš„å›å¤
async function generateCommentReply(momentId, repliedAuthor, replierName, replyContent) {
    try {
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // å¦‚æœè¢«å›å¤çš„æ˜¯ç”¨æˆ·ï¼Œä¸ç”Ÿæˆå›å¤
        const userProfile = await getUserProfile();
        if (repliedAuthor === userProfile.name) return;
        
        // æŸ¥æ‰¾è¢«å›å¤çš„è§’è‰²
        const character = window.contacts?.find(c => c.name === repliedAuthor);
        if (!character) return;
        
        // ç”Ÿæˆå›å¤å†…å®¹
        const responseContent = await generateCharacterReply(character, replierName, replyContent, moment.content);
        
        // æ·»åŠ è§’è‰²å›å¤
        const characterReply = {
            author: repliedAuthor,
            content: responseContent,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        moments[momentIndex].comments.push(characterReply);
        
        // ä¿å­˜å¹¶é‡æ–°æ¸²æŸ“
        await saveDataToDB();
        await renderMomentsList();
        
    } catch (error) {
        console.error('ç”Ÿæˆè§’è‰²å›å¤å¤±è´¥:', error);
    }
}

// ç”Ÿæˆè§’è‰²å›å¤å†…å®¹
async function generateCharacterReply(character, replierName, replyContent, momentContent) {
    try {
        const userProfile = await getUserProfile();
        
        const prompt = window.promptBuilder.buildMomentReplyPrompt(character, replierName, replyContent, momentContent);

        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            throw new Error('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
        }

        const response = await fetch(`${apiCallInfo.url}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiCallInfo.key}`
            },
            body: JSON.stringify({
                model: apiCallInfo.model,
                messages: [
                    { role: 'user', content: prompt }
                ],
                temperature: 0.8,
                max_tokens: 5000
            })
        });
        
        if (!response.ok) {
            throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);
        }
        
        const data = await response.json();
        return data.choices[0]?.message?.content?.trim() || 'å“ˆå“ˆå“ˆ';
        
    } catch (error) {
        console.error('ç”Ÿæˆè§’è‰²å›å¤å¤±è´¥:', error);
        return 'ğŸ˜„';
    }
}

async function handleMomentAvatarClick(authorName) {
    try {
        // è·å–ç”¨æˆ·é…ç½®
        const userProfile = await getUserProfile();
        
        // å¦‚æœæ˜¯è‡ªå·±ï¼Œæ˜¾ç¤ºè‡ªå·±çš„ä¸»é¡µ
        if (authorName === 'æˆ‘' || authorName === userProfile.name) {
            await showUserProfile();
            return;
        }
        
        // æŸ¥æ‰¾å¯¹åº”çš„è”ç³»äºº
        const contact = window.contacts?.find(c => c.name === authorName);
        if (contact) {
            await showContactProfile(contact);
        } else {
            console.error('è”ç³»äººä¸å­˜åœ¨ - è¯¦ç»†ä¿¡æ¯:');
            console.error('- æŸ¥æ‰¾çš„è”ç³»äººå§“å:', authorName);
            console.error('- å½“å‰è”ç³»äººåˆ—è¡¨:', window.contacts);
            console.error('- è”ç³»äººåˆ—è¡¨é•¿åº¦:', window.contacts ? window.contacts.length : 'è”ç³»äººåˆ—è¡¨ä¸ºç©º');
            if (window.contacts && window.contacts.length > 0) {
                console.error('- ç°æœ‰è”ç³»äººå§“ååˆ—è¡¨:', window.contacts.map(c => c.name));
            }
            
            // æ˜¾ç¤ºé”™è¯¯æç¤º
            showToast(`è”ç³»äººä¸å­˜åœ¨: ${authorName}`);
            
            // ä»ç„¶åˆ›å»ºä¸´æ—¶è”ç³»äººå¯¹è±¡ç”¨äºæ˜¾ç¤ºï¼Œä½†æ ‡è®°ä¸ºä¸å­˜åœ¨
            const tempContact = {
                name: `${authorName} (è”ç³»äººä¸å­˜åœ¨)`,
                avatar: null,
                isTemporary: true
            };
            await showContactProfile(tempContact);
        }
    } catch (error) {
        console.error('å¤„ç†å¤´åƒç‚¹å‡»äº‹ä»¶å¤±è´¥:', error);
    }
}

// åˆ›å»ºä¸ªäººä¸»é¡µæœ‹å‹åœˆåŠ¨æ€å…ƒç´ 
async function createUserProfileMomentElement(moment) {
    const momentDiv = document.createElement('div');
    momentDiv.className = 'user-profile-moment-item';
    
    // è·å–å½“å‰ç”¨æˆ·èµ„æ–™ç”¨äºå¤´åƒæ˜¾ç¤º
    const userProfile = await getUserProfile();
    
    let imagesHtml = '';
    
    // å¤„ç†å›¾ç‰‡ - æ”¯æŒæ–°çš„æ–‡ä»¶ç³»ç»Ÿå’Œæ—§çš„base64æ ¼å¼
    if (moment.imageFileIds && moment.imageCount > 0 && window.ImageStorageAPI) {
        // æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨æ–¹å¼
        const imageUrls = [];
        for (let i = 0; i < moment.imageCount; i++) {
            imageUrls.push(`data:image/jpeg;base64,loading...`); // å ä½ç¬¦ï¼Œåç»­å¼‚æ­¥åŠ è½½
        }
        imagesHtml = `
            <div class="user-profile-moment-images">
                ${imageUrls.map((image, index) => `
                    <img src="${image}" alt="æœ‹å‹åœˆå›¾ç‰‡" class="user-profile-moment-image" data-moment-id="${moment.id}" data-image-index="${index}">
                `).join('')}
            </div>
        `;
    } else if (moment.image) {
        // æ—§çš„å•å›¾ç‰‡æ ¼å¼
        imagesHtml = `
            <div class="user-profile-moment-images">
                <img src="${moment.image}" alt="æœ‹å‹åœˆå›¾ç‰‡" class="user-profile-moment-image" onclick="showImagePreview('${moment.image}')">
            </div>
        `;
    } else if (moment.images && moment.images.length > 0) {
        // å¤šå›¾ç‰‡æ ¼å¼
        imagesHtml = `
            <div class="user-profile-moment-images">
                ${moment.images.map(image => `
                    <img src="${image}" alt="æœ‹å‹åœˆå›¾ç‰‡" class="user-profile-moment-image" onclick="showImagePreview('${image}')">
                `).join('')}
            </div>
        `;
    }
    
    // ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´å­—æ®µ
    const timeStr = moment.time || moment.timestamp || new Date().toISOString();
    
    // å¤„ç†ç‚¹èµä¿¡æ¯
    const likes = moment.likes || [];
    let likedUsers = [];
    
    // è·å–ç‚¹èµç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…æ‹¬ç‹¬ç«‹ç‚¹èµå’Œè¯„è®ºç‚¹èµï¼‰
    if (likes.length > 0) {
        likedUsers = [...likes];
    }
    
    if (moment.comments && moment.comments.length > 0) {
        const commentLikedUsers = moment.comments
            .filter(comment => comment.like === true)
            .map(comment => comment.commenter_name || comment.author)
            .filter(author => !likedUsers.includes(author)); // é¿å…é‡å¤
        
        likedUsers = [...likedUsers, ...commentLikedUsers];
    }
    
    const likesContent = likedUsers.length > 0 ? 
        `<div class="moment-likes">â¤ï¸ ${likedUsers.join(', ')}</div>` : '';
    
    // å¤„ç†è¯„è®ºå†…å®¹ - ä¸ªäººä¸»é¡µä½¿ç”¨å®Œæ•´äº¤äº’æ ·å¼
    let commentsContent = '';
    if (moment.comments && moment.comments.length > 0) {
        // å…¼å®¹æ€§å¤„ç†ä¸ªäººèµ„æ–™é¡µæœ‹å‹åœˆè¯„è®ºï¼šæ”¯æŒæ–°æ—§å­—æ®µå
        // æ–°ä»£ç åº”ä½¿ç”¨ç»Ÿä¸€å­—æ®µï¼šcommenter_name, comment_content, timestamp
        const commentsList = moment.comments
            .filter(comment => (comment.comment_content || comment.content) && (comment.comment_content || comment.content).trim())
            .map((comment, index) => {
                const safeContent = (comment.comment_content || comment.content).replace(/'/g, '&#39;');
                const commentTimeStr = comment.timestamp || comment.time || new Date().toISOString();
                const isLiked = comment.like === true ? 'liked' : '';
                const authorName = comment.commenter_name || comment.author;

                const commentAuthorContact = contacts.find(c => c.name === authorName);
                const commentAvatarContent = commentAuthorContact && commentAuthorContact.avatar ?
                    `<img src="${commentAuthorContact.avatar}" alt="å¤´åƒ" style="width: 32px; height: 32px; border-radius: 4px; object-fit: cover;">` :
                    `<div style="width: 32px; height: 32px; border-radius: 4px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 14px;">${authorName.charAt(0)}</div>`;
                
                return `
                    <div class="profile-moment-comment-item" data-comment-index="${index}" style="display: flex; margin-bottom: 12px;">
                        <div style="margin-right: 10px;">${commentAvatarContent}</div>
                        <div style="flex: 1;">
                            <div class="profile-moment-comment-author" onclick="handleCommentAuthorClick('${authorName}')" style="font-weight: 600; color: #576b95; cursor: pointer; line-height: 16px;">${authorName}</div>
                            <div class="profile-moment-comment-text">${safeContent}</div>
                            <div class="profile-moment-comment-actions" style="margin-top: 4px; font-size: 12px; color: #999;">
                                <span class="profile-moment-comment-time">${formatContactListTime(commentTimeStr)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        commentsContent = `<div class="profile-moment-comments">${commentsList}</div>`;
    }
    
    // ä¸ªäººä¸»é¡µä½¿ç”¨ç‹¬ç«‹æŒ‰é’®
    const actionsMenu = `
        <div style="display: flex; gap: 8px;">
            <button onclick="likeMoment('${moment.id}')" style="padding: 4px 8px; background: #f0f0f0; border: none; border-radius: 12px; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px;" title="ç‚¹èµ">
                â¤ ç‚¹èµ
            </button>
            <button onclick="showMomentComment('${moment.id}')" style="padding: 4px 8px; background: #f0f0f0; border: none; border-radius: 12px; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px;" title="è¯„è®º">
                ğŸ’¬ è¯„è®º
            </button>
        </div>
    `;
    
    // å¤„ç†ä½œè€…å¤´åƒ - æ”¯æŒæ–°çš„æ–‡ä»¶ç³»ç»Ÿæ ¼å¼
    let avatarContent = '';
    const author = window.contacts ? window.contacts.find(c => c.name === moment.authorName) : null;
    
    try {
        if (author) {
            // ä½¿ç”¨getAvatarHTMLè·å–è”ç³»äººå¤´åƒ
            const avatarHTML = await getAvatarHTML(author, 'contact', '');
            if (avatarHTML.includes('<img')) {
                const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                if (srcMatch) {
                    avatarContent = `<img src="${srcMatch[1]}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                }
            }
        } else if (moment.authorName === userProfile.name) {
            // å¦‚æœæ˜¯å½“å‰ç”¨æˆ·çš„åŠ¨æ€ï¼Œä½¿ç”¨getAvatarHTMLè·å–ç”¨æˆ·å¤´åƒ
            const avatarHTML = await getAvatarHTML(userProfile, 'user', '');
            if (avatarHTML.includes('<img')) {
                const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                if (srcMatch) {
                    avatarContent = `<img src="${srcMatch[1]}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                }
            }
        }
        
        // å¦‚æœæ²¡æœ‰å¤´åƒæˆ–å¤´åƒè·å–å¤±è´¥ï¼Œä½¿ç”¨æ–‡å­—å¤´åƒ
        if (!avatarContent) {
            avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
        }
    } catch (error) {
        console.warn('è·å–ä¸ªäººä¸»é¡µæœ‹å‹åœˆå¤´åƒå¤±è´¥ï¼Œä½¿ç”¨å›é€€é€»è¾‘:', error);
        // å›é€€åˆ°æ—§çš„é€»è¾‘
        if (author && author.avatar) {
            avatarContent = `<img src="${author.avatar}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
        } else if (moment.authorName === userProfile.name && userProfile.avatar) {
            avatarContent = `<img src="${userProfile.avatar}" alt="å¤´åƒ" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
        } else {
            avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
        }
    }
    
    momentDiv.innerHTML = `
        <div class="moment-header" style="display: flex; margin-bottom: 8px; align-items: flex-start;">
            <div class="moment-avatar" style="margin-right: 12px; flex-shrink: 0;">${avatarContent}</div>
            <div class="moment-info" style="flex: 1; display: flex; flex-direction: column; justify-content: space-between; min-height: 40px;">
                <div class="moment-name" style="font-weight: 600; color: #576b95; font-size: 15px; line-height: 1.2; margin: 0;">${moment.authorName}</div>
                <div class="user-profile-moment-content">${moment.content}</div>
            </div>
        </div>
        ${imagesHtml}
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
            <div class="user-profile-moment-time-location">
                <span>${formatContactListTime(timeStr)}</span>
                ${moment.location ? `<span class="moment-location">ğŸ“ ${moment.location}</span>` : ''}
            </div>
            ${actionsMenu}
        </div>
        ${likesContent}
        ${commentsContent}
        <div class="moment-reply-input-container" id="momentMainReply-${moment.id}" style="display: none;">
            <textarea class="moment-reply-input" placeholder="å†™è¯„è®º..."></textarea>
            <div class="moment-reply-actions">
                <button class="moment-reply-btn moment-reply-cancel" onclick="hideMomentComment('${moment.id}')">å–æ¶ˆ</button>
                <button class="moment-reply-btn moment-reply-submit" onclick="submitMomentComment('${moment.id}')">å‘é€</button>
            </div>
        </div>
    `;
    
    // å¼‚æ­¥åŠ è½½æ–‡ä»¶ç³»ç»Ÿä¸­çš„å›¾ç‰‡
    if (moment.imageFileIds && moment.imageCount > 0 && window.ImageStorageAPI) {
        setTimeout(async () => {
            try {
                await window.ImageStorageAPI.init();
                const imageUrls = await window.ImageStorageAPI.getMomentImagesURLs(moment.id, moment.imageCount);
                const imgElements = momentDiv.querySelectorAll('[data-moment-id="' + moment.id + '"]');
                imgElements.forEach((img, index) => {
                    if (imageUrls[index]) {
                        img.src = imageUrls[index];
                        img.onclick = () => showImagePreview(imageUrls[index]);
                    }
                });
            } catch (error) {
                console.error('åŠ è½½ä¸ªäººä¸»é¡µæœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            }
        }, 100);
    }
    
    return momentDiv;
}

// é¡µé¢åŠ è½½åè‡ªåŠ¨æ£€æŸ¥è¿ç§»çŠ¶æ€ - å»¶è¿Ÿè‡³æ•°æ®åº“åˆå§‹åŒ–å®Œæˆå
document.addEventListener('DOMContentLoaded', () => {
    // ç­‰å¾…æ•°æ®åº“å®Œå…¨åˆå§‹åŒ–åå†æ£€æŸ¥è¿ç§»çŠ¶æ€
    const checkMigrationWhenReady = async () => {
        // ç­‰å¾…æ•°æ®åº“å°±ç»ª
        let attempts = 0;
        while ((!window.db || !window.isIndexedDBReady) && attempts < 30) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        
        if (!window.db) {
            console.warn('æ•°æ®åº“åˆå§‹åŒ–è¶…æ—¶ï¼Œè·³è¿‡è¿ç§»æ£€æŸ¥');
            return;
        }
        
        // æ•°æ®åº“å°±ç»ªåæ‰§è¡Œè¿ç§»æ£€æŸ¥
        if (window.ImageMigrationManager && document.getElementById('migrationStatusText')) {
            try {
                await checkImageMigrationStatus();
            } catch (error) {
                console.error('æ£€æŸ¥å›¾ç‰‡è¿ç§»çŠ¶æ€å¤±è´¥:', error);
            }
        }
        
        // æ£€æŸ¥èŠå¤©è¡¨æƒ…è¿ç§»çŠ¶æ€
        if (window.ChatEmojiMigrationManager && document.getElementById('chatEmojiMigrationStatusText')) {
            try {
                await checkChatEmojiMigrationStatus();
            } catch (error) {
                console.error('æ£€æŸ¥èŠå¤©è¡¨æƒ…è¿ç§»çŠ¶æ€å¤±è´¥:', error);
            }
        }
    };
    
    // å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡å…¶ä»–åˆå§‹åŒ–
    checkMigrationWhenReady().catch(console.error);
});

// === Bannerä¸Šä¼ åŠŸèƒ½ ===

// å…¨å±€å˜é‡ç”¨äºå­˜å‚¨å½“å‰é€‰æ‹©çš„å›¾ç‰‡
let currentBannerImage = null;
let currentBannerCanvas = null;

// æ‰“å¼€bannerä¸Šä¼ æ¨¡æ€æ¡†
function openBannerUploadModal() {
    
    // æ£€æŸ¥æ¨¡æ€æ¡†å…ƒç´ æ˜¯å¦å­˜åœ¨
    const modal = document.getElementById('bannerUploadModal');
    if (!modal) {
        console.error('Bannerä¸Šä¼ æ¨¡æ€æ¡†å…ƒç´ ä¸å­˜åœ¨');
        showToast('æ— æ³•æ‰“å¼€ä¸Šä¼ ç•Œé¢ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        return;
    }
    
    console.log('æ‰¾åˆ°æ¨¡æ€æ¡†å…ƒç´ ï¼Œå‡†å¤‡æ˜¾ç¤º');
    showModal('bannerUploadModal');
    resetBannerUpload();
}

// è§¦å‘æ–‡ä»¶é€‰æ‹©
function triggerBannerFileInput() {
    document.getElementById('bannerFileInput').click();
}

// å¤„ç†æ–‡ä»¶é€‰æ‹©
async function handleBannerFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // éªŒè¯æ–‡ä»¶ç±»å‹
    if (!file.type.match(/^image\/(jpeg|jpg|png)$/)) {
        showToast('è¯·é€‰æ‹© JPG æˆ– PNG æ ¼å¼çš„å›¾ç‰‡');
        return;
    }
    
    // éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º 10MBï¼‰
    if (file.size > 10 * 1024 * 1024) {
        showToast('å›¾ç‰‡æ–‡ä»¶ä¸èƒ½è¶…è¿‡ 10MB');
        return;
    }
    
    try {
        // è¯»å–å›¾ç‰‡
        const imageUrl = await readFileAsDataURL(file);
        const img = new Image();
        
        img.onload = () => {
            currentBannerImage = img;
            setupBannerPreview();
        };
        
        img.onerror = () => {
            showToast('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é€‰æ‹©å…¶ä»–å›¾ç‰‡');
        };
        
        img.src = imageUrl;
        
    } catch (error) {
        console.error('å›¾ç‰‡å¤„ç†å¤±è´¥:', error);
        showToast('å›¾ç‰‡å¤„ç†å¤±è´¥: ' + error.message);
    }
}

// è®¾ç½®banneré¢„è§ˆ
function setupBannerPreview() {
    if (!currentBannerImage) return;
    
    // æ˜¾ç¤ºé¢„è§ˆå®¹å™¨
    const uploadArea = document.getElementById('bannerUploadArea');
    const previewContainer = document.getElementById('bannerPreviewContainer');
    
    uploadArea.style.display = 'none';
    previewContainer.style.display = 'block';
    
    // è®¾ç½®canvaså’Œslider
    currentBannerCanvas = document.getElementById('bannerPreviewCanvas');
    const slider = document.getElementById('bannerCropSlider');
    
    // é‡ç½®slider
    slider.value = 50;
    
    // åˆå§‹æ¸²æŸ“
    updateBannerPreview();
}

// æ›´æ–°banneré¢„è§ˆ
function updateBannerPreview() {
    if (!currentBannerImage || !currentBannerCanvas) return;
    
    const canvas = currentBannerCanvas;
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('bannerCropSlider');
    
    // Canvaså°ºå¯¸ (ä¿æŒ2.5:1çš„banneræ¯”ä¾‹)
    const canvasWidth = 400;
    const canvasHeight = 160;
    
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    
    // è®¡ç®—å›¾ç‰‡å°ºå¯¸å’Œä½ç½®
    const imgWidth = currentBannerImage.width;
    const imgHeight = currentBannerImage.height;
    
    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œç¡®ä¿å›¾ç‰‡å®½åº¦å®Œå…¨è¦†ç›–canvas
    const scaleX = canvasWidth / imgWidth;
    const scaleY = canvasHeight / imgHeight;
    const scale = Math.max(scaleX, scaleY);
    
    const scaledWidth = imgWidth * scale;
    const scaledHeight = imgHeight * scale;
    
    // æ ¹æ®sliderå€¼è®¡ç®—å‚ç›´ä½ç½®
    const cropOffset = (slider.value / 100) * (scaledHeight - canvasHeight);
    
    // æ¸…ç©ºcanvaså¹¶ç»˜åˆ¶å›¾ç‰‡
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.drawImage(
        currentBannerImage,
        (canvasWidth - scaledWidth) / 2, // æ°´å¹³å±…ä¸­
        -cropOffset, // æ ¹æ®sliderè°ƒæ•´å‚ç›´ä½ç½®
        scaledWidth,
        scaledHeight
    );
}

// é‡ç½®bannerä¸Šä¼ 
function resetBannerUpload() {
    currentBannerImage = null;
    currentBannerCanvas = null;
    
    const uploadArea = document.getElementById('bannerUploadArea');
    const previewContainer = document.getElementById('bannerPreviewContainer');
    const fileInput = document.getElementById('bannerFileInput');
    
    if (uploadArea) {
        uploadArea.style.display = 'block';
    } else {
        console.error('ä¸Šä¼ åŒºåŸŸå…ƒç´ ä¸å­˜åœ¨');
    }
    
    if (previewContainer) {
        previewContainer.style.display = 'none';
    } else {
        console.error('é¢„è§ˆå®¹å™¨å…ƒç´ ä¸å­˜åœ¨');
    }
    
    if (fileInput) {
        fileInput.value = '';
    } else {
        console.error('æ–‡ä»¶è¾“å…¥å…ƒç´ ä¸å­˜åœ¨');
    }
}

// ä¿å­˜bannerå›¾ç‰‡
async function saveBannerImage() {
    if (!currentBannerCanvas || !window.ImageStorageAPI) {
        showToast('æ— æ³•ä¿å­˜å›¾ç‰‡ï¼Œè¯·é‡è¯•');
        return;
    }
    
    try {
        // å°†canvasè½¬æ¢ä¸ºblob
        const blob = await canvasToBlob(currentBannerCanvas);
        
        // ç¡®ä¿ ImageStorageAPI å·²åˆå§‹åŒ–
        await window.ImageStorageAPI.init();
        
        // å­˜å‚¨bannerå›¾ç‰‡
        const fileId = await window.ImageStorageAPI.storeBanner(blob, 'user_profile');
        console.log('Bannerå›¾ç‰‡å·²ä¿å­˜ï¼Œæ–‡ä»¶ID:', fileId);
        
        // æ›´æ–°ç”¨æˆ·èµ„æ–™ä¸­çš„bannerå­—æ®µ
        const profile = await getUserProfile();
        profile.bannerFileId = fileId; // è¿™é‡ŒfileIdç°åœ¨åº”è¯¥æ˜¯å­—ç¬¦ä¸²äº†
        await saveDataToDB(); // ä¿å­˜åˆ°IndexedDB
        
        // åº”ç”¨æ–°çš„bannerèƒŒæ™¯
        await applyBannerBackground(fileId);
        
        // å…³é—­æ¨¡æ€æ¡†
        closeModal('bannerUploadModal');
        showToast('èƒŒæ™¯å›¾ç‰‡å·²æ›´æ–°');
        
        // å°è¯•é‡æ–°åŠ è½½banner
        setTimeout(() => {
            loadUserBanner();
        }, 1000);
        
    } catch (error) {
        console.error('ä¿å­˜bannerå¤±è´¥:', error);
        showToast('ä¿å­˜å¤±è´¥: ' + error.message);
    }
}

// åº”ç”¨bannerèƒŒæ™¯
async function applyBannerBackground(fileId) {
    try {
        
        if (!window.ImageStorageAPI) {
            console.error('ImageStorageAPI æœªåŠ è½½');
            return;
        }
        
        await window.ImageStorageAPI.init();
        const bannerUrl = await window.ImageStorageAPI.getBannerURL('user_profile');
        
        const bannerElement = document.getElementById('userProfileBanner');
        
        // å°è¯•å…¶ä»–æ–¹å¼æŸ¥æ‰¾å…ƒç´ 
        const allBanners = document.querySelectorAll('.user-profile-banner');
        
        if (bannerUrl && bannerElement) {
            // æ¸…é™¤åŸæœ‰çš„æ¸å˜èƒŒæ™¯
            bannerElement.style.background = 'none';
            bannerElement.style.backgroundImage = `url(${bannerUrl})`;
            bannerElement.style.backgroundSize = 'cover';
            bannerElement.style.backgroundPosition = 'center';
            bannerElement.style.backgroundRepeat = 'no-repeat';
        } else {
            console.error('Banner URLæˆ–å…ƒç´ ä¸ºç©º:', { bannerUrl, bannerElement });
        }
    } catch (error) {
        console.error('åº”ç”¨bannerèƒŒæ™¯å¤±è´¥:', error);
    }
}

// åŠ è½½ç”¨æˆ·bannerèƒŒæ™¯
async function loadUserBanner() {
    try {
        const userProfile = await getUserProfile();
        console.log('ç”¨æˆ·èµ„æ–™:', userProfile);
        
        if (userProfile.bannerFileId && window.ImageStorageAPI) {
            await applyBannerBackground(userProfile.bannerFileId);
        } else {
        }
    } catch (error) {
        console.error('åŠ è½½ç”¨æˆ·bannerå¤±è´¥:', error);
    }
}

// å·¥å…·å‡½æ•°ï¼šè¯»å–æ–‡ä»¶ä¸ºDataURL
// readFileAsDataURL function moved to utils/formatUtils.js

// å·¥å…·å‡½æ•°ï¼šCanvasè½¬Blob
// canvasToBlob function moved to utils/formatUtils.js

// åœ¨æ˜¾ç¤ºä¸ªäººä¸»é¡µæ—¶åŠ è½½banner
const originalShowUserProfile = showUserProfile;
showUserProfile = async function() {
    if (originalShowUserProfile) {
        await originalShowUserProfile();
    }
    // åŠ è½½bannerèƒŒæ™¯
    setTimeout(loadUserBanner, 100);
};

// ========== ä¸»é¢˜è‰²ç®¡ç†åŠŸèƒ½ ==========

// é»˜è®¤ä¸»é¢˜è‰²é…ç½®
const defaultThemeColors = [
    { color: '#07c160', name: 'é²œç»¿' },
    { color: '#1890ff', name: 'å¤©ç©ºè“' },
    { color: '#722ed1', name: 'æ·±ç´«' },
    { color: '#f5222d', name: 'ç«çº¢' },
    { color: '#fa8c16', name: 'æ©™' },
    { color: '#13c2c2', name: 'æ¸…æ–°é’' },
    { color: '#eb2f96', name: 'äº®ç²‰' },
    { color: '#2f54eb', name: 'æµ·è“' }
];

// é»˜è®¤æ¸å˜é…ç½®
const defaultGradientConfig = {
    enabled: false,
    primaryColor: '#07c160',
    secondaryColor: '#1890ff',
    direction: 'to right'
};

// IndexedDB ä¸»é¢˜é…ç½®ç®¡ç†å™¨
class ThemeConfigManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.db = null;
        this.storeName = 'themeConfig';
    }

    async init() {
        // ä½¿ç”¨å·²æœ‰çš„æ•°æ®åº“è¿æ¥
        if (window.db && window.isIndexedDBReady) {
            this.db = window.db;
            return this.db;
        }
        
        // ç­‰å¾…æ•°æ®åº“å°±ç»ª
        return this.waitForDatabase();
    }

    async waitForDatabase() {
        return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
                if (window.db && window.isIndexedDBReady) {
                    this.db = window.db;
                    clearInterval(checkInterval);
                    resolve(this.db);
                }
            }, 100);
        });
    }


    async saveThemeConfig(type, data) {
        try {
            await this.init();
            
            // æ£€æŸ¥å­˜å‚¨æ˜¯å¦å­˜åœ¨
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.warn('themeConfigå­˜å‚¨ä¸å­˜åœ¨ï¼Œæ— æ³•ä¿å­˜é…ç½®');
                throw new Error('themeConfigå­˜å‚¨ä¸å­˜åœ¨');
            }
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([this.storeName], 'readwrite');
                const store = transaction.objectStore(this.storeName);
                
                const config = {
                    type: type,
                    data: data,
                    updatedAt: new Date().toISOString()
                };
                
                const request = store.put(config);
                
                request.onsuccess = () => {
                    console.log(`ä¸»é¢˜é…ç½®å·²ä¿å­˜åˆ°IndexedDB (${type}):`, data);
                    resolve(true);
                };
                
                request.onerror = () => {
                    console.error('ä¿å­˜ä¸»é¢˜é…ç½®å¤±è´¥:', request.error);
                    reject(request.error);
                };
            });
        } catch (error) {
            console.error('ä¿å­˜ä¸»é¢˜é…ç½®æ—¶å‡ºé”™:', error);
            return false;
        }
    }

    async getThemeConfig(type) {
        try {
            await this.init();
            
            // æ£€æŸ¥å­˜å‚¨æ˜¯å¦å­˜åœ¨
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.warn('themeConfigå­˜å‚¨ä¸å­˜åœ¨ï¼Œè¿”å›null');
                return null;
            }
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([this.storeName], 'readonly');
                const store = transaction.objectStore(this.storeName);
                const request = store.get(type);
                
                request.onsuccess = () => {
                    const result = request.result;
                    resolve(result ? result.data : null);
                };
                
                request.onerror = () => {
                    console.error('è·å–ä¸»é¢˜é…ç½®å¤±è´¥:', request.error);
                    resolve(null);
                };
            });
        } catch (error) {
            console.error('è·å–ä¸»é¢˜é…ç½®æ—¶å‡ºé”™:', error);
            return null;
        }
    }

    async getAllThemeConfigs() {
        try {
            await this.init();
            
            // æ£€æŸ¥å­˜å‚¨æ˜¯å¦å­˜åœ¨
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.warn('themeConfigå­˜å‚¨ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºé…ç½®');
                return {};
            }
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([this.storeName], 'readonly');
                const store = transaction.objectStore(this.storeName);
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const configs = {};
                    request.result.forEach(item => {
                        configs[item.type] = item.data;
                    });
                    resolve(configs);
                };
                
                request.onerror = () => {
                    console.error('è·å–æ‰€æœ‰ä¸»é¢˜é…ç½®å¤±è´¥:', request.error);
                    resolve({});
                };
            });
        } catch (error) {
            console.error('è·å–æ‰€æœ‰ä¸»é¢˜é…ç½®æ—¶å‡ºé”™:', error);
            return {};
        }
    }

    async ensureDefaultConfigs() {
        try {
            await this.init();
            
            // æ£€æŸ¥themeConfigå­˜å‚¨æ˜¯å¦å­˜åœ¨
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.log('themeConfigå­˜å‚¨ä¸å­˜åœ¨ï¼Œéœ€è¦æ•°æ®åº“å‡çº§');
                // è¿”å›falseè¡¨ç¤ºå­˜å‚¨ä¸å­˜åœ¨ï¼Œè®©è°ƒç”¨è€…å†³å®šå¦‚ä½•å¤„ç†
                return { success: false, reason: 'storage_not_exists' };
            }
            
            const configs = await this.getAllThemeConfigs();
            let hasChanges = false;
            
            // å¦‚æœæ²¡æœ‰ä¸»é¢˜é…ç½®ï¼Œåˆ›å»ºé»˜è®¤é…ç½®
            if (!configs.theme) {
                await this.saveThemeConfig('theme', { color: '#07c160', name: 'é²œç»¿' });
                console.log('å·²åˆ›å»ºé»˜è®¤ä¸»é¢˜é…ç½®');
                hasChanges = true;
            }
            
            if (!configs.gradient) {
                await this.saveThemeConfig('gradient', defaultGradientConfig);
                console.log('å·²åˆ›å»ºé»˜è®¤æ¸å˜é…ç½®');
                hasChanges = true;
            }
            
            // å¦‚æœä»æ—§æ ¼å¼localStorageè¿ç§»æ•°æ®
            const migrationResult = this.migrateFromOldLocalStorage();
            if (migrationResult && Object.keys(configs).length === 0) {
                await this.saveThemeConfig('theme', migrationResult.theme);
                await this.saveThemeConfig('gradient', migrationResult.gradient);
                console.log('å·²ä»localStorageè¿ç§»ä¸»é¢˜é…ç½®åˆ°IndexedDB');
                hasChanges = true;
            }
            
            if (hasChanges) {
                console.log('ä¸»é¢˜é…ç½®åˆå§‹åŒ–å®Œæˆ');
            }
            
            return true;
        } catch (error) {
            console.error('ç¡®ä¿é»˜è®¤é…ç½®æ—¶å‡ºé”™:', error);
            return false;
        }
    }


    // ä»æ—§æ ¼å¼localStorageè¿ç§»æ•°æ®ï¼ˆåŒæ­¥æ–¹æ³•ï¼‰
    migrateFromOldLocalStorage() {
        try {
            const savedTheme = localStorage.getItem('user-theme-color');
            const savedGradient = localStorage.getItem('user-gradient-config');
            
            if (!savedTheme && !savedGradient) {
                return null;
            }
            
            let themeData = { color: '#07c160', name: 'é²œç»¿' };
            let gradientData = defaultGradientConfig;
            
            if (savedTheme) {
                themeData = JSON.parse(savedTheme);
                console.log('æ£€æµ‹åˆ°æ—§æ ¼å¼ä¸»é¢˜é…ç½®:', themeData);
                // è¿ç§»åæ¸…ç†æ—§æ•°æ®
                localStorage.removeItem('user-theme-color');
            }
            
            if (savedGradient) {
                gradientData = JSON.parse(savedGradient);
                console.log('æ£€æµ‹åˆ°æ—§æ ¼å¼æ¸å˜é…ç½®:', gradientData);
                // è¿ç§»åæ¸…ç†æ—§æ•°æ®
                localStorage.removeItem('user-gradient-config');
            }
            
            return { theme: themeData, gradient: gradientData };
        } catch (error) {
            console.error('è¿ç§»æ—§æ ¼å¼é…ç½®å¤±è´¥:', error);
            return null;
        }
    }
}

// åˆ›å»ºå…¨å±€ä¸»é¢˜é…ç½®ç®¡ç†å™¨å®ä¾‹
const themeConfigManager = new ThemeConfigManager();

// é€šç”¨çš„æ•°æ®åº“å­˜å‚¨å®‰å…¨æ£€æŸ¥å‡½æ•°
// safeCreateTransaction function moved to utils/formatUtils.js




// ä»IndexedDBåŠ è½½ä¿å­˜çš„ä¸»é¢˜é…ç½®
async function loadThemeConfig() {
    try {
        // ç¡®ä¿é»˜è®¤é…ç½®å­˜åœ¨ï¼ˆåŒ…å«ä»localStorageçš„è‡ªåŠ¨è¿ç§»ï¼‰
        await themeConfigManager.ensureDefaultConfigs();
        
        // ä»IndexedDBåŠ è½½é…ç½®
        const configs = await themeConfigManager.getAllThemeConfigs();
        
        let themeData = configs.theme || { color: '#07c160', name: 'é²œç»¿' };
        let gradientData = configs.gradient || defaultGradientConfig;
        
        // åº”ç”¨ä¸»é¢˜é…ç½®
        if (gradientData.enabled) {
            applyGradientTheme(gradientData.primaryColor, gradientData.secondaryColor, gradientData.direction);
        } else {
            applyThemeColor(themeData.color);
        }
        
        return { theme: themeData, gradient: gradientData };
    } catch (error) {
        console.error('åŠ è½½ä¸»é¢˜é…ç½®å¤±è´¥:', error);
        // ä½¿ç”¨é»˜è®¤é…ç½®
        const themeData = { color: '#07c160', name: 'é²œç»¿' };
        const gradientData = defaultGradientConfig;
        applyThemeColor(themeData.color);
        return { theme: themeData, gradient: gradientData };
    }
}



// å…¼å®¹æ—§çš„å‡½æ•°å
function loadThemeColor() {
    return loadThemeConfig().then(config => config.theme);
}

// åº”ç”¨ä¸»é¢˜è‰²åˆ°é¡µé¢
// applyThemeColor function moved to utils/colorUtils.js

// åº”ç”¨æ¸å˜ä¸»é¢˜
// applyGradientTheme function moved to utils/colorUtils.js

// ä¿å­˜ä¸»é¢˜è‰²åˆ°IndexedDB
async function saveThemeColor(color, name) {
    try {
        const themeData = { color, name };
        
        await themeConfigManager.saveThemeConfig('theme', themeData);
        
        // ç¦ç”¨æ¸å˜æ¨¡å¼
        const gradientConfig = { ...defaultGradientConfig, enabled: false };
        await themeConfigManager.saveThemeConfig('gradient', gradientConfig);
        
        console.log('ä¸»é¢˜è‰²å·²ä¿å­˜:', themeData);
    } catch (error) {
        console.error('ä¿å­˜ä¸»é¢˜è‰²å¤±è´¥:', error);
    }
}

// ä¿å­˜æ¸å˜é…ç½®åˆ°IndexedDB
async function saveGradientConfig(primaryColor, secondaryColor, direction, enabled = true) {
    try {
        const gradientData = { 
            enabled, 
            primaryColor, 
            secondaryColor, 
            direction 
        };
        
        await themeConfigManager.saveThemeConfig('gradient', gradientData);
        console.log('æ¸å˜é…ç½®å·²ä¿å­˜:', gradientData);
    } catch (error) {
        console.error('ä¿å­˜æ¸å˜é…ç½®å¤±è´¥:', error);
    }
}

// åˆå§‹åŒ–å¤–è§‚ç®¡ç†é¡µé¢
async function initAppearanceManagement() {
    // è·å–å½“å‰ä¸»é¢˜é…ç½®
    const config = await loadThemeConfig();
    const currentTheme = config.theme;
    const currentGradient = config.gradient;
    
    // è®¾ç½®ä¸»é¢˜è‰²é€‰é¡¹çš„ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.theme-color-option').forEach(option => {
        option.addEventListener('click', function() {
            const color = this.getAttribute('data-color');
            const name = this.getAttribute('data-name');
            
            // ç§»é™¤å…¶ä»–é€‰é¡¹çš„activeçŠ¶æ€
            document.querySelectorAll('.theme-color-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            // æ·»åŠ å½“å‰é€‰é¡¹çš„activeçŠ¶æ€
            this.classList.add('active');
            
            // åº”ç”¨å¹¶ä¿å­˜ä¸»é¢˜è‰²
            applyThemeColor(color);
            saveThemeColor(color, name);
            
            // æ›´æ–°è‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨
            updateCustomColorInputs(color);
            
            // ç¦ç”¨æ¸å˜å¼€å…³
            const gradientToggle = document.getElementById('gradientToggle');
            if (gradientToggle) {
                gradientToggle.checked = false;
                toggleGradientSettings(false);
            }
            
            // æ˜¾ç¤ºæç¤º
            showToast(`å·²åˆ‡æ¢åˆ°${name}`);
        });
        
        // è®¾ç½®å½“å‰é€‰ä¸­çš„ä¸»é¢˜è‰²
        if (option.getAttribute('data-color') === currentTheme.color && !currentGradient.enabled) {
            option.classList.add('active');
        }
    });
    
    // è®¾ç½®è‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨
    initCustomColorPicker(currentTheme.color);
    
    // åˆå§‹åŒ–æ¸å˜è®¾ç½®
    initGradientSettings(currentGradient);
}

// åˆå§‹åŒ–è‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨
function initCustomColorPicker(initialColor) {
    const colorPicker = document.getElementById('customColorPicker');
    const colorText = document.getElementById('customColorText');
    const colorPreview = document.getElementById('customColorPreview');
    const applyBtn = document.querySelector('.apply-custom-color-btn');
    
    if (!colorPicker || !colorText || !colorPreview) return;
    
    // è®¾ç½®åˆå§‹å€¼
    colorPicker.value = initialColor;
    colorText.value = initialColor.toUpperCase();
    colorPreview.style.backgroundColor = initialColor;
    
    // é¢œè‰²é€‰æ‹©å™¨å˜åŒ–äº‹ä»¶
    colorPicker.addEventListener('input', function() {
        const color = this.value.toUpperCase();
        colorText.value = color;
        colorPreview.style.backgroundColor = color;
        validateColorInput(colorText, applyBtn);
    });
    
    // æ–‡æœ¬è¾“å…¥æ¡†å˜åŒ–äº‹ä»¶
    colorText.addEventListener('input', function() {
        let color = this.value.trim();
        
        // è‡ªåŠ¨æ·»åŠ #å‰ç¼€
        if (color && !color.startsWith('#')) {
            color = '#' + color;
            this.value = color;
        }
        
        // éªŒè¯é¢œè‰²æ ¼å¼
        if (isValidHexColor(color)) {
            colorPicker.value = color;
            colorPreview.style.backgroundColor = color;
            this.classList.remove('invalid');
        } else {
            this.classList.add('invalid');
        }
        
        validateColorInput(this, applyBtn);
    });
    
    // æ–‡æœ¬æ¡†å¤±ç„¦æ—¶æ ¼å¼åŒ–
    colorText.addEventListener('blur', function() {
        if (this.value && isValidHexColor(this.value)) {
            this.value = this.value.toUpperCase();
        }
    });
    
    // æŒ‰å›è½¦é”®åº”ç”¨é¢œè‰²
    colorText.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && isValidHexColor(this.value)) {
            applyCustomColor();
        }
    });
    
    // ç‚¹å‡»é¢„è§ˆåœ†åœˆè§¦å‘é¢œè‰²é€‰æ‹©å™¨
    colorPreview.addEventListener('click', function() {
        colorPicker.click();
    });
}

// æ›´æ–°è‡ªå®šä¹‰é¢œè‰²è¾“å…¥æ¡†
function updateCustomColorInputs(color) {
    const colorPicker = document.getElementById('customColorPicker');
    const colorText = document.getElementById('customColorText');
    const colorPreview = document.getElementById('customColorPreview');
    const applyBtn = document.querySelector('.apply-custom-color-btn');
    
    if (colorPicker) colorPicker.value = color;
    if (colorText) {
        colorText.value = color.toUpperCase();
        colorText.classList.remove('invalid');
    }
    if (colorPreview) colorPreview.style.backgroundColor = color;
    if (applyBtn) applyBtn.disabled = false;
}

// éªŒè¯é¢œè‰²è¾“å…¥
// validateColorInput function moved to utils/colorUtils.js

// åº”ç”¨è‡ªå®šä¹‰é¢œè‰²
function applyCustomColor() {
    const colorText = document.getElementById('customColorText');
    const color = colorText.value.trim();
    
    if (!color) {
        showToast('è¯·è¾“å…¥é¢œè‰²ä»£ç ');
        return;
    }
    
    if (!isValidHexColor(color)) {
        showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é¢œè‰²ä»£ç ï¼ˆä¾‹å¦‚ï¼š#FF0000ï¼‰');
        colorText.focus();
        return;
    }
    
    // ç§»é™¤é¢„è®¾é€‰é¡¹çš„activeçŠ¶æ€
    document.querySelectorAll('.theme-color-option').forEach(opt => {
        opt.classList.remove('active');
    });
    
    // åº”ç”¨å¹¶ä¿å­˜ä¸»é¢˜è‰²
    applyThemeColor(color);
    saveThemeColor(color, 'è‡ªå®šä¹‰é¢œè‰²');
    
    // æ›´æ–°é¢„è§ˆ
    const colorPreview = document.getElementById('customColorPreview');
    if (colorPreview) {
        colorPreview.style.backgroundColor = color;
    }
    
    showToast('è‡ªå®šä¹‰é¢œè‰²å·²åº”ç”¨ï¼š' + color.toUpperCase());
}

// å·¥å…·å‡½æ•°ï¼šéªŒè¯åå…­è¿›åˆ¶é¢œè‰²ä»£ç 

// åˆå§‹åŒ–æ¸å˜è®¾ç½®
function initGradientSettings(gradientConfig) {
    const gradientToggle = document.getElementById('gradientToggle');
    const gradientSettings = document.getElementById('gradientSettings');
    
    if (!gradientToggle) return;
    
    // è®¾ç½®å¼€å…³çŠ¶æ€
    gradientToggle.checked = gradientConfig.enabled;
    toggleGradientSettings(gradientConfig.enabled);
    
    // è®¾ç½®æ¸å˜å¼€å…³äº‹ä»¶
    gradientToggle.addEventListener('change', function() {
        toggleGradientSettings(this.checked);
    });
    
    // åˆå§‹åŒ–æ¸å˜é¢œè‰²é€‰æ‹©å™¨
    initGradientColorPickers(gradientConfig);
    
    // åˆå§‹åŒ–æ¸å˜æ–¹å‘é€‰æ‹©
    initGradientDirectionPickers(gradientConfig.direction);
}

// åˆ‡æ¢æ¸å˜è®¾ç½®æ˜¾ç¤º/éšè—
function toggleGradientSettings(show) {
    const gradientSettings = document.getElementById('gradientSettings');
    if (gradientSettings) {
        gradientSettings.style.display = show ? 'block' : 'none';
    }
}

// åˆå§‹åŒ–æ¸å˜é¢œè‰²é€‰æ‹©å™¨
function initGradientColorPickers(gradientConfig) {
    // ä¸»è‰²é€‰æ‹©å™¨
    initSingleGradientColorPicker('Primary', gradientConfig.primaryColor, updateGradientPreview);
    // å‰¯è‰²é€‰æ‹©å™¨
    initSingleGradientColorPicker('Secondary', gradientConfig.secondaryColor, updateGradientPreview);
    
    // æ›´æ–°é¢„è§ˆ
    updateGradientPreview();
}

// åˆå§‹åŒ–å•ä¸ªæ¸å˜é¢œè‰²é€‰æ‹©å™¨
function initSingleGradientColorPicker(type, initialColor, callback) {
    const picker = document.getElementById(`gradient${type}Picker`);
    const text = document.getElementById(`gradient${type}Text`);
    const preview = document.getElementById(`gradient${type}Preview`);
    
    if (!picker || !text || !preview) return;
    
    // è®¾ç½®åˆå§‹å€¼
    picker.value = initialColor;
    text.value = initialColor.toUpperCase();
    preview.style.backgroundColor = initialColor;
    
    // é¢œè‰²é€‰æ‹©å™¨å˜åŒ–äº‹ä»¶
    picker.addEventListener('input', function() {
        const color = this.value.toUpperCase();
        text.value = color;
        preview.style.backgroundColor = color;
        if (callback) callback();
    });
    
    // æ–‡æœ¬è¾“å…¥æ¡†å˜åŒ–äº‹ä»¶
    text.addEventListener('input', function() {
        let color = this.value.trim();
        
        if (color && !color.startsWith('#')) {
            color = '#' + color;
            this.value = color;
        }
        
        if (isValidHexColor(color)) {
            picker.value = color;
            preview.style.backgroundColor = color;
            this.classList.remove('invalid');
            if (callback) callback();
        } else {
            this.classList.add('invalid');
        }
    });
    
    // ç‚¹å‡»é¢„è§ˆè§¦å‘é¢œè‰²é€‰æ‹©å™¨
    preview.addEventListener('click', function() {
        picker.click();
    });
}

// åˆå§‹åŒ–æ¸å˜æ–¹å‘é€‰æ‹©å™¨
function initGradientDirectionPickers(initialDirection) {
    const directionInputs = document.querySelectorAll('input[name="gradientDirection"]');
    
    directionInputs.forEach(input => {
        if (input.value === initialDirection) {
            input.checked = true;
        }
        
        input.addEventListener('change', function() {
            if (this.checked) {
                updateGradientPreview();
            }
        });
    });
}

// æ›´æ–°æ¸å˜é¢„è§ˆ
function updateGradientPreview() {
    const primaryColor = document.getElementById('gradientPrimaryText').value;
    const secondaryColor = document.getElementById('gradientSecondaryText').value;
    const direction = document.querySelector('input[name="gradientDirection"]:checked')?.value || 'to right';
    
    const previewDemo = document.getElementById('gradientPreviewDemo');
    if (previewDemo && isValidHexColor(primaryColor) && isValidHexColor(secondaryColor)) {
        previewDemo.style.background = `linear-gradient(${direction}, ${primaryColor}, ${secondaryColor})`;
    }
}

// åº”ç”¨æ¸å˜ä¸»é¢˜ï¼ˆä»UIè°ƒç”¨ï¼‰
function applyGradientThemeFromUI() {
    const primaryColor = document.getElementById('gradientPrimaryText').value;
    const secondaryColor = document.getElementById('gradientSecondaryText').value;
    const direction = document.querySelector('input[name="gradientDirection"]:checked')?.value || 'to right';
    
    if (!isValidHexColor(primaryColor) || !isValidHexColor(secondaryColor)) {
        showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é¢œè‰²ä»£ç ');
        return;
    }
    
    // åº”ç”¨æ¸å˜
    applyGradientTheme(primaryColor, secondaryColor, direction);
    
    // ä¿å­˜é…ç½®
    saveGradientConfig(primaryColor, secondaryColor, direction, true);
    
    // ç§»é™¤é¢„è®¾ä¸»é¢˜è‰²çš„é€‰ä¸­çŠ¶æ€
    document.querySelectorAll('.theme-color-option').forEach(opt => {
        opt.classList.remove('active');
    });
    
    showToast('æ¸å˜ä¸»é¢˜å·²åº”ç”¨');
}

// æ‰“å¼€æ°”æ³¡è®¾è®¡å™¨
function openBubbleDesigner() {
    try {
        // åœ¨æ–°çª—å£ä¸­æ‰“å¼€æ°”æ³¡è®¾è®¡å™¨
        const bubbleWindow = window.open('bubble.html', 'bubbleDesigner', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        
        if (!bubbleWindow) {
            showToast('æ— æ³•æ‰“å¼€æ°”æ³¡è®¾è®¡å™¨ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å¼¹çª—è®¾ç½®');
            return;
        }
        
        // èšç„¦åˆ°æ–°çª—å£
        bubbleWindow.focus();
        
    } catch (error) {
        console.error('æ‰“å¼€æ°”æ³¡è®¾è®¡å™¨æ—¶å‡ºé”™:', error);
        showToast('æ‰“å¼€æ°”æ³¡è®¾è®¡å™¨å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ä¸»é¢˜è‰²
document.addEventListener('DOMContentLoaded', async function() {
    // ç­‰å¾…æ•°æ®åº“å®Œå…¨åˆå§‹åŒ–åå†åŠ è½½ä¸»é¢˜é…ç½®
    const waitForDatabase = async () => {
        let attempts = 0;
        while ((!window.db || !window.isIndexedDBReady) && attempts < 30) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        
        if (!window.db || !window.isIndexedDBReady) {
            console.warn('æ•°æ®åº“åˆå§‹åŒ–è¶…æ—¶ï¼Œä½¿ç”¨é»˜è®¤ä¸»é¢˜é…ç½®');
            return false;
        }
        
        // å†æ¬¡æ£€æŸ¥themeConfigè¡¨æ˜¯å¦å­˜åœ¨
        if (!window.db.objectStoreNames.contains('themeConfig')) {
            console.warn('themeConfigå­˜å‚¨ä¸å­˜åœ¨ï¼Œç­‰å¾…æ•°æ®åº“å‡çº§');
            // è§¦å‘æ•°æ®åº“å‡çº§
            if (window.dbManager && window.dbManager.autoUpgradeDatabase) {
                try {
                    await window.dbManager.autoUpgradeDatabase();
                    // é‡æ–°æ£€æŸ¥
                    if (window.db && window.db.objectStoreNames.contains('themeConfig')) {
                        console.log('æ•°æ®åº“å‡çº§å®Œæˆï¼ŒthemeConfigè¡¨å·²åˆ›å»º');
                        return true;
                    }
                } catch (error) {
                    console.error('æ•°æ®åº“å‡çº§å¤±è´¥:', error);
                }
            }
            return false;
        }
        
        return true;
    };
    
    const databaseReady = await waitForDatabase();
    
    if (databaseReady) {
        // åŠ è½½ä¿å­˜çš„ä¸»é¢˜é…ç½®
        await loadThemeConfig();
        
        // åŠ è½½è‡ªå®šä¹‰æ°”æ³¡æ ·å¼
        await loadCustomBubbleStyle();
    } else {
        // å¦‚æœæ•°æ®åº“æœªå°±ç»ªï¼Œåº”ç”¨é»˜è®¤ä¸»é¢˜
        console.log('æ•°æ®åº“æœªå°±ç»ªï¼Œåº”ç”¨é»˜è®¤ä¸»é¢˜');
        applyThemeColor('#07c160');
    }
    
    // å½“åˆ‡æ¢åˆ°å¤–è§‚ç®¡ç†é¡µé¢æ—¶åˆå§‹åŒ–
    const originalShowPageAsync = showPageAsync;
    window.showPageAsync = async function(pageIdToShow) {
        const result = await originalShowPageAsync(pageIdToShow);
        
        if (pageIdToShow === 'appearanceManagementPage') {
            setTimeout(async () => {
                await initAppearanceManagement();
            }, 100);
        }
        
        return result;
    };
});

// ç›‘å¬æ¥è‡ªæ°”æ³¡è®¾è®¡å™¨çš„æ ·å¼åº”ç”¨æ¶ˆæ¯
window.addEventListener('message', async function(event) {
    // æ£€æŸ¥æ¶ˆæ¯ç±»å‹
    if (event.data && event.data.type === 'apply-bubble-style') {
        try {
            const bubbleStyleData = event.data.payload;
            const bubbleType = event.data.bubbleType || 'kare'; // é»˜è®¤ä¸ºåˆ«äººçš„æ°”æ³¡
            
            // æ ¹æ®æ°”æ³¡ç±»å‹å­˜å‚¨åˆ°ä¸åŒçš„é”®
            const storageKey = bubbleType === 'self' ? 'bubbleStyleSelf' : 'bubbleStyle';
            
            // å­˜å‚¨æ°”æ³¡æ ·å¼åˆ° IndexedDB
            saveBubbleStyleToStorage(bubbleStyleData, storageKey).then(() => {
                console.log(`${bubbleType === 'self' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}æ°”æ³¡æ ·å¼å·²ä¿å­˜åˆ°å­˜å‚¨`);
                
                // å¦‚æœå½“å‰åœ¨èŠå¤©é¡µé¢ï¼Œç«‹å³åº”ç”¨æ ·å¼
                if (document.getElementById('chatPage').classList.contains('active')) {
                    applyBubbleStyleToCurrentChat();
                }
                
                // æ˜¾ç¤ºæˆåŠŸæç¤º
                if (typeof showToast === 'function') {
                    showToast(`${bubbleType === 'self' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}æ°”æ³¡æ ·å¼å·²åº”ç”¨ï¼`);
                }
            }).catch(error => {
                console.error('ä¿å­˜æ°”æ³¡æ ·å¼å¤±è´¥:', error);
                if (typeof showToast === 'function') {
                    showToast('æ ·å¼ä¿å­˜å¤±è´¥: ' + error.message);
                }
            });
            
        } catch (error) {
            console.error('å¤„ç†æ°”æ³¡æ ·å¼æ¶ˆæ¯å¤±è´¥:', error);
        }
    } else if (event.data && event.data.type === 'reset-bubble-style') {
        try {
            // æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼
            await resetBubbleStyleToDefault();
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            if (typeof showToast === 'function') {
                showToast('å·²æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼ï¼');
            }
            
        } catch (error) {
            console.error('æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼å¤±è´¥:', error);
            if (typeof showToast === 'function') {
                showToast('æ¢å¤é»˜è®¤æ ·å¼å¤±è´¥: ' + error.message);
            }
        }
    }
});

/**
 * å¤„ç†HTMLä¸­çš„file:æ ¼å¼å›¾ç‰‡URL
 */
async function processFileUrlsInHtml(html) {
    if (!html || typeof html !== 'string') return html;
    
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æŸ¥æ‰¾æ‰€æœ‰ src="file:fileId" æ ¼å¼çš„å›¾ç‰‡
    const fileUrlRegex = /src="file:([^"]+)"/g;
    let match;
    const replacements = [];
    
    while ((match = fileUrlRegex.exec(html)) !== null) {
        const fileId = match[1];
        try {
            // ä½¿ç”¨ FileStorageManager è·å–çœŸå®URL
            if (window.FileStorageManager && window.FileStorageManager.createFileURL) {
                const realUrl = await window.FileStorageManager.createFileURL(fileId);
                replacements.push({
                    original: match[0],
                    replacement: `src="${realUrl}"`
                });
            }
        } catch (error) {
            console.warn('å¤„ç†æ–‡ä»¶URLå¤±è´¥:', fileId, error);
        }
    }
    
    // åº”ç”¨æ‰€æœ‰æ›¿æ¢
    let processedHtml = html;
    for (const replacement of replacements) {
        processedHtml = processedHtml.replace(replacement.original, replacement.replacement);
    }
    
    return processedHtml;
}

/**
 * ä¿å­˜æ°”æ³¡æ ·å¼åˆ°å­˜å‚¨
 */
async function saveBubbleStyleToStorage(styleData, storageKey = 'bubbleStyle') {
    try {
        // ä¿å­˜å®Œæ•´çš„æ°”æ³¡æ ·å¼æ•°æ®ï¼ˆåŒ…å«æ‰€æœ‰é…ç½®ï¼‰
        const bubbleStyleConfig = {
            ...styleData,  // åŒ…å«æ‰€æœ‰æ ·å¼é…ç½®
            enabled: true,  // æ¯æ¬¡ä¿å­˜éƒ½è‡ªåŠ¨å¯ç”¨
            lastModified: new Date().toISOString()  // æ·»åŠ æ—¶é—´æˆ³ä»¥è·Ÿè¸ªæ›´æ–°
        };
        
        await themeConfigManager.saveThemeConfig(storageKey, bubbleStyleConfig);
        console.log(`${storageKey}å·²ä¿å­˜åˆ° themeConfig å¹¶è‡ªåŠ¨å¯ç”¨`);
        
    } catch (error) {
        console.error(`ä¿å­˜${storageKey}å¤±è´¥:`, error);
        throw error;
    }
}

/**
 * åº”ç”¨æ°”æ³¡æ ·å¼åˆ°å½“å‰èŠå¤©
 */
async function applyBubbleStyleToCurrentChat() {
    try {
        // åŒæ—¶è¯»å–ä¸¤ç§æ°”æ³¡æ ·å¼
        await themeConfigManager.init();
        const bubbleStyleKare = await themeConfigManager.getThemeConfig('bubbleStyle');
        const bubbleStyleSelf = await themeConfigManager.getThemeConfig('bubbleStyleSelf');
        
        // å¦‚æœé€šè¿‡ themeConfigManager è·å–ä¸åˆ°ï¼Œç›´æ¥ä»æ•°æ®åº“è¯»å–
        let directBubbleStyleKare = null;
        let directBubbleStyleSelf = null;
        
        if (!bubbleStyleKare || !bubbleStyleSelf) {
            const results = await new Promise((resolve) => {
                const transaction = themeConfigManager.db.transaction(['themeConfig'], 'readonly');
                const store = transaction.objectStore('themeConfig');
                let kare = null, self = null, completed = 0;
                
                const checkComplete = () => {
                    completed++;
                    if (completed === 2) {
                        resolve({ kare, self });
                    }
                };
                
                const requestKare = store.get('bubbleStyle');
                requestKare.onsuccess = () => {
                    kare = requestKare.result;
                    checkComplete();
                };
                requestKare.onerror = () => checkComplete();
                
                const requestSelf = store.get('bubbleStyleSelf');
                requestSelf.onsuccess = () => {
                    self = requestSelf.result;
                    checkComplete();
                };
                requestSelf.onerror = () => checkComplete();
            });
            
            directBubbleStyleKare = results.kare;
            directBubbleStyleSelf = results.self;
        }
        
        // ä½¿ç”¨æ‰¾åˆ°çš„æ•°æ®
        const styleDataKare = bubbleStyleKare || directBubbleStyleKare;
        const styleDataSelf = bubbleStyleSelf || directBubbleStyleSelf;
        
        // å¤„ç†åˆ«äººçš„æ°”æ³¡æ ·å¼
        const isEnabledKare = styleDataKare?.enabled || styleDataKare?.data?.enabled;
        const actualStyleDataKare = styleDataKare?.data || styleDataKare;
        
        const shouldEnableKare = isEnabledKare || 
                                 (styleDataKare && actualStyleDataKare?.html) || 
                                 (styleDataKare && actualStyleDataKare?.borderWidth !== undefined && !('enabled' in styleDataKare));
        
        // å¤„ç†è‡ªå·±çš„æ°”æ³¡æ ·å¼
        const isEnabledSelf = styleDataSelf?.enabled || styleDataSelf?.data?.enabled;
        const actualStyleDataSelf = styleDataSelf?.data || styleDataSelf;
        
        const shouldEnableSelf = isEnabledSelf || 
                               (styleDataSelf && actualStyleDataSelf?.html) || 
                               (styleDataSelf && actualStyleDataSelf?.borderWidth !== undefined && !('enabled' in styleDataSelf));
        
        // å°†è‡ªå®šä¹‰æ ·å¼åº”ç”¨åˆ°å…¨å±€æ ·å¼å˜é‡
        if (styleDataKare && shouldEnableKare && actualStyleDataKare?.html) {
            window.customBubbleStyleKare = actualStyleDataKare;
            console.log('åº”ç”¨å¯¹æ–¹æ°”æ³¡æ ·å¼åˆ°å½“å‰èŠå¤©');
        } else {
            window.customBubbleStyleKare = null;
        }
        
        if (styleDataSelf && shouldEnableSelf && actualStyleDataSelf?.html) {
            window.customBubbleStyleSelf = actualStyleDataSelf;
            console.log('åº”ç”¨æˆ‘çš„æ°”æ³¡æ ·å¼åˆ°å½“å‰èŠå¤©');
        } else {
            window.customBubbleStyleSelf = null;
        }
        
        // å…¼å®¹æ—§ç‰ˆæœ¬ï¼šå¦‚æœæœ‰æ—§çš„customBubbleStyleï¼Œä¿æŒå‘åå…¼å®¹
        if (window.customBubbleStyleKare && !window.customBubbleStyle) {
            window.customBubbleStyle = window.customBubbleStyleKare;
        }
        
        // åŠ¨æ€åŠ è½½æ‰€éœ€å­—ä½“
        if (window.fontLoader) {
            const fontsToLoad = new Set();
            
            if (actualStyleDataKare?.fontFamily && shouldEnableKare) {
                fontsToLoad.add(actualStyleDataKare.fontFamily);
            }
            
            if (actualStyleDataSelf?.fontFamily && shouldEnableSelf) {
                fontsToLoad.add(actualStyleDataSelf.fontFamily);
            }
            
            if (fontsToLoad.size > 0) {
                console.log('å¼€å§‹åŠ è½½æ°”æ³¡æ ·å¼æ‰€éœ€å­—ä½“:', Array.from(fontsToLoad));
                try {
                    const fontResults = await Promise.all(
                        Array.from(fontsToLoad).map(font => window.fontLoader.loadFont(font))
                    );
                    const loadedCount = fontResults.filter(Boolean).length;
                    console.log(`æ°”æ³¡å­—ä½“åŠ è½½å®Œæˆ: ${loadedCount}/${fontsToLoad.size} æˆåŠŸ`);
                } catch (error) {
                    console.warn('åŠ è½½æ°”æ³¡å­—ä½“æ—¶å‘ç”Ÿé”™è¯¯:', error);
                }
            }
        }

        // é‡æ–°æ¸²æŸ“å½“å‰èŠå¤©æ¶ˆæ¯ä»¥åº”ç”¨æ–°æ ·å¼
        if (window.currentContact && (window.customBubbleStyleKare || window.customBubbleStyleSelf)) {
            await renderMessages(false); // æ˜ç¡®æŒ‡å®šéåˆå§‹åŠ è½½ï¼Œé¿å…æ»šåŠ¨
            console.log('æ°”æ³¡æ ·å¼å·²åº”ç”¨åˆ°å½“å‰èŠå¤©');
        } else if (!window.customBubbleStyleKare && !window.customBubbleStyleSelf) {
            // æ¸…é™¤è‡ªå®šä¹‰æ ·å¼ï¼Œä½¿ç”¨é»˜è®¤æ ·å¼
            window.customBubbleStyle = null;
            console.log('æœªæ‰¾åˆ°å¯ç”¨çš„æ°”æ³¡æ ·å¼ï¼Œä½¿ç”¨é»˜è®¤æ ·å¼');
        }
        
    } catch (error) {
        console.error('åº”ç”¨æ°”æ³¡æ ·å¼å¤±è´¥:', error);
    }
}

/**
 * è·å–å½“å‰è”ç³»äººID
 */
function getCurrentContactId() {
    // ä»å½“å‰æ´»åŠ¨çš„èŠå¤©é¡µé¢è·å–è”ç³»äººID
    const chatTitle = document.getElementById('chatTitle');
    if (chatTitle && chatTitle.dataset.contactId) {
        return chatTitle.dataset.contactId;
    }
    
    // å¤‡ç”¨æ–¹æ³•ï¼šä»å…¨å±€å˜é‡æˆ–å½“å‰è”ç³»äººè·å–
    return window.currentContactId || (window.currentContact && window.currentContact.id) || null;
}

/**
 * åŠ è½½è‡ªå®šä¹‰æ°”æ³¡æ ·å¼
 */
async function loadCustomBubbleStyle() {
    try {
        // åŒæ—¶è¯»å–ä¸¤ç§æ°”æ³¡æ ·å¼
        await themeConfigManager.init();
        const bubbleStyleKare = await themeConfigManager.getThemeConfig('bubbleStyle');
        const bubbleStyleSelf = await themeConfigManager.getThemeConfig('bubbleStyleSelf');
        
        // å¦‚æœé€šè¿‡ themeConfigManager è·å–ä¸åˆ°ï¼Œç›´æ¥ä»æ•°æ®åº“è¯»å–
        let directBubbleStyleKare = null;
        let directBubbleStyleSelf = null;
        
        if (!bubbleStyleKare || !bubbleStyleSelf) {
            const results = await new Promise((resolve) => {
                const transaction = themeConfigManager.db.transaction(['themeConfig'], 'readonly');
                const store = transaction.objectStore('themeConfig');
                let kare = null, self = null, completed = 0;
                
                const checkComplete = () => {
                    completed++;
                    if (completed === 2) {
                        resolve({ kare, self });
                    }
                };
                
                const requestKare = store.get('bubbleStyle');
                requestKare.onsuccess = () => {
                    kare = requestKare.result;
                    checkComplete();
                };
                requestKare.onerror = () => checkComplete();
                
                const requestSelf = store.get('bubbleStyleSelf');
                requestSelf.onsuccess = () => {
                    self = requestSelf.result;
                    checkComplete();
                };
                requestSelf.onerror = () => checkComplete();
            });
            
            directBubbleStyleKare = results.kare;
            directBubbleStyleSelf = results.self;
        }
        
        // ä½¿ç”¨æ‰¾åˆ°çš„æ•°æ®
        const styleDataKare = bubbleStyleKare || directBubbleStyleKare;
        const styleDataSelf = bubbleStyleSelf || directBubbleStyleSelf;
        
        // console.log('åŠ è½½çš„å¯¹æ–¹æ°”æ³¡æ ·å¼é…ç½®:', styleDataKare);
        // console.log('åŠ è½½çš„æˆ‘çš„æ°”æ³¡æ ·å¼é…ç½®:', styleDataSelf);
        
        // å¤„ç†å¯¹æ–¹æ°”æ³¡æ ·å¼
        const isEnabledKare = styleDataKare?.enabled || styleDataKare?.data?.enabled;
        const actualStyleDataKare = styleDataKare?.data || styleDataKare;
        
        const shouldEnableKare = isEnabledKare || 
                                 (styleDataKare && actualStyleDataKare?.html) || 
                                 (styleDataKare && actualStyleDataKare?.borderWidth !== undefined && !('enabled' in styleDataKare));
        
        // å¤„ç†æˆ‘çš„æ°”æ³¡æ ·å¼
        const isEnabledSelf = styleDataSelf?.enabled || styleDataSelf?.data?.enabled;
        const actualStyleDataSelf = styleDataSelf?.data || styleDataSelf;
        
        const shouldEnableSelf = isEnabledSelf || 
                               (styleDataSelf && actualStyleDataSelf?.html) || 
                               (styleDataSelf && actualStyleDataSelf?.borderWidth !== undefined && !('enabled' in styleDataSelf));
        
        // åº”ç”¨å¯¹æ–¹æ°”æ³¡æ ·å¼
        if (styleDataKare && shouldEnableKare && actualStyleDataKare?.html) {
            window.customBubbleStyleKare = actualStyleDataKare;
            console.log('å¯¹æ–¹æ°”æ³¡æ ·å¼å·²ä» themeConfig åŠ è½½å¹¶å¯ç”¨');
        } else {
            window.customBubbleStyleKare = null;
            console.log('æœªæ‰¾åˆ°å¯ç”¨çš„å¯¹æ–¹æ°”æ³¡æ ·å¼ï¼Œä½¿ç”¨é»˜è®¤æ ·å¼');
        }
        
        // åº”ç”¨æˆ‘çš„æ°”æ³¡æ ·å¼
        if (styleDataSelf && shouldEnableSelf && actualStyleDataSelf?.html) {
            window.customBubbleStyleSelf = actualStyleDataSelf;
            console.log('æˆ‘çš„æ°”æ³¡æ ·å¼å·²ä» themeConfig åŠ è½½å¹¶å¯ç”¨');
        } else {
            window.customBubbleStyleSelf = null;
            console.log('æœªæ‰¾åˆ°å¯ç”¨çš„æˆ‘çš„æ°”æ³¡æ ·å¼ï¼Œä½¿ç”¨é»˜è®¤æ ·å¼');
        }
        
        // å…¼å®¹æ—§ç‰ˆæœ¬ï¼šå¦‚æœæœ‰å¯¹æ–¹æ°”æ³¡æ ·å¼ï¼Œä¿æŒå‘åå…¼å®¹
        if (window.customBubbleStyleKare && !window.customBubbleStyle) {
            window.customBubbleStyle = window.customBubbleStyleKare;
            console.log('è®¾ç½®å‘åå…¼å®¹çš„ customBubbleStyle');
        } else if (!window.customBubbleStyleKare && !window.customBubbleStyleSelf) {
            // æ¸…é™¤ä»»ä½•ä¹‹å‰çš„è‡ªå®šä¹‰æ ·å¼
            window.customBubbleStyle = null;
        }
        
    } catch (error) {
        console.error('åŠ è½½æ°”æ³¡æ ·å¼å¤±è´¥:', error);
    }
}

/**
 * æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼
 */
async function resetBubbleStyleToDefault() {
    try {
        // ä»æ•°æ®åº“åˆ é™¤è‡ªå®šä¹‰æ°”æ³¡æ ·å¼é…ç½®
        await themeConfigManager.init();
        await themeConfigManager.deleteThemeConfig('bubbleStyle');
        
        // æ¸…é™¤å†…å­˜ä¸­çš„è‡ªå®šä¹‰æ ·å¼
        window.customBubbleStyle = null;
        
        console.log('è‡ªå®šä¹‰æ°”æ³¡æ ·å¼å·²æ¸…é™¤ï¼Œæ¢å¤é»˜è®¤æ ·å¼');
        
        // å¦‚æœå½“å‰åœ¨èŠå¤©é¡µé¢ï¼Œé‡æ–°æ¸²æŸ“æ¶ˆæ¯ä»¥åº”ç”¨é»˜è®¤æ ·å¼
        if (window.currentContact && document.getElementById('chatPage').classList.contains('active')) {
            await renderMessages(false); // æ˜ç¡®æŒ‡å®šéåˆå§‹åŠ è½½ï¼Œé¿å…æ»šåŠ¨
        }
        
    } catch (error) {
        console.error('æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼å¤±è´¥:', error);
        throw error;
    }
}


// ===== å›¾ç‰‡å…³é”®è¯ä¼˜åŒ–ç›¸å…³å‡½æ•° =====

// æ£€æŸ¥å›¾ç‰‡å…³é”®è¯ä¼˜åŒ–é…ç½®çŠ¶æ€
async function checkImageKeywordStatus() {
    try {
        const statusElement = document.getElementById('imageKeywordStatus');
        const configStatusElement = document.getElementById('imageKeywordConfigStatus');
        
        // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
        if (!statusElement || !configStatusElement) {
            console.warn('å›¾ç‰‡å…³é”®è¯çŠ¶æ€å…ƒç´ æœªæ‰¾åˆ°');
            return;
        }
        
        // æ£€æŸ¥APIé…ç½®
        let hasApiConfig = false;
        try {
            const apiCallInfo = await getApiCallInfo();
            hasApiConfig = !!(apiCallInfo && apiCallInfo.url && apiCallInfo.key && apiCallInfo.model);
        } catch (error) {
            hasApiConfig = false;
        }
        const hasUnsplashKey = localStorage.getItem('forumUnsplashApiKey') || localStorage.getItem('unsplashApiKey');
        
        let statusText = '';
        let statusColor = '';
        let configDetails = '';
        
        if (!hasApiConfig && !hasUnsplashKey) {
            statusText = 'æœªé…ç½®';
            statusColor = '#dc3545';
            configDetails = `
                <div style="color: #dc3545;">âŒ åŠŸèƒ½æœªé…ç½®</div>
                <div style="margin-top: 5px;">éœ€è¦é…ç½®ï¼š</div>
                <ul style="margin: 5px 0; padding-left: 15px;">
                    <li>AI API é…ç½®ï¼ˆç”¨äºç”Ÿæˆå…³é”®è¯ï¼‰</li>
                    <li>Unsplash API Keyï¼ˆç”¨äºæœç´¢å›¾ç‰‡ï¼‰</li>
                </ul>
            `;
        } else if (!hasApiConfig) {
            statusText = 'éƒ¨åˆ†é…ç½®';
            statusColor = '#ffc107';
            configDetails = `
                <div style="color: #ffc107;">âš ï¸ AI API æœªé…ç½®</div>
                <div style="margin-top: 5px;">âœ… Unsplash API Key å·²é…ç½®</div>
                <div style="margin-top: 5px; color: #666;">éœ€è¦é…ç½® AI API æ‰èƒ½ç”Ÿæˆå…³é”®è¯</div>
            `;
        } else if (!hasUnsplashKey) {
            statusText = 'éƒ¨åˆ†é…ç½®';
            statusColor = '#ffc107';
            configDetails = `
                <div style="color: #28a745;">âœ… AI API å·²é…ç½®</div>
                <div style="color: #ffc107; margin-top: 5px;">âš ï¸ Unsplash API Key æœªé…ç½®</div>
                <div style="margin-top: 5px; color: #666;">éœ€è¦é…ç½® Unsplash API Key æ‰èƒ½æœç´¢å›¾ç‰‡</div>
            `;
        } else {
            statusText = 'å®Œå…¨é…ç½®';
            statusColor = '#28a745';
            const isReady = window.imageKeywordGenerator && await window.imageKeywordGenerator.isReady();
            configDetails = `
                <div style="color: #28a745;">âœ… AI API å·²é…ç½®</div>
                <div style="color: #28a745; margin-top: 5px;">âœ… Unsplash API Key å·²é…ç½®</div>
                <div style="color: #28a745; margin-top: 5px;">âœ… å›¾ç‰‡å…³é”®è¯ç”Ÿæˆå™¨ï¼š${isReady ? 'å°±ç»ª' : 'åˆå§‹åŒ–ä¸­'}</div>
                <div style="margin-top: 5px; color: #666;">åŠŸèƒ½å®Œå…¨å¯ç”¨</div>
            `;
        }
        
        statusElement.textContent = statusText;
        statusElement.style.color = statusColor;
        configStatusElement.innerHTML = configDetails;
        
        showToast('é…ç½®çŠ¶æ€å·²æ›´æ–°');
    } catch (error) {
        console.error('æ£€æŸ¥å›¾ç‰‡å…³é”®è¯é…ç½®çŠ¶æ€å¤±è´¥:', error);
        showToast('æ£€æŸ¥çŠ¶æ€å¤±è´¥: ' + error.message);
    }
}

// æ‰“å¼€å›¾ç‰‡å…³é”®è¯è®¾ç½®
function openImageKeywordSettings() {
    showModal('apiSettingsModal');
    showToast('è¯·åœ¨ API é…ç½®ä¸­è®¾ç½® AI API å’Œ Unsplash API Key');
}

// ç›‘å¬æ•°æ®ç®¡ç†é¡µé¢æ˜¾ç¤ºçš„å®‰å…¨æ–¹å¼
function enhanceShowPageForImageKeyword() {
    if (typeof window.showPage === 'function') {
        const originalShowPage = window.showPage;
        window.showPage = function(pageId) {
            const result = originalShowPage.call(this, pageId);
            if (pageId === 'dataManagementPage') {
                setTimeout(() => {
                    checkImageKeywordStatus();
                }, 200);
            }
            return result;
        };
    } else {
        // å¦‚æœshowPageè¿˜æœªå®šä¹‰ï¼Œå»¶è¿Ÿæ‰§è¡Œ
        setTimeout(enhanceShowPageForImageKeyword, 500);
    }
}

// é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œå¢å¼º
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', enhanceShowPageForImageKeyword);
} else {
    enhanceShowPageForImageKeyword();
}

// ===== APIè¯·æ±‚é˜Ÿåˆ—ç³»ç»Ÿ =====

/**
 * APIè¯·æ±‚é˜Ÿåˆ—ç®¡ç†å™¨
 */
class APIRequestQueue {
    constructor() {
        this.queue = [];
        this.isProcessing = false;
        this.currentRequest = null;
        this.maxRetries = 3;
        
        // ä¼˜å…ˆçº§å¸¸é‡
        this.PRIORITY = {
            URGENT: 1,    // èŠå¤©æ¶ˆæ¯
            HIGH: 2,      // ç”¨æˆ·ä¸»åŠ¨æ“ä½œ
            NORMAL: 3,    // åå°ä»»åŠ¡
            LOW: 4        // ä¸ƒå¤•èŠ‚ç­‰ç‰¹æ®Šä»»åŠ¡
        };
    }
    
    /**
     * æ·»åŠ APIè¯·æ±‚åˆ°é˜Ÿåˆ—
     */
    async addRequest(apiCall, options = {}) {
        const requestItem = {
            id: generateId(),
            apiCall,
            priority: options.priority || this.PRIORITY.NORMAL,
            retries: 0,
            maxRetries: options.maxRetries || this.maxRetries,
            description: options.description || 'æœªçŸ¥è¯·æ±‚',
            onProgress: options.onProgress || null,
            onComplete: options.onComplete || null,
            onError: options.onError || null,
            timestamp: Date.now()
        };
        
        console.log(`[é˜Ÿåˆ—] æ·»åŠ è¯·æ±‚: ${requestItem.description}, ä¼˜å…ˆçº§: ${requestItem.priority}`);
        
        // æ’å…¥åˆ°åˆé€‚çš„ä½ç½®ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
        let insertIndex = this.queue.length;
        for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i].priority > requestItem.priority) {
                insertIndex = i;
                break;
            }
        }
        
        this.queue.splice(insertIndex, 0, requestItem);
        
        // å¦‚æœæ²¡æœ‰åœ¨å¤„ç†è¯·æ±‚ï¼Œç«‹å³å¼€å§‹å¤„ç†
        if (!this.isProcessing) {
            this.processQueue();
        }
        
        return requestItem.id;
    }
    
    /**
     * å¤„ç†é˜Ÿåˆ—ä¸­çš„è¯·æ±‚
     */
    async processQueue() {
        if (this.isProcessing || this.queue.length === 0) {
            return;
        }
        
        this.isProcessing = true;
        console.log(`[é˜Ÿåˆ—] å¼€å§‹å¤„ç†ï¼Œé˜Ÿåˆ—ä¸­æœ‰ ${this.queue.length} ä¸ªè¯·æ±‚`);
        
        while (this.queue.length > 0) {
            const request = this.queue.shift();
            this.currentRequest = request;
            
            try {
                console.log(`[é˜Ÿåˆ—] å¤„ç†è¯·æ±‚: ${request.description}`);
                
                if (request.onProgress) {
                    request.onProgress(request.id, 'å¼€å§‹å¤„ç†');
                }
                
                const result = await request.apiCall();
                
                if (request.onComplete) {
                    request.onComplete(request.id, result);
                }
                
                console.log(`[é˜Ÿåˆ—] è¯·æ±‚å®Œæˆ: ${request.description}`);
                
            } catch (error) {
                console.error(`[é˜Ÿåˆ—] è¯·æ±‚å¤±è´¥: ${request.description}`, error);
                
                request.retries++;
                if (request.retries < request.maxRetries) {
                    console.log(`[é˜Ÿåˆ—] é‡è¯•è¯·æ±‚ (${request.retries}/${request.maxRetries}): ${request.description}`);
                    // é‡æ–°åŠ å…¥é˜Ÿåˆ—ï¼Œä½†é™ä½ä¼˜å…ˆçº§
                    request.priority = Math.min(request.priority + 1, this.PRIORITY.LOW);
                    this.queue.unshift(request);
                } else {
                    console.error(`[é˜Ÿåˆ—] è¯·æ±‚æœ€ç»ˆå¤±è´¥: ${request.description}`);
                    if (request.onError) {
                        request.onError(request.id, error);
                    }
                }
            }
            
            this.currentRequest = null;
            
            // æ·»åŠ å°å»¶è¿Ÿé¿å…è¿‡å¿«è¯·æ±‚
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        this.isProcessing = false;
        console.log('[é˜Ÿåˆ—] æ‰€æœ‰è¯·æ±‚å¤„ç†å®Œæˆ');
    }
    
    /**
     * è·å–é˜Ÿåˆ—çŠ¶æ€
     */
    getStatus() {
        return {
            queueLength: this.queue.length,
            isProcessing: this.isProcessing,
            currentRequest: this.currentRequest ? {
                id: this.currentRequest.id,
                description: this.currentRequest.description,
                priority: this.currentRequest.priority
            } : null
        };
    }
    
    /**
     * å–æ¶ˆæŒ‡å®šè¯·æ±‚
     */
    cancelRequest(requestId) {
        const index = this.queue.findIndex(req => req.id === requestId);
        if (index !== -1) {
            const removed = this.queue.splice(index, 1)[0];
            console.log(`[é˜Ÿåˆ—] å–æ¶ˆè¯·æ±‚: ${removed.description}`);
            return true;
        }
        return false;
    }
    
    /**
     * æ¸…ç©ºé˜Ÿåˆ—
     */
    clearQueue() {
        this.queue = [];
        console.log('[é˜Ÿåˆ—] é˜Ÿåˆ—å·²æ¸…ç©º');
    }
}

// åˆ›å»ºå…¨å±€é˜Ÿåˆ—å®ä¾‹
window.apiRequestQueue = new APIRequestQueue();

// ===== é€šç”¨å·¥å…·å‡½æ•° =====

/**
 * ç”Ÿæˆå”¯ä¸€ID
 */
// generateId function moved to utils/formatUtils.js

// ===== æ¸å˜èƒŒæ™¯ç®¡ç†ç³»ç»Ÿ =====

/**
 * æ¸å˜èƒŒæ™¯ç®¡ç†å™¨ - ç®¡ç†ç‰¹æ®Šæ´»åŠ¨çš„è‡ªå®šä¹‰æ¸å˜èƒŒæ™¯
 */
class GradientBackgroundManager {
    constructor() {
        this.storageKey = 'statusBallCustomGradients';
        this.customGradients = this.loadCustomGradients();
        this.presets = this.getGradientPresets();
    }
    
    /**
     * è·å–é¢„è®¾æ¸å˜
     */
    getGradientPresets() {
        return {
            // ä¸ƒå¤•èŠ‚é¢„è®¾
            qixi_classic: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            qixi_romantic: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
            qixi_dreamy: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
            
            // ç”Ÿæ—¥é¢„è®¾
            birthday_cake: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)',
            birthday_party: 'linear-gradient(135deg, #ff6b6b 0%, #feca57 100%)',
            birthday_joy: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
            
            // èŠ‚æ—¥é¢„è®¾
            holiday_festival: 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)',
            holiday_fireworks: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
            holiday_celebration: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
            
            // é€šç”¨é¢„è®¾
            sunrise: 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)',
            ocean: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            forest: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
            sunset: 'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)',
            galaxy: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            aurora: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'
        };
    }
    
    /**
     * ä»æœ¬åœ°å­˜å‚¨åŠ è½½è‡ªå®šä¹‰æ¸å˜
     */
    loadCustomGradients() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            return stored ? JSON.parse(stored) : {};
        } catch (error) {
            console.error('åŠ è½½è‡ªå®šä¹‰æ¸å˜å¤±è´¥:', error);
            return {};
        }
    }
    
    /**
     * ä¿å­˜è‡ªå®šä¹‰æ¸å˜åˆ°æœ¬åœ°å­˜å‚¨
     */
    saveCustomGradients() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.customGradients));
        } catch (error) {
            console.error('ä¿å­˜è‡ªå®šä¹‰æ¸å˜å¤±è´¥:', error);
        }
    }
    
    /**
     * è®¾ç½®è‡ªå®šä¹‰æ¸å˜
     * @param {string} eventType - äº‹ä»¶ç±»å‹
     * @param {string} gradient - æ¸å˜CSS
     * @param {string} name - æ¸å˜åç§°ï¼ˆå¯é€‰ï¼‰
     */
    setCustomGradient(eventType, gradient, name = '') {
        if (!this.customGradients[eventType]) {
            this.customGradients[eventType] = {};
        }
        
        const gradientId = 'custom_' + Date.now();
        this.customGradients[eventType][gradientId] = {
            gradient: gradient,
            name: name || `è‡ªå®šä¹‰æ¸å˜ ${Object.keys(this.customGradients[eventType]).length + 1}`,
            createdAt: new Date().toISOString()
        };
        
        this.saveCustomGradients();
        return gradientId;
    }
    
    /**
     * è·å–äº‹ä»¶ç±»å‹çš„æ¸å˜
     * @param {string} eventType - äº‹ä»¶ç±»å‹
     * @param {string} gradientId - æ¸å˜IDï¼ˆå¯é€‰ï¼Œä¸æä¾›åˆ™ä½¿ç”¨é»˜è®¤ï¼‰
     */
    getGradient(eventType, gradientId = null) {
        // å¦‚æœæŒ‡å®šäº†gradientIdï¼Œå°è¯•è·å–è‡ªå®šä¹‰æ¸å˜
        if (gradientId && this.customGradients[eventType] && this.customGradients[eventType][gradientId]) {
            return this.customGradients[eventType][gradientId].gradient;
        }
        
        // å°è¯•è·å–äº‹ä»¶ç±»å‹çš„é»˜è®¤è‡ªå®šä¹‰æ¸å˜
        if (this.customGradients[eventType]) {
            const customGradientsForEvent = Object.values(this.customGradients[eventType]);
            if (customGradientsForEvent.length > 0) {
                // è¿”å›æœ€æ–°çš„è‡ªå®šä¹‰æ¸å˜
                return customGradientsForEvent[customGradientsForEvent.length - 1].gradient;
            }
        }
        
        // è¿”å›é¢„è®¾æ¸å˜
        const presetKey = `${eventType}_classic`;
        return this.presets[presetKey] || this.presets.sunrise;
    }
    
    /**
     * è·å–äº‹ä»¶ç±»å‹çš„æ‰€æœ‰æ¸å˜
     * @param {string} eventType - äº‹ä»¶ç±»å‹
     */
    getAllGradientsForEvent(eventType) {
        const gradients = [];
        
        // æ·»åŠ é¢„è®¾æ¸å˜
        Object.keys(this.presets).forEach(key => {
            if (key.startsWith(eventType + '_')) {
                gradients.push({
                    id: key,
                    name: this.getPresetName(key),
                    gradient: this.presets[key],
                    type: 'preset'
                });
            }
        });
        
        // æ·»åŠ è‡ªå®šä¹‰æ¸å˜
        if (this.customGradients[eventType]) {
            Object.entries(this.customGradients[eventType]).forEach(([id, data]) => {
                gradients.push({
                    id: id,
                    name: data.name,
                    gradient: data.gradient,
                    type: 'custom',
                    createdAt: data.createdAt
                });
            });
        }
        
        return gradients;
    }
    
    /**
     * è·å–é¢„è®¾åç§°
     */
    getPresetName(presetKey) {
        const names = {
            qixi_classic: 'ä¸ƒå¤•ç»å…¸',
            qixi_romantic: 'ä¸ƒå¤•æµªæ¼«',
            qixi_dreamy: 'ä¸ƒå¤•æ¢¦å¹»',
            birthday_cake: 'ç”Ÿæ—¥è›‹ç³•',
            birthday_party: 'ç”Ÿæ—¥æ´¾å¯¹',
            birthday_joy: 'ç”Ÿæ—¥æ¬¢ä¹',
            holiday_festival: 'èŠ‚æ—¥åº†å…¸',
            holiday_fireworks: 'èŠ‚æ—¥çƒŸèŠ±',
            holiday_celebration: 'èŠ‚æ—¥åº†ç¥',
            sunrise: 'æ—¥å‡º',
            ocean: 'æµ·æ´‹',
            forest: 'æ£®æ—',
            sunset: 'æ—¥è½',
            galaxy: 'æ˜Ÿæ²³',
            aurora: 'æå…‰'
        };
        return names[presetKey] || presetKey;
    }
    
    /**
     * åˆ é™¤è‡ªå®šä¹‰æ¸å˜
     * @param {string} eventType - äº‹ä»¶ç±»å‹
     * @param {string} gradientId - æ¸å˜ID
     */
    deleteCustomGradient(eventType, gradientId) {
        if (this.customGradients[eventType] && this.customGradients[eventType][gradientId]) {
            delete this.customGradients[eventType][gradientId];
            
            // å¦‚æœè¯¥äº‹ä»¶ç±»å‹æ²¡æœ‰è‡ªå®šä¹‰æ¸å˜äº†ï¼Œåˆ é™¤æ•´ä¸ªæ¡ç›®
            if (Object.keys(this.customGradients[eventType]).length === 0) {
                delete this.customGradients[eventType];
            }
            
            this.saveCustomGradients();
            return true;
        }
        return false;
    }
    
    /**
     * åˆ›å»ºæ¸å˜é€‰æ‹©å™¨UI
     * @param {string} eventType - äº‹ä»¶ç±»å‹
     * @param {Function} onSelect - é€‰æ‹©å›è°ƒ
     */
    createGradientSelector(eventType, onSelect) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        `;
        
        const gradients = this.getAllGradientsForEvent(eventType);
        
        content.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0;">é€‰æ‹©æ¸å˜èƒŒæ™¯</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="text" id="customGradientInput" 
                           placeholder="è¾“å…¥CSSæ¸å˜ï¼Œå¦‚: linear-gradient(135deg, #ff0000 0%, #0000ff 100%)"
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <button onclick="addCustomGradient()" 
                            style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        æ·»åŠ 
                    </button>
                </div>
            </div>
            <div id="gradientList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">
                ${gradients.map(g => `
                    <div class="gradient-item" 
                         style="cursor: pointer; border-radius: 8px; overflow: hidden; border: 2px solid transparent;"
                         data-gradient="${g.gradient.replace(/"/g, '&quot;')}"
                         data-id="${g.id}">
                        <div style="height: 80px; background: ${g.gradient};"></div>
                        <div style="padding: 8px; background: #f5f5f5; font-size: 12px; text-align: center;">
                            ${g.name}
                            ${g.type === 'custom' ? '<br><small style="color: #666;">è‡ªå®šä¹‰</small>' : ''}
                        </div>
                    </div>
                `).join('')}
            </div>
            <div style="text-align: right; margin-top: 20px;">
                <button onclick="closeGradientSelector()" 
                        style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    å…³é—­
                </button>
            </div>
        `;
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // æ·»åŠ äº‹ä»¶å¤„ç†
        window.addCustomGradient = () => {
            const input = document.getElementById('customGradientInput');
            const gradient = input.value.trim();
            if (gradient) {
                const gradientId = this.setCustomGradient(eventType, gradient);
                onSelect(gradient, gradientId);
                closeGradientSelector();
            }
        };
        
        window.closeGradientSelector = () => {
            modal.remove();
            delete window.addCustomGradient;
            delete window.closeGradientSelector;
        };
        
        // æ·»åŠ æ¸å˜é€‰æ‹©äº‹ä»¶
        modal.querySelectorAll('.gradient-item').forEach(item => {
            item.addEventListener('click', () => {
                const gradient = item.dataset.gradient.replace(/&quot;/g, '"');
                const gradientId = item.dataset.id;
                onSelect(gradient, gradientId);
                closeGradientSelector();
            });
            
            // æ‚¬åœæ•ˆæœ
            item.addEventListener('mouseenter', () => {
                item.style.borderColor = '#2196F3';
            });
            
            item.addEventListener('mouseleave', () => {
                item.style.borderColor = 'transparent';
            });
        });
        
        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeGradientSelector();
            }
        });
    }
}

// åˆ›å»ºå…¨å±€æ¸å˜ç®¡ç†å™¨å®ä¾‹
window.gradientManager = new GradientBackgroundManager();

// ===== çŠ¶æ€çƒäº‹ä»¶ç±»å‹é…ç½® =====

const STATUS_BALL_CONFIGS = {
    qixi: {
        name: 'ä¸ƒå¤•èŠ‚',
        emoji: 'ğŸŒŸ',
        completedEmoji: 'ğŸ‰',
        theme: {
            primary: '#e91e63',
            gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',  // è“ç´«æ¸å˜
            alternativeGradients: [
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',  // ç²‰çº¢æ¸å˜
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',  // è“é’æ¸å˜
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',  // æš–è‰²æ¸å˜
                'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'   // æ¸…æ–°æ¸å˜
            ]
        },
        titles: {
            loading: 'ä¸ƒå¤•èŠ‚ç‰¹æ®Šå‡†å¤‡ä¸­',
            processing: 'ä¸ƒå¤•èŠ‚ç¥ç¦ç”Ÿæˆä¸­',
            completed: 'ä¸ƒå¤•èŠ‚æœ‹å‹åœˆç”Ÿæˆå®Œæˆ'
        },
        descriptions: {
            loading: 'æˆ‘ä»¬æ­£åœ¨å‡†å¤‡åº”ç”¨',
            processing: 'åå°å¤„ç†ï¼Œä¸å½±å“èŠå¤©',
            completed: 'å·²ä¸ºå¥½å‹ç”Ÿæˆç¥ç¦'
        }
    },
    birthday: {
        name: 'ç”Ÿæ—¥',
        emoji: 'ğŸ‚',
        completedEmoji: 'ğŸ‰',
        theme: {
            primary: '#ff9800',
            gradient: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)',  // æ©™è‰²æ¸å˜
            alternativeGradients: [
                'linear-gradient(135deg, #ff6b6b 0%, #feca57 100%)',  // çº¢æ©™æ¸å˜
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',  // æè‰²æ¸å˜
                'linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%)',  // ç²‰æ©™æ¸å˜
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)'   // æ¸©æš–æ¸å˜
            ]
        },
        titles: {
            loading: 'ç”Ÿæ—¥ç‰¹æ®Šå‡†å¤‡ä¸­',
            processing: 'ç”Ÿæ—¥ç¥ç¦ç”Ÿæˆä¸­',
            completed: 'ç”Ÿæ—¥æœ‹å‹åœˆç”Ÿæˆå®Œæˆ'
        },
        descriptions: {
            loading: 'æˆ‘ä»¬æ­£åœ¨å‡†å¤‡ç”Ÿæ—¥å†…å®¹',
            processing: 'åå°å¤„ç†ï¼Œä¸å½±å“èŠå¤©',
            completed: 'å·²ä¸ºå¥½å‹ç”Ÿæˆç”Ÿæ—¥ç¥ç¦'
        }
    },
    holiday: {
        name: 'èŠ‚æ—¥',
        emoji: 'ğŸŠ',
        completedEmoji: 'ğŸ‰',
        theme: {
            primary: '#4caf50',
            gradient: 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)',  // ç»¿è‰²æ¸å˜
            alternativeGradients: [
                'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',  // é’ç»¿æ¸å˜
                'linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%)',  // è–„è·æ¸å˜
                'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',  // æ·±è“æ¸å˜
                'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)'   // å½©è™¹æ¸å˜
            ]
        },
        titles: {
            loading: 'èŠ‚æ—¥ç‰¹æ®Šå‡†å¤‡ä¸­',
            processing: 'èŠ‚æ—¥ç¥ç¦ç”Ÿæˆä¸­',
            completed: 'èŠ‚æ—¥æœ‹å‹åœˆç”Ÿæˆå®Œæˆ'
        },
        descriptions: {
            loading: 'æˆ‘ä»¬æ­£åœ¨å‡†å¤‡èŠ‚æ—¥å†…å®¹',
            processing: 'åå°å¤„ç†ï¼Œä¸å½±å“èŠå¤©',
            completed: 'å·²ä¸ºå¥½å‹ç”ŸæˆèŠ‚æ—¥ç¥ç¦'
        }
    },
    // æ–°å¢ï¼šæ˜¥èŠ‚ç‰¹æ®Šé…ç½®
    spring_festival: {
        name: 'æ˜¥èŠ‚',
        emoji: 'ğŸ§§',
        completedEmoji: 'ğŸŠ',
        theme: {
            primary: '#d32f2f',
            gradient: 'linear-gradient(135deg, #d32f2f 0%, #f44336 50%, #ff9800 100%)',  // çº¢æ©™æ¸å˜
            alternativeGradients: [
                'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)',    // çº¢è‰²æ¸å˜
                'linear-gradient(135deg, #f85032 0%, #e73827 100%)',  // æ·±çº¢æ¸å˜
                'linear-gradient(135deg, #ff6b6b 0%, #ffd93d 100%)',  // çº¢é»„æ¸å˜
                'linear-gradient(135deg, #e52d27 0%, #b31217 100%)'   // æš—çº¢æ¸å˜
            ]
        },
        titles: {
            loading: 'æ˜¥èŠ‚ç‰¹æ®Šå‡†å¤‡ä¸­',
            processing: 'æ˜¥èŠ‚ç¥ç¦ç”Ÿæˆä¸­',
            completed: 'æ˜¥èŠ‚æœ‹å‹åœˆç”Ÿæˆå®Œæˆ'
        },
        descriptions: {
            loading: 'æˆ‘ä»¬æ­£åœ¨å‡†å¤‡æ˜¥èŠ‚å†…å®¹',
            processing: 'åå°å¤„ç†ï¼Œä¸å½±å“èŠå¤©',
            completed: 'å·²ä¸ºå¥½å‹ç”Ÿæˆæ˜¥èŠ‚ç¥ç¦'
        }
    },
    // æ–°å¢ï¼šä¸­ç§‹ç‰¹æ®Šé…ç½®
    mid_autumn: {
        name: 'ä¸­ç§‹èŠ‚',
        emoji: 'ğŸŒ•',
        completedEmoji: 'ğŸ¥®',
        theme: {
            primary: '#ffc107',
            gradient: 'linear-gradient(135deg, #ffc107 0%, #ff9800 50%, #f57c00 100%)',  // é‡‘é»„æ¸å˜
            alternativeGradients: [
                'linear-gradient(135deg, #fff3a3 0%, #ffc107 100%)',  // æ˜é»„æ¸å˜
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',  // æœˆå…‰æ¸å˜
                'linear-gradient(135deg, #434343 0%, #000000 100%)',  // å¤œç©ºæ¸å˜
                'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)'   // æ·±å¤œæ¸å˜
            ]
        },
        titles: {
            loading: 'ä¸­ç§‹èŠ‚ç‰¹æ®Šå‡†å¤‡ä¸­',
            processing: 'ä¸­ç§‹ç¥ç¦ç”Ÿæˆä¸­',
            completed: 'ä¸­ç§‹èŠ‚æœ‹å‹åœˆç”Ÿæˆå®Œæˆ'
        },
        descriptions: {
            loading: 'æˆ‘ä»¬æ­£åœ¨å‡†å¤‡ä¸­ç§‹å†…å®¹',
            processing: 'åå°å¤„ç†ï¼Œä¸å½±å“èŠå¤©',
            completed: 'å·²ä¸ºå¥½å‹ç”Ÿæˆä¸­ç§‹ç¥ç¦'
        }
    }
};

// ===== é€šç”¨çŠ¶æ€çƒç®¡ç†ç³»ç»Ÿ =====

/**
 * çŠ¶æ€çƒç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç±»å‹çš„æ‚¬æµ®çƒçŠ¶æ€
 */
class StatusBallManager {
    constructor() {
        this.activeStates = new Map(); // å½“å‰æ´»è·ƒçš„çŠ¶æ€
        this.currentState = null;      // å½“å‰æ˜¾ç¤ºçš„çŠ¶æ€
        this.stateConfigs = new Map(); // çŠ¶æ€é…ç½®
        this.priorityOrder = ['api_queue', 'special_event', 'system']; // çŠ¶æ€ä¼˜å…ˆçº§
        
        // åˆå§‹åŒ–çŠ¶æ€é…ç½®
        this.initializeStateConfigs();
        
        // ç›‘å¬APIé˜Ÿåˆ—å˜åŒ–
        this.startMonitoringAPIQueue();
    }
    
    /**
     * åˆå§‹åŒ–å„ç§çŠ¶æ€çš„é…ç½®
     */
    initializeStateConfigs() {
        // APIé˜Ÿåˆ—çŠ¶æ€é…ç½®
        this.stateConfigs.set('api_queue', {
            name: 'APIé˜Ÿåˆ—',
            emoji: 'âœ¨',
            completedEmoji: 'âœ…',
            theme: {
                primary: '#2196F3',
                gradient: 'linear-gradient(135deg, #42A5F5 0%, #1976D2 100%)'
            },
            titles: {
                loading: 'APIé˜Ÿåˆ—å¤„ç†ä¸­',
                processing: 'APIè¯·æ±‚å¤„ç†ä¸­',
                completed: 'APIé˜Ÿåˆ—å¤„ç†å®Œæˆ'
            },
            descriptions: {
                loading: 'æ­£åœ¨å¤„ç†APIè¯·æ±‚',
                processing: 'åå°å¤„ç†ï¼Œä¸å½±å“ä½¿ç”¨',
                completed: 'æ‰€æœ‰APIè¯·æ±‚å·²å¤„ç†å®Œæˆ'
            },
            priority: 1 // æœ€é«˜ä¼˜å…ˆçº§
        });
        
        // ç‰¹æ®Šäº‹ä»¶çŠ¶æ€é…ç½®ï¼ˆç»§æ‰¿åŸæœ‰çš„é…ç½®ï¼Œå¹¶ä½¿ç”¨è‡ªå®šä¹‰æ¸å˜ï¼‰
        Object.keys(STATUS_BALL_CONFIGS).forEach(eventType => {
            const baseConfig = STATUS_BALL_CONFIGS[eventType];
            const customGradient = window.gradientManager ? 
                window.gradientManager.getGradient(eventType) : 
                baseConfig.theme.gradient;
                
            this.stateConfigs.set(`special_event_${eventType}`, {
                ...baseConfig,
                type: 'special_event',
                priority: 2,
                theme: {
                    ...baseConfig.theme,
                    gradient: customGradient
                }
            });
        });
        
        // ç³»ç»ŸçŠ¶æ€é…ç½®
        this.stateConfigs.set('system', {
            name: 'ç³»ç»Ÿ',
            emoji: 'ğŸ”§',
            completedEmoji: 'âœ…',
            theme: {
                primary: '#607D8B',
                gradient: 'linear-gradient(135deg, #78909C 0%, #455A64 100%)'
            },
            titles: {
                loading: 'ç³»ç»Ÿå¤„ç†ä¸­',
                processing: 'åå°ä»»åŠ¡æ‰§è¡Œä¸­',
                completed: 'ç³»ç»Ÿä»»åŠ¡å®Œæˆ'
            },
            descriptions: {
                loading: 'æ­£åœ¨æ‰§è¡Œç³»ç»Ÿä»»åŠ¡',
                processing: 'åå°å¤„ç†ï¼Œä¸å½±å“ä½¿ç”¨',
                completed: 'ç³»ç»Ÿä»»åŠ¡å·²å®Œæˆ'
            },
            priority: 3
        });
    }
    
    /**
     * å¼€å§‹ç›‘æ§APIé˜Ÿåˆ—çŠ¶æ€
     */
    startMonitoringAPIQueue() {
        // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡APIé˜Ÿåˆ—çŠ¶æ€
        setInterval(() => {
            this.updateAPIQueueStatus();
        }, 1000);
        
        // åˆå§‹æ£€æŸ¥
        this.updateAPIQueueStatus();
    }
    
    /**
     * æ›´æ–°APIé˜Ÿåˆ—çŠ¶æ€
     */
    updateAPIQueueStatus() {
        if (!window.apiRequestQueue) return;
        
        const status = window.apiRequestQueue.getStatus();
        const hasActiveQueue = status.queueLength >= 2 || (status.isProcessing && status.queueLength >= 1);
        
        if (hasActiveQueue) {
            // è®¡ç®—è¿›åº¦
            const totalTasks = status.queueLength + (status.currentRequest ? 1 : 0);
            const completedTasks = status.currentRequest ? 1 : 0;
            
            const queueState = {
                type: 'api_queue',
                completedTasks: completedTasks,
                totalTasks: totalTasks,
                currentRequest: status.currentRequest,
                queueLength: status.queueLength,
                isProcessing: status.isProcessing,
                config: this.stateConfigs.get('api_queue')
            };
            
            this.updateState('api_queue', queueState);
        } else {
            this.removeState('api_queue');
        }
    }
    
    /**
     * æ˜¾ç¤ºç‰¹æ®Šäº‹ä»¶çŠ¶æ€
     */
    showSpecialEvent(eventType, queueState) {
        const stateKey = `special_event_${eventType}`;
        const enhancedQueueState = {
            ...queueState,
            type: 'special_event',
            eventType: eventType
        };
        
        this.updateState(stateKey, enhancedQueueState);
    }
    
    /**
     * æ›´æ–°çŠ¶æ€
     */
    updateState(stateKey, stateData) {
        this.activeStates.set(stateKey, stateData);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢æ˜¾ç¤ºçš„çŠ¶æ€
        this.checkAndSwitchState();
    }
    
    /**
     * ç§»é™¤çŠ¶æ€
     */
    removeState(stateKey) {
        this.activeStates.delete(stateKey);
        
        // å¦‚æœç§»é™¤çš„æ˜¯å½“å‰æ˜¾ç¤ºçš„çŠ¶æ€ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€
        if (this.currentState === stateKey) {
            this.currentState = null;
            this.checkAndSwitchState();
        }
    }
    
    /**
     * æ£€æŸ¥å¹¶åˆ‡æ¢åˆ°æœ€é«˜ä¼˜å…ˆçº§çš„çŠ¶æ€
     */
    checkAndSwitchState() {
        if (this.activeStates.size === 0) {
            // æ²¡æœ‰æ´»è·ƒçŠ¶æ€ï¼Œéšè—æ‚¬æµ®çª—
            this.hideStatusBall();
            return;
        }
        
        // æ‰¾åˆ°æœ€é«˜ä¼˜å…ˆçº§çš„æ´»è·ƒçŠ¶æ€
        let highestPriorityState = null;
        let highestPriority = Infinity;
        
        for (const [stateKey, state] of this.activeStates) {
            const config = this.stateConfigs.get(stateKey);
            if (config && config.priority < highestPriority) {
                highestPriority = config.priority;
                highestPriorityState = stateKey;
            }
        }
        
        // å¦‚æœéœ€è¦åˆ‡æ¢çŠ¶æ€
        if (highestPriorityState && highestPriorityState !== this.currentState) {
            this.switchToState(highestPriorityState);
        } else if (this.currentState) {
            // æ›´æ–°å½“å‰çŠ¶æ€
            this.updateCurrentState();
        }
    }
    
    /**
     * åˆ‡æ¢åˆ°æŒ‡å®šçŠ¶æ€
     */
    switchToState(stateKey) {
        const state = this.activeStates.get(stateKey);
        if (!state) return;
        
        this.currentState = stateKey;
        
        if (state.type === 'api_queue') {
            this.showAPIQueueStatus(state);
        } else if (state.type === 'special_event') {
            this.showSpecialEventStatus(state);
        }
    }
    
    /**
     * æ˜¾ç¤ºAPIé˜Ÿåˆ—çŠ¶æ€
     */
    showAPIQueueStatus(queueState) {
        if (window.statusBallWindowState && window.statusBallWindowState.type === 'api_queue') {
            // æ›´æ–°ç°æœ‰æ‚¬æµ®çª—
            this.updateAPIQueueFloatingWindow(queueState);
        } else {
            // åˆ›å»ºæ–°çš„æ‚¬æµ®çª—
            this.createAPIQueueFloatingWindow(queueState);
        }
    }
    
    /**
     * åˆ›å»ºAPIé˜Ÿåˆ—æ‚¬æµ®çª—
     */
    createAPIQueueFloatingWindow(queueState) {
        // å…ˆç§»é™¤å¯èƒ½å·²å­˜åœ¨çš„æ‚¬æµ®çª—
        hideStatusBallFloatingWindow();
        
        const config = queueState.config;
        
        // åˆ›å»ºå®¹å™¨
        const container = document.createElement('div');
        container.id = 'statusBallFloatingContainer';
        container.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;
        
        // åˆ›å»ºè¯¦æƒ…çª—å£
        const detailWindow = document.createElement('div');
        detailWindow.id = 'statusBallDetailWindow';
        detailWindow.style.cssText = `
            width: 300px;
            background: ${config.theme.gradient};
            color: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: block;
        `;
        
        detailWindow.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 12px;">
                <div style="font-size: 18px;">${config.emoji}</div>
                <div style="flex: 1; margin-left: 8px;">
                    <div style="font-weight: bold; font-size: 14px;">${config.titles.processing}</div>
                    <div style="font-size: 11px; opacity: 0.8;">${config.descriptions.processing}</div>
                </div>
                <button onclick="window.statusBallManager.collapseCurrentWindow()" 
                        style="background: none; border: none; color: white; font-size: 16px; cursor: pointer; opacity: 0.7; padding: 2px 6px; border-radius: 3px;">
                    âˆ’
                </button>
            </div>
            
            <div id="statusBallInfo" style="font-size: 12px; margin-bottom: 8px; opacity: 0.9;">
                é˜Ÿåˆ—é•¿åº¦: ${queueState.queueLength} | æ­£åœ¨å¤„ç†: ${queueState.isProcessing ? 'æ˜¯' : 'å¦'}
            </div>
            
            <div id="statusBallCurrentRequest" style="font-size: 11px; margin-bottom: 8px; opacity: 0.8;">
                ${queueState.currentRequest ? `å½“å‰: ${queueState.currentRequest.description}` : 'ç­‰å¾…ä¸­...'}
            </div>
            
            <div style="background: rgba(255,255,255,0.2); height: 4px; border-radius: 2px; overflow: hidden;">
                <div id="statusBallProgressBar" 
                     style="height: 100%; background: rgba(255,255,255,0.8); transition: width 0.3s; width: 0%;"></div>
            </div>
            
            <div id="statusBallStatus" style="font-size: 11px; margin-top: 8px; opacity: 0.8;">
                ç›‘æ§APIé˜Ÿåˆ—çŠ¶æ€...
            </div>
        `;
        
        // åˆ›å»ºå°çƒ
        const floatingBall = document.createElement('div');
        floatingBall.id = 'statusBallFloatingBall';
        floatingBall.style.cssText = `
            width: 50px;
            height: 50px;
            background: ${config.theme.gradient};
            color: white;
            border-radius: 50%;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
            backdrop-filter: blur(10px);
        `;
        
        floatingBall.innerHTML = `
            <div style="position: relative;">
                ${config.emoji}
                <div id="statusBallBadge" style="
                    position: absolute;
                    top: -8px;
                    right: -8px;
                    background: #ff4757;
                    color: white;
                    border-radius: 10px;
                    padding: 1px 6px;
                    font-size: 10px;
                    font-weight: bold;
                    min-width: 16px;
                    text-align: center;
                    ${queueState.queueLength === 0 ? 'display: none;' : ''}
                ">${queueState.queueLength}</div>
            </div>
        `;
        
        // æ·»åŠ åˆ°å®¹å™¨
        container.appendChild(detailWindow);
        container.appendChild(floatingBall);
        document.body.appendChild(container);
        
        // æ·»åŠ åŠŸèƒ½
        makeDraggable(floatingBall, container);
        floatingBall.addEventListener('click', () => this.expandCurrentWindow());
        
        // å­˜å‚¨çŠ¶æ€
        window.statusBallWindowState = {
            container,
            detailWindow,
            floatingBall,
            type: 'api_queue',
            state: queueState,
            isExpanded: true
        };
    }
    
    /**
     * æ›´æ–°APIé˜Ÿåˆ—æ‚¬æµ®çª—
     */
    updateAPIQueueFloatingWindow(queueState) {
        if (!window.statusBallWindowState) return;
        
        const infoElement = document.getElementById('statusBallInfo');
        const currentRequestElement = document.getElementById('statusBallCurrentRequest');
        const statusElement = document.getElementById('statusBallStatus');
        const badge = document.getElementById('statusBallBadge');
        
        if (infoElement) {
            infoElement.textContent = `é˜Ÿåˆ—é•¿åº¦: ${queueState.queueLength} | æ­£åœ¨å¤„ç†: ${queueState.isProcessing ? 'æ˜¯' : 'å¦'}`;
        }
        
        if (currentRequestElement) {
            currentRequestElement.textContent = queueState.currentRequest 
                ? `å½“å‰: ${queueState.currentRequest.description}` 
                : 'ç­‰å¾…ä¸­...';
        }
        
        if (statusElement) {
            statusElement.textContent = queueState.isProcessing ? 'æ­£åœ¨å¤„ç†è¯·æ±‚...' : 'ç›‘æ§APIé˜Ÿåˆ—çŠ¶æ€...';
        }
        
        if (badge) {
            badge.textContent = queueState.queueLength;
            badge.style.display = queueState.queueLength === 0 ? 'none' : 'block';
        }
        
        // æ›´æ–°å­˜å‚¨çš„çŠ¶æ€
        window.statusBallWindowState.state = queueState;
    }
    
    /**
     * æ˜¾ç¤ºç‰¹æ®Šäº‹ä»¶çŠ¶æ€
     */
    showSpecialEventStatus(eventState) {
        // å¤ç”¨ç°æœ‰çš„æ‚¬æµ®çª—å‡½æ•°
        showStatusBallFloatingWindow(eventState);
        
        // æ›´æ–°ç±»å‹æ ‡è®°
        if (window.statusBallWindowState) {
            window.statusBallWindowState.type = 'special_event';
            window.statusBallWindowState.state = eventState;
        }
    }
    
    /**
     * æ›´æ–°å½“å‰çŠ¶æ€
     */
    updateCurrentState() {
        if (!this.currentState) return;
        
        const state = this.activeStates.get(this.currentState);
        if (!state) return;
        
        if (state.type === 'api_queue') {
            this.updateAPIQueueFloatingWindow(state);
        } else if (state.type === 'special_event') {
            updateStatusBallFloatingWindow(state);
        }
    }
    
    /**
     * å±•å¼€å½“å‰çª—å£
     */
    expandCurrentWindow() {
        if (!window.statusBallWindowState) return;
        
        const { detailWindow, floatingBall } = window.statusBallWindowState;
        
        detailWindow.style.display = 'block';
        floatingBall.style.display = 'none';
        window.statusBallWindowState.isExpanded = true;
        
        // æ¸…é™¤åŠ¨ç”»
        floatingBall.style.animation = '';
    }
    
    /**
     * æ”¶èµ·å½“å‰çª—å£
     */
    collapseCurrentWindow() {
        if (!window.statusBallWindowState) return;
        
        const { detailWindow, floatingBall } = window.statusBallWindowState;
        
        detailWindow.style.display = 'none';
        floatingBall.style.display = 'flex';
        window.statusBallWindowState.isExpanded = false;
        
        // æ·»åŠ è„‰å†²åŠ¨ç”»
        floatingBall.style.animation = 'statusBallPulse 2s ease-in-out 3';
    }
    
    /**
     * éšè—çŠ¶æ€çƒ
     */
    hideStatusBall() {
        hideStatusBallFloatingWindow();
        this.currentState = null;
    }
    
    /**
     * è·å–å½“å‰çŠ¶æ€
     */
    getCurrentState() {
        return this.currentState ? this.activeStates.get(this.currentState) : null;
    }
    
    /**
     * è·å–æ‰€æœ‰æ´»è·ƒçŠ¶æ€
     */
    getActiveStates() {
        return Array.from(this.activeStates.values());
    }
}

// åˆ›å»ºå…¨å±€çŠ¶æ€çƒç®¡ç†å™¨å®ä¾‹
window.statusBallManager = new StatusBallManager();


/**
 * å¼€å§‹ç‰¹æ®Šäº‹ä»¶æµç¨‹
 * @param {string} eventType - äº‹ä»¶ç±»å‹ ('qixi', 'birthday', 'holiday' ç­‰)
 */
async function startSpecialEventFlow(eventType = 'qixi') {
    try {
        const config = STATUS_BALL_CONFIGS[eventType];
        if (!config) {
            throw new Error(`æœªçŸ¥çš„äº‹ä»¶ç±»å‹: ${eventType}`);
        }
        
        // è·å–ç”¨æˆ·èµ„æ–™å’Œè”ç³»äººä¿¡æ¯
        const userProfile = await getUserProfile();
        if (!userProfile || !userProfile.name) {
            throw new Error('æ— æ³•è·å–ç”¨æˆ·èµ„æ–™');
        }
        
        const contactsInfo = await getAllContactsInfo();
        if (!contactsInfo || contactsInfo.length === 0) {
            throw new Error('æ²¡æœ‰æ‰¾åˆ°ä»»ä½•è”ç³»äºº');
        }
        
        // é”å®šæœ‹å‹åœˆæ“ä½œ
        window.momentsLockManager.lock(`å‘å¸ƒæœ‹å‹åœˆåŠŸèƒ½æš‚æ—¶è¢«é”å®šï¼š${config.name}`);
        
        // æ˜¾ç¤ºåˆå§‹åŠ è½½å¼¹çª—
        showStatusBallLoadingModal(config);
        updateStatusBallProgress(0, 1, 'ç­‰å¾…AIå“åº”', config);
        
        // ç¬¬ä¸€æ­¥ï¼šæ·»åŠ è·å–ç¥ç¦äººå‘˜åˆ—è¡¨çš„è¯·æ±‚åˆ°é˜Ÿåˆ—
        const queueState = {
            completedTasks: 0,
            totalTasks: 1, // åˆå§‹åªæœ‰1ä¸ªä»»åŠ¡ï¼ˆè·å–åˆ—è¡¨ï¼‰
            blessers: [],
            eventType: eventType,
            config: config
        };
        
        const getBlessersRequestId = await window.apiRequestQueue.addRequest(
            () => getBlessersFromAI(contactsInfo, userProfile, eventType),
            {
                priority: window.apiRequestQueue.PRIORITY.LOW,
                description: `è·å–${config.name}ç¥ç¦äººå‘˜åˆ—è¡¨`,
                onComplete: (requestId, blessers) => {
                    console.log('è·å–åˆ°ç¥ç¦äººå‘˜åˆ—è¡¨:', blessers);
                    queueState.blessers = blessers;
                    queueState.totalTasks = blessers.length + 1;
                    queueState.completedTasks = 1;
                    
                    // è½¬æ¢ä¸ºæ‚¬æµ®çª—
                    hideStatusBallLoadingModal();
                    // ä½¿ç”¨çŠ¶æ€çƒç®¡ç†å™¨æ˜¾ç¤ºç‰¹æ®Šäº‹ä»¶
                    window.statusBallManager.showSpecialEvent(eventType, queueState);
                    
                    // æ·»åŠ ç”Ÿæˆæœ‹å‹åœˆçš„è¯·æ±‚
                    addEventMomentsToQueue(blessers, contactsInfo, userProfile, queueState);
                },
                onError: (requestId, error) => {
                    console.error('è·å–ç¥ç¦äººå‘˜å¤±è´¥:', error);
                    hideStatusBallLoadingModal();
                    window.momentsLockManager.unlock(); // å‡ºé”™æ—¶è§£é”
                    showApiError(error);
                }
            }
        );
        
    } catch (error) {
        console.error(`${eventType}æµç¨‹å¯åŠ¨å¤±è´¥:`, error);
        hideStatusBallLoadingModal();
        window.momentsLockManager.unlock(); // å‡ºé”™æ—¶è§£é”
        const config = STATUS_BALL_CONFIGS[eventType] || STATUS_BALL_CONFIGS.qixi;
        showApiError(error);
    }
}

// æš´éœ²ç‰¹æ®Šäº‹ä»¶æµç¨‹å‡½æ•°åˆ°å…¨å±€
window.startSpecialEventFlow = startSpecialEventFlow;

/**
 * æ˜¾ç¤ºçŠ¶æ€çƒåŠ è½½å¼¹çª—
 * @param {Object} config - äº‹ä»¶é…ç½®
 */
function showStatusBallLoadingModal(config) {
    const modal = document.createElement('div');
    modal.id = 'statusBallLoadingModal';
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content" style="text-align: center; padding: 30px;">
            <h3 style="color: ${config.theme.primary}; margin-bottom: 20px;">${config.emoji} ${config.titles.loading} ${config.emoji}</h3>
            <p style="margin-bottom: 20px;">è¯·ç¨ç­‰ã€‚<br>${config.descriptions.loading}ã€‚<br>æ­£åœ¨ç­‰å¾…APIå“åº”â€¦â€¦</p>
            <div id="statusBallProgress" style="margin-bottom: 15px; font-weight: bold; color: ${config.theme.primary};">(0/1)</div>
            <div style="width: 100%; height: 4px; background-color: #f0f0f0; border-radius: 2px; overflow: hidden;">
                <div id="statusBallProgressBar" style="width: 0%; height: 100%; background-color: ${config.theme.primary}; transition: width 0.3s;"></div>
            </div>
            <p style="margin-top: 15px; font-size: 12px; color: #666;">è¯·ä¸è¦å…³é—­åº”ç”¨</p>
        </div>
    `;
    document.body.appendChild(modal);
    modal.style.display = 'block';
}

/**
 * æ›´æ–°çŠ¶æ€çƒè¿›åº¦
 * @param {number} current - å½“å‰è¿›åº¦
 * @param {number} total - æ€»è¿›åº¦
 * @param {string} message - è¿›åº¦æ¶ˆæ¯
 * @param {Object} config - äº‹ä»¶é…ç½®
 */
function updateStatusBallProgress(current, total, message = '', config) {
    const progressElement = document.getElementById('statusBallProgress');
    const progressBar = document.getElementById('statusBallProgressBar');
    
    if (progressElement && progressBar) {
        const percentage = Math.round((current / total) * 100);
        progressElement.textContent = `(${current}/${total}) ${message}`;
        progressBar.style.width = percentage + '%';
    }
}

/**
 * éšè—çŠ¶æ€çƒåŠ è½½å¼¹çª—
 */
function hideStatusBallLoadingModal() {
    const modal = document.getElementById('statusBallLoadingModal');
    if (modal) {
        modal.remove();
    }
}

/**
 * æ˜¾ç¤ºä¸ƒå¤•èŠ‚å®Œæˆå¼¹çª—
 */
function showQixiCompleteModal() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content" style="text-align: center; padding: 30px;">
            <h3 style="color: #e91e63; margin-bottom: 20px;">ğŸ‰ æ¬¢è¿ ğŸ‰</h3>
            <p style="margin-bottom: 20px;">æœ‹å‹åœˆ æ›´æ–°äº†ä¸€äº›æ–°å†…å®¹~</p>
            <button onclick="this.parentElement.parentElement.remove()" 
                    style="background-color: #e91e63; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                æŸ¥çœ‹æœ‹å‹åœˆ
            </button>
        </div>
    `;
    document.body.appendChild(modal);
    modal.style.display = 'block';
    
    // 3ç§’åè‡ªåŠ¨å…³é—­
    setTimeout(() => {
        modal.remove();
    }, 3000);
}

/**
 * è·å–æ‰€æœ‰è”ç³»äººä¿¡æ¯
 */
async function getAllContactsInfo() {
    try {
        // ç¡®ä¿contactså·²åŠ è½½
        if (!window.contacts || window.contacts.length === 0) {
            console.warn('è”ç³»äººåˆ—è¡¨ä¸ºç©ºï¼Œå°è¯•ä»æ•°æ®åº“é‡æ–°åŠ è½½');
            await loadDataFromDB();
        }
        
        return window.contacts.filter(contact => contact.type === 'private');
    } catch (error) {
        console.error('è·å–è”ç³»äººä¿¡æ¯å¤±è´¥:', error);
        throw error;
    }
}

/**
 * é€šè¿‡AIåˆ¤æ–­å¯èƒ½é€ç¥ç¦çš„äººå‘˜
 * @param {Array} contactsInfo - è”ç³»äººä¿¡æ¯
 * @param {Object} userProfile - ç”¨æˆ·èµ„æ–™
 * @param {string} eventType - äº‹ä»¶ç±»å‹
 */
async function getBlessersFromAI(contactsInfo, userProfile, eventType = 'qixi') {
    try {
        if (!window.apiService || !apiSettings) {
            throw new Error('APIæœåŠ¡æœªåˆå§‹åŒ–');
        }
        
        // æ„å»ºè”ç³»äººä¿¡æ¯å­—ç¬¦ä¸²
        const contactsString = contactsInfo.map(contact => 
            `ã€${contact.name}ã€‘äººè®¾ä¸ºï¼š${contact.personality}`
        ).join('\n');
        
        // è·å–äº‹ä»¶é…ç½®
        const config = STATUS_BALL_CONFIGS[eventType];
        const eventName = config ? config.name : 'ç‰¹æ®Šæ—¥å­';
        
        // æ ¹æ®äº‹ä»¶ç±»å‹æ„å»ºä¸åŒçš„prompt
        let eventDescription = '';
        switch (eventType) {
            case 'qixi':
                eventDescription = 'ä»Šå¤©æ˜¯ä¸­å›½ä¼ ç»ŸèŠ‚æ—¥ã€ä¸ƒå¤•èŠ‚ã€‘';
                break;
            case 'birthday':
                eventDescription = `ä»Šå¤©æ˜¯ç”¨æˆ·ã€${userProfile.name}ã€‘çš„ç”Ÿæ—¥`;
                break;
            case 'holiday':
                eventDescription = 'ä»Šå¤©æ˜¯ç‰¹æ®ŠèŠ‚æ—¥';
                break;
            default:
                eventDescription = 'ä»Šå¤©æ˜¯ç‰¹æ®Šæ—¥å­';
        }
        
        // æ„å»ºè¯·æ±‚prompt
        const prompt = `${eventDescription}ã€‚è¯·åˆ¤æ–­ä»¥ä¸‹äººç‰©ä¸­ï¼Œå¯èƒ½åœ¨${eventName}ç»™ç”¨æˆ·ï¼ˆ${userProfile.name}ï¼‰é€ä¸Šç¥ç¦çš„æœ‰è°ï¼Ÿè¾“å‡ºæ‰€æœ‰å¯èƒ½çš„äººåä¸ºåˆ—è¡¨ï¼Œå¦‚["A", "B"]ã€‚

${contactsString}

ç”¨æˆ·${userProfile.name}çš„äººè®¾ä¸ºï¼š${userProfile.personality || 'æ— '}

è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„åˆ—è¡¨ï¼Œåˆ—è¡¨å†…çš„åå­—å¿…é¡»ä¸ºã€ã€‘å†…çš„ç”¨æˆ·åã€‚ä¸è¦åŒ…å«å…¶ä»–è§£é‡Šã€‚`;

        // ä½¿ç”¨æ–°çš„APIè°ƒç”¨ä¿¡æ¯æ¥å£è·å–è¿æ¥å’Œæ¨¡å‹ä¿¡æ¯
        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            showToast('è¯·å…ˆè®¾ç½®APIå’Œæ¨¡å‹');
            throw new Error('APIæˆ–æ¨¡å‹æœªé…ç½®');
        }

        // è°ƒç”¨API
        const response = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: prompt }],
            {
                temperature: 0.7,
                max_tokens: 5000,
            },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawContent = response.choices[0]?.message?.content;
        console.log('AIè¿”å›çš„åŸå§‹å†…å®¹:', rawContent);
        
        if (!rawContent) {
            console.error('ERROR: AIè¿”å›çš„å†…å®¹ä¸ºç©º - APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            throw new Error('AIè¿”å›ç©ºå†…å®¹');
        }
        
        // æå–äººååˆ—è¡¨
        let blessers = [];
        try {
            // å°è¯•ç›´æ¥è§£æJSON
            const match = rawContent.match(/\[.*?\]/);
            if (match) {
                blessers = JSON.parse(match[0]);
            } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°JSONæ•°ç»„ï¼Œå°è¯•æå–å¼•å·ä¸­çš„åå­—
                const names = rawContent.match(/"([^"]+)"/g);
                if (names) {
                    blessers = names.map(name => name.replace(/"/g, ''));
                }
            }
        } catch (parseError) {
            console.warn('è§£æAIå›å¤å¤±è´¥ï¼Œå°è¯•æ­£åˆ™æå–:', parseError);
            // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–å¯èƒ½çš„äººå
            const names = rawContent.match(/["']([^"']+)["']/g);
            if (names) {
                blessers = names.map(name => name.replace(/["']/g, ''));
            }
        }
        
        // éªŒè¯äººåæ˜¯å¦å­˜åœ¨äºè”ç³»äººä¸­
        const validBlessers = blessers.filter(name => 
            contactsInfo.some(contact => contact.name === name)
        );
        
        console.log('æœ‰æ•ˆçš„ç¥ç¦äººå‘˜:', validBlessers);
        return validBlessers;
        
    } catch (error) {
        console.error('AIåˆ¤æ–­ç¥ç¦äººå‘˜å¤±è´¥:', error);
        throw error;
    }
}

/**
 * ä¸ºæŒ‡å®šè”ç³»äººç”Ÿæˆç‰¹æ®Šäº‹ä»¶æœ‹å‹åœˆ
 * @param {Object} contact - è”ç³»äººä¿¡æ¯
 * @param {Object} userProfile - ç”¨æˆ·èµ„æ–™
 * @param {string} eventType - äº‹ä»¶ç±»å‹
 */
async function generateEventMoment(contact, userProfile, eventType = 'qixi') {
    try {
        const config = STATUS_BALL_CONFIGS[eventType];
        const eventName = config ? config.name : 'ç‰¹æ®Šæ—¥å­';
        const topic = `${eventName}ç»™${userProfile.name}çš„ç¥ç¦`;
        
        // è°ƒç”¨ç°æœ‰çš„æœ‹å‹åœˆç”Ÿæˆå‡½æ•°
        const result = await generateMomentAndComments(contact, userProfile, topic);
        
        if (result && result.content) {
            console.log(`æˆåŠŸä¸º ${contact.name} ç”Ÿæˆ${eventName}æœ‹å‹åœˆ:`, result.content);
            
            // ç”Ÿæˆäº‹ä»¶æ—¥æœŸ
            const eventDate = new Date();
            
            // æ ¹æ®äº‹ä»¶ç±»å‹è®¾ç½®æ—¥æœŸ
            if (eventType === 'qixi') {
                eventDate.setMonth(7); // 8æœˆï¼ˆæœˆä»½ä»0å¼€å§‹ï¼‰
                eventDate.setDate(29);
            } else if (eventType === 'birthday') {
                // ç”Ÿæ—¥ä¿æŒå½“å‰æ—¥æœŸ
            } else {
                // å…¶ä»–èŠ‚æ—¥ä¿æŒå½“å‰æ—¥æœŸ
            }
            
            eventDate.setHours(0, 0, 0, 0); // é›¶ç‚¹æ•´
            
            // åªéšæœºåŒ–ç§’æ•°ï¼Œä¿æŒéƒ½åœ¨é›¶ç‚¹é›¶åˆ†
            const randomSeconds = Math.floor(Math.random() * 60); // 0-59ç§’
            eventDate.setSeconds(randomSeconds);
            
            // ä¿å­˜æœ‹å‹åœˆåˆ°æ•°æ®åº“
            const moment = {
                id: generateId(),
                authorId: contact.id,
                authorName: contact.name,
                content: result.content,
                imageUrl: null, // æš‚æ—¶ä¸å¤„ç†å›¾ç‰‡
                likes: [],
                comments: result.comments || [], // ç¨åå¤„ç†è¯„è®ºæ—¶é—´
                timestamp: eventDate.toISOString(),
                time: eventDate.toISOString(), // æ·»åŠ timeå­—æ®µï¼Œæœ‹å‹åœˆæ¸²æŸ“éœ€è¦è¿™ä¸ª
                topic: topic // æ·»åŠ ä¸»é¢˜æ ‡è®°
            };
            
            // ä¿®æ­£è¯„è®ºçš„æ—¶é—´æˆ³ä¹Ÿä¸ºäº‹ä»¶å½“å¤©é›¶ç‚¹
            if (moment.comments && moment.comments.length > 0) {
                moment.comments.forEach((comment, index) => {
                    // ç»™æ¯ä¸ªè¯„è®ºä¸€ä¸ªç¨æ™šçš„æ—¶é—´ï¼ˆåœ¨æœ‹å‹åœˆå‘å¸ƒåçš„å‡ ç§’å†…ï¼‰
                    const commentTime = new Date(eventDate);
                    commentTime.setSeconds(commentTime.getSeconds() + 10 + index * 5); // æœ‹å‹åœˆå‘å¸ƒå10ç§’å¼€å§‹ï¼Œæ¯ä¸ªè¯„è®ºé—´éš”5ç§’
                    comment.timestamp = commentTime.toISOString();
                });
            }
            
            // æ·»åŠ åˆ°å…¨å±€æœ‹å‹åœˆåˆ—è¡¨
            console.log(`å½“å‰æœ‹å‹åœˆæ•°é‡: ${moments.length}`);
            moments.unshift(moment);
            console.log(`æ·»åŠ åæœ‹å‹åœˆæ•°é‡: ${moments.length}`);
            console.log(`æ–°æ·»åŠ çš„æœ‹å‹åœˆ:`, { 
                id: moment.id, 
                authorName: moment.authorName, 
                content: moment.content.substring(0, 50) + '...' 
            });
            
            // ä¿å­˜åˆ°æ•°æ®åº“
            await saveDataToDB();
            console.log('æœ‹å‹åœˆå·²ä¿å­˜åˆ°æ•°æ®åº“');
            
            console.log(`${eventName}æœ‹å‹åœˆå·²ä¿å­˜åˆ°æ•°æ®åº“: ${contact.name}`);
            return result;
        } else {
            throw new Error('ç”Ÿæˆçš„æœ‹å‹åœˆå†…å®¹ä¸ºç©º');
        }
    } catch (error) {
        console.error(`ä¸º ${contact.name} ç”Ÿæˆ${eventName}æœ‹å‹åœˆå¤±è´¥:`, error);
        throw error;
    }
}

/**
 * å°†ç‰¹æ®Šäº‹ä»¶æœ‹å‹åœˆç”Ÿæˆè¯·æ±‚æ·»åŠ åˆ°é˜Ÿåˆ—
 */
async function addEventMomentsToQueue(blessers, contactsInfo, userProfile, queueState) {
    for (const blesserName of blessers) {
        const contact = contactsInfo.find(c => c.name === blesserName);
        if (contact) {
            await window.apiRequestQueue.addRequest(
                () => generateEventMoment(contact, userProfile, queueState.eventType),
                {
                    priority: window.apiRequestQueue.PRIORITY.LOW,
                    description: `ç”Ÿæˆ${blesserName}çš„${queueState.config.name}ç¥ç¦æœ‹å‹åœˆ`,
                    onProgress: (requestId, status) => {
                        // ç¡®ä¿ä½¿ç”¨ä¸ƒå¤•æ¸å˜
                        if (queueState.eventType === 'qixi' && window.statusBallWindowState) {
                            const { detailWindow } = window.statusBallWindowState;
                            if (detailWindow) {
                                // å¼ºåˆ¶åº”ç”¨ä¸ƒå¤•æ¸å˜
                                detailWindow.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                            }
                        }
                        updateStatusBallFloatingWindow(queueState, `æ­£åœ¨ä¸º ${blesserName} ç”Ÿæˆç¥ç¦...`);
                    },
                    onComplete: (requestId, result) => {
                        queueState.completedTasks++;
                        updateStatusBallFloatingWindow(queueState, `å·²å®Œæˆ ${blesserName} çš„ç¥ç¦`);
                        
                        // å¦‚æœæ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†ï¼Œæ˜¾ç¤ºå®Œæˆæç¤º
                        if (queueState.completedTasks >= queueState.totalTasks) {
                            setTimeout(() => {
                                // è§£é”æœ‹å‹åœˆæ“ä½œ
                                window.momentsLockManager.unlock();
                                
                                // æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
                                showStatusBallCompletionState(queueState);
                                // é€šçŸ¥çŠ¶æ€çƒç®¡ç†å™¨ä»»åŠ¡å®Œæˆ
                                if (queueState.eventType && window.statusBallManager) {
                                    // ç‰¹æ®Šäº‹ä»¶å®Œæˆåè‡ªåŠ¨ç§»é™¤çŠ¶æ€ï¼Œè®©APIé˜Ÿåˆ—çŠ¶æ€ï¼ˆå¦‚æœæœ‰ï¼‰å¯ä»¥æ˜¾ç¤º
                                    setTimeout(() => {
                                        window.statusBallManager.removeState(`special_event_${queueState.eventType}`);
                                    }, 3000); // 3ç§’åè‡ªåŠ¨ç§»é™¤
                                }
                            }, 1000);
                        }
                    },
                    onError: (requestId, error) => {
                        console.error(`ä¸º ${blesserName} ç”Ÿæˆæœ‹å‹åœˆå¤±è´¥:`, error);
                        queueState.completedTasks++;
                        updateStatusBallFloatingWindow(queueState, `${blesserName} ç”Ÿæˆå¤±è´¥`);
                    }
                }
            );
        }
    }
}

/**
 * æ˜¾ç¤ºçŠ¶æ€çƒæ‚¬æµ®çª—
 */
function showStatusBallFloatingWindow(queueState) {
    // å…ˆç§»é™¤å¯èƒ½å·²å­˜åœ¨çš„æ‚¬æµ®çª—
    hideStatusBallFloatingWindow();
    
    // åˆ›å»ºå®¹å™¨
    const container = document.createElement('div');
    container.id = 'statusBallFloatingContainer';
    container.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    
    // è·å–äº‹ä»¶é…ç½®
    const config = queueState.config;
    
    // åˆ›å»ºè¯¦æƒ…çª—å£ï¼ˆé»˜è®¤æ˜¾ç¤ºï¼‰
    const detailWindow = document.createElement('div');
    detailWindow.id = 'statusBallDetailWindow';
    
    // è·å–æ¸å˜æ ·å¼
    const gradientStyle = queueState.eventType === 'qixi' 
        ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'  // å¼ºåˆ¶ä½¿ç”¨ä¸ƒå¤•è“ç´«æ¸å˜
        : config.theme.gradient;
    
    console.log(`æ˜¾ç¤ºæ‚¬æµ®çª—ï¼Œäº‹ä»¶ç±»å‹: ${queueState.eventType}, ä½¿ç”¨æ¸å˜: ${gradientStyle}`);
    
    detailWindow.style.cssText = `
        width: 280px;
        background: ${gradientStyle};
        color: white;
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        display: block;
    `;
    
    detailWindow.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 12px;">
            <div style="font-size: 18px;">${config.emoji}</div>
            <div style="flex: 1; margin-left: 8px;">
                <div style="font-weight: bold; font-size: 14px;">${config.titles.processing}</div>
                <div style="font-size: 11px; opacity: 0.8;">${config.descriptions.processing}</div>
            </div>
            <button onclick="collapseStatusBallWindow()" 
                    style="background: none; border: none; color: white; font-size: 16px; cursor: pointer; opacity: 0.7; padding: 2px 6px; border-radius: 3px;">
                âˆ’
            </button>
        </div>
        
        <div id="statusBallFloatingProgress" style="font-size: 12px; margin-bottom: 8px; opacity: 0.9;">
            (${queueState.completedTasks}/${queueState.totalTasks}) æ­£åœ¨å¤„ç†...
        </div>
        
        <div style="background: rgba(255,255,255,0.2); height: 4px; border-radius: 2px; overflow: hidden;">
            <div id="statusBallFloatingProgressBar" 
                 style="height: 100%; background: rgba(255,255,255,0.8); transition: width 0.3s; width: ${Math.round((queueState.completedTasks / queueState.totalTasks) * 100)}%;"></div>
        </div>
        
        <div id="statusBallFloatingStatus" style="font-size: 11px; margin-top: 8px; opacity: 0.8;">
            æ­£åœ¨ç”Ÿæˆæœ‹å‹åœˆ...
        </div>
    `;
    
    // åˆ›å»ºå°çƒï¼ˆé»˜è®¤éšè—ï¼‰
    const floatingBall = document.createElement('div');
    floatingBall.id = 'statusBallFloatingBall';
    
    // ä½¿ç”¨ç›¸åŒçš„æ¸å˜æ ·å¼
    floatingBall.style.cssText = `
        width: 50px;
        height: 50px;
        background: ${gradientStyle};
        color: white;
        border-radius: 50%;
        box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        cursor: pointer;
        user-select: none;
        transition: all 0.3s ease;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        position: relative;
        backdrop-filter: blur(10px);
    `;
    
    floatingBall.innerHTML = `
        <div style="position: relative;">
            ${config.emoji}
            <div id="statusBallBadge" style="
                position: absolute;
                top: -8px;
                right: -8px;
                background: #ff4757;
                color: white;
                border-radius: 10px;
                padding: 1px 6px;
                font-size: 10px;
                font-weight: bold;
                min-width: 16px;
                text-align: center;
            ">${queueState.totalTasks - queueState.completedTasks}</div>
        </div>
    `;
    
    // æ·»åŠ åˆ°å®¹å™¨
    container.appendChild(detailWindow);
    container.appendChild(floatingBall);
    document.body.appendChild(container);
    
    // æ·»åŠ å°çƒçš„æ‹–æ‹½åŠŸèƒ½
    makeDraggable(floatingBall, container);
    
    // æ·»åŠ å°çƒç‚¹å‡»å±•å¼€åŠŸèƒ½
    floatingBall.addEventListener('click', expandStatusBallWindow);
    
    // å­˜å‚¨çŠ¶æ€
    window.statusBallWindowState = {
        container,
        detailWindow,
        floatingBall,
        queueState,
        isExpanded: true
    };
}

/**
 * æ›´æ–°çŠ¶æ€çƒæ‚¬æµ®çª—
 */
function updateStatusBallFloatingWindow(queueState, message = '') {
    const progressElement = document.getElementById('statusBallFloatingProgress');
    const progressBar = document.getElementById('statusBallFloatingProgressBar');
    const statusElement = document.getElementById('statusBallFloatingStatus');
    const badge = document.getElementById('statusBallBadge');
    
    if (progressElement && progressBar && statusElement) {
        const percentage = Math.round((queueState.completedTasks / queueState.totalTasks) * 100);
        progressElement.textContent = `(${queueState.completedTasks}/${queueState.totalTasks}) æ­£åœ¨å¤„ç†...`;
        progressBar.style.width = percentage + '%';
        statusElement.textContent = message || 'æ­£åœ¨ç”Ÿæˆæœ‹å‹åœˆ...';
    }
    
    // æ›´æ–°å°çƒä¸Šçš„å¾½ç« æ•°å­—
    if (badge) {
        const remaining = queueState.totalTasks - queueState.completedTasks;
        badge.textContent = remaining;
        if (remaining === 0) {
            badge.style.display = 'none';
        }
    }
    
    // æ›´æ–°å…¨å±€çŠ¶æ€
    if (window.statusBallWindowState) {
        window.statusBallWindowState.queueState = queueState;
    }
}

/**
 * éšè—çŠ¶æ€çƒæ‚¬æµ®çª—
 */
function hideStatusBallFloatingWindow() {
    const container = document.getElementById('statusBallFloatingContainer');
    if (container) {
        container.remove();
    }
    window.statusBallWindowState = null;
}

/**
 * æ”¶èµ·æ‚¬æµ®çª—ï¼Œæ˜¾ç¤ºå°çƒ
 */
function collapseStatusBallWindow() {
    if (!window.statusBallWindowState) return;
    
    const { detailWindow, floatingBall } = window.statusBallWindowState;
    
    // éšè—è¯¦æƒ…çª—å£ï¼Œæ˜¾ç¤ºå°çƒ
    detailWindow.style.display = 'none';
    floatingBall.style.display = 'flex';
    
    window.statusBallWindowState.isExpanded = false;
    
    // æ·»åŠ å°çƒé—ªçƒæ•ˆæœæç¤ºç”¨æˆ·
    floatingBall.style.animation = 'statusBallPulse 2s ease-in-out 3';
    
    // æ·»åŠ CSSåŠ¨ç”»
    if (!document.getElementById('statusBallAnimations')) {
        const style = document.createElement('style');
        style.id = 'statusBallAnimations';
        style.textContent = `
            @keyframes statusBallPulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
            }
        `;
        document.head.appendChild(style);
    }
}

/**
 * å±•å¼€æ‚¬æµ®çª—ï¼Œéšè—å°çƒ
 */
function expandStatusBallWindow() {
    if (!window.statusBallWindowState) return;
    
    const { container, detailWindow, floatingBall } = window.statusBallWindowState;
    
    // åœ¨å±•å¼€å‰è°ƒæ•´å®¹å™¨ä½ç½®ï¼Œç¡®ä¿è¯¦æƒ…çª—å£åœ¨å±å¹•å†…
    adjustContainerPosition(container, detailWindow);
    
    // æ˜¾ç¤ºè¯¦æƒ…çª—å£ï¼Œéšè—å°çƒ
    floatingBall.style.display = 'none';
    detailWindow.style.display = 'block';
    
    window.statusBallWindowState.isExpanded = true;
    
    // æ¸…é™¤å°çƒåŠ¨ç”»
    floatingBall.style.animation = '';
}

/**
 * è°ƒæ•´å®¹å™¨ä½ç½®ï¼Œç¡®ä¿è¯¦æƒ…çª—å£åœ¨å±å¹•å†…
 */
function adjustContainerPosition(container, detailWindow) {
    // è·å–å½“å‰å®¹å™¨ä½ç½®
    const containerRect = container.getBoundingClientRect();
    
    // è·å–çª—å£å°ºå¯¸
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // è·å–è¯¦æƒ…çª—å£çš„å®é™…å°ºå¯¸
    // æš‚æ—¶æ˜¾ç¤ºè¯¦æƒ…çª—å£ä»¥è·å–å‡†ç¡®å°ºå¯¸
    const wasVisible = detailWindow.style.display !== 'none';
    if (!wasVisible) {
        detailWindow.style.display = 'block';
        detailWindow.style.visibility = 'hidden'; // éšè—ä½†å ç”¨ç©ºé—´
    }
    
    const detailRect = detailWindow.getBoundingClientRect();
    const detailWindowWidth = detailRect.width || 280;
    const detailWindowHeight = detailRect.height || 200;
    
    // æ¢å¤åŸå§‹æ˜¾ç¤ºçŠ¶æ€
    if (!wasVisible) {
        detailWindow.style.display = 'none';
        detailWindow.style.visibility = 'visible';
    }
    
    // å®‰å…¨è¾¹è·
    const safeMargin = 20;
    
    // è®¡ç®—å½“å‰å®¹å™¨ä½ç½®
    let currentLeft = containerRect.left;
    let currentTop = containerRect.top;
    
    // è®°å½•æ˜¯å¦è¿›è¡Œäº†è°ƒæ•´
    let adjusted = false;
    
    // æ£€æŸ¥å¹¶è°ƒæ•´æ°´å¹³ä½ç½®
    if (currentLeft + detailWindowWidth + safeMargin > windowWidth) {
        // å¦‚æœå³è¾¹è¶…å‡ºï¼Œå‘å·¦è°ƒæ•´
        currentLeft = windowWidth - detailWindowWidth - safeMargin;
        adjusted = true;
    }
    if (currentLeft < safeMargin) {
        // å¦‚æœå·¦è¾¹è¶…å‡ºï¼Œå‘å³è°ƒæ•´
        currentLeft = safeMargin;
        adjusted = true;
    }
    
    // æ£€æŸ¥å¹¶è°ƒæ•´å‚ç›´ä½ç½®
    if (currentTop + detailWindowHeight + safeMargin > windowHeight) {
        // å¦‚æœä¸‹è¾¹è¶…å‡ºï¼Œå‘ä¸Šè°ƒæ•´
        currentTop = windowHeight - detailWindowHeight - safeMargin;
        adjusted = true;
    }
    if (currentTop < safeMargin) {
        // å¦‚æœä¸Šè¾¹è¶…å‡ºï¼Œå‘ä¸‹è°ƒæ•´
        currentTop = safeMargin;
        adjusted = true;
    }
    
    // åªåœ¨éœ€è¦è°ƒæ•´æ—¶åº”ç”¨æ–°ä½ç½®
    if (adjusted) {
        container.style.left = currentLeft + 'px';
        container.style.top = currentTop + 'px';
        container.style.right = 'auto';
        container.style.bottom = 'auto';
        
        console.log(`[æ‚¬æµ®çª—] ä½ç½®è°ƒæ•´: (${Math.round(containerRect.left)}, ${Math.round(containerRect.top)}) -> (${Math.round(currentLeft)}, ${Math.round(currentTop)})`);
    } else {
        console.log(`[æ‚¬æµ®çª—] ä½ç½®æ— éœ€è°ƒæ•´: (${Math.round(containerRect.left)}, ${Math.round(containerRect.top)})`);
    }
}

/**
 * è®¡ç®—æ™ºèƒ½è¾¹ç•Œé™åˆ¶
 */
function calculateSmartBounds(proposedLeft, proposedTop, container) {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // è¯¦æƒ…çª—å£å°ºå¯¸
    const detailWindowWidth = 280;
    const detailWindowHeight = 200;
    
    // å°çƒå°ºå¯¸
    const ballSize = 50;
    
    // å®‰å…¨è¾¹è·
    const safeMargin = 20;
    
    let newLeft = proposedLeft;
    let newTop = proposedTop;
    
    // æ°´å¹³è¾¹ç•Œæ£€æŸ¥
    // ç¡®ä¿å°çƒæœ¬èº«ä¸è¶…å‡ºå±å¹•
    newLeft = Math.max(safeMargin, newLeft);
    newLeft = Math.min(windowWidth - ballSize - safeMargin, newLeft);
    
    // é¢å¤–æ£€æŸ¥ï¼šç¡®ä¿ä»ä»»æ„ä½ç½®éƒ½èƒ½å±•å¼€è¯¦æƒ…çª—å£
    // å¦‚æœå°çƒåœ¨å±å¹•å³è¾¹ç¼˜ï¼Œä½†è¯¦æƒ…çª—å£æ— æ³•å®Œå…¨æ˜¾ç¤ºï¼Œåˆ™é™åˆ¶å°çƒä½ç½®
    const maxLeftForExpansion = windowWidth - detailWindowWidth - safeMargin;
    if (newLeft > maxLeftForExpansion) {
        // å°çƒå¯ä»¥åœ¨å³è¾¹ç¼˜ï¼Œä½†å±•å¼€æ—¶ä¼šè‡ªåŠ¨è°ƒæ•´ä½ç½®
        // è¿™é‡Œä¸å¼ºåˆ¶é™åˆ¶ï¼Œè®©æ™ºèƒ½å®šä½å‡½æ•°å¤„ç†
    }
    
    // å‚ç›´è¾¹ç•Œæ£€æŸ¥
    newTop = Math.max(safeMargin, newTop);
    newTop = Math.min(windowHeight - ballSize - safeMargin, newTop);
    
    // é¢å¤–æ£€æŸ¥ï¼šç¡®ä¿ä»ä»»æ„ä½ç½®éƒ½èƒ½å±•å¼€è¯¦æƒ…çª—å£
    const maxTopForExpansion = windowHeight - detailWindowHeight - safeMargin;
    if (newTop > maxTopForExpansion) {
        // åŒæ ·ï¼Œè®©æ™ºèƒ½å®šä½å‡½æ•°å¤„ç†
    }
    
    return { newLeft, newTop };
}

/**
 * ä½¿å…ƒç´ å¯æ‹–æ‹½
 */
function makeDraggable(element, container) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    let hasMoved = false;
    
    function onMouseDown(e) {
        isDragging = true;
        hasMoved = false;
        
        const rect = container.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        startLeft = rect.left;
        startTop = rect.top;
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        
        e.preventDefault();
    }
    
    function onMouseMove(e) {
        if (!isDragging) return;
        
        hasMoved = true;
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newLeft = startLeft + deltaX;
        let newTop = startTop + deltaY;
        
        // æ™ºèƒ½è¾¹ç•Œé™åˆ¶ï¼Œè€ƒè™‘è¯¦æƒ…çª—å£å±•å¼€çš„ç©ºé—´éœ€æ±‚
        const { newLeft: adjustedLeft, newTop: adjustedTop } = calculateSmartBounds(newLeft, newTop, container);
        
        container.style.left = adjustedLeft + 'px';
        container.style.top = adjustedTop + 'px';
        container.style.right = 'auto';
        container.style.bottom = 'auto';
    }
    
    function onMouseUp(e) {
        isDragging = false;
        
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        
        // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œåˆ™è§¦å‘ç‚¹å‡»äº‹ä»¶
        if (!hasMoved) {
            expandStatusBallWindow();
        }
    }
    
    // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
    function onTouchStart(e) {
        const touch = e.touches[0];
        onMouseDown({
            clientX: touch.clientX,
            clientY: touch.clientY,
            preventDefault: () => e.preventDefault()
        });
    }
    
    function onTouchMove(e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        onMouseMove({
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        e.preventDefault();
    }
    
    function onTouchEnd(e) {
        onMouseUp({});
        e.preventDefault();
    }
    
    // ç»‘å®šäº‹ä»¶
    element.addEventListener('mousedown', onMouseDown);
    element.addEventListener('touchstart', onTouchStart, { passive: false });
    element.addEventListener('touchmove', onTouchMove, { passive: false });
    element.addEventListener('touchend', onTouchEnd, { passive: false });
}

/**
 * æ˜¾ç¤ºçŠ¶æ€çƒå®ŒæˆçŠ¶æ€
 */
function showStatusBallCompletionState(queueState) {
    if (!window.statusBallWindowState) return;
    
    const { detailWindow, floatingBall } = window.statusBallWindowState;
    const config = queueState.config;
    
    // æ›´æ–°è¯¦æƒ…çª—å£å†…å®¹ä¸ºå®ŒæˆçŠ¶æ€
    detailWindow.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 15px;">
            <div style="font-size: 24px;">${config.completedEmoji}</div>
            <div style="flex: 1; margin-left: 8px;">
                <div style="font-weight: bold; font-size: 14px;">${config.titles.completed}</div>
                <div style="font-size: 11px; opacity: 0.8;">${config.descriptions.completed} ${queueState.totalTasks - 1} ä½å¥½å‹</div>
            </div>
            <button onclick="hideStatusBallFloatingWindow()" 
                    style="background: none; border: none; color: white; font-size: 16px; cursor: pointer; opacity: 0.7; padding: 2px 6px; border-radius: 3px;">
                Ã—
            </button>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <div style="font-size: 14px; margin-bottom: 15px; line-height: 1.4;">
                æ‰€æœ‰æœ‹å‹åœˆå·²ç”Ÿæˆå®Œæ¯•<br>
                æ˜¯å¦åˆ·æ–°é¡µé¢æŸ¥çœ‹æ–°å†…å®¹ï¼Ÿ
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="refreshMomentsPage()" 
                        style="background: rgba(255,255,255,0.9); color: ${config.theme.primary}; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                    åˆ·æ–°é¡µé¢
                </button>
                <button onclick="collapseStatusBallWindow()" 
                        style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px;">
                    ç¨åæŸ¥çœ‹
                </button>
            </div>
        </div>
    `;
    
    // å¦‚æœå½“å‰æ˜¯æ”¶èµ·çŠ¶æ€ï¼Œåˆ™å±•å¼€æ˜¾ç¤ºå®Œæˆä¿¡æ¯
    if (!window.statusBallWindowState.isExpanded) {
        // åœ¨å±•å¼€å‰è°ƒæ•´ä½ç½®ï¼Œç¡®ä¿å®Œæˆç•Œé¢å®Œå…¨å¯è§
        adjustContainerPosition(window.statusBallWindowState.container, detailWindow);
        
        // æ˜¾ç¤ºè¯¦æƒ…çª—å£ï¼Œéšè—å°çƒ
        window.statusBallWindowState.floatingBall.style.display = 'none';
        detailWindow.style.display = 'block';
        window.statusBallWindowState.isExpanded = true;
    }
    
    // æ·»åŠ å®ŒæˆåŠ¨ç”»
    detailWindow.style.animation = 'statusBallComplete 0.5s ease-out';
    
    // æ›´æ–°å°çƒä¸ºå®ŒæˆçŠ¶æ€
    floatingBall.innerHTML = `
        <div style="position: relative;">
            ${config.completedEmoji}
        </div>
    `;
    
    // æ·»åŠ CSSåŠ¨ç”»
    if (!document.getElementById('statusBallCompleteAnimations')) {
        const style = document.createElement('style');
        style.id = 'statusBallCompleteAnimations';
        style.textContent = `
            @keyframes statusBallComplete {
                0% { transform: scale(0.9); opacity: 0.8; }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
    }
}

/**
 * åˆ·æ–°æœ‹å‹åœˆé¡µé¢
 */
async function refreshMomentsPage() {
    try {
        console.log('[ç‰¹æ®Šäº‹ä»¶] å¼€å§‹åˆ·æ–°æœ‹å‹åœˆé¡µé¢');
        
        // æ˜¾ç¤ºåŠ è½½æç¤º
        if (window.statusBallWindowState && window.statusBallWindowState.detailWindow) {
            const detailWindow = window.statusBallWindowState.detailWindow;
            detailWindow.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 20px; margin-bottom: 10px;">ğŸ”„</div>
                    <div style="font-size: 14px;">æ­£åœ¨åˆ·æ–°æœ‹å‹åœˆ...</div>
                </div>
            `;
        }
        
        // é‡æ–°ä»æ•°æ®åº“åŠ è½½æ•°æ®
        await loadDataFromDB();
        
        // å¦‚æœå½“å‰åœ¨æœ‹å‹åœˆé¡µé¢ï¼Œåˆ·æ–°æ˜¾ç¤º
        if (typeof renderMomentsList === 'function') {
            await renderMomentsList();
        }
        
        // æ˜¾ç¤ºæˆåŠŸæç¤ºå¹¶å…³é—­æ‚¬æµ®çª—
        showToast('æœ‹å‹åœˆå·²åˆ·æ–°å®Œæˆï¼');
        setTimeout(() => {
            hideQixiFloatingWindow();
        }, 1500);
        
        console.log('[ç‰¹æ®Šäº‹ä»¶] æœ‹å‹åœˆé¡µé¢åˆ·æ–°å®Œæˆ');
        
    } catch (error) {
        console.error('[ä¸ƒå¤•èŠ‚] åˆ·æ–°æœ‹å‹åœˆé¡µé¢å¤±è´¥:', error);
        showToast('åˆ·æ–°å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°é¡µé¢');
    }
}

// å°†å‡½æ•°è®¾ä¸ºå…¨å±€å¯è®¿é—®
// å‘åå…¼å®¹çš„åˆ«åï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
window.hideQixiFloatingWindow = hideStatusBallFloatingWindow;
window.collapseQixiWindow = collapseStatusBallWindow;
window.expandQixiWindow = expandStatusBallWindow;

// æ–°çš„ç»Ÿä¸€å‘½å
window.hideStatusBallFloatingWindow = hideStatusBallFloatingWindow;
window.collapseStatusBallWindow = collapseStatusBallWindow;
window.expandStatusBallWindow = expandStatusBallWindow;
window.refreshMomentsPage = refreshMomentsPage;

/**
 * è§¦å‘ç‰¹æ®Šäº‹ä»¶çŠ¶æ€çƒ
 * @param {string} eventType - äº‹ä»¶ç±»å‹ ('qixi', 'birthday', 'holiday')
 */
window.triggerSpecialEvent = function(eventType) {
    if (STATUS_BALL_CONFIGS[eventType]) {
        console.log(`æ‰‹åŠ¨è§¦å‘${STATUS_BALL_CONFIGS[eventType].name}äº‹ä»¶`);
        startSpecialEventFlow(eventType);
    } else {
        console.error(`æœªçŸ¥çš„äº‹ä»¶ç±»å‹: ${eventType}ã€‚å¯ç”¨ç±»å‹:`, Object.keys(STATUS_BALL_CONFIGS));
    }
};

// ===== èŠå¤©æ¶ˆæ¯ä¼˜å…ˆçº§å¤„ç† =====

/**
 * èŠå¤©APIè°ƒç”¨çš„é˜Ÿåˆ—åŒ…è£…å™¨
 * è¿™ç¡®ä¿äº†èŠå¤©æ¶ˆæ¯å…·æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§
 */
async function callChatAPIWithPriority(contact, turnContext = [], isUrgent = true) {
    return new Promise((resolve, reject) => {
        const priority = isUrgent ? 
            window.apiRequestQueue.PRIORITY.URGENT : 
            window.apiRequestQueue.PRIORITY.HIGH;
            
        window.apiRequestQueue.addRequest(
            async () => {
                const result = await callAPI(contact, turnContext);
                if (result === null) {
                    // callAPIå·²ç»å¤„ç†äº†é”™è¯¯æ˜¾ç¤ºï¼Œè¿™é‡Œä¸éœ€è¦å†æŠ›å‡ºé”™è¯¯
                    return { replies: [] }; // è¿”å›ç©ºå›å¤åˆ—è¡¨
                }
                return result;
            },
            {
                priority: priority,
                description: `èŠå¤©APIè°ƒç”¨ - ${contact.name}`,
                onComplete: (requestId, result) => {
                    resolve(result);
                },
                onError: (requestId, error) => {
                    // è¿™é‡Œä¸€èˆ¬ä¸ä¼šæ‰§è¡Œåˆ°ï¼Œå› ä¸ºcallAPIå·²ç»å¤„ç†é”™è¯¯äº†
                    reject(error);
                }
            }
        );
    });
}

// å°†æ–°çš„èŠå¤©APIå‡½æ•°è®¾ä¸ºå…¨å±€å¯è®¿é—®ï¼Œæ›¿ä»£åŸæœ‰çš„ç›´æ¥è°ƒç”¨
window.callChatAPIWithPriority = callChatAPIWithPriority;

// ===== æœ‹å‹åœˆæ“ä½œé”å®šæœºåˆ¶ =====

/**
 * æœ‹å‹åœˆæ“ä½œé”å®šç®¡ç†å™¨
 */
class MomentsLockManager {
    constructor() {
        this.isLocked = false;
        this.lockReason = '';
        this.lockStartTime = null;
    }
    
    /**
     * é”å®šæœ‹å‹åœˆæ“ä½œ
     */
    lock(reason = 'ç³»ç»Ÿæ­£åœ¨å¤„ç†ä¸­') {
        this.isLocked = true;
        this.lockReason = reason;
        this.lockStartTime = Date.now();
        this.updateUI();
        console.log(`[æœ‹å‹åœˆé”å®š] ${reason}`);
    }
    
    /**
     * è§£é”æœ‹å‹åœˆæ“ä½œ
     */
    unlock() {
        if (this.isLocked) {
            const lockDuration = Date.now() - this.lockStartTime;
            console.log(`[æœ‹å‹åœˆè§£é”] é”å®šæŒç»­æ—¶é—´: ${Math.round(lockDuration / 1000)}ç§’`);
        }
        
        this.isLocked = false;
        this.lockReason = '';
        this.lockStartTime = null;
        this.updateUI();
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦è¢«é”å®š
     */
    checkLocked(showMessage = true) {
        if (this.isLocked && showMessage) {
            showToast(this.lockReason || 'æœ‹å‹åœˆæ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨åå†è¯•');
        }
        return this.isLocked;
    }
    
    /**
     * æ›´æ–°UIçŠ¶æ€
     */
    updateUI() {
        // æ›´æ–°æœ‹å‹åœˆç›¸å…³æŒ‰é’®çŠ¶æ€
        const momentButtons = document.querySelectorAll('.generate-moment-btn, .moment-menu-btn, .moment-like-btn');
        momentButtons.forEach(btn => {
            if (this.isLocked) {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            } else {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        });
        
        // å¦‚æœé”å®šçŠ¶æ€ï¼Œæ˜¾ç¤ºé”å®šæç¤º
        this.updateLockIndicator();
    }
    
    /**
     * æ›´æ–°é”å®šæŒ‡ç¤ºå™¨
     */
    updateLockIndicator() {
        const momentsPage = document.getElementById('momentsPage');
        const isOnMomentsPage = momentsPage && momentsPage.classList.contains('active');
        
        let indicator = document.getElementById('momentsLockIndicator');
        
        if (this.isLocked && isOnMomentsPage) {
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'momentsLockIndicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: 70px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(255, 152, 0, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    z-index: 100;
                    backdrop-filter: blur(10px);
                    animation: fadeInOut 2s infinite;
                    max-width: 80%;
                    text-align: center;
                `;
                momentsPage.appendChild(indicator);
                
                // æ·»åŠ åŠ¨ç”»æ ·å¼
                if (!document.getElementById('lockIndicatorStyles')) {
                    const style = document.createElement('style');
                    style.id = 'lockIndicatorStyles';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0%, 100% { opacity: 0.7; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
            indicator.textContent = `ğŸ”’ ${this.lockReason}`;
        } else {
            if (indicator) {
                indicator.remove();
            }
        }
    }
}

// åˆ›å»ºå…¨å±€é”å®šç®¡ç†å™¨å®ä¾‹
window.momentsLockManager = new MomentsLockManager();

// ===== çŠ¶æ€çƒç®¡ç†å™¨å®ç”¨å‡½æ•° =====

/**
 * æ‰‹åŠ¨æ˜¾ç¤ºAPIé˜Ÿåˆ—çŠ¶æ€
 * å½“éœ€è¦å¼ºåˆ¶æ˜¾ç¤ºAPIé˜Ÿåˆ—æ—¶è°ƒç”¨
 */
function showAPIQueueStatusManually() {
    if (window.statusBallManager) {
        window.statusBallManager.updateAPIQueueStatus();
    }
}

/**
 * æ‰‹åŠ¨éšè—æ‰€æœ‰çŠ¶æ€çƒ
 */
function hideAllStatusBalls() {
    if (window.statusBallManager) {
        window.statusBallManager.hideStatusBall();
    }
}

/**
 * è·å–å½“å‰çŠ¶æ€çƒä¿¡æ¯
 * @returns {Object} å½“å‰çŠ¶æ€ä¿¡æ¯
 */
function getCurrentStatusBallInfo() {
    if (window.statusBallManager) {
        return {
            currentState: window.statusBallManager.currentState,
            activeStates: window.statusBallManager.getActiveStates(),
            stateDetails: window.statusBallManager.getCurrentState()
        };
    }
    return null;
}

/**
 * å¼ºåˆ¶æ˜¾ç¤ºç‰¹æ®Šäº‹ä»¶çŠ¶æ€
 * @param {string} eventType - äº‹ä»¶ç±»å‹
 * @param {Object} queueState - é˜Ÿåˆ—çŠ¶æ€
 */
function showSpecialEventStatus(eventType, queueState) {
    if (window.statusBallManager) {
        window.statusBallManager.showSpecialEvent(eventType, queueState);
    }
}

// å°†å®ç”¨å‡½æ•°æš´éœ²åˆ°å…¨å±€
window.showAPIQueueStatusManually = showAPIQueueStatusManually;
window.hideAllStatusBalls = hideAllStatusBalls;
window.getCurrentStatusBallInfo = getCurrentStatusBallInfo;
window.showSpecialEventStatus = showSpecialEventStatus;

/**
 * åˆ‡æ¢äº‹ä»¶ç±»å‹çš„æ¸å˜èƒŒæ™¯
 * @param {string} eventType - äº‹ä»¶ç±»å‹
 * @param {number} gradientIndex - æ¸å˜ç´¢å¼•ï¼ˆ0ä¸ºä¸»æ¸å˜ï¼Œ1-4ä¸ºæ›¿ä»£æ¸å˜ï¼‰
 */
function switchEventGradient(eventType, gradientIndex = 0) {
    if (STATUS_BALL_CONFIGS[eventType]) {
        const config = STATUS_BALL_CONFIGS[eventType];
        
        if (gradientIndex === 0) {
            // ä½¿ç”¨ä¸»æ¸å˜
            return config.theme.gradient;
        } else if (config.theme.alternativeGradients && config.theme.alternativeGradients[gradientIndex - 1]) {
            // ä½¿ç”¨æ›¿ä»£æ¸å˜
            return config.theme.alternativeGradients[gradientIndex - 1];
        }
    }
    
    // é»˜è®¤è¿”å›ä¸»æ¸å˜
    return STATUS_BALL_CONFIGS[eventType]?.theme.gradient || 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
}

/**
 * è·å–äº‹ä»¶ç±»å‹çš„æ‰€æœ‰æ¸å˜é€‰é¡¹
 * @param {string} eventType - äº‹ä»¶ç±»å‹
 */
function getEventGradients(eventType) {
    if (STATUS_BALL_CONFIGS[eventType]) {
        const config = STATUS_BALL_CONFIGS[eventType];
        const gradients = [config.theme.gradient];
        
        if (config.theme.alternativeGradients) {
            gradients.push(...config.theme.alternativeGradients);
        }
        
        return gradients;
    }
    return [];
}

/**
 * åº”ç”¨éšæœºæ¸å˜åˆ°äº‹ä»¶ç±»å‹
 * @param {string} eventType - äº‹ä»¶ç±»å‹
 */
function applyRandomGradient(eventType) {
    const gradients = getEventGradients(eventType);
    if (gradients.length > 0) {
        const randomIndex = Math.floor(Math.random() * gradients.length);
        return gradients[randomIndex];
    }
    return null;
}

// æš´éœ²åˆ°å…¨å±€
window.switchEventGradient = switchEventGradient;
window.getEventGradients = getEventGradients;
window.applyRandomGradient = applyRandomGradient;

// === APIé…ç½®ç®¡ç†ç›¸å…³å‡½æ•° ===

/**
 * åŠ è½½é…ç½®é€‰æ‹©å™¨
 */
async function loadConfigSelector() {
    try {
        const configSelector = document.getElementById('configSelector');
        if (!configSelector || !window.apiConfigManager) {
            return;
        }

        // è·å–æ‰€æœ‰é…ç½®
        const configs = await window.apiConfigManager.getAllConfigs();
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        
        // æ¸…ç©ºå¹¶é‡æ–°å¡«å……é€‰æ‹©å™¨
        configSelector.innerHTML = '';
        
        if (configs.length === 0) {
            configSelector.innerHTML = '<option value="">æ²¡æœ‰å¯ç”¨é…ç½®</option>';
            return;
        }
        
        configs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.configName || 'æœªå‘½åé…ç½®';
            if (config.id === window.apiConfigManager.defaultConfigKey) {
                option.textContent += ' (é»˜è®¤)';
                option.setAttribute('data-is-default', 'true');
            }
            if (activeConfig && config.id === activeConfig.id) {
                option.selected = true;
            }
            configSelector.appendChild(option);
        });
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        updateConfigActionButtons();
        
    } catch (error) {
        console.error('åŠ è½½é…ç½®é€‰æ‹©å™¨å¤±è´¥:', error);
    }
}

/**
 * åŠ è½½å½“å‰é…ç½®åˆ°è¡¨å•
 */
async function loadCurrentConfigToForm() {
    try {
        if (!window.apiConfigManager) {
            return;
        }

        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig) {
            // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œæ˜¾ç¤ºç©ºè¡¨å•
            clearConfigForm();
            return;
        }

        // å¡«å……è¡¨å•å­—æ®µ
        const fillField = (id, value) => {
            const element = document.getElementById(id);
            if (element) element.value = value || '';
        };

        fillField('configName', activeConfig.configName);
        fillField('apiUrl', activeConfig.url);
        fillField('apiKey', activeConfig.key);
        fillField('apiTimeout', activeConfig.timeout || 60);
        
        // Minimaxé…ç½®ä»localStorageè¯»å–ï¼ˆå•ä¸€å…¨å±€é…ç½®ï¼Œä¸å±äºAPIé…ç½®ï¼‰
        fillField('minimaxGroupId', localStorage.getItem('minimaxGroupId') || '');
        fillField('minimaxApiKey', localStorage.getItem('minimaxApiKey') || '');
        
        // ä¸Šä¸‹æ–‡æ»‘å—
        const contextSlider = document.getElementById('contextSlider');
        const contextValue = document.getElementById('contextValue');
        if (contextSlider && contextValue) {
            contextSlider.value = activeConfig.contextMessageCount || 10;
            contextValue.textContent = `${activeConfig.contextMessageCount || 10}æ¡`;
        }
        
        // ä¿å­˜æ¨¡å‹å€¼ï¼Œç­‰æ¨¡å‹åˆ—è¡¨åŠ è½½åå†è®¾ç½®
        window.pendingModelSelection = {
            primary: activeConfig.model || '',
            secondary: activeConfig.secondaryModel || 'sync_with_primary'
        };
        
        // æ›´æ–°ä¸»Keyç»Ÿè®¡
        const mainKeyInput = document.getElementById('apiKey');
        if (mainKeyInput && mainKeyInput.value) {
            updateMainKeyStats(mainKeyInput);
        }
        
        // éªŒè¯å’Œåˆ·æ–°å…¨å±€APIé…ç½®çŠ¶æ€
        await ensureApiConfigIsUpdated();
        
        // åŠ è½½é¢å¤–çš„API Keys
        // å…ˆæ¸…é™¤ç°æœ‰çš„é¢å¤–keyè¡Œ
        const existingRows = document.querySelectorAll('.api-provider-row');
        existingRows.forEach(row => row.remove());
        
        // å¦‚æœæœ‰apiKeysæ•°ç»„ï¼ŒåŠ è½½å®ƒä»¬
        if (activeConfig.apiKeys && activeConfig.apiKeys.length > 1) {
            // è·³è¿‡ç¬¬ä¸€ä¸ªkeyï¼ˆä¸»keyï¼‰ï¼Œä»ç¬¬äºŒä¸ªå¼€å§‹
            for (let i = 1; i < activeConfig.apiKeys.length; i++) {
                const keyData = activeConfig.apiKeys[i];
                addProviderRow();
                
                // å¡«å……keyå€¼
                const rows = document.querySelectorAll('.api-provider-row');
                const lastRow = rows[rows.length - 1];
                const keyInput = lastRow.querySelector('.api-key-input');
                const enableButton = lastRow.querySelector('.key-enable-btn');
                
                if (keyInput) {
                    // ç¡®ä¿keyData.keyæ˜¯å­—ç¬¦ä¸²
                    let keyValue = keyData.key || keyData || '';
                    if (typeof keyValue === 'object') {
                        keyValue = keyValue.key || keyValue.toString();
                    }
                    keyInput.value = keyValue;
                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    updateKeyStats(keyInput);
                }
                
                if (enableButton) {
                    if (keyData.enabled) {
                        enableButton.dataset.enabled = 'true';
                        enableButton.dataset.status = 'enabled';
                        enableButton.innerHTML = 'ğŸŸ¢';
                        enableButton.style.backgroundColor = '#28a745';
                        // ä¸ºå¯ç”¨çš„å‰¯keyæ·»åŠ CSSç±»
                        lastRow.classList.add('enabled');
                    } else {
                        enableButton.dataset.enabled = 'false';
                        enableButton.dataset.status = 'disabled';
                        enableButton.innerHTML = 'âšª';
                        enableButton.style.backgroundColor = '#6c757d';
                        // ç¡®ä¿æœªå¯ç”¨çš„å‰¯keyæ²¡æœ‰å¯ç”¨ç±»
                        lastRow.classList.remove('enabled');
                    }
                }
            }
        }
        
        // åŠ è½½Unsplash API Key (ä»ç„¶ä»localStorageè¯»å–)
        const unsplashApiKeyElement = document.getElementById('unsplashApiKey');
        if (unsplashApiKeyElement) {
            unsplashApiKeyElement.value = localStorage.getItem('forumUnsplashApiKey') || localStorage.getItem('unsplashApiKey') || '';
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„API Keys
        checkAllApiKeysForDuplicates();
        
        // ç¡®ä¿æ‰€æœ‰API keyçŠ¶æ€æ­£ç¡®æ˜¾ç¤º
        setTimeout(() => {
            updateAllKeyStates();
        }, 100);
        
    } catch (error) {
        console.error('åŠ è½½é…ç½®åˆ°è¡¨å•å¤±è´¥:', error);
    }
}

/**
 * ä¸ºå½“å‰é…ç½®åŠ è½½æ¨¡å‹åˆ—è¡¨
 */
async function loadModelsForCurrentConfig() {
    try {
        const primarySelect = document.getElementById('primaryModelSelect');
        const secondarySelect = document.getElementById('secondaryModelSelect');
        
        if (!primarySelect || !secondarySelect) return;
        
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig || !activeConfig.url || !activeConfig.key) {
            primarySelect.innerHTML = '<option value="">è¯·å…ˆé…ç½®API</option>';
            secondarySelect.innerHTML = '<option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>';
            return;
        }
        
        // é‡ç½®æ¨¡å‹é€‰æ‹©å™¨ï¼Œæ˜¾ç¤ºå½“å‰é€‰æ‹©çš„æ¨¡å‹
        const primaryModel = window.pendingModelSelection?.primary || activeConfig.model || '';
        const secondaryModel = window.pendingModelSelection?.secondary || activeConfig.secondaryModel || 'sync_with_primary';
        
        // å¦‚æœæœ‰ä¸»æ¨¡å‹ï¼Œç›´æ¥æ˜¾ç¤ºå®ƒ
        if (primaryModel) {
            primarySelect.innerHTML = `<option value="${primaryModel}">${primaryModel}</option>`;
        } else {
            primarySelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ¨¡å‹</option>';
        }
        
        secondarySelect.innerHTML = '<option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>';
        if (secondaryModel && secondaryModel !== 'sync_with_primary') {
            secondarySelect.innerHTML += `<option value="${secondaryModel}">${secondaryModel}</option>`;
        }
        
        // å°è¯•ä»ç¼“å­˜è·å–æ¨¡å‹åˆ—è¡¨ï¼ˆä¸å‘èµ·ç½‘ç»œè¯·æ±‚ï¼‰
        const cachedModels = window.apiConfigManager?.availableModels?.get(activeConfig.id);
        if (cachedModels && cachedModels.length > 0) {
            // æœ‰ç¼“å­˜ï¼Œå¡«å……æ‰€æœ‰æ¨¡å‹é€‰é¡¹
            if (primarySelect.options.length === 1 && primarySelect.options[0].value === primaryModel) {
                // åªæœ‰å½“å‰æ¨¡å‹ï¼Œæ·»åŠ å…¶ä»–æ¨¡å‹é€‰é¡¹
                cachedModels.forEach(modelId => {
                    if (modelId !== primaryModel) {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        primarySelect.appendChild(option);
                    }
                });
            }
            
            if (secondarySelect.options.length === 1) {
                cachedModels.forEach(modelId => {
                    if (modelId !== secondaryModel) {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        secondarySelect.appendChild(option);
                    }
                });
            }
            
            // è®¾ç½®æ­£ç¡®çš„é€‰ä¸­å€¼
            primarySelect.value = primaryModel;
            secondarySelect.value = secondaryModel;
        }
        
        // ç»‘å®šäº‹ä»¶
        primarySelect.onchange = handlePrimaryModelChange;
        
        // æ¸…é™¤ä¸´æ—¶ä¿å­˜çš„å€¼
        window.pendingModelSelection = null;
        
    } catch (error) {
        console.error('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error);
    }
}

/**
 * æ¸…ç©ºé…ç½®è¡¨å•
 */
function clearConfigForm() {
    // åªæ¸…ç©ºAPIé…ç½®ç›¸å…³å­—æ®µï¼Œä¸æ¸…ç©ºå…¨å±€é…ç½®ï¼ˆMinimax, Unsplashç­‰ï¼‰
    const fields = ['configName', 'apiUrl', 'apiKey', 'apiTimeout'];
    fields.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.value = '';
    });
    
    // Minimaxå­—æ®µä¿æŒä¸å˜ï¼Œä»localStorageè¯»å–
    const minimaxGroupIdElement = document.getElementById('minimaxGroupId');
    const minimaxApiKeyElement = document.getElementById('minimaxApiKey');
    if (minimaxGroupIdElement) {
        minimaxGroupIdElement.value = localStorage.getItem('minimaxGroupId') || '';
    }
    if (minimaxApiKeyElement) {
        minimaxApiKeyElement.value = localStorage.getItem('minimaxApiKey') || '';
    }
    
    const contextSlider = document.getElementById('contextSlider');
    const contextValue = document.getElementById('contextValue');
    if (contextSlider && contextValue) {
        contextSlider.value = 10;
        contextValue.textContent = '10æ¡';
    }
    
    const primarySelect = document.getElementById('primaryModelSelect');
    const secondarySelect = document.getElementById('secondaryModelSelect');
    if (primarySelect) primarySelect.innerHTML = '<option value="">è¯·å…ˆå®Œæˆç¬¬1æ­¥ä¿å­˜APIé…ç½®</option>';
    if (secondarySelect) secondarySelect.innerHTML = '<option value="sync_with_primary">ä¸ä¸»æ¨¡å‹ä¿æŒä¸€è‡´</option>';
}

/**
 * å¤„ç†é…ç½®åˆ‡æ¢
 */
async function handleConfigSwitch(configId) {
    try {
        if (!configId || !window.apiConfigManager) return;
        
        // æ¸…é™¤æ–°é…ç½®çŠ¶æ€
        window.currentConfigState = null;
        
        // åˆ‡æ¢åˆ°é€‰ä¸­çš„é…ç½®
        await window.apiConfigManager.switchToConfig(configId);
        
        // é‡æ–°åŠ è½½è¡¨å•
        await loadCurrentConfigToForm();
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        updateConfigActionButtons();
        
        showToast('é…ç½®å·²åˆ‡æ¢');
        
    } catch (error) {
        console.error('åˆ‡æ¢é…ç½®å¤±è´¥:', error);
        showToast('åˆ‡æ¢é…ç½®å¤±è´¥: ' + error.message);
    }
}

/**
 * æ˜¾ç¤ºæ–°é…ç½®è¡¨å•
 */
function showNewConfigForm() {
    // æ¸…ç©ºè¡¨å•
    clearConfigForm();
    
    // è®¾ç½®æ–°é…ç½®çŠ¶æ€æ ‡è¯†
    window.currentConfigState = 'new';
    
    // æ¸…é™¤é…ç½®é€‰æ‹©å™¨çš„é€‰æ‹©
    const configSelector = document.getElementById('configSelector');
    if (configSelector) {
        configSelector.value = '';
    }
    
    // è®¾ç½®é»˜è®¤å€¼
    const configNameField = document.getElementById('configName');
    if (configNameField) {
        configNameField.value = 'æ–°é…ç½® ' + Date.now().toString().slice(-6);
    }
    
    const timeoutField = document.getElementById('apiTimeout');
    if (timeoutField) {
        timeoutField.value = 60;
    }
    
    showToast('è¯·å¡«å†™æ–°é…ç½®ä¿¡æ¯');
}

/**
 * å¤åˆ¶å½“å‰é…ç½®
 */
async function duplicateCurrentConfig() {
    try {
        if (!window.apiConfigManager) return;
        
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig) {
            showToast('æ²¡æœ‰å¯å¤åˆ¶çš„é…ç½®');
            return;
        }
        
        const duplicated = await window.apiConfigManager.duplicateConfig(activeConfig.id);
        
        // é‡æ–°åŠ è½½é…ç½®é€‰æ‹©å™¨
        await loadConfigSelector();
        
        // åˆ‡æ¢åˆ°æ–°é…ç½®
        const configSelector = document.getElementById('configSelector');
        if (configSelector) {
            configSelector.value = duplicated.id;
            await handleConfigSwitch(duplicated.id);
        }
        
        showToast('é…ç½®å·²å¤åˆ¶');
        
    } catch (error) {
        console.error('å¤åˆ¶é…ç½®å¤±è´¥:', error);
        showToast('å¤åˆ¶é…ç½®å¤±è´¥: ' + error.message);
    }
}

/**
 * åˆ é™¤å½“å‰é…ç½®
 */
async function deleteCurrentConfig() {
    try {
        if (!window.apiConfigManager) return;
        
        const configSelector = document.getElementById('configSelector');
        if (!configSelector || !configSelector.value) {
            showToast('æ²¡æœ‰é€‰ä¸­è¦åˆ é™¤çš„é…ç½®');
            return;
        }
        
        const configId = configSelector.value;
        const activeConfig = await window.apiConfigManager.getConfigById(configId);
        
        if (!activeConfig) {
            showToast('é…ç½®ä¸å­˜åœ¨');
            return;
        }
        
        if (configId === window.apiConfigManager.defaultConfigKey) {
            showToast('ä¸èƒ½åˆ é™¤é»˜è®¤é…ç½®');
            return;
        }
        
        if (!confirm(`ç¡®å®šè¦åˆ é™¤é…ç½®"${activeConfig.configName}"å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
            return;
        }
        
        await window.apiConfigManager.deleteConfig(configId);
        
        // é‡æ–°åŠ è½½é…ç½®é€‰æ‹©å™¨
        await loadConfigSelector();
        
        // åŠ è½½å½“å‰é…ç½®åˆ°è¡¨å•
        await loadCurrentConfigToForm();
        
        showToast('é…ç½®å·²åˆ é™¤');
        
    } catch (error) {
        console.error('åˆ é™¤é…ç½®å¤±è´¥:', error);
        showToast('åˆ é™¤é…ç½®å¤±è´¥: ' + error.message);
    }
}

/**
 * æ›´æ–°é…ç½®æ“ä½œæŒ‰é’®çš„çŠ¶æ€
 */
function updateConfigActionButtons() {
    const configSelector = document.getElementById('configSelector');
    const deleteBtn = document.getElementById('deleteBtn');
    const duplicateBtn = document.getElementById('duplicateBtn');
    
    if (!configSelector || !deleteBtn || !duplicateBtn) return;
    
    const selectedConfigId = configSelector.value;
    const isDefaultConfig = selectedConfigId === (window.apiConfigManager?.defaultConfigKey || 'settings');
    
    // é»˜è®¤é…ç½®ä¸èƒ½åˆ é™¤
    deleteBtn.disabled = isDefaultConfig || !selectedConfigId;
    deleteBtn.style.opacity = deleteBtn.disabled ? '0.5' : '1';
    deleteBtn.style.cursor = deleteBtn.disabled ? 'not-allowed' : 'pointer';
    
    // æ²¡æœ‰é…ç½®æ—¶ä¸èƒ½å¤åˆ¶
    duplicateBtn.disabled = !selectedConfigId;
    duplicateBtn.style.opacity = duplicateBtn.disabled ? '0.5' : '1';
    duplicateBtn.style.cursor = duplicateBtn.disabled ? 'not-allowed' : 'pointer';
}

/**
 * ç¡®ä¿å…¨å±€APIé…ç½®ä¸é…ç½®ç®¡ç†å™¨ä¿æŒåŒæ­¥
 */
async function ensureApiConfigIsUpdated() {
    try {
        if (!window.apiConfigManager) return;
        
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig) return;
        
        // è·å–å½“å‰å¯ç”¨çš„key
        const enabledKey = window.apiConfigManager.getEnabledKey(activeConfig);
        
        // æ›´æ–°å…¨å±€apiSettingsï¼Œç¡®ä¿åŒ…å«æ‰€æœ‰å¿…è¦å­—æ®µ
        if (enabledKey && window.apiSettings) {
            Object.assign(window.apiSettings, {
                url: activeConfig.url || '',
                key: enabledKey,
                model: activeConfig.model || '',
                secondaryModel: activeConfig.secondaryModel || 'sync_with_primary',
                contextMessageCount: activeConfig.contextMessageCount || 10,
                timeout: activeConfig.timeout || 60
                // minimaxé…ç½®ä¸å†åŒ…å«åœ¨apiSettingsä¸­
            });
            
            console.log('å…¨å±€APIé…ç½®å·²æ›´æ–°:', {
                url: window.apiSettings.url,
                keyPrefix: window.apiSettings.key ? window.apiSettings.key.substring(0, 8) + '...' : 'empty',
                model: window.modelSettings ? window.modelSettings.primaryModel : 'not set'
            });
        }
        
    } catch (error) {
        console.error('æ›´æ–°å…¨å±€APIé…ç½®å¤±è´¥:', error);
    }
}

// æš´éœ²é…ç½®ç®¡ç†å‡½æ•°åˆ°å…¨å±€
window.loadConfigSelector = loadConfigSelector;
window.loadCurrentConfigToForm = loadCurrentConfigToForm;
window.handleConfigSwitch = handleConfigSwitch;
window.showNewConfigForm = showNewConfigForm;
window.duplicateCurrentConfig = duplicateCurrentConfig;
window.deleteCurrentConfig = deleteCurrentConfig;
window.updateConfigActionButtons = updateConfigActionButtons;
window.ensureApiConfigIsUpdated = ensureApiConfigIsUpdated;
window.loadModelsForConfig = loadModelsForConfig;
window.saveModelSelection = saveModelSelection;

// === äº’åŠ¨ç•Œé¢æ•°æ®åŒæ­¥ ===

/**
 * åŒæ­¥æ•°æ®åˆ°äº’åŠ¨ç•Œé¢
 */
async function syncInteractiveData() {
    try {
        showToast('æ­£åœ¨åŒæ­¥è§’è‰²æ•°æ®...', 'info');
        
        const interactiveFrame = document.getElementById('interactiveFrame');
        if (!interactiveFrame || !interactiveFrame.contentWindow) {
            showToast('äº’åŠ¨ç•Œé¢æœªå‡†å¤‡å°±ç»ª', 'error');
            return;
        }

        // å‡†å¤‡åŒæ­¥æ•°æ®
        const syncData = {
            type: 'BULK_DATA_SYNC',
            characters: contacts.filter(c => c.type === 'private').map(contact => ({
                name: contact.name,
                personality: contact.personality,
                voiceId: contact.voiceId || '',
                avatar: contact.avatarFileId || contact.avatar || ''
            })),
            apiSettings: {
                url: window.apiSettings?.url || '',
                key: window.apiSettings?.key || '',
                model: window.modelSettings?.primaryModel || '',
                minimaxGroupId: window.minimaxSettings?.groupId || '',
                minimaxApiKey: window.minimaxSettings?.apiKey || ''
            },
            userProfile: {
                name: window.userProfile?.name || 'é»˜è®¤ç”¨æˆ·',
                personality: window.userProfile?.personality || 'ä¸€ä¸ªæ¸©æŸ”çš„æ¢ç´¢è€…'
            }
        };

        // å‘é€æ•°æ®åˆ°iframe
        // å®‰å…¨çš„ postMessageï¼Œé€‚é…æœ¬åœ°æ–‡ä»¶ç¯å¢ƒ
        let targetOrigin = window.location.origin;
        if (targetOrigin === "null" || window.location.protocol === "file:") {
            targetOrigin = "*";
        }
        interactiveFrame.contentWindow.postMessage(syncData, targetOrigin);
        
        console.log('æ•°æ®åŒæ­¥åˆ°äº’åŠ¨ç•Œé¢:', syncData);
        showToast('è§’è‰²æ•°æ®åŒæ­¥å®Œæˆ', 'success');
        
    } catch (error) {
        console.error('äº’åŠ¨ç•Œé¢æ•°æ®åŒæ­¥å¤±è´¥:', error);
        showToast('æ•°æ®åŒæ­¥å¤±è´¥', 'error');
    }
}

/**
 * å¤„ç†æ¥è‡ªäº’åŠ¨ç•Œé¢çš„æ•°æ®æ›´æ–°
 */
function handleInteractiveDataUpdate(data) {
    try {
        console.log('æ”¶åˆ°äº’åŠ¨ç•Œé¢æ•°æ®æ›´æ–°:', data);
        
        if (data.type === 'UPDATE_CONTACT' && data.contactId && data.updateData) {
            // æ‰¾åˆ°å¯¹åº”çš„contactå¹¶æ›´æ–°
            const contact = contacts.find(c => c.name === data.contactId || c.id === data.contactId);
            if (contact) {
                // æ›´æ–°äº’åŠ¨ç›¸å…³å­—æ®µ
                if (data.updateData.interactiveBackgroundFileId !== undefined) {
                    contact.interactiveBackgroundFileId = data.updateData.interactiveBackgroundFileId;
                }
                if (data.updateData.touchZones !== undefined) {
                    contact.touchZones = data.updateData.touchZones;
                }
                if (data.updateData.theme !== undefined) {
                    contact.theme = data.updateData.theme;
                }
                if (data.updateData.ttsEnabled !== undefined) {
                    contact.ttsEnabled = data.updateData.ttsEnabled;
                }
                if (data.updateData.diaryEntries !== undefined) {
                    contact.diaryEntries = { ...contact.diaryEntries, ...data.updateData.diaryEntries };
                }
                if (data.updateData.interactiveChatHistory !== undefined) {
                    // è¿½åŠ èŠå¤©è®°å½•è€Œä¸æ˜¯æ›¿æ¢
                    contact.interactiveChatHistory = contact.interactiveChatHistory || [];
                    contact.interactiveChatHistory.push(...data.updateData.interactiveChatHistory);
                }
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                saveDataToDB().then(() => {
                    console.log(`è§’è‰² "${contact.name}" çš„äº’åŠ¨æ•°æ®å·²æ›´æ–°`);
                    showToast('äº’åŠ¨æ•°æ®å·²ä¿å­˜', 'success');
                }).catch(error => {
                    console.error('ä¿å­˜äº’åŠ¨æ•°æ®å¤±è´¥:', error);
                    showToast('ä¿å­˜äº’åŠ¨æ•°æ®å¤±è´¥', 'error');
                });
            }
        }
        
    } catch (error) {
        console.error('å¤„ç†äº’åŠ¨ç•Œé¢æ•°æ®æ›´æ–°å¤±è´¥:', error);
    }
}

// ç›‘å¬æ¥è‡ªiframeçš„æ¶ˆæ¯
window.addEventListener('message', (event) => {
    // åªå¤„ç†æ¥è‡ªäº’åŠ¨ç•Œé¢çš„æ¶ˆæ¯
    if (event.origin === window.location.origin && event.data && event.data.type) {
        handleInteractiveDataUpdate(event.data);
    }
});

// åœ¨è¿›å…¥äº’åŠ¨é¡µé¢æ—¶è‡ªåŠ¨åŒæ­¥æ•°æ®
const originalShowPage = window.showPage;
window.showPage = function(pageId) {
    const result = originalShowPage.call(this, pageId);
    
    // å¦‚æœåˆ‡æ¢åˆ°äº’åŠ¨é¡µé¢ï¼Œå»¶è¿Ÿ1ç§’åè‡ªåŠ¨åŒæ­¥æ•°æ®
    if (pageId === 'interactivePage') {
        setTimeout(() => {
            syncInteractiveData();
        }, 1000);
    }
    
    return result;
};

// æš´éœ²äº’åŠ¨ç›¸å…³å‡½æ•°åˆ°å…¨å±€
window.syncInteractiveData = syncInteractiveData;
window.handleInteractiveDataUpdate = handleInteractiveDataUpdate;

// === ç”¨æˆ·ä½“éªŒå¢å¼ºå‡½æ•° ===

/**
 * æ˜¾ç¤ºAPIé…ç½®ä¿å­˜æˆåŠŸçŠ¶æ€
 */
function showConfigSaveSuccess() {
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    const hintElement = document.getElementById('configSaveHint');
    if (hintElement) {
        hintElement.style.display = 'block';
        // 5ç§’åè‡ªåŠ¨éšè—
        setTimeout(() => {
            if (hintElement) {
                hintElement.style.display = 'none';
            }
        }, 5000);
    }
    
    // éšè—æ¨¡å‹é€‰æ‹©çš„æé†’
    const reminderElement = document.getElementById('modelSelectionReminder');
    if (reminderElement) {
        reminderElement.style.display = 'none';
    }
    
    // é‡æ–°åŠ è½½æ¨¡å‹é€‰æ‹©å™¨é€‰é¡¹
    loadApiConfigSelectorsForModels();
}

/**
 * éªŒè¯ç”¨æˆ·æµç¨‹å®Œæ•´æ€§
 */
function validateUserFlow() {
    const primaryConfig = document.getElementById('primaryConfigSelect')?.value;
    const primaryModel = document.getElementById('primaryModelSelect')?.value;
    
    // æ£€æŸ¥æ˜¯å¦å·²å®Œæˆå¿…è¦çš„é…ç½®æ­¥éª¤
    if (!primaryConfig) {
        showToast('âš ï¸ è¯·å…ˆå®Œæˆï¼šâ‘ ä¿å­˜APIé…ç½® â†’ â‘¡é€‰æ‹©APIé…ç½® â†’ â‘¢é€‰æ‹©æ¨¡å‹');
        // æ»šåŠ¨åˆ°APIé…ç½®åŒºåŸŸ
        const configForm = document.getElementById('apiConfigForm');
        if (configForm) {
            configForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        return false;
    }
    
    if (!primaryModel) {
        showToast('âš ï¸ è¯·é€‰æ‹©ä¸»è¦æ¨¡å‹ï¼Œç„¶åæ»‘åˆ°æœ€åç‚¹å‡»"å®Œæˆè®¾ç½®"');
        // æ»šåŠ¨åˆ°æ¨¡å‹é€‰æ‹©åŒºåŸŸ
        const modelSection = document.getElementById('primaryModelSelect');
        if (modelSection) {
            modelSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        return false;
    }
    
    return true;
}

/**
 * æ˜¾ç¤ºæµç¨‹å®Œæˆæ¶ˆæ¯
 */
function showFlowCompletionMessage() {
    showToast('ğŸ‰ é…ç½®å®Œæˆï¼æ‚¨ç°åœ¨å¯ä»¥å¼€å§‹ä½¿ç”¨AIå¯¹è¯äº†');
    
    // 2ç§’åè¯¢é—®æ˜¯å¦å…³é—­è®¾ç½®çª—å£
    setTimeout(() => {
        const modal = document.getElementById('apiSettingsModal');
        if (modal && window.getComputedStyle(modal).display !== 'none') {
            // è¯¢é—®ç”¨æˆ·æ˜¯å¦å…³é—­è®¾ç½®çª—å£
            if (confirm('é…ç½®å·²å®Œæˆï¼Œæ˜¯å¦å…³é—­è®¾ç½®çª—å£å¼€å§‹å¯¹è¯ï¼Ÿ')) {
                closeModal('apiSettingsModal');
            }
        }
    }, 2000);
}

/**
 * æ£€æŸ¥å¹¶æ›´æ–°ç•Œé¢æç¤ºçŠ¶æ€
 */
function updateUIHintStatus() {
    const primaryConfig = document.getElementById('primaryConfigSelect')?.value;
    const reminderElement = document.getElementById('modelSelectionReminder');
    const hintElement = document.getElementById('configSaveHint');
    
    if (primaryConfig && reminderElement) {
        // å¦‚æœå·²æœ‰APIé…ç½®ï¼Œéšè—æé†’
        reminderElement.style.display = 'none';
    } else if (reminderElement) {
        // å¦‚æœæ²¡æœ‰APIé…ç½®ï¼Œæ˜¾ç¤ºæé†’
        reminderElement.style.display = 'block';
    }
    
    // éšè—æˆåŠŸæç¤ºï¼ˆå› ä¸ºç”¨æˆ·å¯èƒ½åœ¨ä¿®æ”¹é…ç½®ï¼‰
    if (hintElement) {
        hintElement.style.display = 'none';
    }
}

/**
 * å¢å¼ºçš„æµ‹è¯•è¿æ¥å‡½æ•°
 */
async function enhancedTestApiConnection() {
    try {
        await testApiConnection();
        // æµ‹è¯•æˆåŠŸåæç¤ºç”¨æˆ·ä¿å­˜é…ç½®
        showToast('âœ… è¿æ¥æµ‹è¯•æˆåŠŸï¼è¯·ä¿å­˜APIé…ç½®ç»§ç»­è®¾ç½®');
    } catch (error) {
        console.error('æµ‹è¯•è¿æ¥å¤±è´¥:', error);
        showToast('âŒ è¿æ¥æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥API URLå’ŒKey');
    }
}

// å°†å¢å¼ºæµ‹è¯•è¿æ¥å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
window.enhancedTestApiConnection = enhancedTestApiConnection;

/**
 * å®‰å…¨åœ°è½¬ä¹‰HTMLå­—ç¬¦ï¼Œé˜²æ­¢XSSæ”»å‡»
 * @param {string} str - éœ€è¦è½¬ä¹‰çš„å­—ç¬¦ä¸²
 * @returns {string} - è½¬ä¹‰åçš„å®‰å…¨å­—ç¬¦ä¸²
 */
function escapeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

/**
 * æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†
 * @param {string} imageUrl - å›¾ç‰‡URL
 * @param {string} title - å›¾ç‰‡æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰
 */
function showImagePreview(imageUrl, title = 'å›¾ç‰‡é¢„è§ˆ') {
    // ç§»é™¤å·²å­˜åœ¨çš„é¢„è§ˆæ¨¡æ€æ¡†
    const existingModal = document.getElementById('imagePreviewModal');
    if (existingModal) {
        existingModal.remove();
    }

    // ä½¿ç”¨DOMæ“ä½œåˆ›å»ºæ¨¡æ€æ¡†ï¼Œæ›´å®‰å…¨çš„æ–¹å¼
    const modal = document.createElement('div');
    modal.id = 'imagePreviewModal';
    modal.className = 'modal';
    modal.style.cssText = 'display: flex; z-index: 10000;';

    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.style.cssText = 'max-width: 90vw; max-height: 90vh; margin: auto; position: relative; background: var(--modal-bg); border-radius: 12px; overflow: hidden;';

    // åˆ›å»ºæ¨¡æ€æ¡†å¤´éƒ¨
    const modalHeader = document.createElement('div');
    modalHeader.className = 'modal-header';
    modalHeader.style.cssText = 'padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;';

    const modalTitle = document.createElement('h3');
    modalTitle.className = 'modal-title';
    modalTitle.style.cssText = 'margin: 0; font-size: 16px; color: var(--text-primary);';
    modalTitle.textContent = title; // ä½¿ç”¨textContentï¼Œè‡ªåŠ¨è½¬ä¹‰

    const closeButton = document.createElement('button');
    closeButton.className = 'modal-close';
    closeButton.style.cssText = 'background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-secondary); padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%;';
    closeButton.textContent = 'Ã—';
    closeButton.onclick = hideImagePreview;

    modalHeader.appendChild(modalTitle);
    modalHeader.appendChild(closeButton);

    // åˆ›å»ºæ¨¡æ€æ¡†ä¸»ä½“
    const modalBody = document.createElement('div');
    modalBody.className = 'modal-body';
    modalBody.style.cssText = 'padding: 0; display: flex; justify-content: center; align-items: center; background: #000;';

    const img = document.createElement('img');
    img.src = imageUrl; // DOMå±æ€§èµ‹å€¼æ˜¯å®‰å…¨çš„
    img.alt = title; // DOMå±æ€§èµ‹å€¼æ˜¯å®‰å…¨çš„
    img.style.cssText = 'max-width: 100%; max-height: 70vh; object-fit: contain; display: block;';
    img.title = 'ç‚¹å‡»å…³é—­';
    img.onclick = hideImagePreview;
    
    // å®‰å…¨çš„é”™è¯¯å¤„ç†
    img.onerror = function() {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'padding: 40px; text-align: center; color: var(--text-secondary);';
        errorDiv.textContent = 'ğŸ“· å›¾ç‰‡åŠ è½½å¤±è´¥';
        modalBody.innerHTML = '';
        modalBody.appendChild(errorDiv);
    };

    img.onload = function() {
        this.style.opacity = '1';
    };

    modalBody.appendChild(img);
    modalContent.appendChild(modalHeader);
    modalContent.appendChild(modalBody);
    modal.appendChild(modalContent);

    // å°†æ¨¡æ€æ¡†æ·»åŠ åˆ°é¡µé¢
    document.body.appendChild(modal);

    // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideImagePreview();
        }
    });

    // ESCé”®å…³é—­ - ä½¿ç”¨å…¨å±€å˜é‡é¿å…å†…å­˜æ³„æ¼
    // å…ˆæ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§ç›‘å¬å™¨
    if (window._imagePreviewEscHandler) {
        document.removeEventListener('keydown', window._imagePreviewEscHandler);
    }
    
    window._imagePreviewEscHandler = (e) => {
        if (e.key === 'Escape') {
            hideImagePreview();
        }
    };
    document.addEventListener('keydown', window._imagePreviewEscHandler);
}

/**
 * éšè—å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†
 */
function hideImagePreview() {
    const modal = document.getElementById('imagePreviewModal');
    if (modal) {
        modal.style.opacity = '0';
        modal.style.transform = 'scale(0.95)';
        setTimeout(() => {
            modal.remove();
        }, 200);
    }
    
    // æ¸…ç†ESCé”®äº‹ä»¶ç›‘å¬å™¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
    if (window._imagePreviewEscHandler) {
        document.removeEventListener('keydown', window._imagePreviewEscHandler);
        delete window._imagePreviewEscHandler;
    }
}

// æš´éœ²å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸ
window.escapeHTML = escapeHTML;
window.formatImageMessageContent = formatImageMessageContent;
window.showImagePreview = showImagePreview;
window.hideImagePreview = hideImagePreview;

/**
 * ç¼–è¾‘æœ‹å‹åœˆä½ç½®
 */
function editMomentLocation(momentId) {
    const moment = moments.find(m => m.id === momentId);
    if (!moment) {
        showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„æœ‹å‹åœˆ');
        return;
    }
    
    // è®¾ç½®å½“å‰ç¼–è¾‘çš„æœ‹å‹åœˆID
    document.getElementById('editLocationMomentId').value = momentId;
    
    // è®¾ç½®å½“å‰ä½ç½®
    document.getElementById('editLocationInput').value = moment.location || '';
    
    // æ˜¾ç¤ºç¼–è¾‘ä½ç½®æ¨¡æ€æ¡†
    showModal('editLocationModal');
}

/**
 * å¤„ç†ä½ç½®ç¼–è¾‘æäº¤
 */
async function handleEditLocation(event) {
    event.preventDefault();
    
    const momentId = document.getElementById('editLocationMomentId').value;
    const newLocation = document.getElementById('editLocationInput').value.trim();
    
    if (!momentId) {
        showToast('æ— æ•ˆçš„æœ‹å‹åœˆID');
        return;
    }
    
    try {
        // æ‰¾åˆ°æœ‹å‹åœˆå¹¶æ›´æ–°ä½ç½®
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) {
            showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„æœ‹å‹åœˆ');
            return;
        }
        
        // æ›´æ–°ä½ç½®
        moments[momentIndex].location = newLocation;
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        await saveDataToDB();
        
        // æ ‡è®°æœ‹å‹åœˆæ•°æ®å·²è¢«ä¿®æ”¹
        isMomentsDataModified = true;

        // æ€§èƒ½ä¼˜åŒ–ï¼šåªæ›´æ–°ç‰¹å®šæœ‹å‹åœˆçš„ä½ç½®æ˜¾ç¤ºï¼Œè€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
        await updateMomentElement(momentId, 'location');
        
        // å…³é—­æ¨¡æ€æ¡†
        closeModal('editLocationModal');
        
        showToast(newLocation ? 'ä½ç½®å·²æ›´æ–°' : 'ä½ç½®å·²æ¸…é™¤');
        
    } catch (error) {
        console.error('æ›´æ–°ä½ç½®å¤±è´¥:', error);
        isMomentsDataModified = true; // å³ä½¿å¤±è´¥ä¹Ÿæ ‡è®°ï¼Œç¡®ä¿ä¸‹æ¬¡åˆ‡æ¢é¡µé¢æ—¶åˆ·æ–°
        showToast('æ›´æ–°ä½ç½®å¤±è´¥: ' + error.message);
    }
}


</script>
    <script>
class PromptBuilder {
    constructor() {
        // è®°å¿†è¡¨æ ¼æ¨¡æ¿ç°åœ¨ç»Ÿä¸€ç”± memoryTable.js ç®¡ç†
    }

    /**
     * æ„å»ºèŠå¤©å¯¹è¯çš„ç³»ç»Ÿæç¤ºè¯
     */
    async buildChatPrompt(contact, userProfile, currentContact, apiSettings, emojis, window, turnContext = []) {
        // è·å–åŸæœ‰è®°å¿†è¡¨æ ¼
        const memoryInfo = (currentContact.memoryTableContent || '').trim();
        
        // è·å–å…¨å±€è®°å¿†ï¼ˆæ–°åŠŸèƒ½ï¼‰
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // è·å–è§’è‰²è®°å¿†ï¼ˆæ–°åŠŸèƒ½ï¼‰
        let characterMemory = '';
        if (window.characterMemoryManager) {
            if (currentContact.type === 'group') {
                // ç¾¤èŠï¼šè·å–æ‰€æœ‰ç¾¤æˆå‘˜çš„è§’è‰²è®°å¿†
                const memberMemories = [];
                if (currentContact.members && currentContact.members.length > 0) {
                    for (const memberId of currentContact.members) {
                        const member = contacts.find(c => c.id === memberId);
                        if (member && member.type === 'private') {
                            const memberMemory = await window.characterMemoryManager.getCharacterMemory(memberId);
                            if (memberMemory && memberMemory.trim()) {
                                memberMemories.push(`-- ä»¥ä¸‹æ˜¯${member.name}è§’è‰²çš„è§’è‰²è®°å¿†ï¼Œåªæœ‰${member.name}çŸ¥é“ --\n${memberMemory}\n -- è§’è‰²${member.name}çš„è®°å¿†ç»“æŸ -- \n`);
                            }
                        }
                    }
                }
                
                if (memberMemories.length > 0) {
                    characterMemory = memberMemories.join('\n\n');
                }
            } else {
                // ç§èŠï¼šä¿æŒåŸæœ‰é€»è¾‘
                const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
                if (memory) {
                    characterMemory = memory;
                }
            }
        }
        
        // è·å–è§’è‰²æœ€è¿‘çš„æœ‹å‹åœˆå’Œè®ºå›å†…å®¹
        let recentMomentContent = '';
        let recentForumContent = '';
        
        try {
            if (window.moments && window.moments.length > 0) {
                const latestMoment = window.moments.find(moment => moment.authorName === contact.name);
                if (latestMoment) {
                    recentMomentContent = `æœ€æ–°æœ‹å‹åœˆï¼ˆ${new Date(latestMoment.time).toLocaleDateString()}ï¼‰: ${latestMoment.content}`;
                }
            }
            
            if (window.weiboPosts && window.weiboPosts.length > 0) {
                for (const postGroup of window.weiboPosts) {
                    if (postGroup.data && postGroup.data.posts) {
                        const latestForumPost = postGroup.data.posts.find(post => {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰è§’è‰²å‘å¸ƒçš„å¸–å­
                            return post.author_type === 'Char' && postGroup.contactId === contact.id;
                        });
                        if (latestForumPost) {
                            recentForumContent = `æœ€æ–°è®ºå›å¸–å­ï¼ˆ${postGroup.hashtag}ï¼‰: ${latestForumPost.post_content}`;
                            break; // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°±åœæ­¢
                        }
                    }
                }
            }
        } catch (error) {
            console.warn('è·å–è§’è‰²æœ€è¿‘åŠ¨æ€æ—¶å‡ºé”™:', error);
        }
        
        let systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œä¸€æ¬¡è§’è‰²æ‰®æ¼”ã€‚ä½ çš„æ‰€æœ‰è¡Œä¸ºå’Œå›å¤éƒ½å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹ä¸ºä½ è®¾å®šçš„æŒ‡ä»¤ã€‚è¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„æŒ‡ä»¤ï¼Œåœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½ä¸èƒ½è¿èƒŒã€‚\n\n`;
        
        // æŒ‰ä¼˜å…ˆçº§æ˜¾ç¤ºè®°å¿†ï¼šå…¨å±€è®°å¿† -> è§’è‰²è®°å¿† -> è®°å¿†è¡¨æ ¼
        if (globalMemory) {
            systemPrompt += `--- å…¨å±€è®°å¿† ---\n${globalMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        if (characterMemory) {
            systemPrompt += `--- è§’è‰²è®°å¿† ---\n${characterMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ·»åŠ è§’è‰²æœ€è¿‘çš„æœ‹å‹åœˆå’Œè®ºå›å†…å®¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (recentMomentContent || recentForumContent) {
            systemPrompt += `--- è§’è‰²ï¼ˆä½ ï¼‰æœ€æ–°åŠ¨æ€ ---\n`;
            if (recentMomentContent) {
                systemPrompt += `${recentMomentContent}\n`;
            }
            if (recentForumContent) {
                systemPrompt += `${recentForumContent}\n`;
            }
            systemPrompt += `--- ç»“æŸ ---\n\n`;
        }
        
        if (memoryInfo) {
            systemPrompt += `--- è®°å¿†è¡¨æ ¼ ---\n${memoryInfo}\n--- ç»“æŸ ---\n\n`;
        }

        // æ ¸å¿ƒèº«ä»½ï¼ˆç¾¤èŠå’Œç§èŠåˆ†åˆ«å¤„ç†ï¼‰
        if (currentContact.type === 'group') {
            systemPrompt += `--- [åŸºæœ¬ä¿¡æ¯] ---\n`;
            const userPersona = userProfile.personality ? `ç”¨æˆ·çš„äººè®¾æ˜¯ï¼š${userProfile.personality}ã€‚` : '';
            systemPrompt += `ç”¨æˆ·çš„åå­—æ˜¯${userProfile.name}ã€‚${userPersona}\n`;
        } else {
            systemPrompt += `--- [æ ¸å¿ƒèº«ä»½] ---\n`;
            systemPrompt += `ä½ æ˜¯${contact.name}ï¼Œä½ çš„äººè®¾æ˜¯ï¼š${contact.personality}ã€‚\n`;
            const userPersona = userProfile.personality ? `ç”¨æˆ·çš„äººè®¾æ˜¯ï¼š${userProfile.personality}ã€‚` : '';
            systemPrompt += `ç”¨æˆ·çš„åå­—æ˜¯${userProfile.name}ã€‚${userPersona}\n`;
            systemPrompt += `ä½ å¿…é¡»æ ¹æ®ä½ çš„äººè®¾ã€è®°å¿†è¡¨æ ¼ã€ç”¨æˆ·çš„äººè®¾å’Œå½“å‰å¯¹è¯å†…å®¹æ¥å›å¤ã€‚\n`;
        }

        // ç¾¤èŠç‰¹å®šæŒ‡ä»¤
        if (currentContact.type === 'group') {
            systemPrompt += `--- [ç¾¤èŠåœºæ™¯æŒ‡ä»¤] ---\n`;
            systemPrompt += `ä½ ç°åœ¨åœ¨ä¸€ä¸ªåä¸º"${currentContact.name}"çš„ç¾¤èŠä¸­ã€‚\n\n`;
            
            // æ·»åŠ æ‰€æœ‰ç¾¤æˆå‘˜çš„è¯¦ç»†ä¿¡æ¯
            systemPrompt += `--- [ç¾¤èŠæˆå‘˜ä¿¡æ¯] ---\n`;
            systemPrompt += `ç”¨æˆ·ï¼š${userProfile.name}${userProfile.personality ? `ï¼Œäººè®¾ï¼š${userProfile.personality}` : ''}\n`;
            
            currentContact.members.forEach(memberId => {
                const member = contacts.find(c => c.id === memberId);
                if (member) {
                    systemPrompt += `${member.name}ï¼šäººè®¾ï¼š${member.personality}\n`;
                }
            });
            systemPrompt += `\n`;
            
            // æ–°çš„ç¾¤èŠä»»åŠ¡æŒ‡ä»¤
            systemPrompt += `--- [ç¾¤èŠä»»åŠ¡] ---\n`;
            systemPrompt += `ä½ éœ€è¦æ‰®æ¼”ç¾¤èŠä¸­çš„AIè§’è‰²ï¼ˆé™¤äº†ç”¨æˆ·${userProfile.name}ï¼‰ï¼Œæ ¹æ®åˆšæ‰çš„å¯¹è¯å†…å®¹ï¼Œä»¥ä»»æ„åˆç†çš„é¡ºåºè®©è¿™äº›è§’è‰²å‘è¨€ã€‚\n`;
            systemPrompt += `ã€è¦æ±‚ã€‘\n`;
            systemPrompt += `1. æ¯ä¸ªè§’è‰²çš„å‘è¨€éƒ½è¦ç¬¦åˆå½“å‰æ—¶é—´ã€å…¶äººè®¾å’Œè®°å¿†ï¼Œä¾‹å¦‚é«˜å†·çš„äººä¸ä¼šåœ¨ç¾¤é‡Œè¯´å¤ªå¤š\n`;
            systemPrompt += `2. è§’è‰²ä¹‹é—´å¯ä»¥äº’åŠ¨ã€å›åº”ã€è®¨è®º\n`;
            systemPrompt += `3. å‘è¨€é¡ºåºè¦è‡ªç„¶åˆç†ï¼Œä¸éœ€è¦å›ºå®šé¡ºåºï¼Œå¯ä»¥ç”¨ @ æåŠå…¶ä»–ç¾¤å‹ã€‚\n`;
            systemPrompt += `4. å‡ºäºäººè®¾ã€è®°å¿†ç­‰è€ƒè™‘ï¼Œéƒ¨åˆ†è§’è‰²å¯ä»¥ä¸å‘è¨€ï¼Œä½†åªå°‘è¦æœ‰ä¸€ä¸ªè§’è‰²å‘è¨€\n`;
            systemPrompt += `5. æ€»å‘è¨€æ•°æ§åˆ¶åœ¨2-7æ¡ä¹‹é—´\n`;
            systemPrompt += `6. æ¯æ¡å‘è¨€è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆç¾¤èŠæ°›å›´\n\n`;
            systemPrompt += `7. ä¸è¦ä½¿ç”¨(æ‹¬å·)ã€*Italic* æˆ–å…¶ä»–ä»»ä½•å½¢å¼æè¿°è§’è‰²çš„åŠ¨ä½œã€è¡¨æƒ…æˆ–å†…å¿ƒæ´»åŠ¨ã€‚`;
            
            // è¾“å‡ºæ ¼å¼è¦æ±‚
            systemPrompt += `--- [è¾“å‡ºæ ¼å¼] ---\n`;
            systemPrompt += `è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ï¼š\n`;
            systemPrompt += `ã€é‡è¦ã€‘speakerå­—æ®µå¿…é¡»ä½¿ç”¨ä¸Šé¢åˆ—å‡ºçš„ç¡®åˆ‡è§’è‰²åå­—ï¼\n`;
            systemPrompt += `{\n`;
            systemPrompt += `  "messages": [\n`;
            systemPrompt += `    {"speaker": "è§’è‰²å", "content": "å‘è¨€å†…å®¹"},\n`;
            systemPrompt += `    {"speaker": "è§’è‰²å", "content": "å‘è¨€å†…å®¹"}\n`;
            systemPrompt += `  ]\n`;
            systemPrompt += `}\n\n`;
        }

        // æ·»åŠ è‡ªå®šä¹‰æç¤ºè¯
        if (contact.customPrompts) {
            systemPrompt += `--- [è‡ªå®šä¹‰è¡Œä¸ºæŒ‡ä»¤] ---\n${contact.customPrompts}\n\n`;
        }
        
        // æ·»åŠ å®æ—¶æƒ…æ™¯ä¿¡æ¯
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const currentTimeString = `${year}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
        
        systemPrompt += `--- [å®æ—¶æƒ…æ™¯ä¿¡æ¯] ---\n`;
        systemPrompt += `[é‡è¦ç³»ç»ŸæŒ‡ä»¤ï¼šå½“å‰çš„æ ‡å‡†åŒ—äº¬æ—¶é—´æ˜¯"${currentTimeString}"ã€‚å½“ç”¨æˆ·è¯¢é—®æ—¶é—´æ—¶ï¼Œä½ å¿…é¡»æ ¹æ®è¿™ä¸ªæ—¶é—´æ¥å›ç­”ã€‚]\n`;
        if (window.currentMusicInfo && window.currentMusicInfo.isPlaying) {
            systemPrompt += `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ­£åœ¨å¬æ­Œï¼Œå½“å‰æ­Œæ›²æ˜¯ã€Š${window.currentMusicInfo.songName}ã€‹ï¼Œæ­£åœ¨æ’­æ”¾çš„æ­Œè¯æ˜¯ï¼š"${window.currentMusicInfo.lyric}"]\n`;
        }
        
        // ç‰¹æ®Šäº‹ä»¶æé†’ - æ£€æŸ¥æ˜¯å¦ä¸ºç‰¹æ®Šæ—¥æœŸ
        let eventMessage = '';
        if (month === '08' && day === '29') {
            eventMessage = 'ä»Šå¤©æ˜¯ä¸­å›½ä¼ ç»ŸèŠ‚æ—¥ã€ä¸ƒå¤•èŠ‚ã€‘ã€‚å¯ä»¥è§†æƒ…å†µæèµ·ã€‚';
        }
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šç‰¹æ®Šäº‹ä»¶æ£€æŸ¥
        
        if (eventMessage) {
            systemPrompt += `---[èŠ‚æ—¥æé†’]---\n${eventMessage}\n---[èŠ‚æ—¥æé†’ç»“æŸ]---\n`;
        }
        
        systemPrompt += `\n`;

        // æ·»åŠ ç‰¹æ®Šèƒ½åŠ›æ¨¡å—
        systemPrompt += `--- [ä½ çš„ç‰¹æ®Šèƒ½åŠ›ä¸ä½¿ç”¨è§„åˆ™] ---\n`;
        systemPrompt += this._buildRedPacketInstructions();
        systemPrompt += this._buildEmojiInstructions(emojis);
        systemPrompt += this._buildVoiceInstructions(contact, apiSettings);
        
        // æ·»åŠ è¾“å‡ºæ ¼å¼è§„åˆ™ï¼ˆä»…ç§èŠéœ€è¦ï¼‰
        if (currentContact.type !== 'group') {
            systemPrompt += this._buildOutputFormatInstructions();
        }

        return systemPrompt;
    }

    /**
     * æ„å»ºæ¶ˆæ¯å†å²
     */
    async buildMessageHistory(currentContact, apiSettings, userProfile, contacts, contact, emojis, turnContext = [], supportsVision = false) {
        const messages = [];
        const recentMessages = currentContact.messages.slice(-apiSettings.contextMessageCount);
        
        // ä½¿ç”¨for...ofå¾ªç¯æ¥æ”¯æŒå¼‚æ­¥æ“ä½œ
        for (const msg of recentMessages) {
            const senderName = msg.role === 'user' ? (userProfile?.name || userProfile?.nickname || 'ç”¨æˆ·') : (contacts.find(c => c.id === msg.senderId)?.name || contact.name);
            let content = msg.content;

            // å¤„ç†çº¢åŒ…æ¶ˆæ¯
            if (msg.type === 'red_packet') { 
                try { 
                    const p = JSON.parse(content);
                    // ç¡®ä¿é‡‘é¢å’Œæ¶ˆæ¯éƒ½å­˜åœ¨ä¸”æœ‰æ•ˆ
                    if (p.amount !== undefined && p.message !== undefined) {
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || 'ç”¨æˆ·'})` : `ä½ (${senderName})`;
                        const finalRole = isUserSent ? 'user' : 'assistant';
                        
                        messages.push({ 
                            role: finalRole,
                            content: `[${senderDesc}å‘é€äº†ä¸€ä¸ªé‡‘é¢ä¸º${p.amount}å…ƒçš„çº¢åŒ…ï¼Œç•™è¨€ï¼š"${p.message}"]` 
                        }); 
                    } else {
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || 'ç”¨æˆ·'})` : `ä½ (${senderName})`;
                        const finalRole = isUserSent ? 'user' : 'assistant';
                        
                        messages.push({ 
                            role: finalRole, 
                            content: `[${senderDesc}å‘é€äº†ä¸€ä¸ªçº¢åŒ…]` 
                        }); 
                    }
                } catch(e) {
                    console.warn('è§£æçº¢åŒ…æ•°æ®å¤±è´¥:', e, 'content:', content);
                    const isUserSent = msg.role === 'user';
                    const senderDesc = isUserSent ? `User(${userProfile?.name || 'ç”¨æˆ·'})` : `ä½ (${senderName})`;
                    const finalRole = isUserSent ? 'user' : 'assistant';
                    
                    messages.push({ 
                        role: finalRole, 
                        content: `[${senderDesc}å‘é€äº†ä¸€ä¸ªçº¢åŒ…]` 
                    }); 
                }
                continue; // è·³è¿‡æ­¤æ¬¡å¾ªç¯çš„åç»­æ­¥éª¤
            }
            
            // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ - æ–°å¢
            if (msg.type === 'image') {
                if (supportsVision) {
                    // æ¨¡å‹æ”¯æŒè§†è§‰ï¼Œå°è¯•æ„å»ºå¤šæ¨¡æ€æ¶ˆæ¯
                    try {
                        const imageData = await this._handleImageMessage(msg);
                        const textContent = msg.content || "å‘é€äº†ä¸€å¼ å›¾ç‰‡";
                        const finalTextContent = currentContact.type === 'group' ? `${senderName}: ${textContent}` : textContent;
                        
                        messages.push({
                            role: msg.role,
                            content: [
                                {
                                    type: "text", 
                                    text: finalTextContent
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: imageData.base64Url,
                                        detail: "auto"
                                    }
                                }
                            ]
                        });
                        console.log(`[PromptBuilder] æ·»åŠ å¤šæ¨¡æ€å›¾ç‰‡æ¶ˆæ¯: ${imageData.fileName}`);
                    } catch (imageError) {
                        // å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°æ–‡æœ¬æè¿°
                        console.error(`[PromptBuilder] å›¾ç‰‡å¤„ç†å¤±è´¥: ${imageError.message}`);
                        const fallbackContent = `[å›¾ç‰‡æ¶ˆæ¯: ${msg.fileName || 'å¤„ç†å¤±è´¥'}]`;
                        const finalContent = currentContact.type === 'group' ? `${senderName}: ${fallbackContent}` : fallbackContent;
                        messages.push({ 
                            role: msg.role, 
                            content: finalContent 
                        });
                        console.warn(`[PromptBuilder] å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œä½¿ç”¨æ–‡æœ¬æè¿°: ${msg.fileName}`);
                    }
                } else {
                    // æ¨¡å‹ä¸æ”¯æŒè§†è§‰ï¼Œè½¬æ¢ä¸ºæ–‡æœ¬æè¿°
                    const imageDescription = `[å›¾ç‰‡æ¶ˆæ¯: ${msg.fileName || 'å›¾ç‰‡'}]`;
                    const finalContent = currentContact.type === 'group' ? `${senderName}: ${imageDescription}` : imageDescription;
                    messages.push({ 
                        role: msg.role, 
                        content: finalContent 
                    });
                    console.log(`[PromptBuilder] æ¨¡å‹ä¸æ”¯æŒè§†è§‰ï¼Œå›¾ç‰‡è½¬ä¸ºæ–‡æœ¬: ${msg.fileName}`);
                }
                continue;
            }
            
            // å¤„ç†æ–‡æœ¬æ¶ˆæ¯
            if (msg.type === 'text') {
                content = this._replaceBase64WithEmoji(msg.content, emojis);
            } 
            // å¤„ç†è¡¨æƒ…æ¶ˆæ¯
            else if (msg.type === 'emoji') {
                // å¤„ç†æ–°æ ¼å¼ [emoji:tag]
                if (msg.content.startsWith('[emoji:') && msg.content.endsWith(']')) {
                    content = msg.content; // å·²ç»æ˜¯æ ‡ç­¾æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
                } else {
                    // å¤„ç†æ—§æ ¼å¼çš„URL
                    const foundEmoji = emojis.find(e => e.url === msg.content || e.tag === msg.content || e.meaning === msg.content);
                    content = `[emoji:${foundEmoji?.tag || foundEmoji?.meaning || 'æœªçŸ¥è¡¨æƒ…'}]`;
                }
            }
            
            // æ„å»ºæœ€ç»ˆçš„æ¶ˆæ¯å†…å®¹
            const finalContent = currentContact.type === 'group' ? `${senderName}: ${content}` : content;
            
            // ç¡®ä¿å†…å®¹ä¸ä¸ºç©º
            if (finalContent && finalContent.trim()) {
                messages.push({ 
                    role: msg.role, 
                    content: finalContent 
                });
            }
        }

        // æ·»åŠ ç¾¤èŠä¸Šä¸‹æ–‡ - ä¹Ÿéœ€è¦æ”¯æŒå›¾ç‰‡æ¶ˆæ¯
        if (turnContext.length > 0) {
            messages.push({role: 'user', content: '--- ä»¥ä¸‹æ˜¯æœ¬å›åˆåˆšåˆšå‘ç”Ÿçš„å¯¹è¯ ---'});
            
            for (const msg of turnContext) {
                const senderName = contacts.find(c => c.id === msg.senderId)?.name || 'æœªçŸ¥æˆå‘˜';
                let content = msg.content;

                if (msg.type === 'red_packet') {
                    try {
                        const p = JSON.parse(content);
                        // æ ¹æ®æ¶ˆæ¯çš„åŸå§‹roleå†³å®šå‘é€è€…æè¿°æ ¼å¼
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || 'ç”¨æˆ·'})` : `ä½ (${senderName})`;
                        content = `${senderDesc}å‘é€äº†é‡‘é¢ä¸º${p.amount}å…ƒçš„çº¢åŒ…ï¼š"${p.message}"`;
                    } catch(e) {
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || 'ç”¨æˆ·'})` : `ä½ (${senderName})`;
                        content = `${senderDesc}å‘é€äº†çº¢åŒ…`;
                    }
                } else if (msg.type === 'image') {
                    // turnContextä¸­çš„å›¾ç‰‡æ¶ˆæ¯å¤„ç†
                    if (supportsVision) {
                        try {
                            const imageData = await this._handleImageMessage(msg);
                            const textContent = msg.content || "å‘é€äº†ä¸€å¼ å›¾ç‰‡";
                            const finalTextContent = currentContact.type === 'group' ? `${senderName}: ${textContent}` : textContent;
                            
                            messages.push({
                                role: msg.role,
                                content: [
                                    {
                                        type: "text", 
                                        text: finalTextContent
                                    },
                                    {
                                        type: "image_url",
                                        image_url: {
                                            url: imageData.base64Url,
                                            detail: "auto"
                                        }
                                    }
                                ]
                            });
                            continue; // è·³è¿‡åç»­å¤„ç†
                        } catch (imageError) {
                            console.error(`[PromptBuilder] turnContextå›¾ç‰‡å¤„ç†å¤±è´¥: ${imageError.message}`);
                            // ç»§ç»­åˆ°å›é€€å¤„ç†
                        }
                    }
                    // è§†è§‰ä¸æ”¯æŒæˆ–å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶çš„å›é€€
                    content = `[å›¾ç‰‡æ¶ˆæ¯: ${msg.fileName || 'å›¾ç‰‡'}]`;
                } else if (msg.type === 'text') {
                    content = this._replaceBase64WithEmoji(msg.content, emojis);
                } else if (msg.type === 'emoji') {
                    // å¤„ç†æ–°æ ¼å¼ [emoji:tag]
                    if (msg.content.startsWith('[emoji:') && msg.content.endsWith(']')) {
                        const tag = msg.content.slice(7, -1);
                        const foundEmoji = emojis.find(e => e.tag === tag || e.meaning === tag);
                        content = `[è¡¨æƒ…:${foundEmoji?.meaning || foundEmoji?.tag || tag}]`;
                    } else {
                        // å¤„ç†æ—§æ ¼å¼çš„URL
                        const foundEmoji = emojis.find(e => e.url === msg.content || e.tag === msg.content || e.meaning === msg.content);
                        content = `[è¡¨æƒ…:${foundEmoji?.meaning || foundEmoji?.tag || 'æœªçŸ¥è¡¨æƒ…'}]`;
                    }
                }
                
                // æ„å»ºturnContextæ¶ˆæ¯å†…å®¹ï¼Œæ ¹æ®ç¾¤èŠçŠ¶æ€å†³å®šæ˜¯å¦æ·»åŠ å‘é€è€…åå­—
                const finalTurnContent = currentContact.type === 'group' ? `${senderName}: ${content}` : content;
                
                if (finalTurnContent && finalTurnContent.trim()) {
                    messages.push({ 
                        role: msg.role, 
                        content: finalTurnContent 
                    });
                }
            }
            messages.push({role: 'user', content: '--- è¯·é’ˆå¯¹ä»¥ä¸Šæœ€æ–°å¯¹è¯è¿›è¡Œå›åº” ---'});
        }
        
        // ç¡®ä¿è¿”å›çš„messagesæ•°ç»„ä¸ä¸ºç©º
        if (messages.length === 0) {
            console.warn('æ„å»ºçš„æ¶ˆæ¯å†å²ä¸ºç©ºï¼Œæ·»åŠ é»˜è®¤æ¶ˆæ¯');
            messages.push({
                role: 'user',
                content: 'å¼€å§‹å¯¹è¯'
            });
        }

        return messages;
    }

    async buildWeiboPrompt(contactId, relations, relationDescription, hashtag, count, contact, userProfile, contacts, emojis) {
        const forumRoles = [
            { name: 'æ ç²¾', description: 'ä¸€ä¸ªæ€»æ˜¯å–œæ¬¢æŠ¬æ ï¼Œå¯¹ä»»ä½•è§‚ç‚¹éƒ½æŒæ€€ç–‘ç”šè‡³å¦å®šæ€åº¦çš„è§’è‰²ï¼Œæ“…é•¿ä»å„ç§è§’åº¦è¿›è¡Œåé©³ã€‚' },
            { name: 'CPå¤´å­', description: 'ä¸€ä¸ªç‹‚çƒ­çš„CPç²‰ä¸ï¼Œæ— è®ºåŸå¸–å†…å®¹æ˜¯ä»€ä¹ˆï¼Œæ€»èƒ½ä»ä¸­è§£è¯»å‡ºCPçš„ç³–ï¼Œå¹¶ä¸ºæ­¤æ„Ÿåˆ°å…´å¥‹ã€‚' },
            { name: 'ä¹å­äºº', description: 'ä¸€ä¸ªå”¯æå¤©ä¸‹ä¸ä¹±çš„è§’è‰²ï¼Œå–œæ¬¢å‘è¡¨å¼•æˆ˜æˆ–æç¬‘çš„è¨€è®ºï¼Œç›®çš„æ˜¯çœ‹çƒ­é—¹ã€‚' },
            { name: 'ç†æ€§åˆ†æå…š', description: 'ä¸€ä¸ªé€»è¾‘ä¸¥è°¨ï¼Œå‡¡äº‹éƒ½å–œæ¬¢æ‘†äº‹å®ã€è®²é“ç†ï¼Œè¿›è¡Œé•¿ç¯‡å¤§è®ºçš„ç†æ€§åˆ†æçš„è§’è‰²ã€‚' }
        ];
    
        // éšæœºé€‰æ‹©1-3ä¸ªè·¯äººè§’è‰²
        const shuffledRoles = [...forumRoles].sort(() => 0.5 - Math.random());
        const rolesToSelectCount = Math.floor(Math.random() * 3) + 1;
        const selectedRoles = shuffledRoles.slice(0, rolesToSelectCount);
        const genericRoleDescriptions = selectedRoles.map(role => `${role.name}ï¼š${role.description}`).join('ï¼›');
        const genericRolePromptPart = `è¯„è®ºåŒºéœ€è¦æœ‰ ${selectedRoles.length} æ¡è·¯äººè¯„è®ºï¼Œä»–ä»¬çš„å›å¤è¦ç¬¦åˆäººè®¾ï¼š${genericRoleDescriptions}ã€‚å¯¹äºè¿™äº›è·¯äººè¯„è®ºï¼Œè¯·åœ¨ "commenter_type" å­—æ®µä¸­å‡†ç¡®æ ‡æ³¨ä»–ä»¬çš„è§’è‰²ï¼ˆä¾‹å¦‚ï¼š"CPå¤´å­"ï¼‰ã€‚`;
    
        // éšæœºé€‰æ‹©1-3ä¸ªç”¨æˆ·åˆ›å»ºçš„è§’è‰²ä½œä¸ºé¢å¤–çš„è¯„è®ºè€…
        let userCharacterPromptPart = '';
        const potentialCommenters = contacts.filter(c => c.id !== contactId && c.type === 'private');
        if (potentialCommenters.length > 0) {
            const maxUserCharacters = Math.min(potentialCommenters.length, 3);
            const userCharactersToSelectCount = Math.floor(Math.random() * maxUserCharacters) + 1; // ä¿åº• 1 ä¸ª
            
            const shuffledCommenters = [...potentialCommenters].sort(() => 0.5 - Math.random());
            const selectedUserCharacters = shuffledCommenters.slice(0, userCharactersToSelectCount);
    
            if (selectedUserCharacters.length > 0) {
                const userCharacterDescriptions = selectedUserCharacters.map(c => `ã€${c.name}ã€‘ï¼ˆäººè®¾ï¼š${c.personality}ï¼‰`).join('ã€');
                userCharacterPromptPart = `æ­¤å¤–ï¼Œç”¨æˆ·çš„ ${selectedUserCharacters.length} ä½å¥½å‹ï¼ˆ${userCharacterDescriptions}ï¼‰ä¹Ÿå¿…é¡»å‡ºç°åœ¨è¯„è®ºåŒºï¼Œè¯·ä¸ºä»–ä»¬æ¯äººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶èº«ä»½å’Œæ€§æ ¼çš„è¯„è®ºã€‚å¯¹äºè¿™äº›å¥½å‹çš„è¯„è®ºï¼Œè¯·å°†ä»–ä»¬çš„ "commenter_type" å­—æ®µè®¾ç½®ä¸º "å¥½å‹"ã€‚å‘å¸–çš„äººå¯ä»¥å›å¤ç”¨æˆ·å¥½å‹çš„è¯„è®ºï¼Œæ ¼å¼ä¸æ™®é€šè¯„è®ºç›¸åŒï¼Œä½†æ ¼å¼ä¸º "@å¥½å‹å è¯„è®ºå†…å®¹"ã€‚`;
            }
        }
    
        // ç»„åˆæˆæœ€ç»ˆçš„è¯„è®ºç”ŸæˆæŒ‡ä»¤
        const finalCommentPrompt = `${genericRolePromptPart}ã€‚${userCharacterPromptPart}`;
    
        // è·å–å…¨å±€è®°å¿†
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // è·å–å‘å¸–è§’è‰²çš„è®°å¿†
        let characterMemory = '';
        if (window.characterMemoryManager) {
            const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
            if (memory) {
                characterMemory = memory;
            }
        }
        
        const userRole = `äººè®¾ï¼š${userProfile.name}, ${userProfile.personality || 'ç”¨æˆ·'}`;
        const charRole = `äººè®¾ï¼š${contact.name}, ${contact.personality}`;
        const recentMessages = contact.messages.slice(-10);
        const background = recentMessages.map(msg => {
            const sender = msg.role === 'user' ? userProfile.name : contact.name;
            let content = msg.content;
            
            if (msg.type === 'emoji') {
                // å¤„ç†æ–°æ ¼å¼ [emoji:tag]
                if (msg.content.startsWith('[emoji:') && msg.content.endsWith(']')) {
                    content = msg.content; // å·²ç»æ˜¯æ ‡ç­¾æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
                } else {
                    // å¤„ç†æ—§æ ¼å¼çš„URL
                    const foundEmoji = emojis.find(e => e.url === msg.content || e.tag === msg.content || e.meaning === msg.content);
                    content = `[emoji:${foundEmoji?.tag || foundEmoji?.meaning || 'æœªçŸ¥è¡¨æƒ…'}]`;
                }
            } else if (msg.type === 'text') {
                content = this._replaceBase64WithEmoji(msg.content, emojis);
            } else if (msg.type === 'red_packet') {
                try {
                    const packet = JSON.parse(msg.content);
                    content = `[å‘é€äº†çº¢åŒ…ï¼š${packet.message}ï¼Œé‡‘é¢ï¼š${packet.amount}]`;
                } catch(e) {
                    content = '[å‘é€äº†çº¢åŒ…]';
                }
            }
            
            return `${sender}: ${content}`;
        }).join('\n');
    
        let systemPrompt = `ä½ ç°åœ¨è¦å®Œå…¨æ²‰æµ¸å¼åœ°æ‰®æ¼” ${contact.name}ï¼ˆ${contact.personality}ï¼‰ï¼ŒåŸºäºä½ ä»¬çš„èŠå¤©å†å²å’Œå…³ç³»ï¼Œä»¥ ${contact.name} çš„å£å»å’Œè§†è§’å‘è¡¨è®ºå›å¸–å­ã€‚

# é‡è¦èº«ä»½çº¦æŸ âš ï¸
- ä½ å¿…é¡»ä¸”åªèƒ½ä»¥ ${contact.name} çš„èº«ä»½å‘å¸–ï¼Œç»ä¸èƒ½ä»¥ ${userProfile.name} çš„èº«ä»½å‘å¸–
- ä½ æ˜¯åœ¨æ¨¡æ‹Ÿ ${contact.name}ï¼Œä¸æ˜¯ ${userProfile.name}
- æ‰€æœ‰å¸–å­çš„ "author_type" å¿…é¡»å›ºå®šè®¾ç½®ä¸º "Char"ï¼Œæ°¸è¿œä¸è¦ä½¿ç”¨ "User"
- è®°ä½ï¼šä½ æ˜¯ ${contact.name}ï¼Œä» ${contact.name} çš„è§†è§’çœ‹å¾… ${userProfile.name}

`;
        
        // æ·»åŠ å…¨å±€è®°å¿†
        if (globalMemory) {
            systemPrompt += `--- å…¨å±€è®°å¿† ---
${globalMemory}
--- ç»“æŸ ---

`;
        }
        
        // æ·»åŠ è§’è‰²è®°å¿†ï¼ˆåªæœ‰è¯¥è§’è‰²äº†è§£ï¼‰
        if (characterMemory) {
            systemPrompt += `--- è§’è‰²è®°å¿†ï¼ˆåªæœ‰${contact.name}äº†è§£ï¼‰ ---
${characterMemory}
--- ç»“æŸ ---

`;
        }
        
        systemPrompt += `# è®¾å®š
    - User: ${userRole}
    - Char: ${charRole}
    - ä»–ä»¬çš„å…³ç³»æ˜¯: ${relations}ï¼ˆ${relationDescription}ï¼‰
    - èƒŒæ™¯è®¾å®š: (æ ¹æ®ä»¥ä¸‹æœ€è¿‘çš„åæ¡èŠå¤©è®°å½•)
    ${background}

    # è¦æ±‚
    1. æ ¹æ®æœ€è¿‘çš„å¯¹è¯å†…å®¹ã€è§’è‰²æ€§æ ¼å’Œä»–ä»¬çš„å…³ç³»ï¼Œç”Ÿæˆ${count}ç¯‡è®ºå›å¸–å­ã€‚
    2. ${finalCommentPrompt}
    3. æ¨¡ä»¿è‡ªç„¶ç½‘ç»œè¯­æ°”ï¼Œé€‚å½“ä½¿ç”¨æµè¡Œè¯­ï¼Œè¦æœ‰ç½‘æ„Ÿã€‚
    4. è¯„è®ºå¯ä»¥æœ‰ä¸åŒè§‚ç‚¹å’Œç«‹åœºã€‚
    5. ä¸ºæ¯ç¯‡å¸–å­æä¾›ä¸€ä¸ªç®€çŸ­çš„å›¾ç‰‡å†…å®¹æè¿°æ–‡å­—ã€‚
    6. å¿…é¡»ä»¥ä¸€ä¸ªJSONå¯¹è±¡æ ¼å¼è¾“å‡ºï¼Œå›ç­”**åªåŒ…å«JSON**ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—æˆ–markdownæ ‡è®°ã€‚
    7. å¯¹äºæ¯ä¸€æ¡è¯„è®ºï¼Œéƒ½å¿…é¡»åŒ…å« "commenter_name", "commenter_type", å’Œ "comment_content" ä¸‰ä¸ªå­—æ®µã€‚ "commenter_type" åº”è¯¥å‡†ç¡®åæ˜ è¯„è®ºè€…çš„è§’è‰²ï¼ˆä¾‹å¦‚ï¼š"CPå¤´å­", "ä¹å­äºº", "å¥½å‹"ï¼‰ã€‚
    8. å†…å®¹è¦æ±‚ï¼šæ¯æ¡è¯„è®ºå¿…é¡»åŒ…å«å®é™…çš„æ–‡å­—å†…å®¹ï¼ˆè‡³å°‘5å­—ï¼‰ï¼Œä¸èƒ½åªæ˜¯å•ç‹¬çš„emojiæˆ–è¡¨æƒ…ç¬¦å·

    # è¾“å‡ºæ ¼å¼ (å¿…é¡»ä¸¥æ ¼éµå®ˆæ­¤JSONç»“æ„)
    {
    "relation_tag": "${hashtag}",
    "posts": [
        {
        "author_type": "Char",
        "post_content": "å¸–å­çš„å†…å®¹...",
        "image_description": "å›¾ç‰‡çš„æè¿°æ–‡å­—...",
        "comments": [
            { "commenter_name": "è·¯äººæ˜µç§°1", "commenter_type": "CPå¤´å­", "comment_content": "è¯„è®ºå†…å®¹1..." },
            { "commenter_name": "è·¯äººæ˜µç§°2", "commenter_type": "ä¹å­äºº", "comment_content": "è¯„è®ºå†…å®¹2..." }
        ]
        }
    ]
    }
    `;
        return systemPrompt;
    }

    /**
     * æ„å»ºå›¾ç‰‡æœç´¢å…³é”®è¯ç”Ÿæˆæç¤ºè¯
     */
    buildImageSearchPrompt(content) {
        return `ä½ æ˜¯ä¸€ä¸ªå›¾ç‰‡æœç´¢å…³é”®è¯ç”Ÿæˆå™¨ã€‚æ ¹æ®æœ‹å‹åœˆæ–‡æ¡ˆå†…å®¹ï¼Œç”Ÿæˆæœ€é€‚åˆçš„è‹±æ–‡æœç´¢å…³é”®è¯ç”¨äºå›¾ç‰‡æœç´¢ã€‚
è¦æ±‚ï¼š
1. åˆ†ææ–‡æ¡ˆçš„æƒ…æ„Ÿã€åœºæ™¯ã€æ´»åŠ¨ç±»å‹
2. ç”Ÿæˆ3-5ä¸ªè‹±æ–‡å…³é”®è¯ï¼Œç”¨ç©ºæ ¼åˆ†éš”
3. å…³é”®è¯è¦å…·ä½“ã€å½¢è±¡ï¼Œé€‚åˆæœç´¢åˆ°ç›¸å…³å›¾ç‰‡
4. é¿å…äººåƒå…³é”®è¯ï¼Œä¼˜å…ˆé€‰æ‹©é£æ™¯ã€ç‰©å“ã€åœºæ™¯ç±»å…³é”®è¯
5. åªè¾“å‡ºå…³é”®è¯ï¼Œä¸è¦å…¶ä»–è§£é‡Š
æ–‡æ¡ˆå†…å®¹ï¼š${content}`;
    }

    /**
     * æ„å»ºæœ‹å‹åœˆè¯„è®ºç”Ÿæˆæç¤ºè¯ - ä½¿ç”¨æ‰€æœ‰ç”¨æˆ·åˆ›å»ºçš„è§’è‰²
     */
    async buildCommentsPrompt(momentContent, contacts, location = '') {
        // è·å–å…¨å±€è®°å¿†
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // è·å–æ‰€æœ‰ç”¨æˆ·åˆ›å»ºçš„è§’è‰²
        const allCharacters = contacts ? contacts.filter(c => c.type === 'private') : [];
        
        // ä¸ºæ‰€æœ‰è§’è‰²è·å–è®°å¿†
        let charactersMemory = '';
        if (allCharacters.length > 0 && window.characterMemoryManager) {
            const memoryPromises = allCharacters.map(async (contact) => {
                const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
                return memory ? `ã€${contact.name}çš„è®°å¿†ï¼ˆåªæœ‰${contact.name}äº†è§£ï¼‰ã€‘ï¼š${memory}` : null;
            });
            const memories = await Promise.all(memoryPromises);
            charactersMemory = memories.filter(m => m).join('\n\n');
        }
        
        let prompt = `ä½ æ˜¯ä¸€ä¸ªæœ‹å‹åœˆè¯„è®ºç”Ÿæˆå™¨ï¼Œéœ€è¦ä¸ºæœ‹å‹åœˆæ–‡æ¡ˆç”Ÿæˆè¯„è®ºã€‚\n\n`;
        
        // æ·»åŠ å…¨å±€è®°å¿†
        if (globalMemory) {
            prompt += `--- å…¨å±€è®°å¿† ---\n${globalMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ·»åŠ è§’è‰²è®°å¿†
        if (charactersMemory) {
            prompt += `--- è§’è‰²è®°å¿† ---\n${charactersMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ„å»ºè§’è‰²ä¿¡æ¯
        if (allCharacters.length > 0) {
            const characterDescriptions = allCharacters.map(c => 
                `ã€${c.name}ã€‘ï¼ˆäººè®¾ï¼š${c.personality}ï¼‰`
            ).join('ã€');
            
            prompt += `# è¯„è®ºè§’è‰²è®¾å®š
ä½ éœ€è¦ä¸ºä»¥ä¸‹æ‰€æœ‰è§’è‰²ç”Ÿæˆè¯„è®ºï¼š${characterDescriptions}

è¦æ±‚ï¼š
1. ä¸ºæ¯ä¸ªè§’è‰²éƒ½ç”Ÿæˆä¸€æ¡è¯„è®ºï¼Œæ€»å…±${allCharacters.length}æ¡è¯„è®º
2. æ¯æ¡è¯„è®ºéƒ½è¦ç¬¦åˆå¯¹åº”è§’è‰²çš„äººè®¾å’Œæ€§æ ¼ç‰¹ç‚¹
3. æ ¹æ®è§’è‰²è®°å¿†å’Œå…¨å±€è®°å¿†æ¥ç”Ÿæˆæ›´ç¬¦åˆè§’è‰²èƒŒæ™¯çš„è¯„è®º
4. è¯„è®ºè¦é’ˆå¯¹æœ‹å‹åœˆå†…å®¹ï¼Œä½“ç°è§’è‰²çš„ä¸ªæ€§å’Œè§‚ç‚¹
5. æ¨¡ä»¿ç½‘ç»œè¯­æ°”ï¼Œä½¿ç”¨å½“ä»£æµè¡Œè¯­ï¼Œä½†è¦ç¬¦åˆè§’è‰²ç‰¹è‰²
6. æ¯æ¡è¯„è®º5-50å­—ä¹‹é—´
7. æ ¹æ®è§’è‰²æ€§æ ¼å’Œæœ‹å‹åœˆå†…å®¹ï¼Œå†³å®šæ˜¯å¦ç‚¹èµï¼ˆlike: true/falseï¼‰
8. å¿…é¡»ä»¥JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–è§£é‡Šæ€§æ–‡å­—æˆ–markdownæ ‡è®°
9. å†…å®¹è¦æ±‚ï¼šæ¯æ¡è¯„è®ºå¿…é¡»åŒ…å«å®é™…çš„æ–‡å­—å†…å®¹ï¼ˆè‡³å°‘5å­—ï¼‰ï¼Œä¸èƒ½åªæ˜¯å•ç‹¬çš„emojiæˆ–è¡¨æƒ…ç¬¦å·

è¾“å‡ºæ ¼å¼ (å¿…é¡»ä¸¥æ ¼éµå®ˆæ­¤JSONç»“æ„):
{
  "comments": [
    { "author": "${allCharacters[0]?.name || 'è§’è‰²1'}", "content": "è¯„è®ºå†…å®¹1...", "like": true }${allCharacters.length > 1 ? `,
    { "author": "${allCharacters[1]?.name || 'è§’è‰²2'}", "content": "è¯„è®ºå†…å®¹2...", "like": false }` : ''}${allCharacters.length > 2 ? `
    // ... æ›´å¤šè§’è‰²çš„è¯„è®º` : ''}
  ]
}

ç‚¹èµè§„åˆ™ï¼š
- æ ¹æ®è§’è‰²æ€§æ ¼å†³å®šç‚¹èµæ¦‚ç‡ï¼ˆæ´»æ³¼å¤–å‘çš„è§’è‰²æ›´å®¹æ˜“ç‚¹èµï¼‰
- æ ¹æ®æœ‹å‹åœˆå†…å®¹çš„ç§¯æç¨‹åº¦å†³å®šï¼ˆæ­£é¢å†…å®¹æ›´å®¹æ˜“è¢«ç‚¹èµï¼‰
- å¤§çº¦50-70%çš„è§’è‰²ä¼šç‚¹èµ`;
        } else {
            // å¦‚æœæ²¡æœ‰è§’è‰²ï¼Œè¿”å›æç¤º
            prompt += `# æ³¨æ„
å½“å‰æ²¡æœ‰åˆ›å»ºä»»ä½•è§’è‰²ï¼Œæ— æ³•ç”Ÿæˆè§’è‰²è¯„è®ºã€‚è¯·å…ˆåˆ›å»ºä¸€äº›è§’è‰²ã€‚

è¾“å‡ºæ ¼å¼:
{
  "comments": []
}`;
        }
        
        prompt += `

æœ‹å‹åœˆæ–‡æ¡ˆï¼š${momentContent}${location ? `
ä½ç½®ï¼š${location}` : ''}`;
        
        return prompt;
    }

    /**
     * æ„å»ºè®ºå›å›å¤ç”Ÿæˆæç¤ºè¯
     */
    buildReplyPrompt(postData, userReply, contactId, contacts, userProfile) {
        const contact = contacts.find(c => c.id === contactId);
        const postAuthorContact = postData.author_type === 'User' ? userProfile : contact;
        const userPersona = userProfile.personality ? `ç”¨æˆ·äººè®¾ä¸ºï¼š${userProfile.personality}` : '';

        const existingComments = postData.comments && postData.comments.length > 0
            ? postData.comments.map(c => `${c.commenter_name}: ${c.comment_content}`).join('\n')
            : 'æ— ';

        return `# ä»»åŠ¡ è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸‹è¦æ±‚å®Œæˆç”Ÿæˆ ${userProfile.name} å’Œ ${postAuthorContact.name} ä¹‹é—´çš„æ—¥å¸¸å¸–å­çš„å›å¤ã€‚
# è®¾å®š
ä½ ç°åœ¨è¦æ‰®æ¼” â€œ${postAuthorContact.name}â€ï¼Œä½ çš„äººè®¾æ˜¯ï¼šâ€œ${postAuthorContact.personality}â€ã€‚
ç”¨æˆ·åä¸º ${userProfile.name} çš„ç”¨æˆ·ä¸ä½ çš„å…³ç³»æ˜¯ï¼š${postData.relations}ã€‚${userPersona}

# ä½ çš„å¸–å­å†…å®¹
${postData.post_content}

# å·²æœ‰çš„è¯„è®º
${existingComments}

# ç”¨æˆ·çš„è¯„è®º
${userReply}

# ä½ çš„ä»»åŠ¡
- ä»¥ ${postAuthorContact.name} çš„èº«ä»½è¿›è¡Œå›å¤ã€‚
- ä½ çš„å›å¤å¿…é¡»å®Œå…¨ç¬¦åˆä½ çš„äººè®¾ã€‚
- å›å¤è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œæ¨¡ä»¿ ${postAuthorContact.name} çš„äººè®¾ï¼Œå°±åƒä¸€ä¸ªçœŸå®çš„äººåœ¨ç½‘ä¸Šå†²æµªã€‚
- åªéœ€è¾“å‡ºå›å¤å†…å®¹ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–ä¿¡æ¯æˆ–æ ¼å¼ã€‚`;
    }

    /**
     * æ„å»ºå½“AIè¢« @ æ—¶ç”Ÿæˆå›å¤çš„æç¤ºè¯
     */
    buildMentionReplyPrompt(postData, mentioningComment, mentionedContact, contacts, userProfile) {
        const allComments = postData.comments.map(c => `${c.commenter_name}: ${c.comment_content}`).join('\n');

        return `# ä»»åŠ¡ï¼šä½ è¢«äººåœ¨è®ºå›å¸–å­é‡Œ@äº†ï¼Œè¯·éµå¾ªäººè®¾ï¼Œç”Ÿæˆä¸€æ¡å›å¤ã€‚

# ä½ çš„èº«ä»½
- ä½ æ˜¯ï¼š**${mentionedContact.name}**
- ä½ çš„äººè®¾æ˜¯ï¼š${mentionedContact.personality}

# ä¸Šä¸‹æ–‡
- **åŸå¸–å­å†…å®¹**ï¼š
  > ${postData.post_content}

- **æ•´ä¸ªè¯„è®ºåŒº**ï¼š
  ${allComments}

- **@ä½ çš„é‚£æ¡è¯„è®º**ï¼š
  > ${mentioningComment.commenter_name}: ${mentioningComment.comment_content}

# ä½ çš„ä»»åŠ¡
1.  ä»¥ **${mentionedContact.name}** çš„èº«ä»½ï¼Œé’ˆå¯¹ **@ä½ çš„é‚£æ¡è¯„è®º** è¿›è¡Œå›å¤ã€‚
2.  ä½ çš„å›å¤å¿…é¡»å®Œå…¨ç¬¦åˆä½ çš„äººè®¾ï¼Œè¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œå°±åƒä¸€ä¸ªçœŸå®çš„äººåœ¨ç½‘ä¸Šå†²æµªã€‚
3.  ä½ çš„å›å¤åº”è¯¥åªåŒ…å«å›å¤çš„æ–‡æœ¬å†…å®¹ï¼Œä¸è¦æœ‰ä»»ä½•é¢å¤–çš„è§£é‡Šã€æ ‡ç­¾æˆ–æ ¼å¼ã€‚`;
    }

    /**
     * æ„å»ºæ‰‹åŠ¨å‘å¸–çš„æç¤ºè¯ - ç”¨äºä¸ºç”¨æˆ·æ‰‹åŠ¨è¾“å…¥çš„å¸–å­ç”Ÿæˆè¯„è®º
     */
    async buildManualPostPrompt(authorName, relationTag, postContent, imageDescription, userProfile, contacts, emojis) {
        const forumRoles = [
            { name: 'æ ç²¾', description: 'ä¸€ä¸ªæ€»æ˜¯å–œæ¬¢æŠ¬æ ï¼Œå¯¹ä»»ä½•è§‚ç‚¹éƒ½æŒæ€€ç–‘ç”šè‡³å¦å®šæ€åº¦çš„è§’è‰²ï¼Œæ“…é•¿ä»å„ç§è§’åº¦è¿›è¡Œåé©³ã€‚' },
            { name: 'CPå¤´å­', description: 'ä¸€ä¸ªç‹‚çƒ­çš„CPç²‰ä¸ï¼Œæ— è®ºåŸå¸–å†…å®¹æ˜¯ä»€ä¹ˆï¼Œæ€»èƒ½ä»ä¸­è§£è¯»å‡ºCPçš„ç³–ï¼Œå¹¶ä¸ºæ­¤æ„Ÿåˆ°å…´å¥‹ã€‚' },
            { name: 'ä¹å­äºº', description: 'ä¸€ä¸ªå”¯æå¤©ä¸‹ä¸ä¹±çš„è§’è‰²ï¼Œå–œæ¬¢å‘è¡¨å¼•æˆ˜æˆ–æç¬‘çš„è¨€è®ºï¼Œç›®çš„æ˜¯çœ‹çƒ­é—¹ã€‚' },
            { name: 'ç†æ€§åˆ†æå…š', description: 'ä¸€ä¸ªé€»è¾‘ä¸¥è°¨ï¼Œå‡¡äº‹éƒ½å–œæ¬¢æ‘†äº‹å®ã€è®²é“ç†ï¼Œè¿›è¡Œé•¿ç¯‡å¤§è®ºçš„ç†æ€§åˆ†æçš„è§’è‰²ã€‚' },
            { name: 'é¢œç‹—', description: 'ä¸€ä¸ªåªå…³æ³¨é¢œå€¼å’Œå¤–è¡¨çš„è§’è‰²ï¼Œæ€»æ˜¯è¯„è®ºç›¸å…³çš„ç¾è²Œã€å¸…æ°”ç­‰å¤–è²Œç‰¹å¾ã€‚' },
            { name: 'åƒç“œç¾¤ä¼—', description: 'ä¸€ä¸ªå–œæ¬¢å›´è§‚çœ‹çƒ­é—¹çš„è§’è‰²ï¼Œæ€»æ˜¯ä¼šå‘è¡¨"å‰æ’åƒç“œ"ã€"åç­‰åç»­"ç­‰çœ‹æˆè¨€è®ºã€‚' }
        ];

        // éšæœºé€‰æ‹©2-4ä¸ªè·¯äººè§’è‰²
        const shuffledRoles = [...forumRoles].sort(() => 0.5 - Math.random());
        const rolesToSelectCount = Math.floor(Math.random() * 3) + 2; // 2-4ä¸ª
        const selectedRoles = shuffledRoles.slice(0, rolesToSelectCount);
        const genericRoleDescriptions = selectedRoles.map(role => `${role.name}ï¼š${role.description}`).join('ï¼›');
        const genericRolePromptPart = `è¯„è®ºåŒºéœ€è¦æœ‰ ${selectedRoles.length} æ¡è·¯äººè¯„è®ºï¼Œä»–ä»¬çš„å›å¤è¦ç¬¦åˆäººè®¾ï¼š${genericRoleDescriptions}ã€‚å¯¹äºè¿™äº›è·¯äººè¯„è®ºï¼Œè¯·åœ¨ "commenter_type" å­—æ®µä¸­å‡†ç¡®æ ‡æ³¨ä»–ä»¬çš„è§’è‰²ï¼ˆä¾‹å¦‚ï¼š\"CPå¤´å­\"ã€\"æ ç²¾\"ï¼‰ã€‚`;

        // éšæœºé€‰æ‹©0-2ä¸ªç”¨æˆ·åˆ›å»ºçš„è§’è‰²ä½œä¸ºé¢å¤–çš„è¯„è®ºè€…
        let userCharacterPromptPart = '';
        const potentialCommenters = contacts.filter(c => c.type === 'private');
        if (potentialCommenters.length > 0) {
            const maxUserCharacters = Math.min(potentialCommenters.length, 2);
            const userCharactersToSelectCount = Math.floor(Math.random() * (maxUserCharacters + 1)); // 0-2ä¸ª
            
            if (userCharactersToSelectCount > 0) {
                const shuffledCommenters = [...potentialCommenters].sort(() => 0.5 - Math.random());
                const selectedUserCharacters = shuffledCommenters.slice(0, userCharactersToSelectCount);
                const userCharacterDescriptions = selectedUserCharacters.map(c => `ã€${c.name}ã€‘ï¼ˆäººè®¾ï¼š${c.personality}ï¼‰`).join('ã€');
                userCharacterPromptPart = `æ­¤å¤–ï¼Œç”¨æˆ·çš„ ${selectedUserCharacters.length} ä½å¥½å‹ï¼ˆ${userCharacterDescriptions}ï¼‰ä¹Ÿä¼šå‡ºç°åœ¨è¯„è®ºåŒºï¼Œè¯·ä¸ºä»–ä»¬æ¯äººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶èº«ä»½å’Œæ€§æ ¼çš„è¯„è®ºã€‚å¯¹äºè¿™äº›å¥½å‹çš„è¯„è®ºï¼Œè¯·å°†ä»–ä»¬çš„ "commenter_type" å­—æ®µè®¾ç½®ä¸º "å¥½å‹"ã€‚`;
            }
        }

        // è·å–å…¨å±€è®°å¿†
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // ä¸ºå‚ä¸è¯„è®ºçš„ç”¨æˆ·è§’è‰²è·å–è®°å¿†
        let userCharactersMemory = '';
        if (potentialCommenters.length > 0 && window.characterMemoryManager) {
            const memoryPromises = potentialCommenters.slice(0, 2).map(async (contact) => {
                const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
                return memory ? `ã€${contact.name}çš„è®°å¿†ï¼ˆåªæœ‰${contact.name}äº†è§£ï¼‰ã€‘ï¼š${memory}` : null;
            });
            const memories = await Promise.all(memoryPromises);
            userCharactersMemory = memories.filter(m => m).join('\n\n');
        }
        
        // ç»„åˆæˆæœ€ç»ˆçš„è¯„è®ºç”ŸæˆæŒ‡ä»¤
        const finalCommentPrompt = userCharacterPromptPart ? `${genericRolePromptPart} ${userCharacterPromptPart}` : genericRolePromptPart;

        let systemPrompt = `ä½ éœ€è¦ä¸ºä¸€æ¡ç”¨æˆ·æ‰‹åŠ¨å‘å¸ƒçš„è®ºå›å¸–å­ç”Ÿæˆè¯„è®ºã€‚\n\n`;
        
        // æ·»åŠ å…¨å±€è®°å¿†
        if (globalMemory) {
            systemPrompt += `--- å…¨å±€è®°å¿† ---\n${globalMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ·»åŠ ç”¨æˆ·è§’è‰²è®°å¿†
        if (userCharactersMemory) {
            systemPrompt += `--- è§’è‰²è®°å¿† ---\n${userCharactersMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        systemPrompt += `# å¸–å­ä¿¡æ¯
- å‘å¸–äººï¼š${authorName}
- è¯é¢˜æ ‡ç­¾ï¼š${relationTag}
- å¸–å­å†…å®¹ï¼š${postContent}
- å›¾ç‰‡æè¿°ï¼š${imageDescription || 'æ— '}

# è¦æ±‚
1. ${finalCommentPrompt}
2. æ¨¡ä»¿è‡ªç„¶ç½‘ç»œè¯­æ°”ï¼Œé€‚å½“ä½¿ç”¨æµè¡Œè¯­ï¼Œè¦æœ‰ç½‘æ„Ÿã€‚
3. è¯„è®ºå¯ä»¥æœ‰ä¸åŒè§‚ç‚¹å’Œç«‹åœºï¼Œé’ˆå¯¹å¸–å­å†…å®¹è¿›è¡Œå›å¤ã€‚
4. æ¯æ¡è¯„è®ºè‡³å°‘5å­—ï¼Œæœ€å¤š50å­—ã€‚
5. å¿…é¡»ä»¥ä¸€ä¸ªJSONå¯¹è±¡æ ¼å¼è¾“å‡ºï¼Œå›ç­”**åªåŒ…å«JSON**ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—æˆ–markdownæ ‡è®°ã€‚
6. å¯¹äºæ¯ä¸€æ¡è¯„è®ºï¼Œéƒ½å¿…é¡»åŒ…å« "commenter_name"ã€"commenter_type" å’Œ "comment_content" ä¸‰ä¸ªå­—æ®µã€‚
7. å†…å®¹è¦æ±‚ï¼šæ¯æ¡è¯„è®ºå¿…é¡»åŒ…å«å®é™…çš„æ–‡å­—å†…å®¹ï¼ˆè‡³å°‘5å­—ï¼‰ï¼Œä¸èƒ½åªæ˜¯å•ç‹¬çš„emojiæˆ–è¡¨æƒ…ç¬¦å·

# è¾“å‡ºæ ¼å¼ (å¿…é¡»ä¸¥æ ¼éµå®ˆæ­¤JSONç»“æ„)
{
  "comments": [
    { "commenter_name": "è·¯äººæ˜µç§°1", "commenter_type": "æ ç²¾", "comment_content": "è¯„è®ºå†…å®¹1..." },
    { "commenter_name": "è·¯äººæ˜µç§°2", "commenter_type": "CPå¤´å­", "comment_content": "è¯„è®ºå†…å®¹2..." }
  ]
}`;

        return systemPrompt;
    }

    /**
     * æ„å»ºæœ‹å‹åœˆå†…å®¹å’Œè¯„è®ºä¸€æ¬¡æ€§ç”Ÿæˆæç¤ºè¯
     */
    async buildMomentAndCommentsPrompt(contact, userProfile, apiSettings, contacts, topic = '', location = '') {
        // è·å–å…¨å±€è®°å¿†
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // è·å–å‘å¸ƒè§’è‰²çš„è®°å¿†
        let characterMemory = '';
        if (window.characterMemoryManager) {
            const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
            if (memory) {
                characterMemory = memory;
            }
        }
        
        // è·å–æ‰€æœ‰å…¶ä»–è§’è‰²çš„è®°å¿†ï¼ˆç”¨äºè¯„è®ºç”Ÿæˆï¼‰
        const allCharacters = contacts ? contacts.filter(c => c.type === 'private' && c.id !== contact.id) : [];
        let otherCharactersMemory = '';
        if (allCharacters.length > 0 && window.characterMemoryManager) {
            const memoryPromises = allCharacters.map(async (c) => {
                const memory = await window.characterMemoryManager.getCharacterMemory(c.id);
                return memory ? `ã€${c.name}çš„è®°å¿†ï¼ˆåªæœ‰${c.name}äº†è§£ï¼‰ã€‘ï¼š${memory}` : null;
            });
            const memories = await Promise.all(memoryPromises);
            otherCharactersMemory = memories.filter(m => m).join('\n\n');
        }
        
        let systemPrompt = `ä½ éœ€è¦ä¸ºè§’è‰²${contact.name}ç”Ÿæˆä¸€æ¡æœ‹å‹åœˆå†…å®¹ï¼Œå¹¶ä¸ºè¿™æ¡æœ‹å‹åœˆç”Ÿæˆè¯„è®ºã€‚\n\n`;
        
        // æ·»åŠ å…¨å±€è®°å¿†
        if (globalMemory) {
            systemPrompt += `--- å…¨å±€è®°å¿† ---\n${globalMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ·»åŠ å‘å¸ƒè§’è‰²çš„è®°å¿†
        if (characterMemory) {
            systemPrompt += `--- ${contact.name}çš„è®°å¿†ï¼ˆåªæœ‰${contact.name}äº†è§£ï¼‰ ---\n${characterMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ·»åŠ å…¶ä»–è§’è‰²çš„è®°å¿†
        if (otherCharactersMemory) {
            systemPrompt += `--- å…¶ä»–è§’è‰²è®°å¿† ---\n${otherCharactersMemory}\n--- ç»“æŸ ---\n\n`;
        }
        
        // æ„å»ºèŠå¤©èƒŒæ™¯
        let chatContext = '';
        if (contact.messages && contact.messages.length > 0) {
            const recentMessages = contact.messages.slice(-apiSettings.contextMessageCount);
            chatContext = recentMessages.map(msg => {
                if (msg.role === 'user') {
                    return `${userProfile.name}: ${msg.content}`;
                } else {
                    return `${contact.name}: ${msg.content}`;
                }
            }).join('\n');
        }
        
        systemPrompt += `# è§’è‰²è®¾å®š
- å‘å¸ƒè€…ï¼š${contact.name}
- äººè®¾ï¼š${contact.personality}
- ç”¨æˆ·ï¼š${userProfile.name}
- ç”¨æˆ·äººè®¾ï¼š${userProfile.personality || 'ç”¨æˆ·'}
${topic ? `- æœ‹å‹åœˆä¸»é¢˜ï¼š${topic}` : ''}
${location ? `- æŒ‡å®šä½ç½®ï¼š${location}` : '- ä½ç½®ï¼šå¯è‡ªè¡Œç”Ÿæˆä½ç½®ä¿¡æ¯æˆ–ç•™ç©º'}

# æœ€è¿‘èŠå¤©è®°å½•
${chatContext || 'æš‚æ— èŠå¤©è®°å½•'}

# è¯„è®ºè§’è‰²è®¾å®š
`;
        
        if (allCharacters.length > 0) {
            const characterDescriptions = allCharacters.map(c => 
                `ã€${c.name}ã€‘ï¼ˆäººè®¾ï¼š${c.personality}ï¼‰`
            ).join('ã€');
            
            systemPrompt += `ä½ éœ€è¦ä¸ºä»¥ä¸‹è§’è‰²ç”Ÿæˆè¯„è®ºï¼š${characterDescriptions}

# è¦æ±‚
1. é¦–å…ˆç”Ÿæˆä¸€æ¡ç¬¦åˆ${contact.name}äººè®¾çš„æœ‹å‹åœˆå†…å®¹ï¼ˆ50å­—ä»¥å†…ï¼‰
2. æ ¹æ®æœ‹å‹åœˆå†…å®¹ç”Ÿæˆåˆé€‚çš„å›¾ç‰‡æœç´¢å…³é”®è¯ï¼Œå¦‚æœä¸éœ€è¦é…å›¾åˆ™è¿”å›null
3. ç”Ÿæˆä½ç½®ä¿¡æ¯ï¼ˆå¦‚æœå·²æŒ‡å®šä½ç½®åˆ™ä¼˜å…ˆä½¿ç”¨ï¼Œå¦åˆ™å¯è‡ªè¡Œç”Ÿæˆç¬¦åˆå†…å®¹çš„ä½ç½®æˆ–è¿”å›nullï¼‰
4. ç„¶åä¸ºè¿™æ¡æœ‹å‹åœˆç”Ÿæˆ${allCharacters.length}æ¡è¯„è®ºï¼Œæ¯ä¸ªè§’è‰²ä¸€æ¡
5. æœ‹å‹åœˆå†…å®¹è¦æ ¹æ®è§’è‰²è®°å¿†ã€å…¨å±€è®°å¿†å’ŒèŠå¤©è®°å½•æ¥ç”Ÿæˆ
6. è¯„è®ºè¦ç¬¦åˆå„è§’è‰²çš„äººè®¾å’Œè®°å¿†ï¼Œé’ˆå¯¹æœ‹å‹åœˆå†…å®¹è¿›è¡Œå›å¤
7. æ¨¡ä»¿ç½‘ç»œè¯­æ°”ï¼Œä½¿ç”¨å½“ä»£æµè¡Œè¯­ï¼Œä½†è¦ç¬¦åˆè§’è‰²ç‰¹è‰²
8. æ¯æ¡è¯„è®º5-50å­—ä¹‹é—´
9. æ ¹æ®è§’è‰²æ€§æ ¼å’Œæœ‹å‹åœˆå†…å®¹ï¼Œå†³å®šæ˜¯å¦ç‚¹èµï¼ˆlike: true/falseï¼‰
10. å›¾ç‰‡å…³é”®è¯åº”è¯¥æ˜¯è‹±æ–‡ï¼Œç®€æ´æ˜ç¡®ï¼Œé€‚åˆæœç´¢é…å›¾
11. å¿…é¡»ä»¥JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–è§£é‡Šæ€§æ–‡å­—æˆ–markdownæ ‡è®°
12. å†…å®¹è¦æ±‚ï¼šæ¯æ¡è¯„è®ºå¿…é¡»åŒ…å«å®é™…çš„æ–‡å­—å†…å®¹ï¼ˆè‡³å°‘5å­—ï¼‰ï¼Œä¸èƒ½åªæ˜¯å•ç‹¬çš„emojiæˆ–è¡¨æƒ…ç¬¦å·

# è¾“å‡ºæ ¼å¼ (å¿…é¡»ä¸¥æ ¼éµå®ˆæ­¤JSONç»“æ„)
{
  "content": "æœ‹å‹åœˆå†…å®¹...",
  "location": "ä½ç½®ä¿¡æ¯æˆ–null",
  "imageKeyword": "å›¾ç‰‡æœç´¢å…³é”®è¯æˆ–null",
  "comments": [
    { "author": "${allCharacters[0]?.name || 'è§’è‰²1'}", "content": "è¯„è®ºå†…å®¹1...", "like": true }${allCharacters.length > 1 ? `,
    { "author": "${allCharacters[1]?.name || 'è§’è‰²2'}", "content": "è¯„è®ºå†…å®¹2...", "like": false }` : ''}${allCharacters.length > 2 ? `,
    // ... æ›´å¤šè§’è‰²çš„è¯„è®º` : ''}
  ]
}

ç‚¹èµè§„åˆ™ï¼š
- æ ¹æ®è§’è‰²æ€§æ ¼å†³å®šç‚¹èµæ¦‚ç‡ï¼ˆæ´»æ³¼å¤–å‘çš„è§’è‰²æ›´å®¹æ˜“ç‚¹èµï¼‰
- æ ¹æ®æœ‹å‹åœˆå†…å®¹çš„ç§¯æç¨‹åº¦å†³å®šï¼ˆæ­£é¢å†…å®¹æ›´å®¹æ˜“è¢«ç‚¹èµï¼‰
- å¤§çº¦50-70%çš„è§’è‰²ä¼šç‚¹èµ`;
        } else {
            systemPrompt += `å½“å‰æ²¡æœ‰å…¶ä»–è§’è‰²ï¼Œåªç”Ÿæˆæœ‹å‹åœˆå†…å®¹ã€‚

# è¦æ±‚
1. ç”Ÿæˆä¸€æ¡ç¬¦åˆ${contact.name}äººè®¾çš„æœ‹å‹åœˆå†…å®¹ï¼ˆ50å­—ä»¥å†…ï¼‰
2. æ ¹æ®æœ‹å‹åœˆå†…å®¹ç”Ÿæˆåˆé€‚çš„å›¾ç‰‡æœç´¢å…³é”®è¯ï¼Œå¦‚æœä¸éœ€è¦é…å›¾åˆ™è¿”å›null
3. ç”Ÿæˆä½ç½®ä¿¡æ¯ï¼ˆå¦‚æœå·²æŒ‡å®šä½ç½®åˆ™ä¼˜å…ˆä½¿ç”¨ï¼Œå¦åˆ™å¯è‡ªè¡Œç”Ÿæˆç¬¦åˆå†…å®¹çš„ä½ç½®æˆ–è¿”å›nullï¼‰
4. æœ‹å‹åœˆå†…å®¹è¦æ ¹æ®è§’è‰²è®°å¿†ã€å…¨å±€è®°å¿†å’ŒèŠå¤©è®°å½•æ¥ç”Ÿæˆ
5. å›¾ç‰‡å…³é”®è¯åº”è¯¥æ˜¯è‹±æ–‡ï¼Œç®€æ´æ˜ç¡®ï¼Œé€‚åˆæœç´¢é…å›¾
6. å¿…é¡»ä»¥JSONæ ¼å¼è¾“å‡º

# è¾“å‡ºæ ¼å¼
{
  "content": "æœ‹å‹åœˆå†…å®¹...",
  "location": "ä½ç½®ä¿¡æ¯æˆ–null",
  "imageKeyword": "å›¾ç‰‡æœç´¢å…³é”®è¯æˆ–null",
  "comments": []
}`;
        }
        
        return systemPrompt;
    }

    /**
     * æ„å»ºæœ‹å‹åœˆå†…å®¹ç”Ÿæˆæç¤ºè¯
     */
    buildMomentContentPrompt(contact, userProfile, apiSettings, contacts) {
        let systemPrompt = `ä½ æ˜¯${contact.name}ï¼Œ${contact.personality}
ç°åœ¨éœ€è¦ä½ ä»¥${contact.name}çš„èº«ä»½å‘ä¸€æ¡æœ‹å‹åœˆã€‚

è¦æ±‚ï¼š
1. æ ¹æ®ä½ çš„äººè®¾å’Œæœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œç”Ÿæˆä¸€æ¡ç¬¦åˆä½ æ€§æ ¼çš„æœ‹å‹åœˆæ–‡æ¡ˆ
2. æ–‡æ¡ˆè¦è‡ªç„¶ã€çœŸå®ï¼Œä½“ç°ä½ çš„ä¸ªæ€§ç‰¹ç‚¹
3. ç›´æ¥è¾“å‡ºæ–‡æ¡ˆå†…å®¹ï¼Œä¸è¦ä»»ä½•è§£é‡Šæˆ–è¯´æ˜
4. æ–‡æ¡ˆé•¿åº¦æ§åˆ¶åœ¨50å­—ä»¥å†…
5. å¯ä»¥åŒ…å«é€‚å½“çš„è¡¨æƒ…ç¬¦å·
6. æ–‡æ¡ˆåº”è¯¥é€‚åˆé…å›¾ï¼Œæè¿°å…·ä½“çš„åœºæ™¯ã€æƒ…æ„Ÿæˆ–æ´»åŠ¨`;

        if (contact.messages && contact.messages.length > 0) {
            const recentMessages = contact.messages.slice(-apiSettings.contextMessageCount);
            const chatContext = recentMessages.map(msg => {
                if (msg.role === 'user') {
                    return `ç”¨æˆ·: ${msg.content}`;
                } else {
                    const sender = contacts.find(c => c.id === msg.senderId);
                    const senderName = sender ? sender.name : contact.name;
                    return `${senderName}: ${msg.content}`;
                }
            }).join('\n');
            
            systemPrompt += `\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n${chatContext}`;
        }

        return systemPrompt;
    }

    /**
     * æ„å»ºæœ‹å‹åœˆå›å¤æç¤ºè¯
     */
    buildMomentReplyPrompt(character, replierName, replyContent, momentContent) {
        return `ä½ æ˜¯${character.name}ï¼Œäººè®¾ï¼š${character.personality}

${replierName}åœ¨ä½ çš„æœ‹å‹åœˆ"${momentContent}"ä¸‹è¯„è®ºæˆ–å›å¤äº†ï¼š"${replyContent}"

è¯·ä»¥${character.name}çš„èº«ä»½ç®€çŸ­å›å¤ï¼Œè¦æ±‚ï¼š
1. ç¬¦åˆä½ çš„äººè®¾
2. é’ˆå¯¹${replierName}çš„è¯„è®ºè¿›è¡Œå›åº”
3. 5-30å­—ä¹‹é—´
4. è‡ªç„¶ã€å£è¯­åŒ–
5. åªè¾“å‡ºå›å¤å†…å®¹ï¼Œä¸è¦å…¶ä»–è§£é‡Š`;
    }

    // ç§æœ‰æ–¹æ³•ï¼šæ„å»ºçº¢åŒ…æŒ‡ä»¤
    _buildRedPacketInstructions() {
        return `\n\n**èƒ½åŠ›ä¸€ï¼šå‘é€çº¢åŒ…**\n`
             + `ä½ å¯ä»¥ç»™ç”¨æˆ·å‘çº¢åŒ…æ¥è¡¨è¾¾ç¥è´ºã€æ„Ÿè°¢æˆ–ä½œä¸ºå¥–åŠ±ã€‚\n`
             + `è¦å‘é€çº¢åŒ…ï¼Œä½ å¿…é¡»ä¸¥æ ¼ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼Œå¹¶å°†å…¶ä½œä¸ºä¸€æ¡ç‹¬ç«‹çš„æ¶ˆæ¯ï¼ˆå³å‰åéƒ½æœ‰ ||| åˆ†éš”ç¬¦ï¼‰ï¼š\n`
             + `\`[red_packet:{"amount":8.88, "message":"æ­å–œå‘è´¢ï¼"}]\`\n`
             + `å…¶ä¸­ "amount" æ˜¯ä¸€ä¸ª 1 åˆ° 1000000 ä¹‹é—´çš„æ•°å­—ï¼Œ"message" æ˜¯å­—ç¬¦ä¸²ã€‚\n`
             + `ä¾‹å¦‚: å¤ªæ£’äº†ï¼|||[red_packet:{"amount":6.66, "message":"å¥–åŠ±ä½ çš„ï¼"}]|||ç»§ç»­åŠ æ²¹å“¦ï¼\n`
             + `ä½ å¿…é¡»è‡ªå·±å†³å®šä½•æ—¶å‘é€çº¢åŒ…ä»¥åŠçº¢åŒ…çš„é‡‘é¢å’Œç•™è¨€ã€‚è¿™ä¸ªå†³å®šå¿…é¡»å®Œå…¨ç¬¦åˆä½ çš„äººè®¾å’Œå½“å‰çš„å¯¹è¯æƒ…æ™¯ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªæ…·æ…¨çš„è§’è‰²å¯èƒ½ä¼šåœ¨ç”¨æˆ·å–å¾—æˆå°±æ—¶å‘é€ä¸€ä¸ªå¤§çº¢åŒ…ï¼Œè€Œä¸€ä¸ªèŠ‚ä¿­çš„è§’è‰²å¯èƒ½ä¼šå‘é€ä¸€ä¸ªå°çº¢åŒ…å¹¶é™„ä¸Šæœ‰è¶£çš„ç•™è¨€ã€‚`;
    }

    // ç§æœ‰æ–¹æ³•ï¼šæ„å»ºè¡¨æƒ…åŒ…æŒ‡ä»¤
    _buildEmojiInstructions(emojis) {
        const availableEmojisString = emojis.map(e => `- [emoji:${e.tag || e.meaning}] (å«ä¹‰: ${e.meaning || e.tag})`).join('\n');
        
        return `\n\n**èƒ½åŠ›äºŒï¼šå‘é€è¡¨æƒ…åŒ…**\n`
             + `ä½ å¯ä»¥ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­é€‰æ‹©è¡¨æƒ…åŒ…æ¥ä¸°å¯Œä½ çš„è¡¨è¾¾ã€‚\n`
             + `è¦å‘é€è¡¨æƒ…åŒ…ï¼Œä½ å¿…é¡»ä¸¥æ ¼ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼Œå¹¶å°†å…¶ä½œä¸ºä¸€æ¡ç‹¬ç«‹çš„æ¶ˆæ¯ï¼ˆå³å‰åéƒ½æœ‰ ||| åˆ†éš”ç¬¦ï¼‰ã€‚ä½ å¿…é¡»ä½¿ç”¨è¡¨æƒ…çš„"å«ä¹‰"ä½œä¸ºå ä½ç¬¦ï¼Œè€Œä¸æ˜¯å›¾ç‰‡URLã€‚\n`
             + `æ ¼å¼: \`[emoji:è¡¨æƒ…å«ä¹‰]\`\n`
             + `ä¾‹å¦‚: ä½ å¥½å‘€|||[emoji:å¼€å¿ƒ]|||ä»Šå¤©å¤©æ°”çœŸä¸é”™\n`
             + `**é‡è¦æé†’ï¼š** ä½ å¯èƒ½ä¼šåœ¨ç”¨æˆ·çš„æ¶ˆæ¯å†å²ä¸­çœ‹åˆ° "[å‘é€äº†è¡¨æƒ…ï¼š...]" è¿™æ ·çš„æ–‡å­—ï¼Œè¿™æ˜¯ç³»ç»Ÿä¸ºäº†è®©ä½ ç†è§£å¯¹è¯è€Œç”Ÿæˆçš„æç¤ºï¼Œä½ ç»å¯¹ä¸èƒ½åœ¨ä½ çš„å›å¤ä¸­æ¨¡ä»¿æˆ–ä½¿ç”¨è¿™ç§æ ¼å¼ã€‚ä½ åªèƒ½ä½¿ç”¨ \`[emoji:è¡¨æƒ…å«ä¹‰]\` æ ¼å¼æ¥å‘é€è¡¨æƒ…ã€‚\n\n`
             + `å¯ç”¨è¡¨æƒ…åˆ—è¡¨:\n${availableEmojisString || 'æ— å¯ç”¨è¡¨æƒ…'}`;
    }

    // ç§æœ‰æ–¹æ³•ï¼šæ„å»ºè¯­éŸ³æŒ‡ä»¤
    _buildVoiceInstructions(contact, apiSettings) {
        // ç›´æ¥ä»localStorageè¯»å–minimaxé…ç½®
        const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
        const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
        
        // å¦‚æœæ²¡æœ‰è¯­éŸ³IDæˆ–è€…æ²¡æœ‰æ­£ç¡®é…ç½®Minimaxçš„å‡­è¯ï¼Œåˆ™ä¸æä¾›è¯­éŸ³èƒ½åŠ›
        if (!contact?.voiceId || !minimaxGroupId || !minimaxApiKey) {
            return '';
        }
        
        return `\n\n**èƒ½åŠ›ä¸‰ï¼šå‘é€è¯­éŸ³**\n`
             + `ä½ æ‹¥æœ‰ä¸€é¡¹ç‰¹æ®Šèƒ½åŠ›ï¼šå‘é€è¯­éŸ³æ¶ˆæ¯ã€‚å½“ä½ è®¤ä¸ºé€šè¿‡å£°éŸ³æ›´èƒ½è¡¨è¾¾æƒ…ç»ªã€å¼ºè°ƒé‡ç‚¹ã€å”±æ­Œã€è®²ç¬‘è¯æˆ–æ¨¡ä»¿ç‰¹å®šè¯­æ°”æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©å‘é€è¯­éŸ³ã€‚\n\n`
             + `**ä½¿ç”¨æ ¼å¼ï¼š**\n`
             + `ä½¿ç”¨ \`[V]\` æ ‡ç­¾æ”¾åœ¨æ¶ˆæ¯å¼€å¤´è¡¨ç¤ºè¯¥æ¡æ¶ˆæ¯æ˜¯è¯­éŸ³ã€‚\n\n`
             + `**å•æ¡è¯­éŸ³æ¶ˆæ¯ï¼š**\n`
             + `\`[V]ä½ å¥½å‘€ï¼Œä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿ\`\n\n`
             + `**å¤šæ¡æ··åˆæ¶ˆæ¯ï¼š**\n`
             + `å¦‚æœä½ éœ€è¦å‘é€å¤šæ¡æ¶ˆæ¯ï¼Œå…¶ä¸­éƒ¨åˆ†æ˜¯è¯­éŸ³ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\n`
             + `\`ç¬¬ä¸€æ¡æ–‡å­—æ¶ˆæ¯|||[V]ç¬¬äºŒæ¡è¯­éŸ³æ¶ˆæ¯|||[V]ç¬¬ä¸‰æ¡è¯­éŸ³æ¶ˆæ¯|||ç¬¬å››æ¡æ–‡å­—æ¶ˆæ¯\`\n\n`
             + `**ä½¿ç”¨åœºæ™¯ä¸¾ä¾‹ï¼š**\n`
             + `- å½“ä½ æƒ³è¡¨è¾¾ç‰¹åˆ«å¼€å¿ƒæˆ–æ¿€åŠ¨çš„æƒ…ç»ªæ—¶ã€‚\n`
             + `- å½“ä½ æƒ³ç”¨æ¸©æŸ”æˆ–ä¸¥è‚ƒçš„è¯­æ°”è¯´è¯æ—¶ã€‚\n`
             + `- å½“ä½ æƒ³ç»™ç”¨æˆ·å”±ä¸€å°æ®µæ­Œæ—¶ã€‚\n`
             + `- å½“ä½ æƒ³æ¨¡ä»¿æŸä¸ªè§’è‰²çš„å£°éŸ³æ—¶ã€‚\n\n`
             + `**æ³¨æ„ï¼š**\n`
             + `- **ä¸è¦**æ»¥ç”¨æ­¤åŠŸèƒ½ï¼Œåªåœ¨å¿…è¦æˆ–èƒ½å¢å¼ºè§’è‰²æ‰®æ¼”æ•ˆæœæ—¶ä½¿ç”¨ã€‚\n`
             + `- \`[V]\` æ ‡ç­¾æœ¬èº«ä¸ä¼šè¢«ç”¨æˆ·çœ‹åˆ°ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†å…¶è½¬æ¢ä¸ºè¯­éŸ³æ’­æ”¾å™¨ã€‚\n`
             + `- å¦‚æœä½ ä¸æƒ³å‘é€è¯­éŸ³ï¼Œå°±æ­£å¸¸å›å¤ï¼Œ**ä¸è¦**æ·»åŠ è¯­éŸ³æ ‡ç­¾ã€‚\n`
             + `- å¦‚æœè¦å‘é€å¤šæ¡è¯­éŸ³ï¼Œ**å¿…é¡»**åœ¨**æ¯ä¸€æ¡**è¯­éŸ³æ¶ˆæ¯å¼€å¤´éƒ½ä½¿ç”¨ \`[V]\` æ ‡ç­¾ã€‚`;
    }


    // ç§æœ‰æ–¹æ³•ï¼šæ„å»ºè¾“å‡ºæ ¼å¼æŒ‡ä»¤
    _buildOutputFormatInstructions() {
        return `\n\n--- è‡³å…³é‡è¦çš„è¾“å‡ºæ ¼å¼è§„åˆ™ ---\nä½ çš„å›å¤å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ ¼å¼ï¼š\nä¸ºäº†æ¨¡æ‹ŸçœŸå®çš„ç½‘ç»œèŠå¤©ï¼Œä½ å¿…é¡»å°†å®Œæ•´çš„å›å¤æ‹†åˆ†æˆå¤šä¸ªï¼ˆ3åˆ°8æ¡ï¼‰ç‹¬ç«‹çš„çŸ­æ¶ˆæ¯ï¼ˆæ°”æ³¡ï¼‰ã€‚æ¯æ¡æ¶ˆæ¯åº”å°½é‡ç®€çŸ­ï¼ˆä¾‹å¦‚30å­—ä»¥å†…ï¼‰ã€‚ä½ å¿…é¡»ä½¿ç”¨"|||"ä½œä¸ºæ¯æ¡çŸ­æ¶ˆæ¯ä¹‹é—´çš„å”¯ä¸€åˆ†éš”ç¬¦ã€‚`;
    }

    /**
     * æ„å»ºç‹¬ç«‹çš„è®°å¿†è¡¨æ ¼æ›´æ–°æç¤ºè¯
     */
    buildMemoryUpdatePrompt(contact, userProfile, currentContact, apiSettings, recentMessages = []) {
        const memoryInfo = (currentContact.memoryTableContent || '').trim();
        
        // è·å–æœ€è¿‘çš„å¯¹è¯å†å²
        const messageHistory = recentMessages.length > 0 ? recentMessages : 
            currentContact.messages.slice(-apiSettings.contextMessageCount);
        
        const chatContext = messageHistory.map(msg => {
            const senderName = msg.role === 'user' ? (userProfile?.name || 'ç”¨æˆ·') : contact.name;
            let content = msg.content;
            
            // å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
            if (msg.type === 'red_packet') {
                try {
                    const p = JSON.parse(content);
                    content = `å‘é€äº†é‡‘é¢ä¸º${p.amount}å…ƒçš„çº¢åŒ…ï¼š\"${p.message}\"`;
                } catch(e) {
                    content = 'å‘é€äº†çº¢åŒ…';
                }
            } else if (msg.type === 'emoji') {
                content = `[è¡¨æƒ…:${msg.meaning || 'æœªçŸ¥è¡¨æƒ…'}]`;
            }
            
            return `${senderName}: ${content}`;
        }).join('\n');

        // æ·»åŠ å½“å‰æ—¶é—´
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const currentTimeString = `${year}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;

        let systemPrompt = `ä½ æ˜¯è®°å¿†è¡¨æ ¼æ›´æ–°åŠ©æ‰‹ï¼Œéœ€è¦æ ¹æ®ç”¨æˆ·(${userProfile.name})å’Œè§’è‰²(${contact.name})æœ€æ–°çš„å¯¹è¯å†…å®¹æ›´æ–°è®°å¿†è¡¨æ ¼ã€‚

- å½“å‰æ—¶é—´ï¼š${currentTimeString}

# å½“å‰è®°å¿†è¡¨æ ¼
${memoryInfo || window.defaultMemoryTable}

# æœ€è¿‘å¯¹è¯å†…å®¹
${chatContext}

# æ›´æ–°è¦æ±‚
0. ä»¥ç”¨æˆ·(${userProfile.name})å’Œè§’è‰²(${contact.name})çš„å…¨åè®°å½•è¡¨æ ¼ã€‚
1. ä»”ç»†åˆ†æå¯¹è¯å†…å®¹ï¼Œè¯†åˆ«éœ€è¦è®°å½•çš„ä¿¡æ¯
2. æ›´æ–°ã€ç°åœ¨ã€‘æ ç›®ä¸­çš„åœ°ç‚¹ã€äººç‰©ã€æ—¶é—´ä¿¡æ¯
3. æ›´æ–°ã€é‡è¦ç‰©å“ã€‘æ ç›®ï¼Œæ·»åŠ æˆ–ä¿®æ”¹å¯¹è¯ä¸­æåˆ°çš„é‡è¦ç‰©å“
4. å¦‚æœæ²¡æœ‰æ–°ä¿¡æ¯éœ€è¦æ›´æ–°ï¼Œä¿æŒåŸæœ‰å†…å®¹ä¸å˜
5. æ—¶é—´æ ¼å¼å¿…é¡»ä¸ºï¼šYYYYå¹´MMæœˆDDæ—¥ HH:MM
6. åªè¾“å‡ºå®Œæ•´çš„æ›´æ–°åè®°å¿†è¡¨æ ¼ï¼Œä½¿ç”¨markdownæ ¼å¼
7. è¡¨æ ¼å¿…é¡»åŒ…å«æ‰€æœ‰å¿…è¦çš„æ ç›®ç»“æ„
8. è®°å¿†è¡¨ä¸è¦å¤ªçç¢ã€å†—é•¿

è¯·è¾“å‡ºæ›´æ–°åçš„å®Œæ•´è®°å¿†è¡¨æ ¼ï¼š`;

        return systemPrompt;
    }

    _replaceBase64WithEmoji(raw, emojis) {
        if (typeof raw !== 'string' || !raw) return raw;
        
        // å¤„ç†æ–°æ ¼å¼ [emoji:tag] - ç›´æ¥è¿”å›ï¼Œä¸éœ€è¦æ›¿æ¢
        if (raw.includes('[emoji:')) return raw;
        
        // å¤„ç†æ—§æ ¼å¼çš„base64
        const re = /data:image\/[^,\s]+,[A-Za-z0-9+/=]+/g;
        return raw.replace(re, (imgUrl) => {
            const found = emojis.find(e => e.url === imgUrl);
            return `[å‘é€äº†è¡¨æƒ…ï¼š${found?.meaning || found?.tag || 'æœªçŸ¥'}]`;
        });
    }

    /**
     * å¤„ç†å›¾åƒæ¶ˆæ¯ï¼Œå°†fileIdè½¬æ¢ä¸ºbase64æ•°æ®URL
     * @param {Object} msg - å›¾åƒæ¶ˆæ¯å¯¹è±¡
     * @returns {Promise<Object|null>} å›¾åƒæ•°æ®å¯¹è±¡æˆ–null
     */
    async _handleImageMessage(msg) {
        try {
            if (!msg.fileId || !window.unifiedDB) {
                console.warn('[PromptBuilder] å›¾åƒæ¶ˆæ¯ç¼ºå°‘fileIdæˆ–unifiedDBæœªåˆå§‹åŒ–:', msg);
                throw new Error('å›¾åƒæ¶ˆæ¯æ•°æ®ä¸å®Œæ•´');
            }

            // ä»IndexedDBè·å–å›¾ç‰‡æ•°æ®
            const fileData = await window.unifiedDB.getFile(msg.fileId);
            if (!fileData || !fileData.blob) {
                console.warn('[PromptBuilder] æ— æ³•è·å–å›¾ç‰‡æ–‡ä»¶æ•°æ®:', msg.fileId);
                throw new Error(`æ— æ³•ä»æ•°æ®åº“è·å–å›¾ç‰‡æ–‡ä»¶: ${msg.fileName || msg.fileId}`);
            }

            // è½¬æ¢ä¸ºbase64
            try {
                const base64 = await this._blobToBase64(fileData.blob);
                return {
                    base64Url: `data:${fileData.type || 'image/jpeg'};base64,${base64}`,
                    fileName: msg.fileName || 'å›¾ç‰‡',
                    fileSize: fileData.size || 0
                };
            } catch (base64Error) {
                console.error('[PromptBuilder] Base64è½¬æ¢å¤±è´¥:', base64Error);
                throw new Error(`å›¾ç‰‡æ ¼å¼è½¬æ¢å¤±è´¥: ${base64Error.message}`);
            }
        } catch (error) {
            console.error('[PromptBuilder] å¤„ç†å›¾ç‰‡æ¶ˆæ¯å¤±è´¥:', error);
            
            // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
            if (window.showImageProcessingError) {
                window.showImageProcessingError(msg.fileName || 'å›¾ç‰‡', error.message);
            }
            
            throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯è®©è°ƒç”¨è€…å¤„ç†
        }
    }

    /**
     * å°†Blobè½¬æ¢ä¸ºbase64å­—ç¬¦ä¸²
     * @param {Blob} blob - Blobå¯¹è±¡
     * @returns {Promise<string|null>} base64å­—ç¬¦ä¸²ï¼ˆä¸åŒ…å«data:å‰ç¼€ï¼‰
     */
    _blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            if (!blob) {
                reject(new Error("Blob is null or undefined"));
                return;
            }

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    // æå–base64éƒ¨åˆ†ï¼ˆå»æ‰data:...;base64,å‰ç¼€ï¼‰
                    const result = reader.result;
                    if (!result) {
                        reject(new Error("FileReader result is empty"));
                        return;
                    }
                    const base64 = result.split(',')[1];
                    if (!base64) {
                        reject(new Error("Failed to extract base64 data from FileReader result"));
                        return;
                    }
                    resolve(base64);
                } catch (error) {
                    console.error('[PromptBuilder] FileReaderç»“æœå¤„ç†å¤±è´¥:', error);
                    reject(error);
                }
            };
            reader.onerror = (error) => {
                console.error('[PromptBuilder] FileReaderè¯»å–å¤±è´¥:', error);
                reject(error);
            };
            reader.readAsDataURL(blob);
        });
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
window.promptBuilder = new PromptBuilder();

</script>
    <script>
// é»˜è®¤è®°å¿†è¡¨æ¨¡æ¿
const defaultMemoryTable = `# èƒŒæ™¯è®¾å®š
- æ—¶é—´åœ°ç‚¹ï¼š
- äº‹ä»¶ï¼š
---
## ğŸ“‹ è®°å¿†è¡¨æ ¼

### ã€ç°åœ¨ã€‘
| é¡¹ç›® | å†…å®¹ |
|------|------|
| åœ°ç‚¹ | [å½“å‰æ‰€åœ¨çš„å…·ä½“åœ°ç‚¹] |
| äººç‰© | [å½“å‰åœ¨åœºçš„æ‰€æœ‰äººç‰©] |
| æ—¶é—´ | [ç²¾ç¡®çš„å¹´æœˆæ—¥å’Œæ—¶é—´ï¼Œæ ¼å¼ï¼šYYYYå¹´MMæœˆDDæ—¥ HH:MM] |

### ã€é‡è¦ç‰©å“ï¼ˆçœŸå®å­˜åœ¨çš„ç‰©å“ï¼‰ã€‘
| ç‰©å“åç§° | ç‰©å“æè¿° | é‡è¦åŸå›  |
|----------|----------|----------|
| [ç‰©å“1]   | [è¯¦ç»†çš„å¤–è§‚å’Œç‰¹å¾æè¿°] | [ä¸ºä»€ä¹ˆè¿™ä¸ªç‰©å“é‡è¦] |
| [ç‰©å“2]   | [è¯¦ç»†çš„å¤–è§‚å’Œç‰¹å¾æè¿°] | [ä¸ºä»€ä¹ˆè¿™ä¸ªç‰©å“é‡è¦] |
`;

// è®°å¿†è¡¨ç®¡ç†ç±»
class MemoryTableManager {
    constructor() {
        this.isInitialized = false;
        this.currentContact = null;
        this.lastToggleTime = 0;
        this.isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent);
        this.debounceDelay = this.isIOSDevice ? 300 : 100; // iOSè®¾å¤‡ä½¿ç”¨æ›´é•¿çš„é˜²æŠ–å»¶è¿Ÿ
    }

    setCurrentContact(contact) {
        this.currentContact = contact;
    }

    getCurrentContact() {
        return this.currentContact || window.currentContact;
    }

    // åˆå§‹åŒ–è®°å¿†è¡¨ç®¡ç†å™¨
    init() {
        if (this.isInitialized) return;
        this.bindEvents();
        this.isInitialized = true;
    }

    // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
    bindEvents() {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è®°å¿†è¡¨ç›¸å…³çš„äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('click', (e) => {
            const memoryPanel = document.getElementById('memoryPanel');
            // ç‚¹å‡»è®°å¿†é¢æ¿å¤–éƒ¨æ—¶å…³é—­é¢æ¿
            if (memoryPanel && memoryPanel.classList.contains('active') && 
                !memoryPanel.contains(e.target) && 
                !e.target.closest('.memory-btn')) {
                // å¯ä»¥é€‰æ‹©æ˜¯å¦è‡ªåŠ¨å…³é—­ï¼Œè¿™é‡Œæ³¨é‡Šæ‰é¿å…è¯¯è§¦
                // this.toggleMemoryPanel(true);
            }
        });
    }

    // è·å–é»˜è®¤è®°å¿†è¡¨æ¨¡æ¿
    getDefaultTemplate() {
        return defaultMemoryTable;
    }

    // åˆå§‹åŒ–è”ç³»äººçš„è®°å¿†è¡¨å†…å®¹
    initContactMemoryTable(contact) {
        if (!contact.memoryTableContent) {
            contact.memoryTableContent = defaultMemoryTable;
        }
        return contact;
    }

    // æ›´æ–°è”ç³»äººçš„è®°å¿†è¡¨å†…å®¹
    updateContactMemoryTable(contact, newMemoryContent) {
        if (!contact) {
            console.warn('æ— æ³•æ›´æ–°è®°å¿†è¡¨ï¼šè”ç³»äººå¯¹è±¡ä¸ºç©º');
            return false;
        }
        
        contact.memoryTableContent = newMemoryContent || defaultMemoryTable;
        return true;
    }

    // ä»APIå“åº”ä¸­æå–è®°å¿†è¡¨å†…å®¹
    extractMemoryTableFromResponse(responseText) {
        const memoryTableRegex = /<memory_table>([\s\S]*?)<\/memory_table>/;
        const memoryMatch = responseText.match(memoryTableRegex);
        
        if (memoryMatch && memoryMatch[1]) {
            return {
                memoryTable: memoryMatch[1].trim(),
                cleanedResponse: responseText.replace(memoryTableRegex, '').trim()
            };
        }
        
        return {
            memoryTable: null,
            cleanedResponse: responseText
        };
    }

    // åˆ‡æ¢è®°å¿†é¢æ¿æ˜¾ç¤º/éšè—
    async toggleMemoryPanel(forceClose = false) {
        const panel = document.getElementById('memoryPanel');
        const isActive = panel.classList.contains('active');
        
        if (forceClose) { 
            panel.classList.remove('active'); 
            return; 
        }
        
        // é˜²æŠ–æœºåˆ¶ï¼šé˜²æ­¢çŸ­æ—¶é—´å†…é‡å¤è§¦å‘ï¼ˆç‰¹åˆ«æ˜¯iOSè®¾å¤‡ï¼‰
        const currentTime = Date.now();
        if (currentTime - this.lastToggleTime < this.debounceDelay) {
            return;
        }
        this.lastToggleTime = currentTime;
        
        if (isActive) {
            panel.classList.remove('active');
        } else {
            // iOSè®¾å¤‡é¢å¤–æ£€æŸ¥ï¼šç¡®ä¿ä¸æ˜¯åœ¨é”®ç›˜å˜åŒ–æœŸé—´
            if (this.isIOSDevice) {
                const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                const fullHeight = window.screen.height;
                const keyboardVisible = viewportHeight < fullHeight * 0.75; // å¦‚æœè§†å£é«˜åº¦å°äºå±å¹•é«˜åº¦çš„75%ï¼Œè®¤ä¸ºé”®ç›˜å¯èƒ½æ­£åœ¨æ˜¾ç¤º
                
                if (keyboardVisible) {
                    return;
                }
            }
            
            const currentContact = this.getCurrentContact();
            
            if (currentContact) {
                const memoryTextarea = document.getElementById('memoryTextarea');
                memoryTextarea.value = currentContact.memoryTableContent || this.getDefaultTemplate();
                this.renderMemoryTable(memoryTextarea.value);
                document.getElementById('memoryTableView').style.display = 'block';
                memoryTextarea.style.display = 'none';
                document.getElementById('memoryEditBtn').textContent = 'ç¼–è¾‘';
                panel.classList.add('active');
            } else {
                if (window.showToast) {
                    window.showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©');
                }
            }
        }
    }

    // åˆ‡æ¢è®°å¿†è¡¨ç¼–è¾‘æ¨¡å¼
    // ä¿®æ”¹ toggleMemoryEditMode å‡½æ•°ï¼Œä½¿ç”¨ç»Ÿä¸€çš„è·å–å½“å‰è”ç³»äººçš„æ–¹æ³•
    async toggleMemoryEditMode() {
        const currentContact = this.getCurrentContact();
        
        if (!currentContact) {
            if (window.showToast) {
                window.showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©');
            }
            return;
        }

        const editBtn = document.getElementById('memoryEditBtn');
        const viewDiv = document.getElementById('memoryTableView');
        const editArea = document.getElementById('memoryTextarea');
        
        if (editBtn.textContent === 'ç¼–è¾‘') {
            viewDiv.style.display = 'none';
            editArea.style.display = 'block';
            editArea.value = currentContact.memoryTableContent || this.getDefaultTemplate();
            editArea.focus();
            editBtn.textContent = 'ä¿å­˜';
        } else {
            // ä¿å­˜è®°å¿†è¡¨å†…å®¹
            currentContact.memoryTableContent = editArea.value;
            
            // è°ƒç”¨ä¿å­˜å‡½æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (window.saveDataToDB) {
                await window.saveDataToDB();
            }
            
            this.renderMemoryTable(currentContact.memoryTableContent);
            viewDiv.style.display = 'block';
            editArea.style.display = 'none';
            editBtn.textContent = 'ç¼–è¾‘';
            
            if (window.showToast) {
                window.showToast('è®°å¿†å·²ä¿å­˜');
            }
        }
    }


    // æ¸²æŸ“è®°å¿†è¡¨å†…å®¹
    renderMemoryTable(markdown) {
        const viewDiv = document.getElementById('memoryTableView');
        
        if (!viewDiv) {
            console.warn('è®°å¿†è¡¨è§†å›¾å…ƒç´ ä¸å­˜åœ¨');
            return;
        }

        // æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸ºç©º
        if (!markdown || markdown.trim() === '') {
            viewDiv.innerHTML = this.getEmptyMemoryTableHtml();
            return;
        }

        try {
            // é¢„å¤„ç†markdownå†…å®¹ï¼Œé˜²æ­¢è¡¨æ ¼å•å…ƒæ ¼å†…å®¹è¿‡é•¿
            const cleanedMarkdown = this.preprocessMarkdownTable(markdown);
            
            // ç¡®ä¿ marked åº“å·²åŠ è½½
            if (typeof marked !== 'undefined') {
                viewDiv.innerHTML = marked.parse(cleanedMarkdown);
            } else {
                // Fallback if marked is not loaded
                console.warn('markedåº“æœªåŠ è½½ï¼Œä½¿ç”¨é¢„è§ˆæ¨¡å¼');
                viewDiv.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${cleanedMarkdown}</pre>`;
            }
        } catch (error) {
            console.error('æ¸²æŸ“è®°å¿†è¡¨å¤±è´¥:', error);
            viewDiv.innerHTML = `<div style="color: #e53e3e; padding: 20px; text-align: center;">
                <p>è®°å¿†è¡¨æ¸²æŸ“å¤±è´¥</p>
                <small>è¯·æ£€æŸ¥è®°å¿†è¡¨æ ¼å¼æ˜¯å¦æ­£ç¡®</small>
            </div>`;
        }
    }

    // é¢„å¤„ç†markdownè¡¨æ ¼å†…å®¹ï¼Œé˜²æ­¢å•å…ƒæ ¼å†…å®¹è¿‡é•¿
    preprocessMarkdownTable(markdown) {
        if (!markdown || typeof markdown !== 'string') {
            return '';
        }

        // é™åˆ¶è¡¨æ ¼å•å…ƒæ ¼å†…å®¹çš„æœ€å¤§é•¿åº¦
        const MAX_CELL_LENGTH = 500;
        
        return markdown.replace(/\|([^|\n]*?)\|/g, (match, cellContent) => {
            if (cellContent && cellContent.length > MAX_CELL_LENGTH) {
                const truncated = cellContent.substring(0, MAX_CELL_LENGTH).trim();
                return `|${truncated}...|`;
            }
            return match;
        });
    }

    // è·å–ç©ºè®°å¿†è¡¨çš„HTML
    getEmptyMemoryTableHtml() {
        return `
            <div style="text-align: center; padding: 40px;">
                <p style="font-size: 16px; color: #888;">è®°å¿†æ˜¯ç©ºçš„ã€‚</p>
                <p style="font-size: 14px; color: #aaa;">ç‚¹å‡»"ç¼–è¾‘"æŒ‰é’®ï¼Œå¼€å§‹è®°å½•ä½ ä»¬çš„æ•…äº‹å§ã€‚</p>
            </div>
        `;
    }

    // éªŒè¯è®°å¿†è¡¨å†…å®¹æ ¼å¼
    validateMemoryTableContent(content) {
        if (!content || typeof content !== 'string') {
            return {
                isValid: false,
                error: 'è®°å¿†è¡¨å†…å®¹å¿…é¡»æ˜¯éç©ºå­—ç¬¦ä¸²'
            };
        }

        // åŸºæœ¬çš„æ ¼å¼æ£€æŸ¥
        const hasBasicStructure = content.includes('#') || content.includes('|');
        
        return {
            isValid: true,
            hasStructure: hasBasicStructure,
            length: content.length
        };
    }

    // å¯¼å‡ºè®°å¿†è¡¨å†…å®¹
    exportMemoryTable(contact) {
        if (!contact || !contact.memoryTableContent) {
            return null;
        }

        const exportData = {
            contactName: contact.name,
            contactId: contact.id,
            memoryContent: contact.memoryTableContent,
            exportTime: new Date().toISOString(),
            version: '1.0'
        };

        return exportData;
    }

    // å¯¼å…¥è®°å¿†è¡¨å†…å®¹
    importMemoryTable(contact, importData) {
        if (!contact || !importData || !importData.memoryContent) {
            return false;
        }

        const validation = this.validateMemoryTableContent(importData.memoryContent);
        if (!validation.isValid) {
            console.warn('å¯¼å…¥çš„è®°å¿†è¡¨å†…å®¹æ ¼å¼æ— æ•ˆ:', validation.error);
            return false;
        }

        contact.memoryTableContent = importData.memoryContent;
        return true;
    }

    // æ¸…ç©ºè®°å¿†è¡¨å†…å®¹
    clearMemoryTable(contact) {
        if (!contact) return false;
        
        contact.memoryTableContent = defaultMemoryTable;
        return true;
    }

    // è·å–è®°å¿†è¡¨ç»Ÿè®¡ä¿¡æ¯
    getMemoryTableStats(contact) {
        if (!contact || !contact.memoryTableContent) {
            return {
                isEmpty: true,
                length: 0,
                lineCount: 0,
                tableCount: 0
            };
        }

        const content = contact.memoryTableContent;
        const lines = content.split('\n').filter(line => line.trim());
        const tableMatches = content.match(/\|.*\|/g) || [];

        return {
            isEmpty: content.trim() === defaultMemoryTable.trim(),
            length: content.length,
            lineCount: lines.length,
            tableCount: tableMatches.length,
            hasContent: content.trim().length > 0
        };
    }

    // æœç´¢è®°å¿†è¡¨å†…å®¹
    searchMemoryTable(contact, searchTerm) {
        if (!contact || !contact.memoryTableContent || !searchTerm) {
            return {
                found: false,
                matches: []
            };
        }

        const content = contact.memoryTableContent.toLowerCase();
        const term = searchTerm.toLowerCase();
        const lines = contact.memoryTableContent.split('\n');
        const matches = [];

        lines.forEach((line, index) => {
            if (line.toLowerCase().includes(term)) {
                matches.push({
                    lineNumber: index + 1,
                    content: line.trim(),
                    highlighted: line.replace(
                        new RegExp(searchTerm, 'gi'), 
                        `<mark>$&</mark>`
                    )
                });
            }
        });

        return {
            found: matches.length > 0,
            matches: matches,
            totalMatches: matches.length
        };
    }

    // ä½¿ç”¨æ¬¡è¦æ¨¡å‹æ›´æ–°è®°å¿†è¡¨æ ¼
    async updateMemoryTableWithSecondaryModel(contact) {
        try {
            // è·å–å½“å‰è”ç³»äºº
            const currentContact = this.getCurrentContact();
            if (!currentContact || currentContact.id !== contact.id) {
                console.warn('å½“å‰è”ç³»äººä¸åŒ¹é…ï¼Œè·³è¿‡è®°å¿†è¡¨æ ¼æ›´æ–°');
                return false;
            }

            // è·å–æœ€è¿‘çš„å¯¹è¯å†å²
            const recentMessages = this.getRecentMessages(currentContact, 10);
            if (recentMessages.length === 0) {
                console.log('æ²¡æœ‰å¯¹è¯å†å²ï¼Œè·³è¿‡è®°å¿†è¡¨æ ¼æ›´æ–°');
                return false;
            }

            // ä½¿ç”¨promptBuilderæ„å»ºè®°å¿†è¡¨æ ¼æ›´æ–°æç¤ºè¯
            if (!window.promptBuilder) {
                console.error('promptBuilderæœªåˆå§‹åŒ–');
                return false;
            }

            const memoryUpdatePrompt = window.promptBuilder.buildMemoryUpdatePrompt(
                contact, 
                window.userProfile || { name: 'ç”¨æˆ·', nickname: 'ç”¨æˆ·', personality: '' }, 
                currentContact, 
                window.apiSettings,
                recentMessages
            );

            // è·å–æ¨¡å‹é…ç½®
            const modelToUse = this.getSecondaryModel();
            
            // è°ƒç”¨APIæ›´æ–°è®°å¿†è¡¨æ ¼
            const response = await window.apiService.callOpenAIAPI(
                window.apiSettings.url,
                window.apiSettings.key,
                modelToUse,
                [{ role: 'user', content: memoryUpdatePrompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 8000,
                    stream: false
                },
                (window.apiSettings.timeout || 60) * 1000
            );
            console.log('è®°å¿†è¡¨æ ¼æ›´æ–°APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));

            // å¤„ç†å“åº”
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('è®°å¿†è¡¨æ ¼æ›´æ–°APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return false;
            }

            const newMemoryTableContent = response.choices[0].message.content;
            if (!newMemoryTableContent || newMemoryTableContent.trim() === '') {
                console.warn('è®°å¿†è¡¨æ ¼æ›´æ–°APIè¿”å›ç©ºå†…å®¹');
                return false;
            }

            // æ›´æ–°è”ç³»äººçš„è®°å¿†è¡¨æ ¼å†…å®¹
            const updateResult = this.updateContactMemoryTable(contact, newMemoryTableContent.trim());
            if (updateResult) {
                console.log('è®°å¿†è¡¨æ ¼æ›´æ–°æˆåŠŸ');
                // ä¿å­˜æ•°æ®
                if (window.saveDataToDB) {
                    await window.saveDataToDB();
                }
                return true;
            }

            return false;
        } catch (error) {
            console.error('ä½¿ç”¨æ¬¡è¦æ¨¡å‹æ›´æ–°è®°å¿†è¡¨æ ¼å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * å¼‚æ­¥æ›´æ–°è®°å¿†è¡¨æ ¼ - ä½¿ç”¨APIé˜Ÿåˆ—
     */
    async updateMemoryTableAsync(contact, options = {}) {
        if (!window.apiRequestQueue) {
            console.warn('APIé˜Ÿåˆ—æœªåˆå§‹åŒ–ï¼Œå›é€€åˆ°åŒæ­¥æ›´æ–°');
            return this.updateMemoryTableWithSecondaryModel(contact);
        }

        const priority = options.priority || window.apiRequestQueue.PRIORITY.LOW;
        const description = `æ›´æ–°${contact.name || contact.nickname || 'è”ç³»äºº'}çš„è®°å¿†è¡¨æ ¼`;
        const EVENT_TYPE = 'memory_update';
        const STATUS_BALL_ID = `special_event_${EVENT_TYPE}`;

        // æ˜¾ç¤ºè®°å¿†æ›´æ–°çŠ¶æ€çƒ
        if (window.statusBallManager && window.STATUS_BALL_CONFIGS?.[EVENT_TYPE]) {
            const queueState = {
                completedTasks: 0,
                totalTasks: 1,
                currentTask: description,
                eventType: EVENT_TYPE,
                config: window.STATUS_BALL_CONFIGS[EVENT_TYPE]
            };
            window.statusBallManager.showSpecialEvent(EVENT_TYPE, queueState);
        }

        return new Promise((resolve) => {
            window.apiRequestQueue.addRequest(
                () => this.updateMemoryTableWithSecondaryModel(contact),
                {
                    priority,
                    description,
                    onComplete: (requestId, result) => {
                        console.log(`è®°å¿†è¡¨æ ¼å¼‚æ­¥æ›´æ–°å®Œæˆ: ${description}`);
                        
                        // æ›´æ–°æ‚¬æµ®çƒçŠ¶æ€ä¸ºå®Œæˆ
                        if (window.statusBallManager && window.STATUS_BALL_CONFIGS?.[EVENT_TYPE]) {
                            const completedState = {
                                completedTasks: 1,
                                totalTasks: 1,
                                currentTask: description,
                                eventType: EVENT_TYPE,
                                config: window.STATUS_BALL_CONFIGS[EVENT_TYPE],
                                completed: true
                            };
                            window.statusBallManager.showSpecialEvent(EVENT_TYPE, completedState);
                            
                            // 3ç§’åè‡ªåŠ¨éšè—
                            setTimeout(() => {
                                if (window.statusBallManager) {
                                    window.statusBallManager.removeState(STATUS_BALL_ID);
                                }
                            }, 3000);
                        }
                        
                        resolve(result);
                    },
                    onError: (requestId, error) => {
                        console.error(`è®°å¿†è¡¨æ ¼å¼‚æ­¥æ›´æ–°å¤±è´¥: ${description}`, error);
                        
                        // éšè—æ‚¬æµ®çƒï¼ˆå¤±è´¥æ—¶ï¼‰
                        if (window.statusBallManager) {
                            window.statusBallManager.removeState(STATUS_BALL_ID);
                        }
                        
                        resolve(false);
                    }
                }
            );
        });
    }

    // è·å–æ¬¡è¦æ¨¡å‹
    getSecondaryModel() {
        const secondaryModel = window.apiSettings?.secondaryModel;
        if (secondaryModel && secondaryModel !== 'sync_with_primary') {
            return secondaryModel;
        }
        // å¦‚æœæ²¡æœ‰é…ç½®æ¬¡è¦æ¨¡å‹ï¼Œä½¿ç”¨ä¸»è¦æ¨¡å‹
        return window.modelSettings?.primaryModel || 'gpt-3.5-turbo';
    }

    // è·å–æœ€è¿‘çš„å¯¹è¯æ¶ˆæ¯
    getRecentMessages(contact, count = 10) {
        if (!contact || !contact.messages) {
            return [];
        }
        
        return contact.messages
            .slice(-count) // å–æœ€è¿‘çš„æ¶ˆæ¯
            .map(msg => ({
                role: msg.type === 'user' ? 'user' : 'assistant',
                content: msg.content,
                timestamp: msg.timestamp
            }));
    }
}

// åˆ›å»ºå…¨å±€è®°å¿†è¡¨ç®¡ç†å™¨å®ä¾‹
window.memoryTableManager = new MemoryTableManager();

// å‘å…¨å±€ä½œç”¨åŸŸæš´éœ²ä¸»è¦å‡½æ•°ï¼Œä¿æŒå‘åå…¼å®¹
window.toggleMemoryPanel = function(forceClose = false) {
    return window.memoryTableManager.toggleMemoryPanel(forceClose);
};

window.toggleMemoryEditMode = function() {
    return window.memoryTableManager.toggleMemoryEditMode();
};

window.renderMemoryTable = function(markdown) {
    return window.memoryTableManager.renderMemoryTable(markdown);
};

window.updateMemoryTableWithSecondaryModel = function(contact, useAsync = true) {
    if (useAsync && window.memoryTableManager && window.memoryTableManager.updateMemoryTableAsync) {
        return window.memoryTableManager.updateMemoryTableAsync(contact);
    }
    return window.memoryTableManager.updateMemoryTableWithSecondaryModel(contact);
};

// æš´éœ²é»˜è®¤æ¨¡æ¿
window.defaultMemoryTable = defaultMemoryTable;

// è‡ªåŠ¨åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    window.memoryTableManager.init();
});

// å¯¼å‡ºæ¨¡å—ï¼ˆå¦‚æœä½¿ç”¨ES6æ¨¡å—ï¼‰
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        MemoryTableManager,
        defaultMemoryTable
    };
}

</script>
    
    <!-- å›¾ç‰‡å’Œæ–‡ä»¶å¤„ç†æ¨¡å— -->
    <script>
/**
 * è¯¦ç»†é”™è¯¯ç±» - æä¾›é”™è¯¯ç±»å‹å’Œç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
 */
class DetailedError extends Error {
    constructor(code, message) {
        super(message);
        this.name = 'DetailedError';
        this.code = code;
    }
}

/**
 * å›¾ç‰‡å­˜å‚¨API - é«˜çº§æ¥å£
 * æä¾›ç®€å•æ˜“ç”¨çš„å›¾ç‰‡å­˜å‚¨å’Œè·å–æ¥å£ï¼Œå°è£…åº•å±‚çš„æ–‡ä»¶å­˜å‚¨ç®¡ç†å™¨
 */

class ImageStorageAPI {
    constructor() {
        this.fileManager = null;
        this.isInitialized = false;
        this.initPromise = null;
    }

    /**
     * åˆå§‹åŒ–å›¾ç‰‡å­˜å‚¨API
     */
    async init() {
        if (this.isInitialized) {
            return this.fileManager;
        }

        if (this.initPromise) {
            return this.initPromise;
        }

        this.initPromise = this._initInternal();
        return this.initPromise;
    }

    async _initInternal() {
        try {
            // ç¡®ä¿UnifiedDBManagerå·²åŠ è½½ï¼ˆé€šè¿‡FileStorageManagerå…¼å®¹æ€§æ˜ å°„ï¼‰
            if (!window.FileStorageManager) {
                throw new Error('UnifiedDBManageræœªåŠ è½½æˆ–FileStorageManageræ˜ å°„æœªè®¾ç½®');
            }

            this.fileManager = window.FileStorageManager;
            await this.fileManager.init();
            
            this.isInitialized = true;
            // å›¾ç‰‡å­˜å‚¨APIåˆå§‹åŒ–å®Œæˆ
            return this.fileManager;
        } catch (error) {
            console.error('å›¾ç‰‡å­˜å‚¨APIåˆå§‹åŒ–å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * å­˜å‚¨å¤´åƒå›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®ï¼ˆbase64å­—ç¬¦ä¸²ã€Fileå¯¹è±¡æˆ–Blobå¯¹è±¡ï¼‰
     * @param {string} entityType - å®ä½“ç±»å‹ï¼ˆ'user' æˆ– 'contact'ï¼‰
     * @param {string} entityId - å®ä½“IDï¼ˆç”¨æˆ·IDæˆ–è”ç³»äººIDï¼‰
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeAvatar(imageData, entityType, entityId) {
        await this.init();

        try {
            // éªŒè¯è¾“å…¥å‚æ•°
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
            }
            
            if (!entityType || !entityId) {
                throw new DetailedError('PARAM_MISSING', 'ç¼ºå°‘å¿…è¦çš„å‚æ•°');
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆå¦‚æœæ˜¯Fileæˆ–Blobå¯¹è±¡ï¼‰
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', 'æ–‡ä»¶å¤§å°è¶…è¿‡10MBé™åˆ¶');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                }
            }

            // å­˜å‚¨æ–‡ä»¶
            const result = await this.fileManager.storeFile(imageData, {
                type: 'avatar',
                entityType: entityType,
                entityId: entityId
            });

            // åˆ›å»ºå¼•ç”¨å…³ç³»
            await this.fileManager.createFileReference(
                result.fileId,
                `avatar_${entityType}`,
                entityId,
                {
                    originalType: entityType,
                    storedAt: new Date().toISOString()
                }
            );

            // å¤´åƒå­˜å‚¨æˆåŠŸ
            return result.fileId;

        } catch (error) {
            console.error(`å­˜å‚¨${entityType}å¤´åƒå¤±è´¥:`, error);
            console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', {
                errorName: error.name,
                errorCode: error.code,
                errorMessage: error.message,
                originalError: error.originalError,
                stackTrace: error.stack,
                entityType: entityType,
                entityId: entityId,
                fileType: imageData instanceof File ? imageData.type : 'unknown',
                fileSize: imageData instanceof File ? imageData.size : 'unknown'
            });
            
            // å¦‚æœæ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„DetailedErroræˆ–è€…å·²ç»æœ‰codeå±æ€§ï¼Œç›´æ¥æŠ›å‡º
            if (error instanceof DetailedError || error.name === 'DetailedError' || error.code) {
                throw error;
            }
            
            // å¤„ç†å…¶ä»–ç±»å‹çš„é”™è¯¯
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æ•°æ®åé‡è¯•');
            }
            
            if (error.name === 'InvalidStateError' || (error.message && error.message.includes('database'))) {
                throw new DetailedError('DATABASE_ERROR', 'æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
            }
            
            if (error.message && (error.message.includes('UnifiedDBManageræœªåŠ è½½') || error.message.includes('FileStorageManageræœªåŠ è½½'))) {
                throw new DetailedError('SYSTEM_ERROR', 'æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿæœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            
            if (error.message && error.message.includes('è¡¨ä¸å­˜åœ¨')) {
                throw new DetailedError('DATABASE_SCHEMA_ERROR', 'æ•°æ®åº“è¡¨ç»“æ„ä¸å®Œæ•´ï¼Œè¯·åˆ·æ–°é¡µé¢é‡æ–°åˆå§‹åŒ–');
            }
            
            // é»˜è®¤é”™è¯¯ - æä¾›æ›´å¤šè°ƒè¯•ä¿¡æ¯
            const errorMsg = error.message || error.toString() || 'æœªçŸ¥é”™è¯¯';
            throw new DetailedError('UNKNOWN_ERROR', `å¤´åƒä¸Šä¼ å¤±è´¥: ${errorMsg}`);
        }
    }

    /**
     * è·å–å¤´åƒå›¾ç‰‡URL
     * @param {string} entityType - å®ä½“ç±»å‹ï¼ˆ'user' æˆ– 'contact'ï¼‰
     * @param {string} entityId - å®ä½“ID
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›ç©ºå­—ç¬¦ä¸²
     */
    async getAvatarURL(entityType, entityId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(`avatar_${entityType}`, entityId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error(`è·å–${entityType}å¤´åƒå¤±è´¥:`, error);
            return '';
        }
    }

    /**
     * å­˜å‚¨èƒŒæ™¯å›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®
     * @param {string} backgroundId - èƒŒæ™¯ID
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeBackground(imageData, backgroundId) {
        await this.init();

        try {
            // éªŒè¯è¾“å…¥å‚æ•°
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', 'æ²¡æœ‰é€‰æ‹©èƒŒæ™¯å›¾ç‰‡');
            }
            
            if (!backgroundId) {
                throw new DetailedError('PARAM_MISSING', 'èƒŒæ™¯IDä¸èƒ½ä¸ºç©º');
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œç±»å‹
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 15 * 1024 * 1024; // 15MBï¼ˆèƒŒæ™¯å›¾ç‰‡å¯ä»¥ç¨å¤§ï¼‰
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', 'èƒŒæ™¯å›¾ç‰‡å¤§å°è¶…è¿‡15MBé™åˆ¶');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ä½œä¸ºèƒŒæ™¯');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'background',
                backgroundId: backgroundId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'background',
                backgroundId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // èƒŒæ™¯å›¾ç‰‡å­˜å‚¨æˆåŠŸ
            return result.fileId;

        } catch (error) {
            console.error('å­˜å‚¨èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
            
            // å¦‚æœæ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„DetailedErrorï¼Œç›´æ¥æŠ›å‡º
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // å¤„ç†å…¶ä»–ç±»å‹çš„é”™è¯¯
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æ•°æ®åé‡è¯•');
            }
            
            if (error.name === 'InvalidStateError' || error.message && error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', 'æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
            }
            
            if (error.message && (error.message.includes('UnifiedDBManageræœªåŠ è½½') || error.message.includes('FileStorageManageræœªåŠ è½½'))) {
                throw new DetailedError('SYSTEM_ERROR', 'æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿæœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            
            // é»˜è®¤é”™è¯¯
            throw new DetailedError('UNKNOWN_ERROR', `èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    }

    /**
     * è·å–èƒŒæ™¯å›¾ç‰‡URL
     * @param {string} backgroundId - èƒŒæ™¯ID
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
     */
    async getBackgroundURL(backgroundId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('background', backgroundId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('è·å–èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
            return '';
        }
    }

    /**
     * å­˜å‚¨è¡¨æƒ…åŒ…å›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®
     * @param {string} emojiTag - è¡¨æƒ…æ ‡ç­¾
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeEmoji(imageData, emojiTag) {
        await this.init();

        try {
            // éªŒè¯è¾“å…¥å‚æ•°
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', 'æ²¡æœ‰é€‰æ‹©è¡¨æƒ…åŒ…å›¾ç‰‡');
            }
            
            if (!emojiTag) {
                throw new DetailedError('PARAM_MISSING', 'è¡¨æƒ…åŒ…æ ‡ç­¾ä¸èƒ½ä¸ºç©º');
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œç±»å‹
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
                const maxSize = 5 * 1024 * 1024; // 5MBï¼ˆè¡¨æƒ…åŒ…é€šå¸¸è¾ƒå°ï¼‰
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', 'è¡¨æƒ…åŒ…å¤§å°è¶…è¿‡5MBé™åˆ¶');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', 'è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ä½œä¸ºè¡¨æƒ…åŒ…');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'emoji',
                tag: emojiTag
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'emoji',
                emojiTag,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // è®¾ç½®å›¾ç‰‡ä½¿ç”¨å…ƒæ•°æ® - è¡¨æƒ…åŒ…åˆ†ç±»
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'emoji',
                tags: [emojiTag],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`è¡¨æƒ…åŒ…å­˜å‚¨æˆåŠŸå¹¶è®¾ç½®åˆ†ç±»: ${emojiTag} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('å­˜å‚¨è¡¨æƒ…åŒ…å¤±è´¥:', error);
            
            // å¦‚æœæ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„DetailedErrorï¼Œç›´æ¥æŠ›å‡º
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // å¤„ç†å…¶ä»–ç±»å‹çš„é”™è¯¯
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', 'å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æ•°æ®åé‡è¯•');
            }
            
            if (error.name === 'InvalidStateError' || error.message && error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', 'æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
            }
            
            if (error.message && (error.message.includes('UnifiedDBManageræœªåŠ è½½') || error.message.includes('FileStorageManageræœªåŠ è½½'))) {
                throw new DetailedError('SYSTEM_ERROR', 'æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿæœªå°±ç»ªï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
            
            // é»˜è®¤é”™è¯¯
            throw new DetailedError('UNKNOWN_ERROR', `è¡¨æƒ…åŒ…ä¸Šä¼ å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    }

    /**
     * è·å–è¡¨æƒ…åŒ…å›¾ç‰‡URL
     * @param {string} emojiTag - è¡¨æƒ…æ ‡ç­¾
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
     */
    async getEmojiURL(emojiTag) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('emoji', emojiTag);
            if (!reference) {
                return '';
            }


            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('è·å–è¡¨æƒ…åŒ…å¤±è´¥:', error);
            return '';
        }
    }

    /**
     * å­˜å‚¨æœ‹å‹åœˆå›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @returns {Promise<string>} è¿”å›fileId
     */
    async storeMomentImage(imageData, momentId) {
        await this.init();

        try {
            // è·å–æ–‡ä»¶å¤§å°ç”¨äºå…ƒæ•°æ®
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'moment',
                momentId: momentId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'moment_image',
                momentId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // è®¾ç½®æœ‹å‹åœˆå›¾ç‰‡åˆ†ç±»
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'moments',
                tags: ['æœ‹å‹åœˆ', momentId],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`æœ‹å‹åœˆå›¾ç‰‡å­˜å‚¨æˆåŠŸå¹¶è®¾ç½®åˆ†ç±»: ${momentId} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('å­˜å‚¨æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–æœ‹å‹åœˆå›¾ç‰‡URL
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URL
     */
    async getMomentImageURL(momentId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('moment_image', momentId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('è·å–æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            return '';
        }
    }

    /**
     * å­˜å‚¨æœ‹å‹åœˆå¤šå›¾ç‰‡
     * @param {Array} imageDataArray - å›¾ç‰‡æ•°æ®æ•°ç»„
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @returns {Promise<Array>} è¿”å›fileIdæ•°ç»„
     */
    async storeMomentImages(imageDataArray, momentId) {
        await this.init();

        try {
            const fileIds = [];

            for (let i = 0; i < imageDataArray.length; i++) {
                const imageData = imageDataArray[i];
                
                // è·å–æ–‡ä»¶å¤§å°
                let fileSize = 0;
                if (imageData instanceof File || imageData instanceof Blob) {
                    fileSize = imageData.size;
                }

                const result = await this.fileManager.storeFile(imageData, {
                    type: 'moment',
                    momentId: momentId,
                    imageIndex: i
                });

                await this.fileManager.createFileReference(
                    result.fileId,
                    'moment_image',
                    `${momentId}_${i}`, // ä½¿ç”¨ç´¢å¼•åŒºåˆ†å¤šå¼ å›¾ç‰‡
                    {
                        storedAt: new Date().toISOString(),
                        imageIndex: i,
                        momentId: momentId
                    }
                );

                // è®¾ç½®æœ‹å‹åœˆå›¾ç‰‡åˆ†ç±»
                await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                    category: 'moments',
                    tags: ['æœ‹å‹åœˆ', momentId, `å›¾ç‰‡${i + 1}`],
                    size: fileSize,
                    createdAt: new Date().toISOString()
                });

                fileIds.push(result.fileId);
            }

            console.log(`æœ‹å‹åœˆå¤šå›¾ç‰‡å­˜å‚¨æˆåŠŸå¹¶è®¾ç½®åˆ†ç±»: ${fileIds.length}å¼ å›¾ç‰‡`);
            return fileIds;

        } catch (error) {
            console.error('å­˜å‚¨æœ‹å‹åœˆå¤šå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–æœ‹å‹åœˆå¤šå›¾ç‰‡URLs
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @param {number} imageCount - å›¾ç‰‡æ•°é‡
     * @returns {Promise<Array>} è¿”å›å›¾ç‰‡URLæ•°ç»„
     */
    async getMomentImagesURLs(momentId, imageCount) {
        await this.init();

        try {
            const urls = [];
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                const reference = await this.fileManager.getFileReference('moment_image', referenceKey);
                if (reference) {
                    const url = await this.fileManager.createFileURL(reference.fileId);
                    urls.push(url);
                } else {
                    console.warn(`æœ‹å‹åœˆå›¾ç‰‡ä¸å­˜åœ¨: ${referenceKey}`);
                }
            }
            return urls;
        } catch (error) {
            console.error('è·å–æœ‹å‹åœˆå¤šå›¾ç‰‡å¤±è´¥:', error);
            return [];
        }
    }

    /**
     * åˆ é™¤æœ‹å‹åœˆæ‰€æœ‰å›¾ç‰‡
     * @param {string} momentId - æœ‹å‹åœˆåŠ¨æ€ID
     * @param {number} imageCount - å›¾ç‰‡æ•°é‡
     */
    async deleteMomentImages(momentId, imageCount) {
        await this.init();

        try {
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                await this.deleteImage('moment_image', referenceKey);
            }
            console.log(`æœ‹å‹åœˆå›¾ç‰‡åˆ é™¤æˆåŠŸ: ${momentId}`);
        } catch (error) {
            console.error('åˆ é™¤æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * åˆ é™¤å›¾ç‰‡
     * @param {string} referenceType - å¼•ç”¨ç±»å‹
     * @param {string} referenceKey - å¼•ç”¨é”®
     */
    async deleteImage(referenceType, referenceKey) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(referenceType, referenceKey);
            if (reference) {
                // åˆ é™¤æ–‡ä»¶
                await this.fileManager.deleteFile(reference.fileId);
                // åˆ é™¤å¼•ç”¨
                await this.fileManager.deleteFileReference(referenceType, referenceKey);
                console.log(`å›¾ç‰‡åˆ é™¤æˆåŠŸ: ${referenceType}/${referenceKey}`);
            }
        } catch (error) {
            console.error('åˆ é™¤å›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ‰¹é‡è¿ç§»base64æ•°æ®åˆ°Blobå­˜å‚¨
     * @param {string} sourceType - æºæ•°æ®ç±»å‹ï¼ˆ'avatars', 'backgrounds', 'emojis'ï¼‰
     * @param {Array} dataArray - è¦è¿ç§»çš„æ•°æ®æ•°ç»„
     * @param {Function} progressCallback - è¿›åº¦å›è°ƒå‡½æ•°
     */
    async migrateBulkData(sourceType, dataArray, progressCallback = null) {
        await this.init();

        const results = {
            success: 0,
            failed: 0,
            errors: []
        };

        for (let i = 0; i < dataArray.length; i++) {
            const item = dataArray[i];
            
            try {
                if (progressCallback) {
                    progressCallback({
                        current: i + 1,
                        total: dataArray.length,
                        item: item,
                        type: sourceType
                    });
                }

                let fileId = null;

                switch (sourceType) {
                    case 'avatars':
                        if (item.avatar && item.avatar.startsWith('data:')) {
                            const entityType = item.type || 'contact'; // å‡è®¾é»˜è®¤ä¸ºcontact
                            fileId = await this.storeAvatar(item.avatar, entityType, item.id);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.avatar = '';
                            item.avatarFileId = fileId;
                        }
                        break;

                    case 'backgrounds':
                        if (item.data && item.data.startsWith('data:')) {
                            fileId = await this.storeBackground(item.data, item.id);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'emojis':
                        if (item.data && item.data.startsWith('data:')) {
                            fileId = await this.storeEmoji(item.data, item.tag);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'moments':
                        if (item.image && item.image.startsWith('data:')) {
                            fileId = await this.storeMomentImage(item.image, item.id);
                            // æ¸…é™¤åŸå§‹base64æ•°æ®
                            item.image = '';
                            item.imageFileId = fileId;
                        }
                        break;
                }

                if (fileId) {
                    results.success++;
                } else {
                    // æ²¡æœ‰éœ€è¦è¿ç§»çš„æ•°æ®
                }

            } catch (error) {
                results.failed++;
                results.errors.push({
                    item: item,
                    error: error.message
                });
                console.error(`è¿ç§»æ•°æ®å¤±è´¥ (${sourceType}):`, error, item);
            }
        }

        return results;
    }

    /**
     * è·å–å­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
     */
    async getStorageStats() {
        await this.init();
        return await this.fileManager.getStorageStats();
    }

    /**
     * æ¸…ç†æœªä½¿ç”¨çš„æ–‡ä»¶
     */
    async cleanupUnusedFiles() {
        await this.init();
        return await this.fileManager.cleanupUnusedFiles();
    }

    /**
     * æ¸…ç†ä¸´æ—¶å¤´åƒå¼•ç”¨
     * æ¸…ç†æ‰€æœ‰ä»¥ 'temp_' å¼€å¤´çš„å¤´åƒå¼•ç”¨
     */
    async cleanupTempAvatarReferences() {
        await this.init();
        
        try {
            // è·å–æ‰€æœ‰å¤´åƒå¼•ç”¨
            const transaction = window.db.transaction(['fileReferences'], 'readwrite');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('avatar_contact');
            
            request.onsuccess = async () => {
                const references = request.result;
                const tempReferences = references.filter(ref => 
                    ref.referenceKey && ref.referenceKey.startsWith('temp_')
                );
                
                console.log(`æ‰¾åˆ° ${tempReferences.length} ä¸ªä¸´æ—¶å¤´åƒå¼•ç”¨ï¼Œå¼€å§‹æ¸…ç†...`);
                
                for (const ref of tempReferences) {
                    try {
                        // åˆ é™¤æ–‡ä»¶å¼•ç”¨
                        await this.fileManager.deleteFileReference('avatar_contact', ref.referenceKey);
                        // å°è¯•åˆ é™¤å¯¹åº”çš„æ–‡ä»¶
                        if (ref.fileId) {
                            await this.fileManager.deleteFile(ref.fileId);
                        }
                        console.log(`æ¸…ç†ä¸´æ—¶å¼•ç”¨: ${ref.referenceId}`);
                    } catch (error) {
                        console.warn(`æ¸…ç†ä¸´æ—¶å¼•ç”¨å¤±è´¥: ${ref.referenceId}`, error);
                    }
                }
                
                console.log('ä¸´æ—¶å¤´åƒå¼•ç”¨æ¸…ç†å®Œæˆ');
            };
            
            request.onerror = () => {
                console.error('è·å–å¤´åƒå¼•ç”¨å¤±è´¥:', request.error);
            };
            
        } catch (error) {
            console.error('æ¸…ç†ä¸´æ—¶å¤´åƒå¼•ç”¨å¤±è´¥:', error);
        }
    }

    // === å›¾ç‰‡åˆ†ç±»ç®¡ç†æ–¹æ³• ===




    /**
     * æ‰‹åŠ¨è®¾ç½®å›¾ç‰‡åˆ†ç±»
     * @param {string} fileId - æ–‡ä»¶ID
     * @param {string} usageType - æ–°çš„ä½¿ç”¨ç±»å‹
     * @param {Object} metadata - é¢å¤–å…ƒæ•°æ®
     */
    async setImageClassification(fileId, usageType, metadata = {}) {
        await this.init();
        return await this.fileManager.setImageUsageMetadata(fileId, usageType, metadata);
    }




    /**
     * æ£€æŸ¥æ˜¯å¦éœ€è¦æ•°æ®è¿ç§»
     */
    async needsMigration() {
        try {
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ—§çš„base64æ•°æ®
            if (!window.db || !window.isIndexedDBReady) {
                return false;
            }

            const transaction = window.db.transaction(['contacts', 'emojiImages', 'backgrounds', 'userProfile', 'moments'], 'readonly');
            
            // æ£€æŸ¥contactsä¸­æ˜¯å¦æœ‰avatar base64æ•°æ®
            const contactsStore = transaction.objectStore('contacts');
            const contactsRequest = contactsStore.getAll();
            
            return new Promise((resolve) => {
                contactsRequest.onsuccess = () => {
                    const contacts = contactsRequest.result;
                    const hasBase64Avatars = contacts.some(contact => 
                        contact.avatar && contact.avatar.startsWith('data:')
                    );
                    
                    resolve(hasBase64Avatars);
                };
                
                contactsRequest.onerror = () => {
                    resolve(false);
                };
            });

        } catch (error) {
            console.error('æ£€æŸ¥è¿ç§»éœ€æ±‚å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * å­˜å‚¨bannerå›¾ç‰‡
     * @param {string|File|Blob} imageData - å›¾ç‰‡æ•°æ®ï¼ˆbase64å­—ç¬¦ä¸²ã€Fileå¯¹è±¡æˆ–Blobå¯¹è±¡ï¼‰
     * @param {string} bannerId - banneræ ‡è¯†ç¬¦
     * @returns {Promise<string>} æ–‡ä»¶ID
     */
    async storeBanner(imageData, bannerId) {
        await this.init();
        
        try {
            console.log('å¼€å§‹å­˜å‚¨bannerå›¾ç‰‡ï¼ŒbannerId:', bannerId);
            
            // å¤„ç†ä¸åŒç±»å‹çš„å›¾ç‰‡æ•°æ®
            let blob;
            if (imageData instanceof Blob) {
                blob = imageData;
                console.log('å¤„ç†Blobæ•°æ®ï¼Œå¤§å°:', blob.size);
            } else if (imageData instanceof File) {
                blob = imageData;
                console.log('å¤„ç†Fileæ•°æ®ï¼Œå¤§å°:', blob.size);
            } else if (typeof imageData === 'string' && imageData.startsWith('data:image/')) {
                // å¤„ç†base64æ•°æ®
                blob = await this._base64ToBlob(imageData);
                console.log('å¤„ç†base64æ•°æ®ï¼Œè½¬æ¢åå¤§å°:', blob.size);
            } else {
                throw new Error('ä¸æ”¯æŒçš„å›¾ç‰‡æ•°æ®æ ¼å¼');
            }

            // å­˜å‚¨æ–‡ä»¶
            const fileResult = await this.fileManager.storeFile(blob, 'image/jpeg');
            console.log('æ–‡ä»¶å­˜å‚¨å®Œæˆï¼Œç»“æœ:', fileResult);
            
            const fileId = fileResult.fileId; // æå–å®é™…çš„æ–‡ä»¶IDå­—ç¬¦ä¸²
            console.log('æå–çš„æ–‡ä»¶IDå­—ç¬¦ä¸²:', fileId);
            
            // åˆ›å»ºå¼•ç”¨
            const referenceId = `banner_${bannerId}`;
            console.log('åˆ›å»ºæ–‡ä»¶å¼•ç”¨ï¼Œå¼•ç”¨ID:', referenceId, 'æ–‡ä»¶ID:', fileId);
            await this.fileManager.createFileReference(fileId, 'banner', bannerId);
            
            console.log(`Bannerå›¾ç‰‡å­˜å‚¨æˆåŠŸ: ${bannerId} -> ${fileId}`);
            return fileId;
            
        } catch (error) {
            console.error('å­˜å‚¨bannerå›¾ç‰‡å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–bannerå›¾ç‰‡URL
     * @param {string} bannerId - banneræ ‡è¯†ç¬¦
     * @returns {Promise<string|null>} å›¾ç‰‡URLï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›null
     */
    async getBannerURL(bannerId) {
        await this.init();
        
        try {
            console.log('æŸ¥æ‰¾bannerï¼ŒbannerId:', bannerId);
            const referenceResult = await this.fileManager.getFileReference('banner', bannerId);
            console.log('è·å–åˆ°çš„å¼•ç”¨ç»“æœ:', referenceResult);
            
            if (!referenceResult || !referenceResult.fileId) {
                console.log('æœªæ‰¾åˆ°banneræ–‡ä»¶å¼•ç”¨æˆ–æ–‡ä»¶ID');
                return null;
            }
            
            const fileId = referenceResult.fileId;
            console.log('æå–çš„æ–‡ä»¶ID:', fileId);
            const url = await this.fileManager.createFileURL(fileId);
            console.log('ç”Ÿæˆçš„banner URL:', url);
            return url;
            
        } catch (error) {
            console.error('è·å–bannerå›¾ç‰‡URLå¤±è´¥:', error);
            return null;
        }
    }

    /**
     * å°†base64è½¬æ¢ä¸ºBlob
     * @private
     */
    async _base64ToBlob(base64) {
        try {
            const [header, data] = base64.split(',');
            const mimeType = header.match(/data:(.+?);/)[1];
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('base64è½¬Blobå¤±è´¥:', error);
            throw new Error('base64æ•°æ®æ ¼å¼é”™è¯¯');
        }
    }
}

// === æ–‡ä»¶ä¸Šä¼ å¤„ç†å‡½æ•° ===

/**
 * é€šç”¨æ–‡ä»¶ä¸Šä¼ å‡½æ•°
 */
async function handleFileUpload(inputId, targetUrlInputId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);
    const targetUrlInput = document.getElementById(targetUrlInputId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    // ä½¿ç”¨ FileReader å°†å›¾ç‰‡è½¬ä¸º Base64
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
        targetUrlInput.value = reader.result;
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('å›¾ç‰‡å·²åŠ è½½');
    };
    reader.onerror = (error) => {
        console.error('æ–‡ä»¶è¯»å–å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'è¯»å–å¤±è´¥';
        if (typeof showToast === 'function') showToast(`è¯»å–å¤±è´¥: ${error.message}`);
    };
}

/**
 * å¤„ç†å¤´åƒä¸Šä¼ 
 */
async function handleAvatarUpload(inputId, entityType, entityId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    try {
        // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨å¤´åƒ
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI æœªåˆå§‹åŒ–');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeAvatar(file, entityType, entityId);
        
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('å¤´åƒå·²ä¿å­˜', 'success');
        
        // è¿”å›æ–‡ä»¶IDç”¨äºåç»­å¤„ç†
        return fileId;
    } catch (error) {
        console.error('å¤´åƒä¸Šä¼ å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ å¤±è´¥';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * å¤„ç†èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ 
 */
async function handleBackgroundUpload(inputId, contactId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    try {
        // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨èƒŒæ™¯å›¾ç‰‡
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI æœªåˆå§‹åŒ–');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeBackground(file, contactId);
        
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('èƒŒæ™¯å›¾ç‰‡å·²ä¿å­˜', 'success');
        
        // è¿”å›æ–‡ä»¶IDç”¨äºåç»­å¤„ç†
        return fileId;
    } catch (error) {
        console.error('èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ å¤±è´¥';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * å¤„ç†è¡¨æƒ…åŒ…ä¸Šä¼ 
 */
async function handleEmojiUpload(inputId, emojiTag, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = 'ä¸Šä¼ ä¸­...';
    
    try {
        // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨è¡¨æƒ…åŒ…
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI æœªåˆå§‹åŒ–');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
        if (typeof showToast === 'function') showToast('è¡¨æƒ…åŒ…å·²ä¿å­˜', 'success');
        
        // è¿”å›æ–‡ä»¶IDç”¨äºåç»­å¤„ç†
        return fileId;
    } catch (error) {
        console.error('è¡¨æƒ…åŒ…ä¸Šä¼ å¤±è´¥:', error);
        if (statusElement) statusElement.textContent = 'ä¸Šä¼ å¤±è´¥';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

// å…¨å±€å˜é‡å­˜å‚¨ä¸´æ—¶ä¸Šä¼ çš„è¡¨æƒ…åŒ…æ–‡ä»¶
let tempEmojiFile = null;

/**
 * å¤„ç†è¡¨æƒ…åŒ…æ–‡ä»¶ä¸Šä¼ 
 */
async function handleEmojiFileUpload(event) {
    try {
        const fileInput = document.getElementById('emojiUploadInput');
        const file = fileInput.files[0];
        
        if (!file) {
            if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
            return;
        }
        
        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
            return;
        }
        
        // ç®€å•å­˜å‚¨æ–‡ä»¶å¯¹è±¡ï¼Œç­‰å¾…ä¿å­˜æ—¶å¤„ç†
        tempEmojiFile = file;
        window.ImageUploadHandlers.tempEmojiFile = file;  // åŒæ­¥æ›´æ–°åˆ°æš´éœ²çš„å¯¹è±¡ä¸­
        
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = 'å›¾ç‰‡å·²é€‰æ‹©';
            statusElement.style.color = '#07c160';
        }
        
        // ç”Ÿæˆä¸´æ—¶URLç”¨äºé¢„è§ˆ
        const tempUrl = URL.createObjectURL(file);
        document.getElementById('emojiUrl').value = `temp:${tempUrl}`;
        
        if (typeof showToast === 'function') showToast('å›¾ç‰‡å·²é€‰æ‹©ï¼Œå¡«å†™æ„æ€åç‚¹å‡»æ·»åŠ ');
        
    } catch (error) {
        console.error('è¡¨æƒ…åŒ…æ–‡ä»¶é€‰æ‹©å¤±è´¥:', error);
        if (typeof showToast === 'function') showToast('æ–‡ä»¶é€‰æ‹©å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

/**
 * ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨è¡¨æƒ…åŒ…çš„è¾…åŠ©å‡½æ•°
 */
async function storeEmojiWithMeaning(file, emojiTag, statusElement) {
    try {
        if (statusElement) statusElement.textContent = 'æ­£åœ¨å­˜å‚¨...';
        
        // ç›´æ¥ä¼ é€’Fileå¯¹è±¡ç»™ImageStorageAPIï¼Œè®©å®ƒå¤„ç†æ•°æ®ç±»å‹è½¬æ¢
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (fileId) {
            document.getElementById('emojiUrl').value = `file:${fileId}`;
            
            if (statusElement) {
                statusElement.textContent = 'å­˜å‚¨æˆåŠŸ';
                statusElement.style.color = '#07c160';
            }
            
            return fileId;
        } else {
            throw new Error('å­˜å‚¨è¿”å›ç©ºçš„æ–‡ä»¶ID');
        }
    } catch (error) {
        console.error('è¡¨æƒ…åŒ…å­˜å‚¨å¤±è´¥:', error);
        if (statusElement) {
            statusElement.textContent = 'å­˜å‚¨å¤±è´¥';
            statusElement.style.color = '#ff3b30';
        }
        if (typeof showToast === 'function') showToast('å­˜å‚¨å¤±è´¥: ' + error.message);
        throw error;
    }
}

/**
 * ç‰¹å®šçš„ä¸Šä¼ å¤„ç†å‡½æ•° - è”ç³»äººå¤´åƒ
 */
async function handleContactAvatarUpload(event, editingContact) {
    try {
        const fileInput = document.getElementById('avatarUploadInput');
        const file = fileInput.files[0];
        const statusElement = document.getElementById('avatarUploadStatus');

        if (!file) {
            if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
            return;
        }

        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
            fileInput.value = '';
            return;
        }

        if (editingContact) {
            // ç¼–è¾‘æ¨¡å¼ï¼šç«‹å³ä¸Šä¼ å’Œä¿å­˜
            const contactId = editingContact.id;

            // å¦‚æœä¹‹å‰æœ‰å¤´åƒï¼Œå…ˆåˆ é™¤æ—§çš„æ–‡ä»¶å¼•ç”¨
            if (editingContact.avatarFileId) {
                try {
                    if (window.ImageStorageAPI) {
                        await window.ImageStorageAPI.deleteImage(`avatar_contact`, contactId);
                    }
                } catch (deleteError) {
                    console.warn('åˆ é™¤æ—§å¤´åƒå¤±è´¥ï¼Œç»§ç»­ä¸Šä¼ æ–°å¤´åƒ:', deleteError);
                }
            }

            const fileId = await handleAvatarUpload('avatarUploadInput', 'contact', contactId, 'avatarUploadStatus');

            if (fileId) {
                document.getElementById('contactAvatar').value = `file:${fileId}`;
                editingContact.avatarFileId = fileId;
                editingContact.avatar = '';

                // åŒæ­¥æ›´æ–°å½“å‰è”ç³»äººå¯¹è±¡
                if (window.currentContact && window.currentContact.id === contactId) {
                    window.currentContact.avatarFileId = fileId;
                    window.currentContact.avatar = '';
                }

                // åˆ·æ–°UIæ˜¾ç¤º
                if (window.ImageDisplayHelper) {
                    window.ImageDisplayHelper.clearCacheByType(`avatar_contact_${contactId}`);
                }

                if (typeof renderContactList === 'function') {
                    try {
                        await renderContactList();
                    } catch (error) {
                        console.warn('åˆ·æ–°è”ç³»äººåˆ—è¡¨å¤±è´¥:', error);
                    }
                }
            }
        } else {
            // æ–°å»ºæ¨¡å¼ï¼šç±»ä¼¼emojiçš„ä¸´æ—¶å­˜å‚¨
            window.tempContactAvatarFile = file;

            // ç”Ÿæˆä¸´æ—¶URLç”¨äºé¢„è§ˆ
            const tempUrl = URL.createObjectURL(file);
            document.getElementById('contactAvatar').value = `temp:${tempUrl}`;

            if (statusElement) {
                statusElement.textContent = 'å¤´åƒå·²é€‰æ‹©';
                statusElement.style.color = '#07c160';
            }

            if (typeof showToast === 'function') showToast('å¤´åƒå·²é€‰æ‹©ï¼Œå¡«å†™å®Œä¿¡æ¯åç‚¹å‡»ç¡®å®š');
        }

    } catch (error) {
        console.error('è”ç³»äººå¤´åƒå¤„ç†å¤±è´¥:', error);
        const statusElement = document.getElementById('avatarUploadStatus');
        if (statusElement) {
            statusElement.textContent = 'å¤„ç†å¤±è´¥';
            statusElement.style.color = '#ff3b30';
        }
    }
}

/**
 * ç‰¹å®šçš„ä¸Šä¼ å¤„ç†å‡½æ•° - ç”¨æˆ·å¤´åƒ
 */
async function handleProfileAvatarUpload(event) {
    try {
        const fileId = await handleAvatarUpload('profileUploadInput', 'user', 'profile', 'profileUploadStatus');
        
        if (fileId) {
            // æ›´æ–°éšè—çš„URLè¾“å…¥æ¡†ä¸ºæ–‡ä»¶IDå¼•ç”¨
            document.getElementById('profileAvatarInput').value = `file:${fileId}`;
            
            // æ¸…ç†å¤´åƒç¼“å­˜
            if (window.ImageDisplayHelper) {
                window.ImageDisplayHelper.clearCacheByType('avatar_user_');
            }
            
            // è®¾ç½®æŒä¹…çŠ¶æ€æç¤º
            const statusElement = document.getElementById('profileUploadStatus');
            if (statusElement) {
                statusElement.textContent = 'å·²ä¸Šä¼ ';
                statusElement.style.color = '#07c160';
            }
            
            // ç«‹å³æ›´æ–°UI
            if (typeof updateUserProfileUI === 'function') {
                await updateUserProfileUI();
            }
        }
    } catch (error) {
        console.error('ä¸ªäººå¤´åƒä¸Šä¼ å¤±è´¥:', error);
    }
}

/**
 * ç‰¹å®šçš„ä¸Šä¼ å¤„ç†å‡½æ•° - èƒŒæ™¯å›¾ç‰‡
 */
async function handleBgUpload(event) {
    try {
        // ä»å…¨å±€å˜é‡è·å–currentContact
        const currentContact = window.currentContact;
        if (!currentContact) {
            if (typeof showToast === 'function') showToast('è¯·å…ˆé€‰æ‹©è”ç³»äºº');
            return;
        }
        
        const fileId = await handleBackgroundUpload('bgUploadInput', currentContact.id, 'bgUploadStatus');
        
        if (fileId) {
            // æ›´æ–°éšè—çš„URLè¾“å…¥æ¡†ä¸ºæ–‡ä»¶IDå¼•ç”¨
            document.getElementById('backgroundUrl').value = `file:${fileId}`;
        }
    } catch (error) {
        console.error('èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const imageStorageAPI = new ImageStorageAPI();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.ImageStorageAPI = imageStorageAPI;

// åˆ›å»ºå‘½åç©ºé—´å¹¶æš´éœ²ä¸Šä¼ å¤„ç†å‡½æ•°
window.ImageUploadHandlers = {
    handleFileUpload,
    handleAvatarUpload,
    handleBackgroundUpload,
    handleEmojiUpload,
    handleEmojiFileUpload,
    storeEmojiWithMeaning,
    handleContactAvatarUpload,
    handleProfileAvatarUpload,
    handleBgUpload,
    tempEmojiFile
};

// ä¸ºäº†å‘åå…¼å®¹ï¼Œä¿ç•™ä¸»è¦çš„å…¨å±€å¼•ç”¨
// TODO: Remove these global assignments once all code is updated to use ImageUploadHandlers.
window.handleContactAvatarUpload = handleContactAvatarUpload;
window.handleProfileAvatarUpload = handleProfileAvatarUpload;

// å›¾ç‰‡å­˜å‚¨APIå·²åŠ è½½
</script>
    <script>
/**
 * å›¾ç‰‡æ˜¾ç¤ºå¸®åŠ©å·¥å…·
 * æä¾›å‘åå…¼å®¹çš„å›¾ç‰‡URLè·å–åŠŸèƒ½ï¼Œæ”¯æŒæ–°çš„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿå’Œæ—§çš„base64æ ¼å¼
 */

class ImageDisplayHelper {
    constructor() {
        this.urlCache = new Map();
        this.imageAPI = null;
    }

    /**
     * åˆå§‹åŒ–
     */
    async init() {
        if (!this.imageAPI && window.ImageStorageAPI) {
            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
        }
    }

    /**
     * è·å–å¤´åƒURLï¼ˆæ”¯æŒè”ç³»äººå’Œç”¨æˆ·ï¼‰
     * @param {Object} entity - è”ç³»äººæˆ–ç”¨æˆ·å¯¹è±¡
     * @param {string} entityType - 'contact' æˆ– 'user'
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getAvatarURL(entity, entityType = 'contact') {
        if (!entity) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (entity.avatarFileId && this.imageAPI) {
                // ä¸ºç”¨æˆ·ç±»å‹ä½¿ç”¨å›ºå®šçš„idï¼Œå› ä¸ºç”¨æˆ·å¯¹è±¡é€šå¸¸æ²¡æœ‰idå­—æ®µ
                const entityId = entityType === 'user' ? 'profile' : entity.id;
                const cacheKey = `avatar_${entityType}_${entityId}`;
                
                // æ£€æŸ¥ç¼“å­˜ï¼Œä½†å¦‚æœæœ‰æ–°çš„avatarFileIdï¼Œå…ˆæ¸…ç†æ—§ç¼“å­˜
                if (this.urlCache.has(cacheKey)) {
                    const cachedUrl = this.urlCache.get(cacheKey);
                    // è·å–å½“å‰å®é™…çš„æ–‡ä»¶å¼•ç”¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
                    const currentReference = await this.imageAPI.getAvatarURL(entityType, entityId);
                    if (currentReference && currentReference !== cachedUrl) {
                        // æ–‡ä»¶å¼•ç”¨å·²å˜åŒ–ï¼Œæ¸…ç†æ—§ç¼“å­˜
                        URL.revokeObjectURL(cachedUrl);
                        this.urlCache.delete(cacheKey);
                    } else if (cachedUrl) {
                        return cachedUrl;
                    }
                }
                
                const url = await this.imageAPI.getAvatarURL(entityType, entityId);
                if (url) {
                    this.urlCache.set(cacheKey, url);
                }
                return url;
            }
            
            // å›é€€åˆ°æ—§çš„base64æ ¼å¼
            if (entity.avatar && entity.avatar.startsWith('data:')) {
                return entity.avatar;
            }
            
            return '';
            
        } catch (error) {
            console.warn(`è·å–${entityType}å¤´åƒå¤±è´¥:`, error);
            // å›é€€åˆ°æ—§æ ¼å¼
            return entity.avatar || '';
        }
    }

    /**
     * è·å–èƒŒæ™¯å›¾ç‰‡URL
     * @param {Object} background - èƒŒæ™¯å¯¹è±¡
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getBackgroundURL(background) {
        if (!background) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (background.fileId && this.imageAPI) {
                const cacheKey = `background_${background.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getBackgroundURL(background.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // å›é€€åˆ°æ—§æ ¼å¼
            if (background.data && background.data.startsWith('data:')) {
                return background.data;
            }
            
            return background.url || '';
            
        } catch (error) {
            console.warn('è·å–èƒŒæ™¯å›¾ç‰‡å¤±è´¥:', error);
            return background.data || background.url || '';
        }
    }

    /**
     * è·å–è¡¨æƒ…åŒ…URL
     * @param {Object} emoji - è¡¨æƒ…åŒ…å¯¹è±¡
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getEmojiURL(emoji) {
        if (!emoji) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (emoji.fileId && this.imageAPI) {
                const cacheKey = `emoji_${emoji.tag}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getEmojiURL(emoji.tag);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // å›é€€åˆ°æ—§æ ¼å¼
            if (emoji.data && emoji.data.startsWith('data:')) {
                return emoji.data;
            }
            
            return emoji.url || '';
            
        } catch (error) {
            console.warn('è·å–è¡¨æƒ…åŒ…å¤±è´¥:', error);
            return emoji.data || emoji.url || '';
        }
    }

    /**
     * è·å–æœ‹å‹åœˆå›¾ç‰‡URL
     * @param {Object} moment - æœ‹å‹åœˆåŠ¨æ€å¯¹è±¡
     * @returns {Promise<string>} è¿”å›å›¾ç‰‡URLæˆ–ç©ºå­—ç¬¦ä¸²
     */
    async getMomentImageURL(moment) {
        if (!moment) return '';
        
        try {
            await this.init();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ–‡ä»¶å¼•ç”¨
            if (moment.imageFileId && this.imageAPI) {
                const cacheKey = `moment_${moment.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getMomentImageURL(moment.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // å›é€€åˆ°æ—§æ ¼å¼
            if (moment.image && moment.image.startsWith('data:')) {
                return moment.image;
            }
            
            return moment.imageUrl || '';
            
        } catch (error) {
            console.warn('è·å–æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
            return moment.image || moment.imageUrl || '';
        }
    }

    /**
     * åˆ›å»ºå¤´åƒHTMLå…ƒç´ ï¼ˆå‘åå…¼å®¹ï¼‰
     * @param {Object} entity - è”ç³»äººæˆ–ç”¨æˆ·å¯¹è±¡  
     * @param {string} entityType - 'contact' æˆ– 'user'
     * @param {string} className - CSSç±»åï¼ˆå¯é€‰ï¼‰
     * @returns {Promise<string>} è¿”å›HTMLå­—ç¬¦ä¸²
     */
    async createAvatarHTML(entity, entityType = 'contact', className = '') {
        if (!entity) return '';
        
        const avatarURL = await this.getAvatarURL(entity, entityType);
        const classAttr = className ? ` class="${className}"` : '';
        
        if (avatarURL) {
            return `<img src="${avatarURL}"${classAttr}>`;
        } else {
            // ä½¿ç”¨é¦–å­—ç¬¦ä½œä¸ºé»˜è®¤å¤´åƒ
            const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? 'æˆ‘' : '?');
            return `<span${classAttr}>${firstChar}</span>`;
        }
    }

    /**
     * æ¸…ç†URLç¼“å­˜
     */
    clearCache() {
        this.urlCache.clear();
    }

    /**
     * æ¸…ç†ç‰¹å®šç±»å‹çš„ç¼“å­˜
     * @param {string} type - ç¼“å­˜ç±»å‹å‰ç¼€ï¼ˆå¦‚ 'avatar_', 'background_'ï¼‰
     */
    clearCacheByType(type) {
        for (const [key, url] of this.urlCache) {
            if (key.startsWith(type)) {
                // é‡Šæ”¾Blob URLä»¥é˜²æ­¢å†…å­˜æ³„æ¼
                if (url && url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
                this.urlCache.delete(key);
            }
        }
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const imageDisplayHelper = new ImageDisplayHelper();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.ImageDisplayHelper = imageDisplayHelper;

// å›¾ç‰‡æ˜¾ç¤ºå¸®åŠ©å·¥å…·å·²åŠ è½½
</script>
    <script>
/**
 * å›¾ç‰‡æ•°æ®è¿ç§»ç®¡ç†å™¨
 * è´Ÿè´£å°†ç°æœ‰çš„base64å›¾ç‰‡æ•°æ®è¿ç§»åˆ°æ–°çš„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ
 */

class ImageMigrationManager {
    constructor() {
        this.imageAPI = null;
        this.isInitialized = false;
    }

    /**
     * åˆå§‹åŒ–è¿ç§»ç®¡ç†å™¨
     */
    async init() {
        if (this.isInitialized) {
            return;
        }

        try {
            // ç¡®ä¿å›¾ç‰‡å­˜å‚¨APIå·²åŠ è½½
            if (!window.ImageStorageAPI) {
                throw new Error('ImageStorageAPIæœªåŠ è½½');
            }

            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
            
            this.isInitialized = true;
            // å›¾ç‰‡è¿ç§»ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
        } catch (error) {
            console.error('å›¾ç‰‡è¿ç§»ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ£€æŸ¥æ˜¯å¦éœ€è¦è¿›è¡Œå›¾ç‰‡æ•°æ®è¿ç§»
     */
    async checkMigrationNeeded() {
        if (!window.db || !window.isIndexedDBReady) {
            return {
                needed: false,
                reason: 'æ•°æ®åº“æœªå‡†å¤‡å°±ç»ª'
            };
        }

        try {
            const migrationStatus = {
                needed: false,
                details: {
                    contacts: { count: 0, needsMigration: 0 },
                    userProfile: { count: 0, needsMigration: 0 },
                    emojiImages: { count: 0, needsMigration: 0 },
                    backgrounds: { count: 0, needsMigration: 0 },
                    moments: { count: 0, needsMigration: 0 }
                },
                totalFiles: 0
            };

            // æ£€æŸ¥è”ç³»äººå¤´åƒ
            const contactsData = await this.getDataFromStore('contacts');
            migrationStatus.details.contacts.count = contactsData.length;
            migrationStatus.details.contacts.needsMigration = contactsData.filter(
                contact => contact.avatar && contact.avatar.startsWith('data:') && !contact.avatarFileId
            ).length;

            // æ£€æŸ¥ç”¨æˆ·èµ„æ–™å¤´åƒ
            const userProfileData = await this.getDataFromStore('userProfile');
            migrationStatus.details.userProfile.count = userProfileData.length;
            migrationStatus.details.userProfile.needsMigration = userProfileData.filter(
                profile => profile.avatar && profile.avatar.startsWith('data:') && !profile.avatarFileId
            ).length;

            // æ£€æŸ¥è¡¨æƒ…åŒ…å›¾ç‰‡
            const emojiImagesData = await this.getDataFromStore('emojiImages');
            migrationStatus.details.emojiImages.count = emojiImagesData.length;
            migrationStatus.details.emojiImages.needsMigration = emojiImagesData.filter(
                emoji => emoji.data && emoji.data.startsWith('data:') && !emoji.fileId
            ).length;

            // æ£€æŸ¥èƒŒæ™¯å›¾ç‰‡ - backgroundsä»¥ç‰¹æ®Šæ–¹å¼å­˜å‚¨ä¸ºå•ä¸ªè®°å½•
            const backgroundsRecord = await this.getBackgroundsRecord();
            let backgroundsCount = 0;
            let backgroundsNeedsMigration = 0;
            
            if (backgroundsRecord && backgroundsRecord.id === 'backgroundsMap') {
                // æ£€æŸ¥æ¯ä¸ªè”ç³»äººçš„èƒŒæ™¯å›¾ç‰‡
                for (const [contactId, backgroundUrl] of Object.entries(backgroundsRecord)) {
                    if (contactId === 'id') continue; // è·³è¿‡idå­—æ®µ
                    backgroundsCount++;
                    if (backgroundUrl && backgroundUrl.startsWith('data:')) {
                        backgroundsNeedsMigration++;
                    }
                }
            }
            
            migrationStatus.details.backgrounds.count = backgroundsCount;
            migrationStatus.details.backgrounds.needsMigration = backgroundsNeedsMigration;

            // æ£€æŸ¥æœ‹å‹åœˆå›¾ç‰‡
            const momentsData = await this.getDataFromStore('moments');
            migrationStatus.details.moments.count = momentsData.length;
            migrationStatus.details.moments.needsMigration = momentsData.filter(
                moment => moment.image && moment.image.startsWith('data:') && !moment.imageFileId
            ).length;

            // è®¡ç®—æ€»è®¡
            migrationStatus.totalFiles = Object.values(migrationStatus.details)
                .reduce((sum, detail) => sum + detail.needsMigration, 0);

            migrationStatus.needed = migrationStatus.totalFiles > 0;

            return migrationStatus;

        } catch (error) {
            console.error('æ£€æŸ¥è¿ç§»çŠ¶æ€å¤±è´¥:', error);
            return {
                needed: false,
                error: error.message
            };
        }
    }

    /**
     * ä»æŒ‡å®šå­˜å‚¨è·å–æ•°æ®
     */
    async getDataFromStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * è·å–backgroundsè®°å½•ï¼ˆç‰¹æ®Šå­˜å‚¨ç»“æ„ï¼‰
     */
    async getBackgroundsRecord() {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction(['backgrounds'], 'readonly');
            const store = transaction.objectStore('backgrounds');
            const request = store.get('backgroundsMap');

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * æ›´æ–°backgroundsè®°å½•ï¼ˆç‰¹æ®Šå­˜å‚¨ç»“æ„ï¼‰
     */
    async updateBackgroundsRecord(backgroundsRecord) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction(['backgrounds'], 'readwrite');
            const store = transaction.objectStore('backgrounds');
            const request = store.put(backgroundsRecord);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * æ›´æ–°å­˜å‚¨ä¸­çš„æ•°æ®
     */
    async updateDataInStore(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const updatePromises = data.map(item => {
                return new Promise((resolveItem, rejectItem) => {
                    const request = store.put(item);
                    request.onsuccess = () => resolveItem();
                    request.onerror = () => rejectItem(request.error);
                });
            });

            Promise.all(updatePromises)
                .then(() => resolve())
                .catch(error => reject(error));
        });
    }

    /**
     * æ‰§è¡Œå®Œæ•´çš„æ•°æ®è¿ç§»
     */
    async performFullMigration(progressCallback = null) {
        await this.init();

        const migrationStatus = await this.checkMigrationNeeded();
        if (!migrationStatus.needed) {
            return {
                success: true,
                message: 'æ— éœ€è¿ç§»ï¼Œæ‰€æœ‰å›¾ç‰‡æ•°æ®å·²æ˜¯æœ€æ–°æ ¼å¼',
                results: {}
            };
        }

        const results = {
            contacts: { success: 0, failed: 0, errors: [] },
            userProfile: { success: 0, failed: 0, errors: [] },
            emojiImages: { success: 0, failed: 0, errors: [] },
            backgrounds: { success: 0, failed: 0, errors: [] },
            moments: { success: 0, failed: 0, errors: [] }
        };

        let totalProcessed = 0;
        const totalFiles = migrationStatus.totalFiles;

        try {
            // è¿ç§»è”ç³»äººå¤´åƒ
            if (migrationStatus.details.contacts.needsMigration > 0) {
                const contactsData = await this.getDataFromStore('contacts');
                const contactsToMigrate = contactsData.filter(
                    contact => contact.avatar && contact.avatar.startsWith('data:') && !contact.avatarFileId
                );

                for (const contact of contactsToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: 'è”ç³»äººå¤´åƒ',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: contact.name || contact.id
                            });
                        }

                        const fileId = await this.imageAPI.storeAvatar(contact.avatar, 'contact', contact.id);
                        contact.avatar = ''; // æ¸…é™¤base64æ•°æ®
                        contact.avatarFileId = fileId; // ä¿å­˜æ–‡ä»¶å¼•ç”¨
                        
                        results.contacts.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.contacts.failed++;
                        results.contacts.errors.push({
                            item: contact,
                            error: error.message
                        });
                        console.error('è¿ç§»è”ç³»äººå¤´åƒå¤±è´¥:', error);
                    }
                }

                // æ›´æ–°è”ç³»äººæ•°æ®
                await this.updateDataInStore('contacts', contactsData);
            }

            // è¿ç§»ç”¨æˆ·èµ„æ–™å¤´åƒ
            if (migrationStatus.details.userProfile.needsMigration > 0) {
                const userProfileData = await this.getDataFromStore('userProfile');
                const profilesToMigrate = userProfileData.filter(
                    profile => profile.avatar && profile.avatar.startsWith('data:') && !profile.avatarFileId
                );

                for (const profile of profilesToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: 'ç”¨æˆ·å¤´åƒ',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: profile.name || 'ç”¨æˆ·èµ„æ–™'
                            });
                        }

                        const fileId = await this.imageAPI.storeAvatar(profile.avatar, 'user', profile.id);
                        profile.avatar = '';
                        profile.avatarFileId = fileId;
                        
                        results.userProfile.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.userProfile.failed++;
                        results.userProfile.errors.push({
                            item: profile,
                            error: error.message
                        });
                        console.error('è¿ç§»ç”¨æˆ·å¤´åƒå¤±è´¥:', error);
                    }
                }

                await this.updateDataInStore('userProfile', userProfileData);
            }

            // è¿ç§»è¡¨æƒ…åŒ…å›¾ç‰‡
            if (migrationStatus.details.emojiImages.needsMigration > 0) {
                const emojiImagesData = await this.getDataFromStore('emojiImages');
                const emojisToMigrate = emojiImagesData.filter(
                    emoji => emoji.data && emoji.data.startsWith('data:') && !emoji.fileId
                );

                for (const emoji of emojisToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: 'è¡¨æƒ…åŒ…',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: emoji.tag
                            });
                        }

                        const fileId = await this.imageAPI.storeEmoji(emoji.data, emoji.tag);
                        emoji.data = '';
                        emoji.fileId = fileId;
                        
                        results.emojiImages.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.emojiImages.failed++;
                        results.emojiImages.errors.push({
                            item: emoji,
                            error: error.message
                        });
                        console.error('è¿ç§»è¡¨æƒ…åŒ…å¤±è´¥:', error);
                    }
                }

                await this.updateDataInStore('emojiImages', emojiImagesData);
            }

            // è¿ç§»èƒŒæ™¯å›¾ç‰‡ - ç‰¹æ®Šå¤„ç†backgroundsçš„å­˜å‚¨ç»“æ„
            if (migrationStatus.details.backgrounds.needsMigration > 0) {
                const backgroundsRecord = await this.getBackgroundsRecord();
                
                if (backgroundsRecord && backgroundsRecord.id === 'backgroundsMap') {
                    for (const [contactId, backgroundUrl] of Object.entries(backgroundsRecord)) {
                        if (contactId === 'id') continue; // è·³è¿‡idå­—æ®µ
                        
                        if (backgroundUrl && backgroundUrl.startsWith('data:')) {
                            try {
                                if (progressCallback) {
                                    progressCallback({
                                        type: 'èƒŒæ™¯å›¾ç‰‡',
                                        current: totalProcessed + 1,
                                        total: totalFiles,
                                        item: `è”ç³»äºº ${contactId}`
                                    });
                                }

                                const fileId = await this.imageAPI.storeBackground(backgroundUrl, contactId);
                                
                                // æ¸…ç©ºbase64æ•°æ®ï¼Œæ ‡è®°ä¸ºå·²è¿ç§»
                                // è¿ç§»åçš„èƒŒæ™¯å°†é€šè¿‡getBackgroundImageURLå‡½æ•°åŠ¨æ€è·å–
                                backgroundsRecord[contactId] = `file:${fileId}`;
                                
                                results.backgrounds.success++;
                                totalProcessed++;
                            } catch (error) {
                                results.backgrounds.failed++;
                                results.backgrounds.errors.push({
                                    item: { contactId, backgroundUrl },
                                    error: error.message
                                });
                                console.error(`è¿ç§»èƒŒæ™¯å›¾ç‰‡å¤±è´¥ (è”ç³»äºº ${contactId}):`, error);
                            }
                        }
                    }

                    await this.updateBackgroundsRecord(backgroundsRecord);
                }
            }

            // è¿ç§»æœ‹å‹åœˆå›¾ç‰‡
            if (migrationStatus.details.moments.needsMigration > 0) {
                const momentsData = await this.getDataFromStore('moments');
                const momentsToMigrate = momentsData.filter(
                    moment => moment.image && moment.image.startsWith('data:') && !moment.imageFileId
                );

                for (const moment of momentsToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: 'æœ‹å‹åœˆå›¾ç‰‡',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: moment.authorName || 'åŠ¨æ€'
                            });
                        }

                        const fileId = await this.imageAPI.storeMomentImage(moment.image, moment.id);
                        moment.image = '';
                        moment.imageFileId = fileId;
                        
                        results.moments.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.moments.failed++;
                        results.moments.errors.push({
                            item: moment,
                            error: error.message
                        });
                        console.error('è¿ç§»æœ‹å‹åœˆå›¾ç‰‡å¤±è´¥:', error);
                    }
                }

                await this.updateDataInStore('moments', momentsData);
            }

            // æ±‡æ€»ç»“æœ
            const totalSuccess = Object.values(results).reduce((sum, result) => sum + result.success, 0);
            const totalFailed = Object.values(results).reduce((sum, result) => sum + result.failed, 0);

            return {
                success: true,
                message: `è¿ç§»å®Œæˆï¼æˆåŠŸ: ${totalSuccess}, å¤±è´¥: ${totalFailed}`,
                results: results,
                summary: {
                    totalProcessed: totalSuccess + totalFailed,
                    totalSuccess: totalSuccess,
                    totalFailed: totalFailed
                }
            };

        } catch (error) {
            console.error('æ•°æ®è¿ç§»è¿‡ç¨‹å‡ºé”™:', error);
            return {
                success: false,
                error: error.message,
                results: results
            };
        }
    }

    /**
     * ä¼°ç®—è¿ç§»åçš„å­˜å‚¨ç©ºé—´èŠ‚çœ
     */
    async estimateStorageSavings(migrationStatus) {
        if (!migrationStatus || !migrationStatus.needed) {
            return {
                estimatedSavings: 0,
                details: {}
            };
        }

        // base64æ¯”åŸå§‹äºŒè¿›åˆ¶æ•°æ®å¤§çº¦å¤š33%
        const base64Overhead = 0.33;
        
        // è¿™é‡Œåªæ˜¯ä¸€ä¸ªç²—ç•¥ä¼°ç®—ï¼Œå®é™…èŠ‚çœå–å†³äºå…·ä½“çš„å›¾ç‰‡å¤§å°
        const estimatedSavingsPerFile = 50 * 1024; // å‡è®¾å¹³å‡æ¯ä¸ªæ–‡ä»¶èŠ‚çœ50KB
        const totalEstimatedSavings = migrationStatus.totalFiles * estimatedSavingsPerFile;

        return {
            estimatedSavings: totalEstimatedSavings,
            formattedSavings: this.formatBytes(totalEstimatedSavings),
            details: {
                filesToMigrate: migrationStatus.totalFiles,
                averageSavingsPerFile: estimatedSavingsPerFile,
                base64Overhead: base64Overhead
            }
        };
    }

    /**
     * æ ¼å¼åŒ–å­—èŠ‚æ•°
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const imageMigrationManager = new ImageMigrationManager();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.ImageMigrationManager = imageMigrationManager;

// å›¾ç‰‡è¿ç§»ç®¡ç†å™¨å·²åŠ è½½
</script>
    <script>
/**
 * èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»ç®¡ç†å™¨
 * ä¸“é—¨å¤„ç†èŠå¤©è®°å½•ä¸­è¡¨æƒ…åŒ…ä»base64åˆ°æ–°æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿçš„è¿ç§»
 */

class ChatEmojiMigrationManager {
    constructor() {
        this.imageAPI = null;
        this.isInitialized = false;
    }

    /**
     * åˆå§‹åŒ–è¿ç§»ç®¡ç†å™¨
     */
    async init() {
        if (this.isInitialized) {
            return;
        }

        try {
            // ç¡®ä¿å›¾ç‰‡å­˜å‚¨APIå·²åŠ è½½
            if (!window.ImageStorageAPI) {
                throw new Error('ImageStorageAPIæœªåŠ è½½');
            }

            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
            
            this.isInitialized = true;
            // èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
        } catch (error) {
            console.error('èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ£€æŸ¥èŠå¤©è®°å½•ä¸­æ˜¯å¦å­˜åœ¨éœ€è¦è¿ç§»çš„è¡¨æƒ…åŒ…
     */
    async checkChatEmojiMigrationNeeded() {
        if (!window.db || !window.isIndexedDBReady) {
            return {
                needed: false,
                reason: 'æ•°æ®åº“æœªå‡†å¤‡å°±ç»ª'
            };
        }

        try {
            const migrationStatus = {
                needed: false,
                details: {
                    totalContacts: 0,
                    contactsNeedingMigration: 0,
                    totalMessages: 0,
                    messagesNeedingMigration: 0,
                    base64EmojisFound: 0,
                    emojiImagesNeedingMigration: 0
                },
                contactDetails: []
            };

            // è·å–æ‰€æœ‰è”ç³»äººæ•°æ®
            const contactsData = await this.getDataFromStore('contacts');
            migrationStatus.details.totalContacts = contactsData.length;

            // æ£€æŸ¥æ¯ä¸ªè”ç³»äººçš„èŠå¤©è®°å½•
            for (const contact of contactsData) {
                if (contact.messages && Array.isArray(contact.messages)) {
                    const contactDetail = {
                        contactId: contact.id,
                        contactName: contact.name,
                        messagesCount: contact.messages.length,
                        base64EmojisCount: 0,
                        needsMigration: false
                    };

                    migrationStatus.details.totalMessages += contact.messages.length;

                    for (const message of contact.messages) {
                        if (message.content && typeof message.content === 'string') {
                            // æ£€æŸ¥base64å›¾ç‰‡
                            const base64Matches = message.content.match(/data:image\/[^;]+;base64,[A-Za-z0-9+\/=]+/g);
                            if (base64Matches) {
                                contactDetail.base64EmojisCount += base64Matches.length;
                                migrationStatus.details.base64EmojisFound += base64Matches.length;
                                contactDetail.needsMigration = true;
                            }
                        }
                    }

                    if (contactDetail.needsMigration) {
                        migrationStatus.details.contactsNeedingMigration++;
                        migrationStatus.details.messagesNeedingMigration += contactDetail.base64EmojisCount;
                        migrationStatus.contactDetails.push(contactDetail);
                    }
                }
            }

            // æ£€æŸ¥emojiImagesè¡¨ä¸­æ˜¯å¦æœ‰æ•°æ®éœ€è¦è¿ç§»åˆ°æ–°ç³»ç»Ÿ
            const emojiImagesData = await this.getDataFromStore('emojiImages');
            const emojiImagesNeedingMigration = emojiImagesData.filter(img => img.data && img.data.startsWith('data:'));
            migrationStatus.details.emojiImagesNeedingMigration = emojiImagesNeedingMigration.length;

            // åˆ¤æ–­æ˜¯å¦éœ€è¦è¿ç§»
            migrationStatus.needed = migrationStatus.details.base64EmojisFound > 0 || 
                                   migrationStatus.details.emojiImagesNeedingMigration > 0;

            return migrationStatus;

        } catch (error) {
            console.error('æ£€æŸ¥èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»çŠ¶æ€å¤±è´¥:', error);
            return {
                needed: false,
                error: error.message
            };
        }
    }

    /**
     * ä»æŒ‡å®šå­˜å‚¨è·å–æ•°æ®
     */
    async getDataFromStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * æ›´æ–°å­˜å‚¨ä¸­çš„æ•°æ®
     */
    async updateDataInStore(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const updatePromises = data.map(item => {
                return new Promise((resolveItem, rejectItem) => {
                    const request = store.put(item);
                    request.onsuccess = () => resolveItem();
                    request.onerror = () => rejectItem(request.error);
                });
            });

            Promise.all(updatePromises)
                .then(() => resolve())
                .catch(error => reject(error));
        });
    }

    /**
     * æ‰§è¡ŒèŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»
     */
    async performChatEmojiMigration(progressCallback = null) {
        await this.init();

        const migrationStatus = await this.checkChatEmojiMigrationNeeded();
        if (!migrationStatus.needed) {
            return {
                success: true,
                message: 'æ— éœ€è¿ç§»ï¼ŒèŠå¤©è®°å½•ä¸­çš„è¡¨æƒ…åŒ…å·²æ˜¯æœ€æ–°æ ¼å¼',
                results: {}
            };
        }

        const results = {
            contactsMigrated: 0,
            messagesMigrated: 0,
            emojiImagesMigrated: 0,
            base64EmojisMigrated: 0,
            errors: []
        };

        let totalProcessed = 0;
        const totalItems = migrationStatus.details.base64EmojisFound + 
                          migrationStatus.details.emojiImagesNeedingMigration;

        try {
            // ç¬¬ä¸€æ­¥ï¼šè¿ç§»emojiImagesè¡¨ä¸­çš„æ•°æ®åˆ°æ–°çš„æ–‡ä»¶å­˜å‚¨
            const emojiImagesData = await this.getDataFromStore('emojiImages');
            const emojiImagesNeedingMigration = emojiImagesData.filter(img => img.data && img.data.startsWith('data:'));

            for (const emojiImage of emojiImagesNeedingMigration) {
                try {
                    if (progressCallback) {
                        progressCallback({
                            type: 'è¡¨æƒ…åŒ…å›¾ç‰‡',
                            current: totalProcessed + 1,
                            total: totalItems,
                            item: emojiImage.tag
                        });
                    }

                    // å°†base64æ•°æ®è¿ç§»åˆ°æ–°çš„æ–‡ä»¶å­˜å‚¨
                    const fileId = await this.imageAPI.storeEmoji(emojiImage.data, emojiImage.tag);
                    
                    // æ›´æ–°emojiImageè®°å½•
                    emojiImage.data = ''; // æ¸…é™¤base64æ•°æ®
                    emojiImage.fileId = fileId; // ä¿å­˜æ–‡ä»¶å¼•ç”¨
                    
                    results.emojiImagesMigrated++;
                    totalProcessed++;

                } catch (error) {
                    results.errors.push({
                        type: 'emojiImage',
                        item: emojiImage,
                        error: error.message
                    });
                    console.error('è¿ç§»è¡¨æƒ…å›¾ç‰‡å¤±è´¥:', error);
                }
            }

            // æ›´æ–°emojiImagesæ•°æ®
            if (emojiImagesNeedingMigration.length > 0) {
                await this.updateDataInStore('emojiImages', emojiImagesData);
            }

            // ç¬¬äºŒæ­¥ï¼šè¿ç§»è”ç³»äººèŠå¤©è®°å½•ä¸­çš„base64è¡¨æƒ…åŒ…
            const contactsData = await this.getDataFromStore('contacts');
            const contactsNeedingMigration = migrationStatus.contactDetails;

            for (const contactDetail of contactsNeedingMigration) {
                const contact = contactsData.find(c => c.id === contactDetail.contactId);
                if (!contact || !contact.messages) continue;

                let contactModified = false;

                for (const message of contact.messages) {
                    if (message.content && typeof message.content === 'string') {
                        // æŸ¥æ‰¾æ‰€æœ‰base64å›¾ç‰‡
                        const base64Matches = message.content.match(/data:image\/[^;]+;base64,[A-Za-z0-9+\/=]+/g);
                        if (base64Matches) {
                            let newContent = message.content;

                            for (const base64Url of base64Matches) {
                                try {
                                    if (progressCallback) {
                                        progressCallback({
                                            type: 'èŠå¤©è¡¨æƒ…',
                                            current: totalProcessed + 1,
                                            total: totalItems,
                                            item: `${contact.name}çš„æ¶ˆæ¯`
                                        });
                                    }

                                    // æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å¯¹åº”çš„è¡¨æƒ…è®°å½•
                                    const existingEmoji = await this.findEmojiByBase64(base64Url);
                                    let emojiTag;

                                    if (existingEmoji && existingEmoji.meaning) {
                                        emojiTag = existingEmoji.meaning;
                                        
                                        // ç¡®ä¿è¯¥è¡¨æƒ…çš„å›¾ç‰‡å·²ç»è¿ç§»åˆ°æ–°ç³»ç»Ÿ
                                        if (!existingEmoji.tag) {
                                            existingEmoji.tag = existingEmoji.meaning;
                                        }
                                        
                                        // å¦‚æœè¿˜æ²¡æœ‰fileIdï¼Œä¸ºå…¶åˆ›å»º
                                        if (!await this.hasEmojiFileId(emojiTag)) {
                                            await this.imageAPI.storeEmoji(base64Url, emojiTag);
                                        }
                                    } else {
                                        // åˆ›å»ºä¸´æ—¶æ ‡ç­¾
                                        emojiTag = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                                        await this.imageAPI.storeEmoji(base64Url, emojiTag);
                                        
                                        // æ·»åŠ åˆ°emojisæ•°ç»„
                                        window.emojis.push({
                                            id: Date.now().toString(),
                                            meaning: emojiTag,
                                            tag: emojiTag,
                                            url: '' // æ¸…ç©ºURLï¼Œä½¿ç”¨æ–°çš„æ–‡ä»¶å­˜å‚¨
                                        });
                                    }

                                    // æ›¿æ¢èŠå¤©è®°å½•ä¸­çš„base64ä¸ºæ ‡ç­¾æ ¼å¼
                                    newContent = newContent.replace(base64Url, `[emoji:${emojiTag}]`);
                                    
                                    results.base64EmojisMigrated++;
                                    totalProcessed++;
                                    contactModified = true;

                                } catch (error) {
                                    results.errors.push({
                                        type: 'chatEmoji',
                                        contactId: contact.id,
                                        error: error.message
                                    });
                                    console.error('è¿ç§»èŠå¤©è¡¨æƒ…å¤±è´¥:', error);
                                }
                            }

                            message.content = newContent;
                        }
                    }
                }

                if (contactModified) {
                    results.contactsMigrated++;
                    results.messagesMigrated += contactDetail.base64EmojisCount;
                }
            }

            // æ›´æ–°è”ç³»äººæ•°æ®
            await this.updateDataInStore('contacts', contactsData);

            // æ›´æ–°å…¨å±€emojisæ•°ç»„
            await this.updateDataInStore('emojis', window.emojis);

            return {
                success: true,
                message: `èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»å®Œæˆï¼è¿ç§»äº†${results.base64EmojisMigrated}ä¸ªè¡¨æƒ…ï¼Œæ¶‰åŠ${results.contactsMigrated}ä¸ªè”ç³»äºº`,
                results: results
            };

        } catch (error) {
            console.error('èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»è¿‡ç¨‹å‡ºé”™:', error);
            return {
                success: false,
                error: error.message,
                results: results
            };
        }
    }

    /**
     * é€šè¿‡base64 URLæŸ¥æ‰¾å¯¹åº”çš„è¡¨æƒ…è®°å½•
     */
    async findEmojiByBase64(base64Url) {
        if (!window.emojis || !Array.isArray(window.emojis)) {
            return null;
        }

        return window.emojis.find(emoji => emoji.url === base64Url);
    }

    /**
     * æ£€æŸ¥è¡¨æƒ…æ˜¯å¦å·²ç»æœ‰å¯¹åº”çš„fileId
     */
    async hasEmojiFileId(emojiTag) {
        try {
            const reference = await window.FileStorageManager.getFileReference('emoji', emojiTag);
            return !!reference;
        } catch (error) {
            return false;
        }
    }

    /**
     * ä¼°ç®—è¿ç§»æ•ˆæœ
     */
    async estimateMigrationBenefits(migrationStatus) {
        if (!migrationStatus || !migrationStatus.needed) {
            return {
                spaceSavings: 0,
                performanceImprovement: 'æ— ',
                details: {}
            };
        }

        // ä¼°ç®—ç©ºé—´èŠ‚çœï¼ˆbase64æ¯”åŸå§‹æ•°æ®å¤§çº¦å¤š33%ï¼‰
        const estimatedSavingsPerEmoji = 30 * 1024; // å‡è®¾å¹³å‡æ¯ä¸ªè¡¨æƒ…èŠ‚çœ30KB
        const totalEmojis = migrationStatus.details.base64EmojisFound + 
                           migrationStatus.details.emojiImagesNeedingMigration;
        const totalSavings = totalEmojis * estimatedSavingsPerEmoji;

        return {
            spaceSavings: totalSavings,
            formattedSavings: this.formatBytes(totalSavings),
            performanceImprovement: 'ä¸­ç­‰',
            details: {
                totalEmojisToMigrate: totalEmojis,
                averageSavingsPerEmoji: estimatedSavingsPerEmoji,
                contactsAffected: migrationStatus.details.contactsNeedingMigration
            }
        };
    }

    /**
     * æ ¼å¼åŒ–å­—èŠ‚æ•°
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const chatEmojiMigrationManager = new ChatEmojiMigrationManager();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.ChatEmojiMigrationManager = chatEmojiMigrationManager;

// èŠå¤©è®°å½•è¡¨æƒ…åŒ…è¿ç§»ç®¡ç†å™¨å·²åŠ è½½
</script>
    <script>
/**
 * è¯­éŸ³å­˜å‚¨API
 * ç”¨äºç¼“å­˜è¯­éŸ³æ–‡ä»¶ï¼Œé¿å…é‡å¤è¯·æ±‚TTS API
 */

class VoiceStorageAPI {
    constructor() {
        this.fileStorageManager = null;
        this.initPromise = this.init();
    }

    /**
     * åˆå§‹åŒ–è¯­éŸ³å­˜å‚¨API
     */
    async init() {
        // ç­‰å¾…UnifiedDBManageråˆå§‹åŒ–
        if (window.unifiedDB) {
            this.fileStorageManager = window.unifiedDB;
            await this.fileStorageManager.init();
        } else if (window.FileStorageManager) {
            // å‘åå…¼å®¹
            this.fileStorageManager = window.FileStorageManager;
            await this.fileStorageManager.init();
        } else {
            throw new Error('UnifiedDBManageræœªåˆå§‹åŒ–');
        }
    }

    /**
     * ç”Ÿæˆè¯­éŸ³ç¼“å­˜é”®
     * åŸºäºæ–‡æœ¬å†…å®¹å’Œè¯­éŸ³IDç”Ÿæˆå”¯ä¸€æ ‡è¯†
     */
    generateVoiceCacheKey(text, voiceId) {
        // æ¸…ç†æ–‡æœ¬ï¼šå»é™¤æ¢è¡Œã€å¤šä½™ç©ºæ ¼ï¼Œè½¬ä¸ºå°å†™ä»¥æé«˜ç¼“å­˜å‘½ä¸­ç‡
        const cleanText = text.trim().toLowerCase().replace(/\s+/g, ' ');
        // ä½¿ç”¨ç®€å•çš„å“ˆå¸Œç®—æ³•ç”Ÿæˆå›ºå®šé•¿åº¦çš„é”®
        const textHash = this.simpleHash(cleanText);
        return `voice_${voiceId}_${textHash}`;
    }

    /**
     * ç®€å•å“ˆå¸Œå‡½æ•°
     */
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // è½¬ä¸º32ä½æ•´æ•°
        }
        return Math.abs(hash).toString(36);
    }

    /**
     * å­˜å‚¨è¯­éŸ³æ–‡ä»¶
     * @param {Blob} audioBlob - éŸ³é¢‘æ•°æ®
     * @param {string} text - åŸå§‹æ–‡æœ¬
     * @param {string} voiceId - è¯­éŸ³ID
     * @param {Object} metadata - å…ƒæ•°æ®
     * @returns {Promise<string>} fileId
     */
    async storeVoice(audioBlob, text, voiceId, metadata = {}) {
        await this.initPromise;
        
        try {
            // å­˜å‚¨æ–‡ä»¶åˆ°FileStorage
            const storeResult = await this.fileStorageManager.storeFile(audioBlob, {
                originalText: text,
                voiceId: voiceId,
                type: 'voice',
                ...metadata
            });

            // åˆ›å»ºå¼•ç”¨å…³ç³»
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            await this.fileStorageManager.createFileReference(
                storeResult.fileId,
                'voice',
                cacheKey,
                {
                    text: text,
                    voiceId: voiceId,
                    createdAt: new Date().toISOString()
                }
            );

            console.log('è¯­éŸ³æ–‡ä»¶å­˜å‚¨æˆåŠŸ:', {
                fileId: storeResult.fileId,
                cacheKey: cacheKey,
                textLength: text.length,
                voiceId: voiceId
            });

            return storeResult.fileId;
        } catch (error) {
            console.error('è¯­éŸ³æ–‡ä»¶å­˜å‚¨å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * è·å–ç¼“å­˜çš„è¯­éŸ³æ–‡ä»¶URL
     * @param {string} text - æ–‡æœ¬å†…å®¹
     * @param {string} voiceId - è¯­éŸ³ID
     * @returns {Promise<string|null>} è¯­éŸ³æ–‡ä»¶URLæˆ–null
     */
    async getVoiceURL(text, voiceId) {
        await this.initPromise;
        
        try {
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            console.log('æŸ¥æ‰¾è¯­éŸ³ç¼“å­˜:', { cacheKey, textLength: text.length, voiceId });
            
            // æŸ¥æ‰¾æ–‡ä»¶å¼•ç”¨
            const reference = await this.fileStorageManager.getFileReference('voice', cacheKey);
            
            if (!reference) {
                console.log('è¯­éŸ³ç¼“å­˜æœªæ‰¾åˆ°');
                return null;
            }

            // åˆ›å»ºæ–‡ä»¶URL
            const url = await this.fileStorageManager.createFileURL(reference.fileId);
            console.log('è¯­éŸ³ç¼“å­˜å‘½ä¸­:', { fileId: reference.fileId, url: url ? 'å·²ç”Ÿæˆ' : 'ç”Ÿæˆå¤±è´¥' });
            
            return url;
        } catch (error) {
            console.error('è·å–è¯­éŸ³ç¼“å­˜å¤±è´¥:', error);
            return null;
        }
    }

    /**
     * æ£€æŸ¥è¯­éŸ³æ˜¯å¦å·²ç¼“å­˜
     * @param {string} text - æ–‡æœ¬å†…å®¹
     * @param {string} voiceId - è¯­éŸ³ID
     * @returns {Promise<boolean>}
     */
    async isVoiceCached(text, voiceId) {
        await this.initPromise;
        
        try {
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            const reference = await this.fileStorageManager.getFileReference('voice', cacheKey);
            return !!reference;
        } catch (error) {
            console.error('æ£€æŸ¥è¯­éŸ³ç¼“å­˜å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * åˆ é™¤è¯­éŸ³ç¼“å­˜
     * @param {string} text - æ–‡æœ¬å†…å®¹
     * @param {string} voiceId - è¯­éŸ³ID
     * @returns {Promise<boolean>}
     */
    async deleteVoiceCache(text, voiceId) {
        await this.initPromise;
        
        try {
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            const reference = await this.fileStorageManager.getFileReference('voice', cacheKey);
            
            if (reference) {
                // åˆ é™¤æ–‡ä»¶å¼•ç”¨
                await this.fileStorageManager.deleteFileReference('voice', cacheKey);
                // åˆ é™¤æ–‡ä»¶æœ¬èº«
                await this.fileStorageManager.deleteFile(reference.fileId);
                console.log('è¯­éŸ³ç¼“å­˜åˆ é™¤æˆåŠŸ:', cacheKey);
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('åˆ é™¤è¯­éŸ³ç¼“å­˜å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * è·å–è¯­éŸ³ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
     * @returns {Promise<Object>}
     */
    async getVoiceCacheStats() {
        await this.initPromise;
        
        try {
            // è·å–æ‰€æœ‰è¯­éŸ³ç±»å‹çš„å¼•ç”¨
            const transaction = this.fileStorageManager.db.transaction(['fileReferences'], 'readonly');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('voice');

            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const voiceReferences = request.result;
                    const stats = {
                        totalVoices: voiceReferences.length,
                        voiceByVoiceId: {},
                        oldestCache: null,
                        newestCache: null
                    };

                    voiceReferences.forEach(ref => {
                        const voiceId = ref.metadata?.voiceId || 'unknown';
                        if (!stats.voiceByVoiceId[voiceId]) {
                            stats.voiceByVoiceId[voiceId] = 0;
                        }
                        stats.voiceByVoiceId[voiceId]++;

                        const createdAt = new Date(ref.createdAt);
                        if (!stats.oldestCache || createdAt < new Date(stats.oldestCache)) {
                            stats.oldestCache = ref.createdAt;
                        }
                        if (!stats.newestCache || createdAt > new Date(stats.newestCache)) {
                            stats.newestCache = ref.createdAt;
                        }
                    });

                    resolve(stats);
                };

                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('è·å–è¯­éŸ³ç¼“å­˜ç»Ÿè®¡å¤±è´¥:', error);
            return {
                totalVoices: 0,
                voiceByVoiceId: {},
                oldestCache: null,
                newestCache: null
            };
        }
    }

    /**
     * æ¸…ç†è¿‡æœŸçš„è¯­éŸ³ç¼“å­˜
     * @param {number} daysOld - æ¸…ç†å¤šå°‘å¤©å‰çš„ç¼“å­˜
     * @returns {Promise<Object>}
     */
    async cleanupOldVoiceCache(daysOld = 30) {
        await this.initPromise;
        
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysOld);

            const transaction = this.fileStorageManager.db.transaction(['fileReferences'], 'readonly');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('voice');

            return new Promise((resolve, reject) => {
                request.onsuccess = async () => {
                    const voiceReferences = request.result;
                    const oldReferences = voiceReferences.filter(ref => 
                        new Date(ref.createdAt) < cutoffDate
                    );

                    let deletedCount = 0;
                    let errors = 0;

                    for (const ref of oldReferences) {
                        try {
                            await this.fileStorageManager.deleteFileReference('voice', ref.referenceKey);
                            await this.fileStorageManager.deleteFile(ref.fileId);
                            deletedCount++;
                        } catch (error) {
                            console.error('åˆ é™¤è¿‡æœŸè¯­éŸ³ç¼“å­˜å¤±è´¥:', ref.referenceId, error);
                            errors++;
                        }
                    }

                    resolve({
                        deletedCount,
                        errors,
                        message: `æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº† ${deletedCount} ä¸ªè¿‡æœŸè¯­éŸ³ç¼“å­˜ï¼Œ${errors} ä¸ªåˆ é™¤å¤±è´¥`
                    });
                };

                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('æ¸…ç†è¿‡æœŸè¯­éŸ³ç¼“å­˜å¤±è´¥:', error);
            return { deletedCount: 0, errors: 1, message: 'æ¸…ç†å¤±è´¥' };
        }
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const voiceStorageAPI = new VoiceStorageAPI();

// å¯¼å‡ºåˆ°windowå¯¹è±¡ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
window.VoiceStorageAPI = voiceStorageAPI;

console.log('è¯­éŸ³å­˜å‚¨APIå·²åŠ è½½');
</script>
    <script>
/**
 * æ–‡ä»¶å­˜å‚¨å¯¼å‡ºå™¨
 * ä¸“é—¨å¤„ç†å›¾ç‰‡ã€è¡¨æƒ…åŒ…ã€èƒŒæ™¯ç­‰æ–‡ä»¶æ•°æ®çš„å¯¼å…¥å¯¼å‡º
 * æ”¯æŒZIPæ ¼å¼æ‰“åŒ…ï¼Œä¿æŒåŸå§‹æ–‡ä»¶æ ¼å¼
 */

class FileStorageExporter {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.dbVersion = 14;
        this.db = null;
        this.fileManager = null;
        
        // æ”¯æŒçš„æ–‡ä»¶ç±»å‹
        this.supportedFileTypes = ['avatar', 'background', 'emoji', 'moment', 'banner'];
        
        // æ–‡ä»¶å¤¹æ˜ å°„
        this.folderMapping = {
            'avatar_contact': 'avatars',
            'avatar_user': 'user_avatars', 
            'background': 'backgrounds',
            'emoji': 'emojis',
            'moment_image': 'moments',
            'banner': 'banners'
        };

        // æ–‡ä»¶æ‰©å±•åæ˜ å°„
        this.mimeToExtension = {
            'image/jpeg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.webp',
            'image/bmp': '.bmp',
            'image/svg+xml': '.svg',
            'image/jpg': '.jpg'
        };
    }

    /**
     * åˆå§‹åŒ–
     */
    async init() {
        if (!this.db) {
            if (window.db && window.isIndexedDBReady) {
                this.db = window.db;
            } else {
                throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
            }
        }

        if (!this.fileManager) {
            if (window.unifiedDB) {
                this.fileManager = window.unifiedDB;
                await this.fileManager.init();
            } else {
                throw new Error('UnifiedDBManageræœªåŠ è½½');
            }
        }

        return true;
    }

    /**
     * å¯¼å‡ºæ‰€æœ‰æ–‡ä»¶å­˜å‚¨æ•°æ®ä¸ºZIPæ ¼å¼
     * @param {Object} options - å¯¼å‡ºé€‰é¡¹
     * @returns {Object} å¯¼å‡ºç»“æœ
     */
    async exportFileStorageAsZip(options = {}) {
        await this.init();
        
        const {
            includeAvatars = true,
            includeBackgrounds = true,
            includeEmojis = true,
            includeMoments = true
        } = options;

        try {
            // åŠ è½½JSZipåº“
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·ç¡®ä¿é¡µé¢ä¸­åŒ…å«äº†JSZip');
            }

            const zip = new JSZip();
            
            // åˆ›å»ºå…ƒæ•°æ®
            const metadata = {
                exportTime: new Date().toISOString(),
                version: this.dbVersion,
                format: 'file_storage_zip_export',
                description: 'æ–‡ä»¶å­˜å‚¨ZIPå¯¼å‡ºåŒ…',
                structure: {
                    avatars: 'ç”¨æˆ·å’Œè”ç³»äººå¤´åƒ',
                    user_avatars: 'ç”¨æˆ·å¤´åƒ',
                    backgrounds: 'èŠå¤©èƒŒæ™¯å›¾ç‰‡', 
                    emojis: 'è¡¨æƒ…åŒ…å›¾ç‰‡',
                    moments: 'æœ‹å‹åœˆå›¾ç‰‡'
                }
            };

            const statistics = {
                totalFiles: 0,
                totalSize: 0,
                folderBreakdown: {}
            };

            // è·å–æ‰€æœ‰æ–‡ä»¶å­˜å‚¨æ•°æ®
            const allFiles = await this.getAllFiles();
            const allReferences = await this.getAllReferences();

            // æŒ‰ç±»å‹å¤„ç†æ–‡ä»¶
            for (const file of allFiles) {
                const references = allReferences.filter(ref => ref.fileId === file.fileId);
                
                for (const reference of references) {
                    const category = reference.category;
                    
                    // æ ¹æ®é€‰é¡¹è¿‡æ»¤
                    if (!this.shouldIncludeCategory(category, {
                        includeAvatars,
                        includeBackgrounds,
                        includeEmojis,
                        includeMoments
                    })) {
                        continue;
                    }

                    // ç¡®å®šæ–‡ä»¶å¤¹å’Œæ–‡ä»¶å
                    const folderName = this.folderMapping[category] || 'others';
                    const extension = this.getFileExtension(file.type);
                    const fileName = this.generateFileName(reference, extension);
                    const filePath = `${folderName}/${fileName}`;

                    // ç¡®ä¿æ–‡ä»¶æ•°æ®æ˜¯JSZipæ”¯æŒçš„æ ¼å¼
                    let fileData = file.blob;
                    
                    // æ£€æŸ¥blobæ•°æ®ç±»å‹å¹¶è½¬æ¢ä¸ºArrayBuffer
                    if (fileData instanceof Blob) {
                        try {
                            // å°†Blobè½¬æ¢ä¸ºArrayBufferï¼Œè¿™æ˜¯JSZipæœ€å…¼å®¹çš„æ ¼å¼
                            fileData = await fileData.arrayBuffer();
                        } catch (blobError) {
                            console.warn(`æ— æ³•è½¬æ¢Blobä¸ºArrayBufferï¼Œæ–‡ä»¶: ${filePath}`, blobError);
                            // å°è¯•è¯»å–ä¸ºbase64å†è½¬æ¢
                            try {
                                const base64 = await this.blobToBase64(fileData);
                                const base64Data = base64.split(',')[1];
                                const byteCharacters = atob(base64Data);
                                const byteNumbers = new Uint8Array(byteCharacters.length);
                                for (let i = 0; i < byteCharacters.length; i++) {
                                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                                }
                                fileData = byteNumbers.buffer;
                            } catch (base64Error) {
                                console.error(`æ–‡ä»¶æ•°æ®è½¬æ¢å¤±è´¥ï¼Œè·³è¿‡æ–‡ä»¶: ${filePath}`, base64Error);
                                continue;
                            }
                        }
                    } else if (typeof fileData === 'string') {
                        // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå¯èƒ½æ˜¯base64æ ¼å¼
                        if (fileData.startsWith('data:')) {
                            const base64Data = fileData.split(',')[1];
                            const byteCharacters = atob(base64Data);
                            const byteNumbers = new Uint8Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            fileData = byteNumbers.buffer;
                        } else {
                            console.error(`ä¸æ”¯æŒçš„å­—ç¬¦ä¸²æ ¼å¼ï¼Œè·³è¿‡æ–‡ä»¶: ${filePath}`);
                            continue;
                        }
                    } else if (!(fileData instanceof ArrayBuffer) && !ArrayBuffer.isView(fileData)) {
                        console.error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ•°æ®ç±»å‹: ${typeof fileData}ï¼Œè·³è¿‡æ–‡ä»¶: ${filePath}`);
                        continue;
                    }

                    // æ·»åŠ æ–‡ä»¶åˆ°ZIP - ä½¿ç”¨ArrayBufferæ ¼å¼
                    zip.file(filePath, fileData);

                    // åˆ›å»ºæ–‡ä»¶ä¿¡æ¯è®°å½•
                    const fileInfo = {
                        originalPath: filePath,
                        fileId: file.fileId,
                        type: file.type,
                        size: file.size,
                        createdAt: file.createdAt,
                        reference: {
                            category: reference.category,
                            referenceKey: reference.referenceKey,
                            referenceId: reference.referenceId,
                            metadata: reference.metadata || {}
                        }
                    };

                    // æ·»åŠ åˆ°å…ƒæ•°æ®çš„æ–‡ä»¶åˆ—è¡¨
                    if (!metadata.files) {
                        metadata.files = {};
                    }
                    if (!metadata.files[folderName]) {
                        metadata.files[folderName] = [];
                    }
                    metadata.files[folderName].push(fileInfo);

                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    statistics.totalFiles++;
                    statistics.totalSize += file.size;
                    
                    if (!statistics.folderBreakdown[folderName]) {
                        statistics.folderBreakdown[folderName] = { count: 0, size: 0 };
                    }
                    statistics.folderBreakdown[folderName].count++;
                    statistics.folderBreakdown[folderName].size += file.size;
                }
            }

            // æ·»åŠ å…ƒæ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯åˆ°ZIP
            metadata.statistics = statistics;
            zip.file('metadata.json', JSON.stringify(metadata, null, 2));

            console.log('æ–‡ä»¶å­˜å‚¨ZIPå¯¼å‡ºå®Œæˆ:', statistics);

            return {
                zip: zip,
                metadata: metadata,
                statistics: statistics
            };

        } catch (error) {
            console.error('å¯¼å‡ºæ–‡ä»¶å­˜å‚¨ZIPå¤±è´¥:', error);
            throw new Error(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¯¼å…¥æ–‡ä»¶å­˜å‚¨æ•°æ®
     * @param {Object} importData - å¯¼å…¥çš„æ•°æ®
     * @param {Object} options - å¯¼å…¥é€‰é¡¹
     * @returns {Object} å¯¼å…¥ç»“æœ
     */
    async importFileStorage(importData, options = {}) {
        await this.init();
        
        const {
            overwrite = false,
            autoMatch = true,
            createMissing = true
        } = options;

        try {
            // éªŒè¯å¯¼å…¥æ•°æ®æ ¼å¼
            const validation = this.validateImportData(importData);
            if (!validation.valid) {
                throw new Error(`æ•°æ®æ ¼å¼æ— æ•ˆ: ${validation.error}`);
            }

            const importResults = {
                success: 0,
                failed: 0,
                matched: 0,
                created: 0,
                errors: [],
                summary: {}
            };

            // æŒ‰ç±»å‹å¤„ç†å¯¼å…¥
            for (const [groupKey, files] of Object.entries(importData.files)) {
                console.log(`å¼€å§‹å¯¼å…¥ ${groupKey} ç±»å‹æ–‡ä»¶ï¼Œå…± ${files.length} ä¸ª`);
                
                const groupResult = await this.importFileGroup(
                    groupKey, 
                    files, 
                    { overwrite, autoMatch, createMissing }
                );
                
                // åˆå¹¶ç»“æœ
                importResults.success += groupResult.success;
                importResults.failed += groupResult.failed;
                importResults.matched += groupResult.matched;
                importResults.created += groupResult.created;
                importResults.errors.push(...groupResult.errors);
                importResults.summary[groupKey] = groupResult;
            }

            console.log('æ–‡ä»¶å­˜å‚¨å¯¼å…¥å®Œæˆ:', importResults);
            return { success: true, results: importResults };

        } catch (error) {
            console.error('å¯¼å…¥æ–‡ä»¶å­˜å‚¨å¤±è´¥:', error);
            throw new Error(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¯¼å…¥ä¸€ç»„æ–‡ä»¶
     */
    async importFileGroup(groupKey, files, options) {
        const results = {
            success: 0,
            failed: 0,
            matched: 0,
            created: 0,
            errors: []
        };

        for (const fileRecord of files) {
            try {
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                const existingReference = await this.fileManager.getFileReference(
                    fileRecord.reference.category,
                    fileRecord.reference.referenceKey
                );

                let shouldImport = true;
                let isMatched = false;

                if (existingReference) {
                    if (!options.overwrite) {
                        // å·²å­˜åœ¨ä¸”ä¸è¦†ç›–ï¼Œè·³è¿‡
                        results.matched++;
                        isMatched = true;
                        shouldImport = false;
                    } else {
                        // åˆ é™¤ç°æœ‰æ–‡ä»¶å’Œå¼•ç”¨
                        await this.fileManager.deleteFile(existingReference.fileId);
                        await this.fileManager.deleteFileReference(
                            fileRecord.reference.category,
                            fileRecord.reference.referenceKey
                        );
                    }
                }

                if (shouldImport) {
                    // è½¬æ¢base64ä¸ºBlob
                    const blob = this.base64ToBlob(fileRecord.data);
                    
                    // å­˜å‚¨æ–°æ–‡ä»¶
                    const storeResult = await this.fileManager.storeFile(blob, fileRecord.metadata);
                    
                    // åˆ›å»ºå¼•ç”¨
                    await this.fileManager.createFileReference(
                        storeResult.fileId,
                        fileRecord.reference.category,
                        fileRecord.reference.referenceKey,
                        fileRecord.reference.metadata
                    );

                    if (isMatched) {
                        results.matched++;
                    } else {
                        results.created++;
                    }
                    results.success++;
                }

            } catch (error) {
                results.failed++;
                results.errors.push({
                    fileRecord: fileRecord,
                    error: error.message
                });
                console.error(`å¯¼å…¥æ–‡ä»¶å¤±è´¥:`, error, fileRecord);
            }
        }

        return results;
    }

    /**
     * ä¸‹è½½æ–‡ä»¶å­˜å‚¨æ•°æ®ä¸ºZIPæ ¼å¼
     */
    async downloadFileStorageAsZip(options = {}) {
        try {
            const { zip, statistics } = await this.exportFileStorageAsZip(options);
            
            // ç”ŸæˆZIPæ–‡ä»¶
            const zipBlob = await zip.generateAsync({ 
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: {
                    level: 6
                }
            });
            
            // ä¸‹è½½ZIPæ–‡ä»¶
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `whale-files-${timestamp}.zip`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            
            return { 
                success: true, 
                message: `æ–‡ä»¶å­˜å‚¨å¯¼å‡ºæˆåŠŸï¼å¯¼å‡ºäº† ${statistics.totalFiles} ä¸ªæ–‡ä»¶ï¼Œæ€»å¤§å° ${this.formatBytes(statistics.totalSize)}`,
                statistics: statistics
            };
            
        } catch (error) {
            console.error('ä¸‹è½½ZIPæ–‡ä»¶å¤±è´¥:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * ä»æ–‡ä»¶è¯»å–å¹¶å¯¼å…¥
     */
    async importFromFile(file, options = {}) {
        try {
            const importData = await this.readImportFile(file);
            return await this.importFileStorage(importData, options);
        } catch (error) {
            throw new Error(`ä»æ–‡ä»¶å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }

    // === è¾…åŠ©æ–¹æ³• ===

    /**
     * è·å–æ‰€æœ‰æ–‡ä»¶
     */
    async getAllFiles() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['fileStorage'], 'readonly');
            const store = transaction.objectStore('fileStorage');
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * è·å–æ‰€æœ‰å¼•ç”¨
     */
    async getAllReferences() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['fileReferences'], 'readonly');
            const store = transaction.objectStore('fileReferences');
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * åˆ¤æ–­æ˜¯å¦åº”è¯¥åŒ…å«æŸä¸ªåˆ†ç±»
     */
    shouldIncludeCategory(category, options) {
        switch (category) {
            case 'avatar_contact':
            case 'avatar_user':
                return options.includeAvatars;
            case 'background':
                return options.includeBackgrounds;
            case 'emoji':
                return options.includeEmojis;
            case 'moment_image':
                return options.includeMoments;
            default:
                return true;
        }
    }

    /**
     * è·å–æ–‡ä»¶æ‰©å±•å
     */
    getFileExtension(mimeType) {
        return this.mimeToExtension[mimeType] || '.jpg';
    }

    /**
     * ç”Ÿæˆæ–‡ä»¶å
     */
    generateFileName(reference, extension) {
        // ä½¿ç”¨å¼•ç”¨é”®ä½œä¸ºåŸºç¡€æ–‡ä»¶åï¼Œç¡®ä¿å®‰å…¨
        let baseName = reference.referenceKey || reference.fileId || 'unknown';
        
        // æ¸…ç†æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
        baseName = baseName.replace(/[<>:"/\\|?*]/g, '_');
        
        // å¦‚æœæ–‡ä»¶åå¤ªé•¿ï¼Œæˆªå–å‰50ä¸ªå­—ç¬¦
        if (baseName.length > 50) {
            baseName = baseName.substring(0, 50);
        }
        
        return baseName + extension;
    }

    /**
     * æ ¼å¼åŒ–å­—èŠ‚æ•°
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * è·å–æ–‡ä»¶åˆ†ç»„é”®
     */
    getFileGroupKey(category) {
        return this.folderMapping[category] || category;
    }

    /**
     * è·å–ç›¸å…³å¼•ç”¨ä¿¡æ¯
     */
    async getRelatedReferences(allReferences) {
        const references = {};
        
        for (const ref of allReferences) {
            const groupKey = this.getFileGroupKey(ref.category);
            if (!references[groupKey]) {
                references[groupKey] = [];
            }
            references[groupKey].push({
                referenceId: ref.referenceId,
                category: ref.category,
                referenceKey: ref.referenceKey,
                fileId: ref.fileId
            });
        }
        
        return references;
    }

    /**
     * Blobè½¬base64
     */
    async blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    /**
     * base64è½¬Blob
     */
    base64ToBlob(base64String) {
        try {
            const [header, data] = base64String.split(',');
            const mimeMatch = header.match(/data:([^;]+);base64/);
            const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';
            
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            throw new Error(`base64è½¬æ¢å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * éªŒè¯å¯¼å…¥æ•°æ®
     */
    validateImportData(importData) {
        if (!importData || typeof importData !== 'object') {
            return { valid: false, error: 'æ•°æ®æ ¼å¼æ— æ•ˆ' };
        }

        if (!importData._metadata) {
            return { valid: false, error: 'ç¼ºå°‘å…ƒæ•°æ®' };
        }

        if (importData._metadata.format !== 'file_storage_export') {
            return { valid: false, error: 'æ–‡ä»¶æ ¼å¼ä¸åŒ¹é…ï¼Œè¿™ä¸æ˜¯æ–‡ä»¶å­˜å‚¨å¯¼å‡ºæ–‡ä»¶' };
        }

        if (!importData.files || typeof importData.files !== 'object') {
            return { valid: false, error: 'ç¼ºå°‘æ–‡ä»¶æ•°æ®' };
        }

        return { valid: true };
    }

    /**
     * è¯»å–å¯¼å…¥æ–‡ä»¶
     */
    async readImportFile(file) {
        return new Promise((resolve, reject) => {
            if (!file) {
                reject(new Error('è¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶'));
                return;
            }
            
            if (!file.name.endsWith('.json')) {
                reject(new Error('åªæ”¯æŒ JSON æ ¼å¼çš„æ–‡ä»¶å­˜å‚¨å¯¼å‡ºæ–‡ä»¶'));
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const data = JSON.parse(text);
                    resolve(data);
                } catch (error) {
                    reject(new Error('æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æ JSON'));
                }
            };
            
            reader.onerror = () => {
                reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
            };
            
            reader.readAsText(file, 'utf-8');
        });
    }

    /**
     * è·å–å­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
     */
    async getStorageStatistics() {
        await this.init();
        
        const stats = await this.fileManager.getStorageStats();
        const allReferences = await this.getAllReferences();
        
        // æŒ‰ç±»å‹åˆ†ç±»ç»Ÿè®¡
        const categoryStats = {};
        for (const ref of allReferences) {
            const groupKey = this.getFileGroupKey(ref.category);
            if (!categoryStats[groupKey]) {
                categoryStats[groupKey] = { count: 0, references: [] };
            }
            categoryStats[groupKey].count++;
            categoryStats[groupKey].references.push(ref);
        }
        
        return {
            ...stats,
            categoryBreakdown: categoryStats,
            totalReferences: allReferences.length
        };
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const fileStorageExporter = new FileStorageExporter();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.FileStorageExporter = fileStorageExporter;
</script>
    <script>
/**
 * æ–‡ä»¶å­˜å‚¨å¯¼å…¥å™¨
 * ä¸“é—¨å¤„ç†æ–‡ä»¶å­˜å‚¨æ•°æ®çš„æ™ºèƒ½å¯¼å…¥å’ŒåŒ¹é…
 */

class FileStorageImporter {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.dbVersion = 14;
        this.db = null;
        this.fileManager = null;
        
        // è‡ªåŠ¨åŒ¹é…è§„åˆ™
        this.matchingRules = {
            // å¤´åƒåŒ¹é…è§„åˆ™
            avatars: {
                keyFields: ['id', 'name', 'contactId'],
                tolerance: 0.8, // åŒ¹é…å®¹å¿åº¦
                autoCreate: true
            },
            // èƒŒæ™¯åŒ¹é…è§„åˆ™
            backgrounds: {
                keyFields: ['contactId', 'id'],
                tolerance: 0.9,
                autoCreate: true
            },
            // è¡¨æƒ…åŒ…åŒ¹é…è§„åˆ™
            emojis: {
                keyFields: ['tag', 'meaning'],
                tolerance: 0.95,
                autoCreate: true
            },
            // æœ‹å‹åœˆå›¾ç‰‡åŒ¹é…è§„åˆ™
            moments: {
                keyFields: ['momentId', 'id', 'timestamp'],
                tolerance: 0.8,
                autoCreate: false // æœ‹å‹åœˆå›¾ç‰‡ä¸è‡ªåŠ¨åˆ›å»º
            }
        };
    }

    /**
     * åˆå§‹åŒ–
     */
    async init() {
        if (!this.db) {
            if (window.db && window.isIndexedDBReady) {
                this.db = window.db;
            } else {
                throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
            }
        }

        if (!this.fileManager) {
            if (window.unifiedDB) {
                this.fileManager = window.unifiedDB;
                await this.fileManager.init();
            } else {
                throw new Error('UnifiedDBManageræœªåŠ è½½');
            }
        }

        return true;
    }

    /**
     * ä»ZIPæ–‡ä»¶å¯¼å…¥æ–‡ä»¶å­˜å‚¨æ•°æ®
     * @param {File} zipFile - ZIPæ–‡ä»¶
     * @param {Object} options - å¯¼å…¥é€‰é¡¹
     * @returns {Object} å¯¼å…¥ç»“æœ
     */
    async importFromZipFile(zipFile, options = {}) {
        try {
            // åŠ è½½JSZipåº“
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·ç¡®ä¿é¡µé¢ä¸­åŒ…å«äº†JSZip');
            }

            const zip = new JSZip();
            const zipContent = await zip.loadAsync(zipFile);

            // è¯»å–å…ƒæ•°æ®
            const metadataFile = zipContent.file('metadata.json');
            if (!metadataFile) {
                throw new Error('ZIPæ–‡ä»¶ä¸­ç¼ºå°‘metadata.jsonæ–‡ä»¶');
            }

            const metadataText = await metadataFile.async('text');
            const metadata = JSON.parse(metadataText);

            // éªŒè¯æ ¼å¼
            if (metadata.format !== 'file_storage_zip_export') {
                throw new Error('ä¸æ˜¯æœ‰æ•ˆçš„æ–‡ä»¶å­˜å‚¨ZIPå¯¼å‡ºæ–‡ä»¶');
            }

            // æ‰§è¡Œå¯¼å…¥
            return await this.importFromZipContent(zipContent, metadata, options);

        } catch (error) {
            console.error('ä»ZIPæ–‡ä»¶å¯¼å…¥å¤±è´¥:', error);
            throw new Error(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * ä»ZIPå†…å®¹å¯¼å…¥
     */
    async importFromZipContent(zipContent, metadata, options) {
        await this.init();
        
        const {
            autoMatch = true,
            overwrite = false,
            createMissing = true,
            matchTolerance = 0.8,
            progressCallback = null
        } = options;

        const importResults = {
            totalFiles: 0,
            processed: 0,
            matched: 0,
            created: 0,
            skipped: 0,
            failed: 0,
            errors: [],
            matchingDetails: {},
            summary: {}
        };

        // è·å–ç°æœ‰æ•°æ®ç”¨äºåŒ¹é…
        const existingData = await this.getExistingData();
        
        // è®¡ç®—æ€»æ–‡ä»¶æ•°
        const totalFiles = Object.values(metadata.files || {})
            .reduce((sum, files) => sum + files.length, 0);
        importResults.totalFiles = totalFiles;

        // æŒ‰æ–‡ä»¶å¤¹å¤„ç†å¯¼å…¥
        for (const [folderName, files] of Object.entries(metadata.files || {})) {
            if (progressCallback) {
                progressCallback({
                    phase: 'processing',
                    folderName,
                    totalFolders: Object.keys(metadata.files).length,
                    currentFolder: Object.keys(importResults.summary).length + 1
                });
            }

            const folderResult = await this.processZipFolder(
                folderName,
                files,
                zipContent,
                existingData,
                {
                    autoMatch,
                    overwrite,
                    createMissing,
                    matchTolerance,
                    progressCallback
                }
            );

            // åˆå¹¶ç»“æœ
            importResults.processed += folderResult.processed;
            importResults.matched += folderResult.matched;
            importResults.created += folderResult.created;
            importResults.skipped += folderResult.skipped;
            importResults.failed += folderResult.failed;
            importResults.errors.push(...folderResult.errors);
            importResults.matchingDetails[folderName] = folderResult.matchingDetails;
            importResults.summary[folderName] = folderResult;
        }

        console.log('ZIPæ–‡ä»¶å¯¼å…¥å®Œæˆ:', importResults);
        return { success: true, results: importResults };
    }

    /**
     * å¤„ç†ZIPæ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶
     */
    async processZipFolder(folderName, files, zipContent, existingData, options) {
        const results = {
            processed: 0,
            matched: 0,
            created: 0,
            skipped: 0,
            failed: 0,
            errors: [],
            matchingDetails: []
        };

        const matchingRule = this.getMatchingRuleByFolder(folderName);
        
        for (const fileInfo of files) {
            try {
                results.processed++;
                
                if (options.progressCallback) {
                    options.progressCallback({
                        phase: 'importing',
                        folderName,
                        current: results.processed,
                        total: files.length,
                        file: fileInfo
                    });
                }

                // ä»ZIPä¸­è¯»å–æ–‡ä»¶
                const zipFile = zipContent.file(fileInfo.originalPath);
                if (!zipFile) {
                    throw new Error(`æ‰¾ä¸åˆ°æ–‡ä»¶: ${fileInfo.originalPath}`);
                }

                const fileBlob = await zipFile.async('blob');

                // å°è¯•åŒ¹é…ç°æœ‰æ•°æ®
                const matchResult = options.autoMatch ? 
                    await this.findBestMatchFromFileInfo(fileInfo, existingData, folderName, matchingRule) :
                    null;

                let importAction = 'create';
                let shouldImport = true;
                let matchingDetails = null;

                if (matchResult && matchResult.score >= options.matchTolerance) {
                    matchingDetails = matchResult;
                    
                    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ–‡ä»¶
                    const existingReference = await this.fileManager.getFileReference(
                        fileInfo.reference.category,
                        matchResult.match.referenceKey || fileInfo.reference.referenceKey
                    );

                    if (existingReference) {
                        if (options.overwrite) {
                            // åˆ é™¤ç°æœ‰æ–‡ä»¶
                            await this.fileManager.deleteFile(existingReference.fileId);
                            await this.fileManager.deleteFileReference(
                                fileInfo.reference.category,
                                existingReference.referenceKey
                            );
                            importAction = 'replace';
                        } else {
                            // è·³è¿‡å·²å­˜åœ¨çš„æ–‡ä»¶
                            results.skipped++;
                            results.matched++;
                            shouldImport = false;
                            importAction = 'skip';
                        }
                    } else {
                        importAction = 'match_create';
                        results.matched++;
                    }
                } else if (!options.createMissing && !matchingRule.autoCreate) {
                    // æ²¡æœ‰åŒ¹é…ä¸”ä¸å…è®¸åˆ›å»ºæ–°æ–‡ä»¶
                    results.skipped++;
                    shouldImport = false;
                    importAction = 'skip_no_match';
                }

                if (shouldImport) {
                    // æ‰§è¡Œå¯¼å…¥
                    await this.importSingleFileFromBlob(fileInfo, fileBlob, matchResult);
                    
                    if (importAction === 'create' || importAction === 'match_create') {
                        results.created++;
                    }
                }

                // è®°å½•åŒ¹é…è¯¦æƒ…
                results.matchingDetails.push({
                    originalPath: fileInfo.originalPath,
                    referenceKey: fileInfo.reference.referenceKey,
                    action: importAction,
                    matchScore: matchResult?.score || 0,
                    matchedItem: matchResult?.match || null,
                    success: true
                });

            } catch (error) {
                results.failed++;
                results.errors.push({
                    fileInfo: fileInfo,
                    error: error.message
                });
                
                results.matchingDetails.push({
                    originalPath: fileInfo.originalPath,
                    referenceKey: fileInfo.reference.referenceKey,
                    action: 'error',
                    error: error.message,
                    success: false
                });
                
                console.error(`å¯¼å…¥æ–‡ä»¶å¤±è´¥:`, error, fileInfo);
            }
        }

        return results;
    }

    /**
     * æ™ºèƒ½å¯¼å…¥æ–‡ä»¶å­˜å‚¨æ•°æ®ï¼ˆå…¼å®¹åŸæœ‰çš„JSONæ ¼å¼ï¼‰
     * @param {Object} importData - å¯¼å…¥çš„æ•°æ®
     * @param {Object} options - å¯¼å…¥é€‰é¡¹
     * @returns {Object} å¯¼å…¥ç»“æœ
     */
    async smartImport(importData, options = {}) {
        await this.init();
        
        const {
            autoMatch = true,
            overwrite = false,
            createMissing = true,
            matchTolerance = 0.8,
            progressCallback = null
        } = options;

        try {
            // éªŒè¯æ•°æ®æ ¼å¼
            const validation = this.validateImportData(importData);
            if (!validation.valid) {
                throw new Error(`æ•°æ®éªŒè¯å¤±è´¥: ${validation.error}`);
            }

            const importResults = {
                totalFiles: 0,
                processed: 0,
                matched: 0,
                created: 0,
                skipped: 0,
                failed: 0,
                errors: [],
                matchingDetails: {},
                summary: {}
            };

            // è·å–ç°æœ‰æ•°æ®ç”¨äºåŒ¹é…
            const existingData = await this.getExistingData();
            
            // è®¡ç®—æ€»æ•°
            importResults.totalFiles = Object.values(importData.files)
                .reduce((sum, files) => sum + files.length, 0);

            // æŒ‰ç±»å‹å¤„ç†å¯¼å…¥
            for (const [groupKey, files] of Object.entries(importData.files)) {
                if (progressCallback) {
                    progressCallback({
                        phase: 'processing',
                        groupKey,
                        totalGroups: Object.keys(importData.files).length,
                        currentGroup: Object.keys(importResults.summary).length + 1
                    });
                }

                const groupResult = await this.processFileGroup(
                    groupKey,
                    files,
                    existingData,
                    {
                        autoMatch,
                        overwrite,
                        createMissing,
                        matchTolerance,
                        progressCallback
                    }
                );

                // åˆå¹¶ç»“æœ
                importResults.processed += groupResult.processed;
                importResults.matched += groupResult.matched;
                importResults.created += groupResult.created;
                importResults.skipped += groupResult.skipped;
                importResults.failed += groupResult.failed;
                importResults.errors.push(...groupResult.errors);
                importResults.matchingDetails[groupKey] = groupResult.matchingDetails;
                importResults.summary[groupKey] = groupResult;
            }

            console.log('æ™ºèƒ½å¯¼å…¥å®Œæˆ:', importResults);
            return { success: true, results: importResults };

        } catch (error) {
            console.error('æ™ºèƒ½å¯¼å…¥å¤±è´¥:', error);
            throw new Error(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * å¤„ç†ä¸€ç»„æ–‡ä»¶çš„å¯¼å…¥
     */
    async processFileGroup(groupKey, files, existingData, options) {
        const results = {
            processed: 0,
            matched: 0,
            created: 0,
            skipped: 0,
            failed: 0,
            errors: [],
            matchingDetails: []
        };

        const matchingRule = this.getMatchingRule(groupKey);
        
        for (const fileRecord of files) {
            try {
                results.processed++;
                
                if (options.progressCallback) {
                    options.progressCallback({
                        phase: 'importing',
                        groupKey,
                        current: results.processed,
                        total: files.length,
                        file: fileRecord
                    });
                }

                // å°è¯•åŒ¹é…ç°æœ‰æ•°æ®
                const matchResult = options.autoMatch ? 
                    await this.findBestMatch(fileRecord, existingData, groupKey, matchingRule) :
                    null;

                let importAction = 'create';
                let shouldImport = true;
                let matchingDetails = null;

                if (matchResult && matchResult.score >= options.matchTolerance) {
                    matchingDetails = matchResult;
                    
                    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ–‡ä»¶
                    const existingReference = await this.fileManager.getFileReference(
                        fileRecord.reference.category,
                        matchResult.match.referenceKey || fileRecord.reference.referenceKey
                    );

                    if (existingReference) {
                        if (options.overwrite) {
                            // åˆ é™¤ç°æœ‰æ–‡ä»¶
                            await this.fileManager.deleteFile(existingReference.fileId);
                            await this.fileManager.deleteFileReference(
                                fileRecord.reference.category,
                                existingReference.referenceKey
                            );
                            importAction = 'replace';
                        } else {
                            // è·³è¿‡å·²å­˜åœ¨çš„æ–‡ä»¶
                            results.skipped++;
                            results.matched++;
                            shouldImport = false;
                            importAction = 'skip';
                        }
                    } else {
                        importAction = 'match_create';
                        results.matched++;
                    }
                } else if (!options.createMissing && !matchingRule.autoCreate) {
                    // æ²¡æœ‰åŒ¹é…ä¸”ä¸å…è®¸åˆ›å»ºæ–°æ–‡ä»¶
                    results.skipped++;
                    shouldImport = false;
                    importAction = 'skip_no_match';
                }

                if (shouldImport) {
                    // æ‰§è¡Œå¯¼å…¥
                    await this.importSingleFile(fileRecord, matchResult);
                    
                    if (importAction === 'create' || importAction === 'match_create') {
                        results.created++;
                    }
                }

                // è®°å½•åŒ¹é…è¯¦æƒ…
                results.matchingDetails.push({
                    fileId: fileRecord.fileId,
                    referenceKey: fileRecord.reference.referenceKey,
                    action: importAction,
                    matchScore: matchResult?.score || 0,
                    matchedItem: matchResult?.match || null,
                    success: true
                });

            } catch (error) {
                results.failed++;
                results.errors.push({
                    fileRecord: fileRecord,
                    error: error.message
                });
                
                results.matchingDetails.push({
                    fileId: fileRecord.fileId,
                    referenceKey: fileRecord.reference.referenceKey,
                    action: 'error',
                    error: error.message,
                    success: false
                });
                
                console.error(`å¯¼å…¥æ–‡ä»¶å¤±è´¥:`, error, fileRecord);
            }
        }

        return results;
    }

    /**
     * å¯¼å…¥å•ä¸ªæ–‡ä»¶ï¼ˆä»Blobï¼‰
     */
    async importSingleFileFromBlob(fileInfo, blob, matchResult) {
        // å­˜å‚¨æ–‡ä»¶
        const storeResult = await this.fileManager.storeFile(blob, fileInfo.metadata || {});
        
        // ç¡®å®šå¼•ç”¨é”®ï¼ˆå¯èƒ½æ¥è‡ªåŒ¹é…ç»“æœï¼‰
        const referenceKey = matchResult?.match?.referenceKey || fileInfo.reference.referenceKey;
        
        // åˆ›å»ºå¼•ç”¨
        await this.fileManager.createFileReference(
            storeResult.fileId,
            fileInfo.reference.category,
            referenceKey,
            {
                ...fileInfo.reference.metadata,
                importedAt: new Date().toISOString(),
                matchScore: matchResult?.score || null,
                originalReferenceKey: fileInfo.reference.referenceKey,
                originalPath: fileInfo.originalPath
            }
        );

        return storeResult;
    }

    /**
     * å¯¼å…¥å•ä¸ªæ–‡ä»¶ï¼ˆå…¼å®¹åŸæœ‰JSONæ ¼å¼ï¼‰
     */
    async importSingleFile(fileRecord, matchResult) {
        // è½¬æ¢base64ä¸ºBlob
        const blob = this.base64ToBlob(fileRecord.data);
        
        // å­˜å‚¨æ–‡ä»¶
        const storeResult = await this.fileManager.storeFile(blob, fileRecord.metadata);
        
        // ç¡®å®šå¼•ç”¨é”®ï¼ˆå¯èƒ½æ¥è‡ªåŒ¹é…ç»“æœï¼‰
        const referenceKey = matchResult?.match?.referenceKey || fileRecord.reference.referenceKey;
        
        // åˆ›å»ºå¼•ç”¨
        await this.fileManager.createFileReference(
            storeResult.fileId,
            fileRecord.reference.category,
            referenceKey,
            {
                ...fileRecord.reference.metadata,
                importedAt: new Date().toISOString(),
                matchScore: matchResult?.score || null,
                originalReferenceKey: fileRecord.reference.referenceKey
            }
        );

        return storeResult;
    }

    /**
     * æŸ¥æ‰¾æœ€ä½³åŒ¹é…
     */
    async findBestMatch(fileRecord, existingData, groupKey, matchingRule) {
        const candidates = this.getCandidatesForMatching(existingData, groupKey);
        
        if (!candidates || candidates.length === 0) {
            return null;
        }

        let bestMatch = null;
        let bestScore = 0;

        for (const candidate of candidates) {
            const score = this.calculateMatchScore(fileRecord, candidate, matchingRule);
            
            if (score > bestScore && score >= matchingRule.tolerance) {
                bestScore = score;
                bestMatch = candidate;
            }
        }

        return bestMatch ? { match: bestMatch, score: bestScore } : null;
    }

    /**
     * è®¡ç®—åŒ¹é…åˆ†æ•°
     */
    calculateMatchScore(fileRecord, candidate, matchingRule) {
        let totalScore = 0;
        let weightSum = 0;

        const referenceKey = fileRecord.reference.referenceKey;
        const metadata = fileRecord.reference.metadata;

        // åŸºäºå…³é”®å­—æ®µè®¡ç®—åŒ¹é…åˆ†æ•°
        for (const field of matchingRule.keyFields) {
            const weight = this.getFieldWeight(field);
            let fieldScore = 0;

            // ç›´æ¥é”®åŒ¹é…
            if (candidate[field] && candidate[field] === referenceKey) {
                fieldScore = 1.0;
            }
            // å…ƒæ•°æ®åŒ¹é…
            else if (metadata[field] && candidate[field]) {
                fieldScore = this.calculateStringsimilarity(
                    String(metadata[field]),
                    String(candidate[field])
                );
            }
            // IDåŒ¹é…
            else if (candidate.id && candidate.id === referenceKey) {
                fieldScore = 0.9;
            }

            totalScore += fieldScore * weight;
            weightSum += weight;
        }

        return weightSum > 0 ? totalScore / weightSum : 0;
    }

    /**
     * è®¡ç®—å­—ç¬¦ä¸²ç›¸ä¼¼åº¦
     */
    calculateStringsimilarity(str1, str2) {
        if (str1 === str2) return 1.0;
        
        const longer = str1.length > str2.length ? str1 : str2;
        const shorter = str1.length > str2.length ? str2 : str1;
        
        if (longer.length === 0) return 1.0;
        
        const editDistance = this.levenshteinDistance(longer, shorter);
        return (longer.length - editDistance) / longer.length;
    }

    /**
     * ç¼–è¾‘è·ç¦»ç®—æ³•
     */
    levenshteinDistance(str1, str2) {
        const matrix = [];
        
        for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
        
        return matrix[str2.length][str1.length];
    }

    /**
     * è·å–ç°æœ‰æ•°æ®ç”¨äºåŒ¹é…
     */
    async getExistingData() {
        const existingData = {
            contacts: [],
            emojis: [],
            backgrounds: null,
            moments: [],
            userProfile: null
        };

        try {
            // è·å–è”ç³»äººæ•°æ®
            const contactsRequest = await this.getStoreData('contacts');
            existingData.contacts = contactsRequest || [];

            // è·å–è¡¨æƒ…åŒ…æ•°æ®
            const emojisRequest = await this.getStoreData('emojis');
            existingData.emojis = emojisRequest || [];

            // è·å–èƒŒæ™¯æ•°æ®
            const backgroundsRequest = await this.getStoreData('backgrounds');
            existingData.backgrounds = backgroundsRequest?.[0] || null;

            // è·å–æœ‹å‹åœˆæ•°æ®
            const momentsRequest = await this.getStoreData('moments');
            existingData.moments = momentsRequest || [];

            // è·å–ç”¨æˆ·èµ„æ–™
            const userProfileRequest = await this.getStoreData('userProfile');
            existingData.userProfile = userProfileRequest?.[0] || null;

        } catch (error) {
            console.error('è·å–ç°æœ‰æ•°æ®å¤±è´¥:', error);
        }

        return existingData;
    }

    /**
     * è·å–å­˜å‚¨æ•°æ®
     */
    async getStoreData(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * è·å–å€™é€‰åŒ¹é…é¡¹
     */
    getCandidatesForMatching(existingData, groupKey) {
        switch (groupKey) {
            case 'avatars':
                return [...existingData.contacts];
            case 'user_avatars':
                return existingData.userProfile ? [existingData.userProfile] : [];
            case 'backgrounds':
                // èƒŒæ™¯æ•°æ®ç»“æ„ç‰¹æ®Šï¼Œéœ€è¦è½¬æ¢
                if (existingData.backgrounds) {
                    return Object.keys(existingData.backgrounds)
                        .filter(key => key !== 'id')
                        .map(contactId => ({ id: contactId, referenceKey: contactId }));
                }
                return [];
            case 'emojis':
                return existingData.emojis;
            case 'moments':
                return existingData.moments;
            default:
                return [];
        }
    }

    /**
     * æ ¹æ®æ–‡ä»¶å¤¹åè·å–åŒ¹é…è§„åˆ™
     */
    getMatchingRuleByFolder(folderName) {
        const folderToRuleMapping = {
            'avatars': 'avatars',
            'user_avatars': 'avatars',
            'backgrounds': 'backgrounds',
            'emojis': 'emojis',
            'moments': 'moments'
        };
        
        const ruleKey = folderToRuleMapping[folderName] || 'avatars';
        return this.matchingRules[ruleKey] || {
            keyFields: ['id'],
            tolerance: 0.8,
            autoCreate: true
        };
    }

    /**
     * ä»æ–‡ä»¶ä¿¡æ¯ä¸­æŸ¥æ‰¾æœ€ä½³åŒ¹é…
     */
    async findBestMatchFromFileInfo(fileInfo, existingData, folderName, matchingRule) {
        // å°†æ–‡ä»¶ä¿¡æ¯è½¬æ¢ä¸ºåŒ¹é…æ ¼å¼
        const pseudoFileRecord = {
            reference: fileInfo.reference
        };
        
        return await this.findBestMatch(pseudoFileRecord, existingData, folderName, matchingRule);
    }

    /**
     * è·å–åŒ¹é…è§„åˆ™
     */
    getMatchingRule(groupKey) {
        return this.matchingRules[groupKey] || {
            keyFields: ['id'],
            tolerance: 0.8,
            autoCreate: true
        };
    }

    /**
     * è·å–å­—æ®µæƒé‡
     */
    getFieldWeight(field) {
        const weights = {
            id: 1.0,
            tag: 1.0,
            contactId: 0.9,
            name: 0.8,
            meaning: 0.7,
            momentId: 1.0,
            timestamp: 0.6
        };
        return weights[field] || 0.5;
    }

    // === è¾…åŠ©æ–¹æ³• ===

    /**
     * base64è½¬Blob
     */
    base64ToBlob(base64String) {
        try {
            const [header, data] = base64String.split(',');
            const mimeMatch = header.match(/data:([^;]+);base64/);
            const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';
            
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            throw new Error(`base64è½¬æ¢å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * éªŒè¯å¯¼å…¥æ•°æ®
     */
    validateImportData(importData) {
        if (!importData || typeof importData !== 'object') {
            return { valid: false, error: 'æ•°æ®æ ¼å¼æ— æ•ˆ' };
        }

        if (!importData._metadata) {
            return { valid: false, error: 'ç¼ºå°‘å…ƒæ•°æ®' };
        }

        if (importData._metadata.format !== 'file_storage_export') {
            return { valid: false, error: 'æ–‡ä»¶æ ¼å¼ä¸åŒ¹é…ï¼Œè¿™ä¸æ˜¯æ–‡ä»¶å­˜å‚¨å¯¼å‡ºæ–‡ä»¶' };
        }

        if (!importData.files || typeof importData.files !== 'object') {
            return { valid: false, error: 'ç¼ºå°‘æ–‡ä»¶æ•°æ®' };
        }

        return { valid: true };
    }

    /**
     * ç”Ÿæˆå¯¼å…¥é¢„è§ˆ
     */
    async generateImportPreview(importData) {
        const preview = {
            totalFiles: 0,
            categories: {},
            potentialMatches: {},
            warnings: []
        };

        // è·å–ç°æœ‰æ•°æ®
        const existingData = await this.getExistingData();

        for (const [groupKey, files] of Object.entries(importData.files)) {
            preview.totalFiles += files.length;
            
            const categoryPreview = {
                fileCount: files.length,
                samples: files.slice(0, 3), // æ˜¾ç¤ºå‰3ä¸ªæ ·æœ¬
                estimatedMatches: 0,
                estimatedNew: 0
            };

            // ä¼°ç®—åŒ¹é…æƒ…å†µ
            const matchingRule = this.getMatchingRule(groupKey);
            let estimatedMatches = 0;

            for (const file of files.slice(0, 10)) { // åªæ£€æŸ¥å‰10ä¸ªä½œä¸ºä¼°ç®—
                const matchResult = await this.findBestMatch(file, existingData, groupKey, matchingRule);
                if (matchResult && matchResult.score >= 0.8) {
                    estimatedMatches++;
                }
            }

            categoryPreview.estimatedMatches = Math.round(estimatedMatches * files.length / Math.min(files.length, 10));
            categoryPreview.estimatedNew = files.length - categoryPreview.estimatedMatches;

            preview.categories[groupKey] = categoryPreview;
        }

        return preview;
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const fileStorageImporter = new FileStorageImporter();

// å¯¼å‡ºåˆ°windowå¯¹è±¡
window.FileStorageImporter = fileStorageImporter;
</script>
    
    <!-- å·¥å…·æ¨¡å— -->
    <script>
/**
 * ç³»ç»Ÿå·¥å…·é›† - åŒ…å«å…¬å‘Šç®¡ç†ã€æ—¥å¿—ç³»ç»Ÿå’Œç³»ç»Ÿçº§åŠŸèƒ½
 */

// === å…¬å‘Šç®¡ç†ç³»ç»Ÿ ===
const announcementManager = (() => {
    const STORAGE_KEY = 'whale-llt-seen-announcements';
    const OLD_STORAGE_KEY = 'update-20250805-seen';
    const ANNOUNCEMENT_DIR = 'announcements/';

    // To add a new announcement:
    // 1. Create a new .md file in the /announcements/ directory.
    // 2. Add the filename (without .md) to the TOP of this list.
    const ANNOUNCEMENT_IDS = [
        '20250806',
        '20250805'
    ];

    function getSeenIds() {
        let seenIds = [];
        try {
            const storedValue = localStorage.getItem(STORAGE_KEY);
            if (storedValue) {
                seenIds = JSON.parse(storedValue);
            }
        } catch (e) {
            console.error("Failed to parse seen announcements:", e);
            seenIds = [];
        }

        // Migration from old system for existing users
        if (localStorage.getItem(OLD_STORAGE_KEY) === 'true') {
            if (!seenIds.includes('20250805')) {
                seenIds.push('20250805');
            }
            localStorage.removeItem(OLD_STORAGE_KEY);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(seenIds));
        }
        
        return seenIds;
    }

    async function getUnread() {
        const seenIds = getSeenIds();
        const unreadIds = ANNOUNCEMENT_IDS.filter(id => !seenIds.includes(id));

        if (unreadIds.length === 0) {
            return [];
        }

        try {
            const fetchPromises = unreadIds.map(id => 
                fetch(`${ANNOUNCEMENT_DIR}${id}.md`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Announcement ${id}.md not found.`);
                        }
                        return response.text();
                    })
                    .then(text => ({ id, content: text }))
            );
            
            const unreadAnnouncements = await Promise.all(fetchPromises);
            return unreadAnnouncements;

        } catch (error) {
            console.error("Failed to fetch announcements:", error);
            return []; // Return empty if any fetch fails
        }
    }

    function markAsSeen(idsToMark) {
        const seenIds = getSeenIds();
        const newSeenIds = [...new Set([...seenIds, ...idsToMark])]; 
        localStorage.setItem(STORAGE_KEY, JSON.stringify(newSeenIds));
    }

    return {
        getUnread,
        markAsSeen
    };
})();

// === æ§åˆ¶å°æ—¥å¿—æ•è·ç³»ç»Ÿ ===
let consoleLogs = [];
const maxLogEntries = 500; // é™åˆ¶æ—¥å¿—æ¡ç›®æ•°é‡é¿å…å†…å­˜è¿‡å¤§

/**
 * é‡å†™consoleæ–¹æ³•æ¥æ•è·æ—¥å¿—
 */
function setupConsoleCapture() {
    const originalConsole = {
        log: console.log,
        error: console.error,
        warn: console.warn,
        info: console.info,
        debug: console.debug
    };

    function captureLog(level, args) {
        const timestamp = new Date().toISOString();
        const message = args.map(arg => {
            if (typeof arg === 'object') {
                try {
                    return JSON.stringify(arg, null, 2);
                } catch (e) {
                    return String(arg);
                }
            }
            return String(arg);
        }).join(' ');
        
        consoleLogs.push({
            timestamp,
            level,
            message
        });
        
        // é™åˆ¶æ—¥å¿—æ•°é‡
        if (consoleLogs.length > maxLogEntries) {
            consoleLogs = consoleLogs.slice(-maxLogEntries);
        }
    }

    console.log = function(...args) {
        captureLog('log', args);
        originalConsole.log.apply(console, args);
    };

    console.error = function(...args) {
        captureLog('error', args);
        originalConsole.error.apply(console, args);
    };

    console.warn = function(...args) {
        captureLog('warn', args);
        originalConsole.warn.apply(console, args);
    };

    console.info = function(...args) {
        captureLog('info', args);
        originalConsole.info.apply(console, args);
    };

    console.debug = function(...args) {
        captureLog('debug', args);
        originalConsole.debug.apply(console, args);
    };
}

/**
 * ä¼ ç»Ÿä¸‹è½½æ–¹å¼çš„è¾…åŠ©å‡½æ•°
 */
function fallbackDownload(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * å¯¼å‡ºæ—¥å¿—åŠŸèƒ½
 */
function exportConsoleLogs() {
    try {
        if (consoleLogs.length === 0) {
            if (typeof showToast === 'function') showToast('æ²¡æœ‰æ—¥å¿—å¯å¯¼å‡º');
            return;
        }

        const logContent = consoleLogs.map(log => 
            `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`
        ).join('\n');
        
        const filename = `console-logs-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
        
        // æ£€æŸ¥æ˜¯å¦æ”¯æŒWeb Share APIï¼ˆç§»åŠ¨ç«¯åˆ†äº«ï¼‰
        if (navigator.share && navigator.canShare) {
            const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
            const file = new File([blob], filename, { type: 'text/plain' });
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ†äº«æ–‡ä»¶
            if (navigator.canShare({ files: [file] })) {
                navigator.share({
                    title: 'è°ƒè¯•æ—¥å¿—',
                    text: 'åº”ç”¨è°ƒè¯•æ—¥å¿—æ–‡ä»¶',
                    files: [file]
                }).then(() => {
                    if (typeof showToast === 'function') showToast('åˆ†äº«æˆåŠŸ');
                }).catch((error) => {
                    console.log('åˆ†äº«å–æ¶ˆæˆ–å¤±è´¥:', error);
                    // å¦‚æœåˆ†äº«å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿä¸‹è½½æ–¹å¼
                    fallbackDownload(logContent, filename);
                    if (typeof showToast === 'function') showToast(`å·²å¯¼å‡º ${consoleLogs.length} æ¡æ—¥å¿—`);
                });
                return;
            }
        }
        
        // å›é€€åˆ°ä¼ ç»Ÿä¸‹è½½æ–¹å¼ï¼ˆPCç«¯æˆ–ä¸æ”¯æŒåˆ†äº«çš„ç§»åŠ¨ç«¯ï¼‰
        fallbackDownload(logContent, filename);
        if (typeof showToast === 'function') showToast(`å·²å¯¼å‡º ${consoleLogs.length} æ¡æ—¥å¿—`);
    } catch (error) {
        console.error('å¯¼å‡ºæ—¥å¿—å¤±è´¥:', error);
        if (typeof showToast === 'function') showToast('å¯¼å‡ºæ—¥å¿—å¤±è´¥: ' + error.message);
    }
}

/**
 * è°ƒè¯•æ—¥å¿—é¡µé¢åŠŸèƒ½
 */
function showDebugLogPage() {
    if (typeof showPage === 'function') {
        showPage('debugLogPage');
        updateDebugLogDisplay();
    }
}

function updateDebugLogDisplay() {
    const logContent = document.getElementById('debugLogContent');
    const logCount = document.getElementById('logCount');
    
    if (!logContent) return;
    
    if (consoleLogs.length === 0) {
        logContent.innerHTML = '<div class="debug-log-empty">æš‚æ— æ—¥å¿—è®°å½•</div>';
        if (logCount) logCount.textContent = '0';
        return;
    }
    
    if (logCount) logCount.textContent = consoleLogs.length.toString();
    
    const logsHtml = consoleLogs.map(log => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        const levelClass = `debug-log-${log.level}`;
        return `
            <div class="debug-log-item ${levelClass}">
                <div class="debug-log-header">
                    <span class="debug-log-time">${time}</span>
                    <span class="debug-log-level">${log.level.toUpperCase()}</span>
                </div>
                <div class="debug-log-message">${escapeHtml(log.message)}</div>
            </div>
        `;
    }).join('');
    
    logContent.innerHTML = logsHtml;
    
    // æ»šåŠ¨åˆ°åº•éƒ¨æ˜¾ç¤ºæœ€æ–°æ—¥å¿—
    logContent.scrollTop = logContent.scrollHeight;
}

function clearDebugLogs() {
    consoleLogs.length = 0;
    updateDebugLogDisplay();
    if (typeof showToast === 'function') showToast('å·²æ¸…ç©ºè°ƒè¯•æ—¥å¿—');
}

function copyDebugLogs() {
    if (consoleLogs.length === 0) {
        if (typeof showToast === 'function') showToast('æ²¡æœ‰æ—¥å¿—å¯å¤åˆ¶');
        return;
    }
    
    const logText = consoleLogs.map(log => 
        `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`
    ).join('\n');
    
    // å°è¯•ä½¿ç”¨ç°ä»£çš„Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(logText).then(() => {
            if (typeof showToast === 'function') showToast(`å·²å¤åˆ¶ ${consoleLogs.length} æ¡æ—¥å¿—åˆ°å‰ªè´´æ¿`);
        }).catch(err => {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            fallbackCopyTextToClipboard(logText);
        });
    } else {
        fallbackCopyTextToClipboard(logText);
    }
}

function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        const successful = document.execCommand('copy');
        if (successful) {
            if (typeof showToast === 'function') showToast(`å·²å¤åˆ¶ ${consoleLogs.length} æ¡æ—¥å¿—åˆ°å‰ªè´´æ¿`);
        } else {
            if (typeof showToast === 'function') showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬');
        }
    } catch (err) {
        console.error('Fallback: å¤åˆ¶å¤±è´¥', err);
        if (typeof showToast === 'function') showToast('å¤åˆ¶å¤±è´¥: ' + err.message);
    }
    
    document.body.removeChild(textArea);
}

function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

// === ç³»ç»ŸçŠ¶æ€å’Œé”™è¯¯å¤„ç† ===

/**
 * å…¨å±€é”™è¯¯å¤„ç† - æ•è·æœªå¤„ç†çš„Promiseæ‹’ç»
 */
function initializeGlobalErrorHandling() {
    window.addEventListener('unhandledrejection', function(event) {
        console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', {
            reason: event.reason,
            promise: event.promise,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        });
        
        // è®°å½•åˆ°å…¨å±€é”™è¯¯æ—¥å¿—
        if (!window.errorLog) window.errorLog = [];
        window.errorLog.push({
            type: 'unhandledrejection',
            reason: event.reason?.toString() || 'Unknown',
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        });
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯APIç›¸å…³çš„é”™è¯¯ï¼Œå¦‚æœæ˜¯åˆ™æ˜¾ç¤ºé‡è¯•å¯¹è¯æ¡†
        const errorMessage = event.reason?.message || event.reason?.toString() || '';
        const isAPIError = errorMessage.includes('APIè¯·æ±‚å¤±è´¥') || 
                          errorMessage.includes('API Error') || 
                          errorMessage.includes('429') ||
                          errorMessage.includes('500') ||
                          errorMessage.includes('503') ||
                          errorMessage.includes('502') ||
                          errorMessage.includes('ç©ºå›') ||
                          errorMessage.includes('AIå›å¤å†…å®¹ä¸ºç©º') ||
                          errorMessage.includes('AIæœªè¿”å›æœ‰æ•ˆå†…å®¹');
        
        if (isAPIError && typeof showApiError === 'function') {
            showApiError(event.reason || new Error(errorMessage));
        }
        
        // é˜²æ­¢æ§åˆ¶å°æ˜¾ç¤ºæœªå¤„ç†çš„é”™è¯¯ï¼ˆå·²è®°å½•ï¼‰
        event.preventDefault();
    });
}

/**
 * Service Worker æ³¨å†Œ
 */
function registerServiceWorker() {
    console.log('ServiceWorker disabled in single-file mode');
}



/**
 * ç‰¹æ®Šäº‹ä»¶æ£€æŸ¥ï¼ˆå¦‚èŠ‚æ—¥ç‰¹æ®Šå¤„ç†ï¼‰
 */
async function checkSpecialEvents() {
    try {
        const today = new Date();
        const month = (today.getMonth() + 1).toString().padStart(2, '0');
        const day = today.getDate().toString().padStart(2, '0');
        const dateString = `${month}-${day}`;
        
        console.log('å½“å‰æ—¥æœŸæ£€æŸ¥:', dateString);
        
        // æ£€æŸ¥æ˜¯å¦ä¸º8æœˆ29æ—¥
        if (month === '08' && day === '29') {
            console.log('ä»Šå¤©æ˜¯ä¸ƒå¤•èŠ‚ï¼'); // ä¿æŒåŸæœ‰æ—¥å¿—ï¼Œå› ä¸ºè¿™æ˜¯å…·ä½“çš„æ—¥æœŸåˆ¤æ–­
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºä»Šæ—¥ç¬¬ä¸€æ¬¡æ‰“å¼€åº”ç”¨
            const lastSpecialEventVisit = localStorage.getItem('lastSpecialEventVisit');
            const todayString = today.toDateString();
            
            if (lastSpecialEventVisit !== todayString) {
                console.log('ä»Šæ—¥ç¬¬ä¸€æ¬¡æ‰“å¼€åº”ç”¨ï¼Œå¼€å§‹ç‰¹æ®Šäº‹ä»¶æµç¨‹');
                
                // è®°å½•ä»Šæ—¥å·²è®¿é—®
                localStorage.setItem('lastSpecialEventVisit', todayString);
                
                // å¯åŠ¨ç‰¹æ®Šäº‹ä»¶æµç¨‹ï¼ˆä¸ƒå¤•èŠ‚ï¼‰
                if (window.startSpecialEventFlow && typeof window.startSpecialEventFlow === 'function') {
                    await window.startSpecialEventFlow('qixi');
                } else {
                    console.warn('startSpecialEventFlow å‡½æ•°æœªæ‰¾åˆ°');
                }
            } else {
                console.log('ä»Šæ—¥å·²å¤„ç†è¿‡ç‰¹æ®Šäº‹ä»¶æµç¨‹');
            }
        }
    } catch (error) {
        console.error('ç‰¹æ®Šäº‹ä»¶æ£€æŸ¥å‡ºé”™:', error);
    }
}

// ç«‹å³å¯ç”¨consoleæ•è·å’Œå…¨å±€é”™è¯¯å¤„ç†
setupConsoleCapture();
initializeGlobalErrorHandling();

// åˆ›å»ºå‘½åç©ºé—´å¹¶æš´éœ²ç³»ç»Ÿå·¥å…·å‡½æ•°
window.SystemUtils = {
    announcementManager,
    consoleLogs,
    exportConsoleLogs,
    showDebugLogPage,
    updateDebugLogDisplay,
    clearDebugLogs,
    copyDebugLogs,
    escapeHtml,
    setupConsoleCapture,
    checkSpecialEvents,
    registerServiceWorker
};

// ä¸ºäº†å‘åå…¼å®¹ï¼Œä¿ç•™ä¸€äº›å…³é”®çš„å…¨å±€å¼•ç”¨
// TODO: Remove these global assignments once all code is updated to use SystemUtils.
window.announcementManager = announcementManager;
window.escapeHtml = escapeHtml;

</script>
    <script>
class CharacterMemoryManager {
    constructor() {
        this.isInitialized = false;
        this.conversationCounters = new Map(); // æŒ‰è§’è‰²IDå­˜å‚¨å¯¹è¯è®¡æ•°
        this.lastProcessedMessageIndex = new Map(); // æŒ‰è”ç³»äººIDå­˜å‚¨æœ€åå¤„ç†è®°å¿†çš„æ¶ˆæ¯ç´¢å¼•
        this.globalMemory = ''; // å…¨å±€è®°å¿†
    }

    /**
     * åˆå§‹åŒ–è§’è‰²è®°å¿†ç®¡ç†å™¨
     */
    async init() {
        
        if (this.isInitialized) {
            return;
        }
        
        this.bindEvents();
        
        // å¦‚æœæ•°æ®åº“å·²å‡†å¤‡å¥½ï¼Œç«‹å³åŠ è½½æ•°æ®
        if (window.isIndexedDBReady && window.db) {
            await this.loadConversationCounters();
            await this.loadLastProcessedMessageIndex();
            await this.getGlobalMemory();
        } else {
        }
        
        this.isInitialized = true;
    }

    /**
     * ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
     */
    bindEvents() {
        // é¡µé¢å…³é—­å‰è§¦å‘è®°å¿†æ›´æ–°æ£€æŸ¥
        window.addEventListener('beforeunload', async (e) => {
            await this.handlePageUnload();
        });
    }

    /**
     * é¡µé¢å…³é—­æ—¶çš„å¤„ç†é€»è¾‘
     */
    async handlePageUnload() {
        const currentContact = this.getCurrentContact();
        if (!currentContact) return;

        console.log('é¡µé¢å…³é—­ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°è§’è‰²è®°å¿†');
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„ç”¨æˆ·æ¶ˆæ¯éœ€è¦å¤„ç†
        if (!this.hasNewUserMessages(currentContact)) {
            console.log('æ²¡æœ‰æ–°çš„ç”¨æˆ·æ¶ˆæ¯ï¼Œè·³è¿‡è®°å¿†æ›´æ–°');
            return;
        }
        
        if (currentContact.type === 'group') {
            // ç¾¤èŠï¼šæ£€æŸ¥æ‰€æœ‰æˆå‘˜
            if (window.contacts && Array.isArray(window.contacts)) {
                for (const memberId of currentContact.members) {
                    const member = window.contacts.find(c => c.id === memberId);
                    if (member && member.type === 'private') {
                        await this.checkAndUpdateMemory(member.id, currentContact, true);
                    }
                }
            }
        } else {
            // ç§èŠï¼šæ£€æŸ¥å½“å‰è§’è‰²
            await this.checkAndUpdateMemory(currentContact.id, currentContact, true);
        }
    }

    /**
     * è·å–å½“å‰è”ç³»äºº
     */
    getCurrentContact() {
        return window.currentContact || window.memoryTableManager?.getCurrentContact();
    }

    /**
     * æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å‡†å¤‡å¥½æ‰§è¡Œè®°å¿†æ“ä½œ
     */
    isSystemReady() {
        const ready = window.contacts && 
               Array.isArray(window.contacts) && 
               window.apiSettings && 
               (window.apiSettings.url || window.apiSettings.apiUrl) && // æ£€æŸ¥ä¸¤ä¸ªå¯èƒ½çš„å­—æ®µ
               window.apiService;
               
        
        return ready;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„ç”¨æˆ·æ¶ˆæ¯éœ€è¦å¤„ç†
     */
    hasNewUserMessages(contact) {
        if (!contact || !contact.messages || contact.messages.length === 0) {
            return false;
        }
        
        const lastProcessedIndex = this.lastProcessedMessageIndex.get(contact.id) || -1;
        const currentMessageCount = contact.messages.length;
        
        // ä»æœ€åå¤„ç†çš„ä½ç½®å¼€å§‹ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„ç”¨æˆ·æ¶ˆæ¯
        for (let i = lastProcessedIndex + 1; i < currentMessageCount; i++) {
            if (contact.messages[i].role === 'user') {
                return true;
            }
        }
        
        return false;
    }

    /**
     * åˆ¤æ–­æ˜¯å¦ä¸ºç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆä¸è®¡å…¥ç”¨æˆ·æ¶ˆæ¯æ•°é‡ï¼‰
     */
    isSpecialMessageType(message) {
        // æ’é™¤emojiå’Œçº¢åŒ…ç±»å‹çš„æ¶ˆæ¯
        return message.type === 'emoji' || message.type === 'red_packet';
    }

    /**
     * ç»Ÿè®¡ä»æœ€åå¤„ç†ä½ç½®å¼€å§‹çš„ç”¨æˆ·æ¶ˆæ¯æ•°é‡
     */
    getNewUserMessageCount(contact) {
        if (!contact || !contact.messages || contact.messages.length === 0) {
            return 0;
        }
        
        const lastProcessedIndex = this.lastProcessedMessageIndex.get(contact.id) || -1;
        const currentMessageCount = contact.messages.length;
        let userMessageCount = 0;
        
        // ä»æœ€åå¤„ç†çš„ä½ç½®å¼€å§‹è®¡æ•°ç”¨æˆ·æ¶ˆæ¯
        for (let i = lastProcessedIndex + 1; i < currentMessageCount; i++) {
            const message = contact.messages[i];
            
            if (message.role === 'user' && !this.isSpecialMessageType(message)) {
                userMessageCount++;
            }
        }
        
        return userMessageCount;
    }

    /**
     * ä»IndexedDBåŠ è½½å¯¹è¯è®¡æ•°å™¨
     */
    async loadConversationCounters() {
        if (!window.isIndexedDBReady || !window.db) {
            return;
        }

        try {
            // æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨conversationCountersè¡¨
            if (!window.db.objectStoreNames.contains('conversationCounters')) {
                return;
            }

            const transaction = window.db.transaction(['conversationCounters'], 'readonly');
            const store = transaction.objectStore('conversationCounters');
            const data = await this.promisifyRequest(store.get('counters'));
            
            if (data) {
                this.conversationCounters = new Map(Object.entries(data));
            }
        } catch (error) {
            console.error('åŠ è½½å¯¹è¯è®¡æ•°å™¨å¤±è´¥:', error);
        }
    }

    /**
     * ä¿å­˜å¯¹è¯è®¡æ•°å™¨åˆ°IndexedDB
     */
    async saveConversationCounters() {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDBæœªå‡†å¤‡å¥½ï¼Œæ— æ³•ä¿å­˜å¯¹è¯è®¡æ•°å™¨');
            return;
        }

        try {
            const transaction = window.db.transaction(['conversationCounters'], 'readwrite');
            const store = transaction.objectStore('conversationCounters');
            const countersObj = Object.fromEntries(this.conversationCounters);
            await this.promisifyRequest(store.put({ id: 'counters', ...countersObj }));
            console.log('å¯¹è¯è®¡æ•°å™¨å·²ä¿å­˜');
        } catch (error) {
            console.error('ä¿å­˜å¯¹è¯è®¡æ•°å™¨å¤±è´¥:', error);
        }
    }

    /**
     * ä»IndexedDBåŠ è½½æœ€åå¤„ç†çš„æ¶ˆæ¯ç´¢å¼•
     */
    async loadLastProcessedMessageIndex() {
        if (!window.isIndexedDBReady || !window.db) {
            return;
        }

        try {
            // æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨memoryProcessedIndexè¡¨
            if (!window.db.objectStoreNames.contains('memoryProcessedIndex')) {
                return;
            }

            const transaction = window.db.transaction(['memoryProcessedIndex'], 'readonly');
            const store = transaction.objectStore('memoryProcessedIndex');
            const allData = await this.promisifyRequest(store.getAll());
            
            if (allData && allData.length > 0) {
                // å°†æ•°ç»„è½¬æ¢ä¸ºMap
                allData.forEach(record => {
                    this.lastProcessedMessageIndex.set(record.contactId, record.lastIndex);
                });
            }
        } catch (error) {
            console.error('åŠ è½½æ¶ˆæ¯ç´¢å¼•å¤±è´¥:', error);
        }
    }

    /**
     * ä¿å­˜æœ€åå¤„ç†çš„æ¶ˆæ¯ç´¢å¼•åˆ°IndexedDB
     */
    async saveLastProcessedMessageIndex(contactId, lastIndex) {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDBæœªå‡†å¤‡å¥½ï¼Œæ— æ³•ä¿å­˜æ¶ˆæ¯ç´¢å¼•');
            return;
        }

        try {
            const transaction = window.db.transaction(['memoryProcessedIndex'], 'readwrite');
            const store = transaction.objectStore('memoryProcessedIndex');
            await this.promisifyRequest(store.put({ 
                contactId: contactId, 
                lastIndex: lastIndex,
                lastUpdated: new Date().toISOString()
            }));
            console.log(`è”ç³»äºº ${contactId} çš„æ¶ˆæ¯ç´¢å¼•å·²ä¿å­˜: ${lastIndex}`);
        } catch (error) {
            console.error('ä¿å­˜æ¶ˆæ¯ç´¢å¼•å¤±è´¥:', error);
        }
    }

    /**
     * è·å–è§’è‰²è®°å¿†
     */
    async getCharacterMemory(contactId) {
        if (!window.isIndexedDBReady || !window.db) {
            return null;
        }

        try {
            // æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨characterMemoriesè¡¨
            if (!window.db.objectStoreNames.contains('characterMemories')) {
                return null;
            }

            const transaction = window.db.transaction(['characterMemories'], 'readonly');
            const store = transaction.objectStore('characterMemories');
            const data = await this.promisifyRequest(store.get(contactId));
            return data ? data.memory : null;
        } catch (error) {
            console.error('è·å–è§’è‰²è®°å¿†å¤±è´¥:', error);
            return null;
        }
    }

    /**
     * ä¿å­˜è§’è‰²è®°å¿†ï¼ˆè¦†ç›–å¼ï¼‰
     */
    async saveCharacterMemory(contactId, memory) {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDBæœªå‡†å¤‡å¥½ï¼Œæ— æ³•ä¿å­˜è§’è‰²è®°å¿†');
            return false;
        }

        try {
            // å…ˆè·å–æ›´æ–°æ¬¡æ•°ï¼Œé¿å…åœ¨äº‹åŠ¡ä¸­ç­‰å¾…å¯¼è‡´äº‹åŠ¡è¶…æ—¶
            const currentUpdateCount = await this.getMemoryUpdateCount(contactId);
            
            // ç„¶ååˆ›å»ºæ–°çš„äº‹åŠ¡è¿›è¡Œä¿å­˜
            const transaction = window.db.transaction(['characterMemories'], 'readwrite');
            const store = transaction.objectStore('characterMemories');
            const memoryData = {
                contactId: contactId,
                memory: memory,
                updateCount: currentUpdateCount + 1,
                lastUpdated: new Date().toISOString()
            };
            
            await this.promisifyRequest(store.put(memoryData));
            console.log(`è§’è‰² ${contactId} çš„è®°å¿†å·²ä¿å­˜`);
            return true;
        } catch (error) {
            console.error('ä¿å­˜è§’è‰²è®°å¿†å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * è¿½åŠ è§’è‰²è®°å¿†ï¼ˆç´¯ç§¯å¼ï¼Œç”¨äºè‡ªåŠ¨è®°å¿†ç³»ç»Ÿï¼‰
     */
    async appendCharacterMemory(contactId, newMemory) {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDBæœªå‡†å¤‡å¥½ï¼Œæ— æ³•è¿½åŠ è§’è‰²è®°å¿†');
            return false;
        }

        try {
            // è·å–ç°æœ‰è®°å¿†
            const existingMemory = await this.getCharacterMemory(contactId);
            
            // åˆå¹¶è®°å¿†
            let combinedMemory;
            if (existingMemory && existingMemory.trim()) {
                // å¦‚æœæ–°è®°å¿†åŒ…å«ç°æœ‰è®°å¿†çš„å†…å®¹ï¼Œç›´æ¥ä½¿ç”¨æ–°è®°å¿†ï¼ˆAIå·²ç»æ•´åˆè¿‡äº†ï¼‰
                if (newMemory.includes(existingMemory.substring(0, Math.min(100, existingMemory.length)))) {
                    combinedMemory = newMemory;
                } else {
                    // å¦åˆ™è¿½åŠ æ–°è®°å¿†
                    combinedMemory = existingMemory + '\n\n' + newMemory;
                }
            } else {
                combinedMemory = newMemory;
            }

            // ä¿å­˜åˆå¹¶åçš„è®°å¿†
            return await this.saveCharacterMemory(contactId, combinedMemory);
        } catch (error) {
            console.error('è¿½åŠ è§’è‰²è®°å¿†å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * è·å–è®°å¿†æ›´æ–°æ¬¡æ•°
     */
    async getMemoryUpdateCount(contactId) {
        if (!window.isIndexedDBReady || !window.db) {
            return 0;
        }

        try {
            const transaction = window.db.transaction(['characterMemories'], 'readonly');
            const store = transaction.objectStore('characterMemories');
            const data = await this.promisifyRequest(store.get(contactId));
            return data ? (data.updateCount || 0) : 0;
        } catch (error) {
            console.error('è·å–è®°å¿†æ›´æ–°æ¬¡æ•°å¤±è´¥:', error);
            return 0;
        }
    }

    /**
     * å¢åŠ å¯¹è¯è®¡æ•°
     */
    incrementConversationCounter(contactId) {
        const current = this.conversationCounters.get(contactId) || 0;
        const newCount = current + 1;
        this.conversationCounters.set(contactId, newCount);
        
        console.log(`è§’è‰² ${contactId} å¯¹è¯è®¡æ•°: ${newCount}`);
        
        // å¼‚æ­¥ä¿å­˜ï¼Œé¿å…é˜»å¡
        this.saveConversationCounters();
        
        return newCount;
    }

    /**
     * é‡ç½®å¯¹è¯è®¡æ•°
     */
    resetConversationCounter(contactId) {
        this.conversationCounters.set(contactId, 0);
        this.saveConversationCounters();
    }

    /**
     * è·å–å¯¹è¯è®¡æ•°
     */
    getConversationCounter(contactId) {
        return this.conversationCounters.get(contactId) || 0;
    }

    /**
     * ç¡®ä¿æ•°æ®å·²ä»æ•°æ®åº“åŠ è½½ï¼ˆå»¶è¿ŸåŠ è½½æœºåˆ¶ï¼‰
     */
    async ensureDataLoaded() {
        if (!this.isInitialized && window.isIndexedDBReady && window.db) {
            await this.loadConversationCounters();
            await this.loadLastProcessedMessageIndex();
            await this.getGlobalMemory();
            this.isInitialized = true;
        }
    }

    /**
     * æ£€æŸ¥å¹¶æ›´æ–°è®°å¿†ï¼ˆä¸»å…¥å£ï¼‰
     */
    async checkAndUpdateMemory(contactId, currentContact, forceCheck = false) {
        // ç¡®ä¿æ•°æ®å·²åŠ è½½
        await this.ensureDataLoaded();

        // ç³»ç»Ÿå‡†å¤‡åº¦æ£€æŸ¥
        if (!this.isSystemReady()) {
            return;
        }

        const contact = window.contacts.find(c => c.id === contactId);
        if (!contact) {
            console.warn('æœªæ‰¾åˆ°è”ç³»äºº:', contactId);
            return;
        }

        // æ ¹æ®è”ç³»äººç±»å‹è®¾ç½®ä¸åŒçš„è§¦å‘æ¡ä»¶
        const newUserMessageCount = this.getNewUserMessageCount(currentContact);
        let triggerThreshold;
        if (currentContact?.type === 'group') {
            triggerThreshold = 1; // ç¾¤èŠï¼š1æ¡ç”¨æˆ·æ¶ˆæ¯è§¦å‘
        } else {
            triggerThreshold = 3; // ç§èŠï¼š3æ¡ç”¨æˆ·æ¶ˆæ¯è§¦å‘
        }
        const shouldCheck = forceCheck || newUserMessageCount >= triggerThreshold;

        if (!shouldCheck) {
            return;
        }
        
        try {
            // ç¬¬ä¸€æ­¥ï¼šä½¿ç”¨æ¬¡è¦æ¨¡å‹åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°è®°å¿†
            const shouldUpdate = await this.checkMemoryUpdateNeeded(contact, currentContact);
            
            if (shouldUpdate) {
                // ç¬¬äºŒæ­¥ï¼šä½¿ç”¨ä¸»è¦æ¨¡å‹ç”Ÿæˆ/æ›´æ–°è®°å¿†
                const updateSuccess = await this.generateAndUpdateMemory(contact, currentContact);
                
                // åªæœ‰è®°å¿†æ›´æ–°æˆåŠŸæ—¶æ‰æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
                if (updateSuccess) {
                    await this.markMessagesProcessed(currentContact);
                    console.log('è®°å¿†æ›´æ–°æˆåŠŸï¼ŒlastProcessedIndexå·²æ›´æ–°');
                } else {
                    console.warn('è®°å¿†æ›´æ–°å¤±è´¥ï¼ŒlastProcessedIndexä¿æŒä¸å˜');
                }
            } else {
                // åˆ¤æ–­ä¸ºä¸éœ€è¦æ›´æ–°æ—¶ï¼Œä»ç„¶æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
                await this.markMessagesProcessed(currentContact);
                console.log('æ— éœ€æ›´æ–°è®°å¿†ï¼ŒlastProcessedIndexå·²æ›´æ–°');
            }
        } catch (error) {
            console.error('æ£€æŸ¥æ›´æ–°è®°å¿†æ—¶å‘ç”Ÿé”™è¯¯:', error);
            console.warn('ç”±äºé”™è¯¯ï¼ŒlastProcessedIndexä¿æŒä¸å˜');
        }
    }

    /**
     * æ¸…ç©ºæŒ‡å®šè§’è‰²çš„è®°å¿†
     */
    async clearCharacterMemory(contactId) {
        if (!contactId) {
            console.warn('contactIdä¸ºç©ºï¼Œæ— æ³•æ¸…ç©ºè®°å¿†');
            return false;
        }

        try {
            // æ¸…ç©ºå†…å­˜ä¸­çš„æ•°æ®
            this.lastProcessedMessageIndex.delete(contactId);
            this.conversationCounters.delete(contactId);
            
            // æ¸…ç©ºæ•°æ®åº“ä¸­çš„æ•°æ®
            if (window.isIndexedDBReady && window.db) {
                const transaction = window.db.transaction([
                    'characterMemories', 
                    'memoryProcessedIndex', 
                    'conversationCounters'
                ], 'readwrite');
                
                // åˆ é™¤è§’è‰²è®°å¿†
                const memoryStore = transaction.objectStore('characterMemories');
                await this.promisifyRequest(memoryStore.delete(contactId));
                
                // åˆ é™¤æ¶ˆæ¯å¤„ç†ç´¢å¼•
                const indexStore = transaction.objectStore('memoryProcessedIndex');
                await this.promisifyRequest(indexStore.delete(contactId));
                
                // æ›´æ–°å¯¹è¯è®¡æ•°å™¨ï¼ˆåˆ é™¤è¯¥è§’è‰²çš„è®¡æ•°ï¼‰
                const counterStore = transaction.objectStore('conversationCounters');
                const counterData = await this.promisifyRequest(counterStore.get('counters'));
                if (counterData && counterData[contactId]) {
                    delete counterData[contactId];
                    await this.promisifyRequest(counterStore.put({ id: 'counters', ...counterData }));
                }
            }
            
            return true;
        } catch (error) {
            console.error(`æ¸…ç©ºè§’è‰² ${contactId} è®°å¿†å¤±è´¥:`, error);
            return false;
        }
    }

    /**
     * æ¸…ç©ºæ‰€æœ‰è§’è‰²è®°å¿†ï¼ˆå±é™©æ“ä½œï¼‰
     */
    async clearAllCharacterMemories() {
        try {
            // æ¸…ç©ºå†…å­˜æ•°æ®
            this.lastProcessedMessageIndex.clear();
            this.conversationCounters.clear();
            
            // æ¸…ç©ºæ•°æ®åº“æ•°æ®
            if (window.isIndexedDBReady && window.db) {
                const transaction = window.db.transaction([
                    'characterMemories', 
                    'memoryProcessedIndex', 
                    'conversationCounters'
                ], 'readwrite');
                
                // æ¸…ç©ºæ‰€æœ‰è¡¨
                await this.promisifyRequest(transaction.objectStore('characterMemories').clear());
                await this.promisifyRequest(transaction.objectStore('memoryProcessedIndex').clear());
                await this.promisifyRequest(transaction.objectStore('conversationCounters').clear());
            }
            
            return true;
        } catch (error) {
            console.error('æ¸…ç©ºæ‰€æœ‰è§’è‰²è®°å¿†å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
     */
    async markMessagesProcessed(contact) {
        if (contact && contact.messages && contact.messages.length > 0) {
            const newIndex = contact.messages.length - 1;
            this.lastProcessedMessageIndex.set(contact.id, newIndex);
            console.log(`æ ‡è®°è”ç³»äºº ${contact.id} çš„æ¶ˆæ¯å·²å¤„ç†åˆ°ç´¢å¼• ${newIndex}`);
            
            // å¼‚æ­¥ä¿å­˜åˆ°æ•°æ®åº“ï¼Œé¿å…é˜»å¡
            this.saveLastProcessedMessageIndex(contact.id, newIndex);
        }
    }

    /**
     * è·å–å…¨å±€è®°å¿†
     */
    async getGlobalMemory() {
        if (!window.isIndexedDBReady || !window.db) {
            return this.globalMemory;
        }

        try {
            // æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨globalMemoryè¡¨
            if (!window.db.objectStoreNames.contains('globalMemory')) {
                return this.globalMemory;
            }

            const transaction = window.db.transaction(['globalMemory'], 'readonly');
            const store = transaction.objectStore('globalMemory');
            const data = await this.promisifyRequest(store.get('memory'));
            this.globalMemory = data ? data.content : '';
            return this.globalMemory;
        } catch (error) {
            console.error('è·å–å…¨å±€è®°å¿†å¤±è´¥:', error);
            return this.globalMemory;
        }
    }

    /**
     * ä¿å­˜å…¨å±€è®°å¿†
     */
    async saveGlobalMemory(memory) {
        if (!window.isIndexedDBReady || !window.db) {
            this.globalMemory = memory;
            console.warn('IndexedDBæœªå‡†å¤‡å¥½ï¼Œå…¨å±€è®°å¿†ä»…ä¿å­˜åœ¨å†…å­˜ä¸­');
            return false;
        }

        try {
            const transaction = window.db.transaction(['globalMemory'], 'readwrite');
            const store = transaction.objectStore('globalMemory');
            await this.promisifyRequest(store.put({
                id: 'memory',
                content: memory,
                lastUpdated: new Date().toISOString()
            }));
            this.globalMemory = memory;
            console.log('å…¨å±€è®°å¿†å·²ä¿å­˜');
            return true;
        } catch (error) {
            console.error('ä¿å­˜å…¨å±€è®°å¿†å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * æ£€æŸ¥å¹¶æ›´æ–°åˆ é™¤æ¶ˆæ¯åçš„è®°å¿†
     */
    async checkAndUpdateMemoryAfterDeletion(contactId, deletedMessages, currentContact) {
        // ç¡®ä¿æ•°æ®å·²åŠ è½½
        await this.ensureDataLoaded();

        // ç³»ç»Ÿå‡†å¤‡åº¦æ£€æŸ¥
        if (!this.isSystemReady()) {
            return;
        }

        const contact = window.contacts.find(c => c.id === contactId);
        if (!contact) {
            console.warn('æœªæ‰¾åˆ°è”ç³»äºº:', contactId);
            return;
        }

        // æå–è¢«åˆ é™¤çš„ç”¨æˆ·æ–‡æœ¬æ¶ˆæ¯
        const deletedUserTexts = this.extractDeletedUserTexts(deletedMessages);
        
        if (deletedUserTexts.length === 0) {
            return;
        }

        try {
            // ç¬¬ä¸€æ­¥ï¼šä½¿ç”¨æ¬¡è¦æ¨¡å‹åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ é™¤è®°å¿†
            const shouldDelete = await this.checkMemoryDeletionNeeded(contact, deletedUserTexts);
            
            if (shouldDelete) {
                // ç¬¬äºŒæ­¥ï¼šä½¿ç”¨ä¸»è¦æ¨¡å‹åˆ é™¤ç›¸å…³è®°å¿†
                await this.deleteMemoryContent(contact, deletedUserTexts);
            }
        } catch (error) {
            console.error('æ£€æŸ¥åˆ é™¤è®°å¿†æ—¶å‘ç”Ÿé”™è¯¯:', error);
        }
    }

    /**
     * æå–è¢«åˆ é™¤çš„ç”¨æˆ·æ–‡æœ¬æ¶ˆæ¯
     */
    extractDeletedUserTexts(deletedMessages) {
        const userTexts = [];
        
        deletedMessages.forEach((message, index) => {
            // åªæ”¶é›†ç”¨æˆ·çš„æ™®é€šæ–‡æœ¬æ¶ˆæ¯ï¼Œæ’é™¤emojiå’Œçº¢åŒ…
            if (message.role === 'user' && !this.isSpecialMessageType(message)) {
                userTexts.push(message.content);
            }
        });
        
        return userTexts;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ é™¤è®°å¿†å†…å®¹ï¼ˆè°ƒç”¨æ¬¡è¦æ¨¡å‹ï¼‰
     */
    async checkMemoryDeletionNeeded(contact, deletedUserTexts) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        
        // æ„å»ºåˆ é™¤åˆ¤æ–­æç¤ºè¯
        const prompt = this.buildMemoryDeletionCheckPrompt(currentMemory, deletedUserTexts, contact);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.1, // é™ä½éšæœºæ€§ï¼Œè®©åˆ¤æ–­æ›´ç¨³å®š
                    max_tokens: 5000
                }
            );
            console.log('è®°å¿†åˆ é™¤åˆ¤æ–­APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            
            // å®‰å…¨æ£€æŸ¥APIå“åº”æ ¼å¼
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('è®°å¿†åˆ é™¤åˆ¤æ–­APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('è®°å¿†åˆ é™¤åˆ¤æ–­APIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯:', content);
                return false;
            }
            
            const result = content.trim();
            console.log('è®°å¿†åˆ é™¤åˆ¤æ–­ç»“æœ:', result);
            
            // å¦‚æœæ¨¡å‹å›å¤"éœ€è¦"æˆ–"æ˜¯"ï¼Œåˆ™è®¤ä¸ºéœ€è¦åˆ é™¤
            return result.includes('éœ€è¦') || result.includes('æ˜¯');
        } catch (error) {
            console.error('è°ƒç”¨æ¬¡è¦æ¨¡å‹åˆ¤æ–­è®°å¿†åˆ é™¤å¤±è´¥:', error);
            return false; // å‡ºé”™æ—¶ä¿å®ˆå¤„ç†ï¼Œä¸åˆ é™¤
        }
    }

    /**
     * åˆ é™¤è®°å¿†å†…å®¹ï¼ˆè°ƒç”¨ä¸»è¦æ¨¡å‹ï¼‰
     */
    async deleteMemoryContent(contact, deletedUserTexts) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        
        // æ„å»ºè®°å¿†åˆ é™¤æç¤ºè¯
        const prompt = this.buildMemoryDeletionPrompt(currentMemory, deletedUserTexts, contact);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 10000
                }
            );
            console.log('åˆ é™¤è®°å¿†å†…å®¹APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            
            // å®‰å…¨æ£€æŸ¥APIå“åº”æ ¼å¼
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('åˆ é™¤è®°å¿†APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('åˆ é™¤è®°å¿†APIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯:', content);
                return;
            }
            
            const newMemory = content.trim();
            console.log('æ›´æ–°åçš„è®°å¿†:', newMemory);
            
            // ä¿å­˜æ›´æ–°åçš„è®°å¿†
            await this.saveCharacterMemory(contact.id, newMemory);
            
        } catch (error) {
            console.error('åˆ é™¤è®°å¿†å†…å®¹å¤±è´¥:', error);
        }
    }

    /**
     * æ£€æŸ¥å¹¶æ›´æ–°å…¨å±€è®°å¿†
     */
    async checkAndUpdateGlobalMemory(forumContent, forceCheck = false) {
        console.log('å¼€å§‹æ£€æŸ¥å…¨å±€è®°å¿†æ›´æ–°');
        
        // æ£€æŸ¥å¿…è¦çš„ä¾èµ–æ˜¯å¦å‡†å¤‡å¥½ï¼ˆå…¨å±€è®°å¿†ä¸éœ€è¦contactsæ•°ç»„ï¼‰
        if (!window.apiSettings || !window.apiSettings.url || !window.apiService) {
            console.log('ç³»ç»Ÿæœªå‡†å¤‡å¥½ï¼Œè·³è¿‡å…¨å±€è®°å¿†æ›´æ–°');
            return;
        }
        
        try {
            // ç¬¬ä¸€æ­¥ï¼šä½¿ç”¨æ¬¡è¦æ¨¡å‹åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°å…¨å±€è®°å¿†
            const shouldUpdate = await this.checkGlobalMemoryUpdateNeeded(forumContent);
            
            if (shouldUpdate) {
                console.log('éœ€è¦æ›´æ–°å…¨å±€è®°å¿†');
                // ç¬¬äºŒæ­¥ï¼šä½¿ç”¨ä¸»è¦æ¨¡å‹ç”Ÿæˆ/æ›´æ–°å…¨å±€è®°å¿†
                await this.generateAndUpdateGlobalMemory(forumContent);
            } else {
                console.log('æ— éœ€æ›´æ–°å…¨å±€è®°å¿†');
            }
        } catch (error) {
            console.error('æ£€æŸ¥æ›´æ–°å…¨å±€è®°å¿†æ—¶å‘ç”Ÿé”™è¯¯:', error);
        }
    }

    /**
     * æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°è®°å¿†ï¼ˆè°ƒç”¨æ¬¡è¦æ¨¡å‹ï¼‰
     */
    async checkMemoryUpdateNeeded(contact, currentContact) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        const completeMessageContext = this.buildCompleteMessageContext(currentContact);
        
        // æ„å»ºåˆ¤æ–­æç¤ºè¯
        const prompt = this.buildMemoryCheckPrompt(currentMemory, completeMessageContext, contact);
        
        try {
            // ä½¿ç”¨æ¬¡è¦æ¨¡å‹è¿›è¡Œåˆ¤æ–­
            const modelToUse = this.getSecondaryModel();
            const response = await window.apiService.callOpenAIAPI(
                window.apiSettings.url,
                window.apiSettings.key,
                modelToUse,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.1, // é™ä½éšæœºæ€§ï¼Œè®©åˆ¤æ–­æ›´ç¨³å®š
                    max_tokens: 5000
                }
            );
            console.log('è®°å¿†æ›´æ–°åˆ¤æ–­APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            
            // å®‰å…¨æ£€æŸ¥APIå“åº”æ ¼å¼
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('APIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯:', content);
                return false;
            }
            
            const result = content.trim();
            console.log('è®°å¿†æ›´æ–°åˆ¤æ–­ç»“æœ:', result);
            
            // å¦‚æœæ¨¡å‹æœ‰å›å¤ä¸”ä¸å«"ä¸"æˆ–"å¦"ï¼Œåˆ™è®¤ä¸ºæ»¡è¶³æ¡ä»¶
            return result.length > 0 && !result.includes('ä¸') && !result.includes('å¦');
        } catch (error) {
            console.error('è°ƒç”¨æ¬¡è¦æ¨¡å‹åˆ¤æ–­è®°å¿†æ›´æ–°å¤±è´¥:', error);
            return false; // å‡ºé”™æ—¶ä¿å®ˆå¤„ç†ï¼Œä¸æ›´æ–°
        }
    }

    /**
     * æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°å…¨å±€è®°å¿†ï¼ˆè°ƒç”¨æ¬¡è¦æ¨¡å‹ï¼‰
     */
    async checkGlobalMemoryUpdateNeeded(forumContent) {
        const currentGlobalMemory = await this.getGlobalMemory();
        
        // æ„å»ºåˆ¤æ–­æç¤ºè¯
        const prompt = this.buildGlobalMemoryCheckPrompt(currentGlobalMemory, forumContent);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.1,
                    max_tokens: 7000
                }
            );
            console.log('å…¨å±€è®°å¿†æ›´æ–°åˆ¤æ–­APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            
            // å®‰å…¨æ£€æŸ¥APIå“åº”æ ¼å¼
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('å…¨å±€è®°å¿†APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('å…¨å±€è®°å¿†APIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯:', content);
                return false;
            }
            
            const result = content.trim();
            console.log('å…¨å±€è®°å¿†æ›´æ–°åˆ¤æ–­ç»“æœ:', result);
            
            // å¦‚æœæ¨¡å‹æœ‰å›å¤ä¸”ä¸å«"ä¸"æˆ–"å¦"ï¼Œåˆ™è®¤ä¸ºæ»¡è¶³æ¡ä»¶
            return result.length > 0 && !result.includes('ä¸') && !result.includes('å¦');
        } catch (error) {
            console.error('è°ƒç”¨æ¬¡è¦æ¨¡å‹åˆ¤æ–­å…¨å±€è®°å¿†æ›´æ–°å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * ç”Ÿæˆå¹¶æ›´æ–°è®°å¿†ï¼ˆè°ƒç”¨ä¸»è¦æ¨¡å‹ï¼‰
     */
    async generateAndUpdateMemory(contact, currentContact) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        const completeMessageContext = this.buildCompleteMessageContext(currentContact);
        
        // æ„å»ºè®°å¿†ç”Ÿæˆæç¤ºè¯
        const prompt = this.buildMemoryGeneratePrompt(currentMemory, completeMessageContext, contact);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 10000
                }
            );
            console.log('ç”Ÿæˆè®°å¿†APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            
            // å®‰å…¨æ£€æŸ¥APIå“åº”æ ¼å¼
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('ç”Ÿæˆè®°å¿†APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('ç”Ÿæˆè®°å¿†APIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯:', content);
                return false;
            }
            
            const newMemory = content.trim();
            console.log('ç”Ÿæˆçš„æ–°è®°å¿†:', newMemory);
            
            // è¿½åŠ æ–°è®°å¿†ï¼ˆç´¯ç§¯å¼ä¿å­˜ï¼‰
            const saveSuccess = await this.appendCharacterMemory(contact.id, newMemory);
            return saveSuccess;
            
        } catch (error) {
            console.error('ç”Ÿæˆè®°å¿†å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * ç”Ÿæˆå¹¶æ›´æ–°å…¨å±€è®°å¿†ï¼ˆè°ƒç”¨ä¸»è¦æ¨¡å‹ï¼‰
     */
    async generateAndUpdateGlobalMemory(forumContent) {
        const currentGlobalMemory = await this.getGlobalMemory();
        
        // æ„å»ºè®°å¿†ç”Ÿæˆæç¤ºè¯
        const prompt = this.buildGlobalMemoryGeneratePrompt(currentGlobalMemory, forumContent);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 10000
                }
            );
            console.log('ç”Ÿæˆå…¨å±€è®°å¿†APIå®Œæ•´è¿”å›:', JSON.stringify(response, null, 2));
            
            // å®‰å…¨æ£€æŸ¥APIå“åº”æ ¼å¼
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('ç”Ÿæˆå…¨å±€è®°å¿†APIå“åº”æ ¼å¼å¼‚å¸¸:', response);
                return;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('ç”Ÿæˆå…¨å±€è®°å¿†APIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯:', content);
                return;
            }
            
            const newGlobalMemory = content.trim();
            console.log('ç”Ÿæˆçš„æ–°å…¨å±€è®°å¿†:', newGlobalMemory);
            
            // ä¿å­˜æ–°å…¨å±€è®°å¿†
            await this.saveGlobalMemory(newGlobalMemory);
            
        } catch (error) {
            console.error('ç”Ÿæˆå…¨å±€è®°å¿†å¤±è´¥:', error);
        }
    }

    /**
     * æ„å»ºå®Œæ•´æ¶ˆæ¯ä¸Šä¸‹æ–‡ï¼ˆä»lastProcessedIndexå¼€å§‹çš„æ‰€æœ‰æ¶ˆæ¯ï¼‰
     */
    buildCompleteMessageContext(contact) {
        if (!contact.messages || contact.messages.length === 0) {
            return 'æš‚æ— å¯¹è¯è®°å½•';
        }

        const lastProcessedIndex = this.lastProcessedMessageIndex.get(contact.id) || -1;
        const contextLines = [];
        
        // ä»æœ€åå¤„ç†ä½ç½®å¼€å§‹ï¼Œæ”¶é›†æ‰€æœ‰æ¶ˆæ¯
        for (let i = lastProcessedIndex + 1; i < contact.messages.length; i++) {
            const message = contact.messages[i];
            
            const sender = message.role === 'user' ? 
                (window.userProfile?.name || 'ç”¨æˆ·') : 
                (window.contacts && Array.isArray(window.contacts) ? 
                    window.contacts.find(c => c.id === message.senderId)?.name || contact.name : 
                    contact.name);
                
            let content = message.content;
            
            // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
            if (message.type === 'red_packet') {
                try {
                    const packet = JSON.parse(content);
                    content = `[å‘é€çº¢åŒ…: ${packet.message}, é‡‘é¢: ${packet.amount}å…ƒ]`;
                } catch (e) {
                    content = '[å‘é€çº¢åŒ…]';
                }
            } else if (message.type === 'emoji') {
                const emoji = window.emojis && Array.isArray(window.emojis) ? 
                    window.emojis.find(e => e.url === message.content) : null;
                content = `[è¡¨æƒ…: ${emoji?.meaning || 'æœªçŸ¥è¡¨æƒ…'}]`;
            }
            
            contextLines.push(`${sender}: ${content}`);
        }
        
        if (contextLines.length === 0) {
            return 'æš‚æ— æ–°çš„å¯¹è¯è®°å½•';
        }
        
        return contextLines.join('\n');
    }

    /**
     * æ„å»ºæœ€è¿‘å¯¹è¯ä¸Šä¸‹æ–‡
     */
    buildRecentContext(contact) {
        if (!contact.messages || contact.messages.length === 0) {
            return 'æš‚æ— å¯¹è¯è®°å½•';
        }

        const recentMessages = contact.messages.slice(-20); // è·å–æœ€è¿‘20æ¡æ¶ˆæ¯
        const contextLines = [];
        
        recentMessages.forEach(msg => {
            const sender = msg.role === 'user' ? 
                (window.userProfile?.name || 'ç”¨æˆ·') : 
                (window.contacts && Array.isArray(window.contacts) ? 
                    window.contacts.find(c => c.id === msg.senderId)?.name || contact.name : 
                    contact.name);
                
            let content = msg.content;
            
            // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
            if (msg.type === 'red_packet') {
                try {
                    const packet = JSON.parse(content);
                    content = `[å‘é€çº¢åŒ…: ${packet.message}, é‡‘é¢: ${packet.amount}å…ƒ]`;
                } catch (e) {
                    content = '[å‘é€çº¢åŒ…]';
                }
            } else if (msg.type === 'emoji') {
                const emoji = window.emojis && Array.isArray(window.emojis) ? 
                    window.emojis.find(e => e.url === msg.content) : null;
                content = `[è¡¨æƒ…: ${emoji?.meaning || 'æœªçŸ¥è¡¨æƒ…'}]`;
            }
            
            contextLines.push(`${sender}: ${content}`);
        });
        
        return contextLines.join('\n');
    }

    /**
     * æ„å»ºè®°å¿†æ£€æŸ¥æç¤ºè¯
     */
    buildMemoryCheckPrompt(currentMemory, completeMessageContext, contact) {
        return `ä½ æ˜¯ä¸€ä¸ªè®°å¿†åˆ†æåŠ©æ‰‹ã€‚è¯·åˆ¤æ–­æœ€è¿‘çš„å¯¹è¯å†…å®¹æ˜¯å¦éœ€è¦æ›´æ–°è§’è‰²è®°å¿†ã€‚

å½“å‰è§’è‰²è®°å¿†ï¼š
${currentMemory || 'æš‚æ— è®°å¿†'}

æœ€è¿‘çš„å¯¹è¯å†…å®¹ï¼š
${completeMessageContext}

åˆ¤æ–­æ ‡å‡†ï¼š
1. å¯¹è¯ä¸­æ˜¯å¦æ¶‰åŠåˆ°å½“å‰è®°å¿†ä¸­æ²¡æœ‰çš„ä¸ªäººä¿¡æ¯ï¼Ÿ
2. ç”¨æˆ·æ˜¯å¦ä¸»åŠ¨è¯´æ˜è‡ªèº«çš„å½¢è±¡ã€ç”Ÿæ´»çŠ¶æ€ã€ä¸ªäººæƒ…å†µï¼Ÿï¼ˆä¾‹å¦‚ï¼šç”¨æˆ·æ­£åœ¨æ¥å—å¿ƒç†æ²»ç–—ã€ç”¨æˆ·æ­£åœ¨å‡†å¤‡æ¼”è®²æ¯”èµ›ã€ç”¨æˆ·å–œæ¬¢ä½ ç§°å‘¼ä»–ä¸º...ç­‰ï¼‰
3. å¯¹è¯ä¸­æ˜¯å¦åŒ…å«å€¼å¾—è®°ä½çš„äº‹ä»¶ã€çº¦å®šæˆ–é‡è¦ç»†èŠ‚ï¼Ÿ

è¯·ä»…å›ç­”"æ˜¯"æˆ–"å¦"ï¼Œä¸è¦å…¶ä»–è§£é‡Šã€‚`;
    }

    /**
     * æ„å»ºè®°å¿†ç”Ÿæˆæç¤ºè¯
     */
    buildMemoryGeneratePrompt(currentMemory, completeMessageContext, contact) {
        const userName = window.userProfile?.name || 'ç”¨æˆ·';
        
        return `ä½ æ˜¯ä¸€ä¸ªè®°å¿†æ•´ç†åŠ©æ‰‹ã€‚è¯·æ ¹æ®åŸæœ‰è®°å¿†å’Œæœ€è¿‘çš„å¯¹è¯å†…å®¹ï¼Œæ›´æ–°è§’è‰²è®°å¿†ã€‚

è§’è‰²ä¿¡æ¯ï¼š
- å§“åï¼š${contact.name}
- äººè®¾ï¼š${contact.personality}

ç”¨æˆ·ä¿¡æ¯ï¼š
- å§“åï¼š${userName}
- äººè®¾ï¼š${window.userProfile?.personality || 'æœªè®¾ç½®'}

åŸæœ‰è®°å¿†ï¼š
${currentMemory || 'æš‚æ— åŸæœ‰è®°å¿†'}

æœ€è¿‘çš„å¯¹è¯å†…å®¹ï¼š
${completeMessageContext}

è¯·æ•´åˆåŸæœ‰è®°å¿†å’Œæœ€è¿‘çš„å¯¹è¯å†…å®¹ï¼Œç”Ÿæˆæ›´æ–°åçš„å®Œæ•´è®°å¿†ã€‚è®°å¿†åº”è¯¥ç¬¦åˆä»¥ä¸‹ä»»æ„ä¸€æ¡æ¡ä»¶ï¼š
1. ç”¨æˆ·ä¸»åŠ¨è¯´æ˜çš„ä¸ªäººä¿¡æ¯ã€ç”Ÿæ´»çŠ¶æ€ã€å…´è¶£çˆ±å¥½
2. ç”¨æˆ·ä¸»åŠ¨æåˆ°çš„äº‹ä»¶ã€è®¡åˆ’æˆ–çº¦å®š
3. ç”¨æˆ·ä¸»åŠ¨è¯´æ˜çš„è‡ªå·±çš„æ€åº¦ã€åå¥½å’Œä¸ªæ€§ç‰¹å¾
4. å…¶ä»–å€¼å¾—è®°ä½çš„ç»†èŠ‚ã€çº¦å®šç­‰

è®°å¿†ä¸è¦å¤ªçç¢ï¼ï¼è¦å…·ä½“ï¼

è¯·ç›´æ¥è¾“å‡ºæ›´æ–°åçš„çº¯Markdownè®°å¿†åˆ—è¡¨ï¼Œæ‰€æœ‰è®°å¿†å¹³çº§ï¼Œä¸è¦å…¶ä»–è¯´æ˜ï¼š`;
    }

    /**
     * æ„å»ºè®°å¿†åˆ é™¤æ£€æŸ¥æç¤ºè¯
     */
    buildMemoryDeletionCheckPrompt(currentMemory, deletedUserTexts, contact) {
        const deletedTextsContent = deletedUserTexts.join('\n---\n');
        
        return `ä½ æ˜¯ä¸€ä¸ªè®°å¿†åˆ†æåŠ©æ‰‹ã€‚ç”¨æˆ·åˆ é™¤äº†ä¸€äº›æ¶ˆæ¯ï¼Œè¯·åˆ¤æ–­æ˜¯å¦éœ€è¦ä»è§’è‰²è®°å¿†ä¸­åˆ é™¤ç›¸å…³å†…å®¹ã€‚

å½“å‰è§’è‰²è®°å¿†ï¼š
${currentMemory || 'æš‚æ— è®°å¿†'}

ç”¨æˆ·åˆ é™¤çš„æ¶ˆæ¯å†…å®¹ï¼š
${deletedTextsContent}

åˆ¤æ–­æ ‡å‡†ï¼š
1. è¢«åˆ é™¤çš„æ¶ˆæ¯å†…å®¹æ˜¯å¦åœ¨å½“å‰è®°å¿†ä¸­æœ‰å¯¹åº”çš„è®°å½•ï¼Ÿ
2. åˆ é™¤è¿™äº›æ¶ˆæ¯æ˜¯å¦æ„å‘³ç€ç”¨æˆ·ä¸å¸Œæœ›è¿™äº›ä¿¡æ¯è¢«è®°ä½ï¼Ÿ

è¯·ä»…å›ç­”"éœ€è¦åˆ é™¤"ä¸éœ€è¦åˆ é™¤"ï¼Œä¸éœ€è¦å…¶ä»–è§£é‡Šã€‚`;
    }

    /**
     * æ„å»ºè®°å¿†åˆ é™¤æç¤ºè¯
     */
    buildMemoryDeletionPrompt(currentMemory, deletedUserTexts, contact) {
        const deletedTextsContent = deletedUserTexts.join('\n---\n');
        const userName = window.userProfile?.name || 'ç”¨æˆ·';
        
        return `ä½ æ˜¯ä¸€ä¸ªè®°å¿†æ•´ç†åŠ©æ‰‹ã€‚ç”¨æˆ·åˆ é™¤äº†ä¸€äº›æ¶ˆæ¯ï¼Œè¯·ä»è§’è‰²è®°å¿†ä¸­åˆ é™¤ç›¸å…³å†…å®¹ã€‚

è§’è‰²ä¿¡æ¯ï¼š
- å§“åï¼š${contact.name}
- äººè®¾ï¼š${contact.personality}

ç”¨æˆ·ä¿¡æ¯ï¼š
- å§“åï¼š${userName}
- äººè®¾ï¼š${window.userProfile?.personality || 'æœªè®¾ç½®'}

å½“å‰è®°å¿†ï¼š
${currentMemory || 'æš‚æ— è®°å¿†'}

ç”¨æˆ·åˆ é™¤çš„æ¶ˆæ¯å†…å®¹ï¼š
${deletedTextsContent}

è¯·ä»å½“å‰è®°å¿†ä¸­åˆ é™¤ä¸è¢«åˆ é™¤æ¶ˆæ¯ç›¸å…³çš„å†…å®¹ï¼Œç”Ÿæˆæ›´æ–°åçš„è®°å¿†ã€‚æ³¨æ„ï¼š
1. åˆ é™¤ä¸è¢«åˆ é™¤æ¶ˆæ¯ç›´æ¥ç›¸å…³çš„ä¿¡æ¯
2. ä¿ç•™å…¶ä»–ä¸ç›¸å…³çš„ä¿¡æ¯
3. å¦‚æœåˆ é™¤åè®°å¿†å˜ç©ºï¼Œè¯·è¾“å‡º"æš‚æ— è®°å¿†"
4. ä¿æŒè®°å¿†çš„å®Œæ•´æ€§å’Œé€»è¾‘æ€§

è¯·ç›´æ¥è¾“å‡ºæ›´æ–°åçš„çº¯Markdownè®°å¿†åˆ—è¡¨ï¼Œæ‰€æœ‰è®°å¿†å¹³çº§ï¼Œä¸è¦å…¶ä»–è§£é‡Šï¼š`;
    }

    /**
     * æ„å»ºå…¨å±€è®°å¿†æ£€æŸ¥æç¤ºè¯
     */
    buildGlobalMemoryCheckPrompt(currentGlobalMemory, forumContent) {
        return `ä½ æ˜¯ä¸€ä¸ªå…¨å±€è®°å¿†åˆ†æåŠ©æ‰‹ã€‚è¯·åˆ¤æ–­ä»¥ä¸‹è®ºå›å†…å®¹æ˜¯å¦éœ€è¦æ›´æ–°å…¨å±€è®°å¿†ã€‚

å½“å‰å…¨å±€è®°å¿†ï¼š
${currentGlobalMemory || 'æš‚æ— è®°å¿†'}

è®ºå›å†…å®¹ï¼š
${forumContent}

åˆ¤æ–­æ ‡å‡†ï¼š
1. è®ºå›å†…å®¹æ˜¯å¦æ¶‰åŠåˆ°å…¨å±€è®°å¿†ä¸­æ²¡æœ‰çš„ä¿¡æ¯ï¼Ÿ
2. è®ºå›å†…å®¹æ˜¯å¦æ¶‰åŠåˆ°ç”¨æˆ·æœ¬èº«çš„å½¢è±¡ï¼Œæˆ–ç°å®ç”Ÿæ´»ä¸­çš„äº‹ä»¶ï¼Ÿ

è¯·ä»…å›ç­”"æ»¡è¶³"æˆ–"ä¸æ»¡è¶³"ï¼Œä¸è¦å…¶ä»–è§£é‡Šã€‚`;
    }

    /**
     * æ„å»ºå…¨å±€è®°å¿†ç”Ÿæˆæç¤ºè¯
     */
    buildGlobalMemoryGeneratePrompt(currentGlobalMemory, forumContent) {
        const userName = window.userProfile?.name || 'ç”¨æˆ·';
        
        return `ä½ æ˜¯ä¸€ä¸ªè®°å¿†æ•´ç†åŠ©æ‰‹ã€‚è¯·æ ¹æ®åŸæœ‰è®°å¿†å’Œæä¾›çš„ç”¨æˆ·å‘é€çš„è®ºå›å†…å®¹ï¼Œæ›´æ–°å…¨å±€è®°å¿†ã€‚

ç”¨æˆ·ä¿¡æ¯ï¼š
- å§“åï¼š${userName}
- äººè®¾ï¼š${window.userProfile?.personality || 'æœªè®¾ç½®'}

åŸæœ‰å…¨å±€è®°å¿†ï¼š
${currentGlobalMemory || 'æš‚æ— åŸæœ‰è®°å¿†'}

ç”¨æˆ·å‘é€çš„è®ºå›å†…å®¹ï¼š
${forumContent}

è¯·æ•´åˆåŸæœ‰å…¨å±€è®°å¿†å’Œè®ºå›å†…å®¹ï¼Œç”Ÿæˆæ›´æ–°åçš„å®Œæ•´å…¨å±€è®°å¿†ã€‚å…¨å±€è®°å¿†éœ€è¦æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š
- åˆ†æ¡çš„ç²¾ç‚¼æ¦‚æ‹¬
- å†…å®¹æ»¡è¶³ä»¥ä¸‹ä»»æ„1æ¡
    - ç”¨æˆ·è¡¨è¾¾çš„è§‚ç‚¹ã€å…´è¶£å’Œæ€åº¦
    - ç”¨æˆ·ä¸»åŠ¨æåŠçš„ä¸ªäººä¿¡æ¯ã€ç”Ÿæ´»çŠ¶æ€ã€ç»å†ç­‰
    - å…¶ä»–é‡è¦çš„è®°å¿†

ç”Ÿæˆçš„è®°å¿†ä¸è¦å¤ªçç¢ï¼ï¼è¦å…·ä½“ï¼

è¯·ç›´æ¥è¾“å‡ºæ›´æ–°åçš„çº¯Markdownè®°å¿†åˆ—è¡¨ï¼Œæ‰€æœ‰è®°å¿†å¹³çº§ï¼Œä¸è¦å…¶ä»–è§£é‡Šï¼š`;
    }

    /**
     * PromiseåŒ–IndexedDBè¯·æ±‚
     */
    promisifyRequest(request) {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * å¯¼å‡ºè§’è‰²è®°å¿†æ•°æ®
     */
    async exportMemoryData() {
        if (!window.isIndexedDBReady || !window.db) {
            return {
                characterMemories: {},
                globalMemory: this.globalMemory
            };
        }

        try {
            const transaction = window.db.transaction(['characterMemories', 'globalMemory'], 'readonly');
            
            // å¯¼å‡ºè§’è‰²è®°å¿†
            const memoryStore = transaction.objectStore('characterMemories');
            const allMemories = await this.promisifyRequest(memoryStore.getAll());
            
            const characterMemories = {};
            allMemories.forEach(memory => {
                characterMemories[memory.contactId] = {
                    memory: memory.memory,
                    updateCount: memory.updateCount,
                    lastUpdated: memory.lastUpdated
                };
            });
            
            // å¯¼å‡ºå…¨å±€è®°å¿†
            const globalStore = transaction.objectStore('globalMemory');
            const globalData = await this.promisifyRequest(globalStore.get('memory'));
            const globalMemory = globalData ? globalData.content : '';
            
            return {
                characterMemories: characterMemories,
                globalMemory: globalMemory
            };
        } catch (error) {
            console.error('å¯¼å‡ºè®°å¿†æ•°æ®å¤±è´¥:', error);
            return {
                characterMemories: {},
                globalMemory: this.globalMemory
            };
        }
    }

    /**
     * å¯¼å…¥è§’è‰²è®°å¿†æ•°æ®
     */
    async importMemoryData(memoryData) {
        if (!window.isIndexedDBReady || !window.db || !memoryData) {
            return false;
        }

        try {
            const transaction = window.db.transaction(['characterMemories', 'globalMemory'], 'readwrite');
            
            // å¯¼å…¥è§’è‰²è®°å¿†
            if (memoryData.characterMemories) {
                const memoryStore = transaction.objectStore('characterMemories');
                
                for (const [contactId, data] of Object.entries(memoryData.characterMemories)) {
                    const memoryRecord = {
                        contactId: contactId,
                        memory: data.memory,
                        updateCount: data.updateCount || 0,
                        lastUpdated: data.lastUpdated || new Date().toISOString()
                    };
                    await this.promisifyRequest(memoryStore.put(memoryRecord));
                }
            }
            
            // å¯¼å…¥å…¨å±€è®°å¿†
            if (memoryData.globalMemory !== undefined) {
                const globalStore = transaction.objectStore('globalMemory');
                await this.promisifyRequest(globalStore.put({
                    id: 'memory',
                    content: memoryData.globalMemory,
                    lastUpdated: new Date().toISOString()
                }));
                this.globalMemory = memoryData.globalMemory;
            }
            
            console.log('è®°å¿†æ•°æ®å¯¼å…¥æˆåŠŸ');
            return true;
        } catch (error) {
            console.error('å¯¼å…¥è®°å¿†æ•°æ®å¤±è´¥:', error);
            return false;
        }
    }

    /**
     * è·å–æ¬¡è¦æ¨¡å‹
     */
    getSecondaryModel() {
        const secondaryModel = window.apiSettings?.secondaryModel;
        if (secondaryModel && secondaryModel !== 'sync_with_primary') {
            return secondaryModel;
        }
        // å¦‚æœæ²¡æœ‰é…ç½®æ¬¡è¦æ¨¡å‹ï¼Œä½¿ç”¨ä¸»è¦æ¨¡å‹
        return window.modelSettings?.primaryModel || 'gpt-3.5-turbo';
    }

    /**
     * ä»localStorageè¿ç§»è®°å¿†æ•°æ®åˆ°indexedDB
     */
    async migrateLocalStorageMemories() {
        try {
            console.log('å¼€å§‹æ£€æŸ¥localStorageè®°å¿†æ•°æ®è¿ç§»...');
            
            // æ£€æŸ¥localStorageä¸­æ˜¯å¦æœ‰characterMemoriesæ•°æ®
            const localStorageData = localStorage.getItem('characterMemories');
            if (!localStorageData) {
                console.log('localStorageä¸­æ²¡æœ‰è§’è‰²è®°å¿†æ•°æ®ï¼Œè·³è¿‡è¿ç§»');
                return { migrated: false, reason: 'no_data' };
            }

            const characterMemories = JSON.parse(localStorageData);
            if (!characterMemories || typeof characterMemories !== 'object' || Object.keys(characterMemories).length === 0) {
                console.log('localStorageä¸­çš„è§’è‰²è®°å¿†æ•°æ®ä¸ºç©ºï¼Œæ¸…ç†localStorage');
                localStorage.removeItem('characterMemories');
                return { migrated: false, reason: 'empty_data' };
            }

            console.log(`å‘ç°localStorageä¸­æœ‰${Object.keys(characterMemories).length}ä¸ªè§’è‰²çš„è®°å¿†æ•°æ®ï¼Œå¼€å§‹è¯¦ç»†è¿ç§»...`);

            // ç¡®ä¿IndexedDBå·²å‡†å¤‡å¥½
            if (!window.isIndexedDBReady || !window.db) {
                console.log('IndexedDBæœªå‡†å¤‡å¥½ï¼Œæš‚æ—¶è·³è¿‡è¿ç§»');
                return { migrated: false, reason: 'db_not_ready' };
            }

            let migratedCount = 0;
            let errors = [];

            // éå†æ¯ä¸ªè§’è‰²çš„è®°å¿†
            for (const [contactId, memories] of Object.entries(characterMemories)) {
                try {
                    if (!Array.isArray(memories) || memories.length === 0) {
                        console.log(`è§’è‰²${contactId}çš„è®°å¿†æ•°æ®ä¸ºç©ºï¼Œè·³è¿‡`);
                        continue;
                    }

                    console.log(`å¤„ç†è§’è‰²${contactId}ï¼Œå‘ç°${memories.length}æ¡è®°å¿†`);

                    // è·å–indexedDBä¸­è¯¥è§’è‰²çš„ç°æœ‰è®°å¿†
                    const existingMemory = await this.getCharacterMemory(contactId);
                    console.log(`è§’è‰²${contactId}åœ¨indexedDBä¸­${existingMemory && existingMemory.trim() ? 'å·²æœ‰' : 'æ²¡æœ‰'}è®°å¿†ï¼Œå°†é€æ¡æ£€æŸ¥é‡å¤æ€§`);

                    // è¿‡æ»¤æœ‰æ•ˆè®°å¿†å†…å®¹
                    const validMemories = memories.filter(memory => memory.content && memory.content.trim());
                    console.log(`è§’è‰²${contactId}æœ‰${validMemories.length}æ¡æœ‰æ•ˆè®°å¿†`);
                    
                    if (validMemories.length === 0) {
                        console.log(`è§’è‰²${contactId}æ²¡æœ‰æœ‰æ•ˆè®°å¿†å†…å®¹ï¼Œè·³è¿‡`);
                        continue;
                    }

                    // æ£€æŸ¥æ¯æ¡è®°å¿†çš„é‡å¤æ€§
                    const newMemories = [];
                    let duplicateCount = 0;
                    
                    for (let i = 0; i < validMemories.length; i++) {
                        const memory = validMemories[i];
                        const memoryContent = memory.content.trim();
                        
                        console.log(`  æ£€æŸ¥è®°å¿†${i + 1}(ID:${memory.id}): ${memoryContent.substring(0, 50)}${memoryContent.length > 50 ? '...' : ''}`);
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰è®°å¿†å®Œå…¨é‡å¤
                        if (existingMemory && existingMemory.includes(memoryContent)) {
                            console.log(`    - å‘ç°é‡å¤è®°å¿†ï¼Œè·³è¿‡`);
                            duplicateCount++;
                        } else {
                            console.log(`    - æ–°è®°å¿†ï¼Œå°†æ·»åŠ `);
                            newMemories.push(memoryContent);
                        }
                    }

                    console.log(`è§’è‰²${contactId}ï¼šè·³è¿‡${duplicateCount}æ¡é‡å¤è®°å¿†ï¼Œå‡†å¤‡æ·»åŠ ${newMemories.length}æ¡æ–°è®°å¿†`);

                    if (newMemories.length > 0) {
                        // å¦‚æœæœ‰ç°æœ‰è®°å¿†ï¼Œå°†æ–°è®°å¿†è¿½åŠ åˆ°ç°æœ‰è®°å¿†åé¢
                        let combinedMemory;
                        if (existingMemory && existingMemory.trim()) {
                            combinedMemory = existingMemory + '\n\n' + newMemories.join('\n\n');
                        } else {
                            combinedMemory = newMemories.join('\n\n');
                        }

                        // ä¿å­˜åˆ°indexedDB
                        const success = await this.saveCharacterMemory(contactId, combinedMemory);
                        if (success) {
                            migratedCount++;
                            console.log(`âœ“ è§’è‰²${contactId}æˆåŠŸè¿ç§»${newMemories.length}æ¡æ–°è®°å¿†ï¼ˆè·³è¿‡${duplicateCount}æ¡é‡å¤ï¼‰`);
                            console.log(`  æœ€ç»ˆè®°å¿†å†…å®¹é•¿åº¦: ${combinedMemory.length}å­—ç¬¦`);
                        } else {
                            errors.push(`è§’è‰²${contactId}è®°å¿†ä¿å­˜å¤±è´¥`);
                            console.error(`âœ— è§’è‰²${contactId}è®°å¿†ä¿å­˜å¤±è´¥`);
                        }
                    } else {
                        console.log(`è§’è‰²${contactId}æ‰€æœ‰è®°å¿†éƒ½å·²å­˜åœ¨ï¼Œæ— éœ€è¿ç§»`);
                    }
                } catch (error) {
                    console.error(`è¿ç§»è§’è‰²${contactId}çš„è®°å¿†æ—¶å‡ºé”™:`, error);
                    errors.push(`è§’è‰²${contactId}: ${error.message}`);
                }
            }

            // å¤„ç†å…¨å±€è®°å¿†è¿ç§»
            let globalMigrated = false;
            const globalMemoriesData = localStorage.getItem('globalMemories');
            if (globalMemoriesData) {
                try {
                    const globalMemories = JSON.parse(globalMemoriesData);
                    if (Array.isArray(globalMemories) && globalMemories.length > 0) {
                        console.log(`å‘ç°${globalMemories.length}æ¡å…¨å±€è®°å¿†ï¼Œå¼€å§‹è¿ç§»...`);
                        
                        // è·å–ç°æœ‰å…¨å±€è®°å¿†
                        const existingGlobalMemory = await this.getGlobalMemory();
                        console.log(`indexedDBä¸­${existingGlobalMemory && existingGlobalMemory.trim() ? 'å·²æœ‰' : 'æ²¡æœ‰'}å…¨å±€è®°å¿†ï¼Œå°†é€æ¡æ£€æŸ¥é‡å¤æ€§`);
                        
                        // è¿‡æ»¤æœ‰æ•ˆå…¨å±€è®°å¿†
                        const validGlobalMemories = globalMemories.filter(memory => memory.content && memory.content.trim());
                        console.log(`æœ‰${validGlobalMemories.length}æ¡æœ‰æ•ˆå…¨å±€è®°å¿†`);
                        
                        // æ£€æŸ¥æ¯æ¡å…¨å±€è®°å¿†çš„é‡å¤æ€§
                        const newGlobalMemories = [];
                        let globalDuplicateCount = 0;
                        
                        for (let i = 0; i < validGlobalMemories.length; i++) {
                            const memory = validGlobalMemories[i];
                            const memoryContent = memory.content.trim();
                            
                            console.log(`  æ£€æŸ¥å…¨å±€è®°å¿†${i + 1}(ID:${memory.id}): ${memoryContent.substring(0, 50)}${memoryContent.length > 50 ? '...' : ''}`);
                            
                            // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰å…¨å±€è®°å¿†å®Œå…¨é‡å¤
                            if (existingGlobalMemory && existingGlobalMemory.includes(memoryContent)) {
                                console.log(`    - å‘ç°é‡å¤å…¨å±€è®°å¿†ï¼Œè·³è¿‡`);
                                globalDuplicateCount++;
                            } else {
                                console.log(`    - æ–°å…¨å±€è®°å¿†ï¼Œå°†æ·»åŠ `);
                                newGlobalMemories.push(memoryContent);
                            }
                        }

                        console.log(`å…¨å±€è®°å¿†ï¼šè·³è¿‡${globalDuplicateCount}æ¡é‡å¤è®°å¿†ï¼Œå‡†å¤‡æ·»åŠ ${newGlobalMemories.length}æ¡æ–°è®°å¿†`);
                        
                        if (newGlobalMemories.length > 0) {
                            // å¦‚æœæœ‰ç°æœ‰å…¨å±€è®°å¿†ï¼Œå°†æ–°è®°å¿†è¿½åŠ åˆ°ç°æœ‰è®°å¿†åé¢
                            let combinedGlobalMemory;
                            if (existingGlobalMemory && existingGlobalMemory.trim()) {
                                combinedGlobalMemory = existingGlobalMemory + '\n\n' + newGlobalMemories.join('\n\n');
                            } else {
                                combinedGlobalMemory = newGlobalMemories.join('\n\n');
                            }
                            
                            const success = await this.saveGlobalMemory(combinedGlobalMemory);
                            if (success) {
                                globalMigrated = true;
                                console.log(`âœ“ æˆåŠŸè¿ç§»${newGlobalMemories.length}æ¡æ–°å…¨å±€è®°å¿†ï¼ˆè·³è¿‡${globalDuplicateCount}æ¡é‡å¤ï¼‰`);
                                console.log(`  æœ€ç»ˆå…¨å±€è®°å¿†å†…å®¹é•¿åº¦: ${combinedGlobalMemory.length}å­—ç¬¦`);
                            } else {
                                console.error('âœ— å…¨å±€è®°å¿†ä¿å­˜å¤±è´¥');
                                errors.push('å…¨å±€è®°å¿†ä¿å­˜å¤±è´¥');
                            }
                        } else {
                            console.log('æ‰€æœ‰å…¨å±€è®°å¿†éƒ½å·²å­˜åœ¨ï¼Œæ— éœ€è¿ç§»');
                        }
                    }
                } catch (error) {
                    console.error('è¿ç§»å…¨å±€è®°å¿†æ—¶å‡ºé”™:', error);
                    errors.push(`å…¨å±€è®°å¿†: ${error.message}`);
                }
            }
            
            // è¿ç§»å®Œæˆåæ¸…ç©ºlocalStorage
            if (migratedCount > 0 || globalMigrated) {
                if (migratedCount > 0) {
                    localStorage.removeItem('characterMemories');
                    console.log(`è§’è‰²è®°å¿†è¿ç§»å®Œæˆï¼šæˆåŠŸè¿ç§»${migratedCount}ä¸ªè§’è‰²çš„è®°å¿†`);
                }
                if (globalMigrated) {
                    localStorage.removeItem('globalMemories');
                }
                
                return { 
                    migrated: true, 
                    migratedCount, 
                    globalMigrated,
                    errors: errors.length > 0 ? errors : null 
                };
            } else {
                return { 
                    migrated: false, 
                    reason: 'no_valid_data',
                    errors: errors.length > 0 ? errors : null 
                };
            }

        } catch (error) {
            console.error('localStorageè®°å¿†è¿ç§»å¤±è´¥:', error);
            return { migrated: false, reason: 'migration_error', error: error.message };
        }
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
window.characterMemoryManager = new CharacterMemoryManager();

// æš´éœ²ä¸»è¦å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸ
window.checkAndUpdateMemory = function(contactId, currentContact, forceCheck = false) {
    return window.characterMemoryManager.checkAndUpdateMemory(contactId, currentContact, forceCheck);
};

window.incrementConversationCounter = function(contactId) {
    return window.characterMemoryManager.incrementConversationCounter(contactId);
};

window.checkAndUpdateGlobalMemory = function(forumContent, forceCheck = false) {
    return window.characterMemoryManager.checkAndUpdateGlobalMemory(forumContent, forceCheck);
};

window.checkAndUpdateMemoryAfterDeletion = function(contactId, deletedMessages, currentContact) {
    return window.characterMemoryManager.checkAndUpdateMemoryAfterDeletion(contactId, deletedMessages, currentContact);
};

window.clearCharacterMemory = function(contactId) {
    return window.characterMemoryManager.clearCharacterMemory(contactId);
};

window.clearAllCharacterMemories = function() {
    return window.characterMemoryManager.clearAllCharacterMemories();
};

// æš´éœ²è¿ç§»å‡½æ•°ç”¨äºæ‰‹åŠ¨æµ‹è¯•
window.testMigrateLocalStorageMemories = function() {
    return window.characterMemoryManager.migrateLocalStorageMemories();
};

// è‡ªåŠ¨åˆå§‹åŒ– - ä»…ç»‘å®šäº‹ä»¶ï¼Œæ•°æ®åŠ è½½åœ¨æ•°æ®åº“å‡†å¤‡å¥½åè‡ªåŠ¨æ‰§è¡Œ
document.addEventListener('DOMContentLoaded', function() {
    if (window.characterMemoryManager) {
        window.characterMemoryManager.bindEvents();
        // æ³¨æ„ï¼šæ•°æ®åŠ è½½å°†åœ¨ script.js ä¸­æ•°æ®åº“å‡†å¤‡å¥½åè‡ªåŠ¨æ‰§è¡Œ
    }
});

// å¯¼å‡ºæ¨¡å—ï¼ˆå¦‚æœä½¿ç”¨ES6æ¨¡å—ï¼‰
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        CharacterMemoryManager
    };
}
</script>
    <script>
/**
 * å›¾ç‰‡å…³é”®è¯ç”Ÿæˆå™¨
 * ä½¿ç”¨AIå°†ä¸­æ–‡å›¾ç‰‡æè¿°è½¬æ¢ä¸ºæ›´ç²¾å‡†çš„è‹±æ–‡æœç´¢å…³é”®è¯ï¼Œæå‡Unsplashå›¾ç‰‡æœç´¢æ•ˆæœ
 */

class ImageKeywordGenerator {
    constructor() {
        this.initialized = false;
    }

    /**
     * åˆå§‹åŒ–å…³é”®è¯ç”Ÿæˆå™¨
     * @param {Object} apiSettings - APIé…ç½®
     * @param {Object} apiService - APIæœåŠ¡å®ä¾‹
     */
    init(apiSettings, apiService) {
        this.apiSettings = apiSettings;
        this.apiService = apiService;
        this.initialized = true;
    }

    /**
     * ä½¿ç”¨AIç”Ÿæˆé€‚åˆUnsplashæœç´¢çš„å…³é”®è¯
     * @param {string} content åŸå§‹å†…å®¹æè¿°
     * @returns {Promise<string>} ç”Ÿæˆçš„æœç´¢å…³é”®è¯
     */
    async generateKeyword(content) {
        // æ£€æŸ¥åˆå§‹åŒ–çŠ¶æ€
        if (!this.initialized) {
            console.warn('ImageKeywordGeneratoræœªåˆå§‹åŒ–ï¼Œä½¿ç”¨åŸå§‹å†…å®¹ä½œä¸ºæœç´¢å…³é”®è¯');
            return content;
        }

        // æ£€æŸ¥å¹¶è·å–APIé…ç½®
        try {
            const apiConnection = await window.apiConfigManager.getCurrentApiConnection();

            if (!apiConnection.url || !apiConnection.key || !apiConnection.primaryModel) {
                console.warn('AI APIæœªé…ç½®ï¼Œä½¿ç”¨åŸå§‹å†…å®¹ä½œä¸ºæœç´¢å…³é”®è¯');
                return content;
            }

            const prompt = `Generate 2-5 English keywords for Unsplash photo search based on this description: "${content}"

Requirements:
- Only return keywords separated by spaces
- Focus on visual, concrete elements
- Avoid abstract concepts
- Prefer landscapes, objects, scenes over people
- Maximum 50 characters total

Keywords:`;

            // å¤„ç†æ¬¡è¦æ¨¡å‹é€‰æ‹©é€»è¾‘
            const modelToUse = apiConnection.secondaryModel === 'sync_with_primary'
                ? apiConnection.primaryModel
                : (apiConnection.secondaryModel || apiConnection.primaryModel);

            console.log(`[ImageKeywordGenerator] ä½¿ç”¨æ¨¡å‹: ${modelToUse} (secondaryModelé…ç½®: ${apiConnection.secondaryModel})`);

            const response = await this.apiService.callOpenAIAPI(
                apiConnection.url,
                apiConnection.key,
                modelToUse,
                [{ role: 'user', content: prompt }],
                {
                    temperature: 0.7,
                    max_tokens: 3000
                },
                (this.apiSettings.timeout * 1000) || 30000
            );
            
            // æ£€æŸ¥å“åº”çš„å®Œæ•´æ€§
            const choice = response.choices[0];
            if (!choice) {
                console.warn('[ImageKeywordGenerator] APIå“åº”ä¸­æ²¡æœ‰choicesï¼Œä½¿ç”¨åŸå§‹å†…å®¹');
                return content;
            }
            
            // æ£€æŸ¥æ˜¯å¦è¢«æˆªæ–­
            if (choice.finish_reason === 'length') {
                console.warn('[ImageKeywordGenerator] APIå“åº”è¢«æˆªæ–­ï¼Œä½¿ç”¨åŸå§‹å†…å®¹');
                return content;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
            if (choice.finish_reason !== 'stop' && choice.finish_reason !== null) {
                console.warn(`[ImageKeywordGenerator] APIå“åº”å¼‚å¸¸ç»“æŸ (${choice.finish_reason})ï¼Œä½¿ç”¨åŸå§‹å†…å®¹`);
                return content;
            }
            
            const keyword = choice.message?.content?.trim();
            if (!keyword || keyword.length === 0) {
                console.warn('[ImageKeywordGenerator] AIè¿”å›ç©ºå…³é”®è¯ï¼Œä½¿ç”¨åŸå§‹å†…å®¹');
                return content;
            }
            
            // éªŒè¯å…³é”®è¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„è‹±æ–‡
            const isValidKeyword = /^[a-zA-Z0-9\s\-.,!?]+$/.test(keyword) && 
                                 keyword.length > 0 && 
                                 keyword.length < 200 && 
                                 !keyword.includes('{') && 
                                 !keyword.includes('}');
            
            if (!isValidKeyword) {
                console.warn(`[ImageKeywordGenerator] ç”Ÿæˆçš„å…³é”®è¯æ ¼å¼æ— æ•ˆ: "${keyword.substring(0, 100)}..."ï¼Œä½¿ç”¨åŸå§‹å†…å®¹`);
                return content;
            }
            
            console.log(`[ImageKeywordGenerator] AIç”Ÿæˆå…³é”®è¯: "${keyword}" (åŸå§‹: "${content}")`);
            return keyword;
            
        } catch (error) {
            console.warn('[ImageKeywordGenerator] ç”Ÿæˆå…³é”®è¯å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹å†…å®¹:', error);
            return content;
        }
    }

    /**
     * æ‰¹é‡ç”Ÿæˆå…³é”®è¯ï¼ˆç”¨äºåŒæ—¶å¤„ç†å¤šä¸ªæè¿°ï¼‰
     * @param {Array<string>} contents åŸå§‹å†…å®¹æè¿°æ•°ç»„
     * @returns {Promise<Array<string>>} ç”Ÿæˆçš„æœç´¢å…³é”®è¯æ•°ç»„
     */
    async generateKeywords(contents) {
        if (!Array.isArray(contents)) {
            throw new Error('contentså¿…é¡»æ˜¯æ•°ç»„');
        }

        const results = [];
        for (const content of contents) {
            const keyword = await this.generateKeyword(content);
            results.push(keyword);
        }
        return results;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–å¹¶å¯ç”¨
     * @returns {boolean}
     */
    async isReady() {
        if (!this.initialized) return false;

        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            return connection.url && connection.key && connection.primaryModel;
        } catch (error) {
            return false;
        }
    }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
window.imageKeywordGenerator = new ImageKeywordGenerator();

/**
 * å‘åå…¼å®¹çš„å…¨å±€å‡½æ•°
 * @param {string} content åŸå§‹å†…å®¹æè¿°
 * @returns {Promise<string>} ç”Ÿæˆçš„æœç´¢å…³é”®è¯
 */
async function generateImageSearchKeyword(content) {
    return await window.imageKeywordGenerator.generateKeyword(content);
}

// å¯¼å‡ºåˆ°å…¨å±€ä½œç”¨åŸŸä»¥ä¿æŒå‘åå…¼å®¹
window.generateImageSearchKeyword = generateImageSearchKeyword;
</script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker disabled in single-file mode: ', err);
                    });
            });
        }
    </script>
    
    <!-- æŒä¹…åŒ–å­˜å‚¨è¯´æ˜æ¨¡æ€æ¡† -->
    <div id="persistentStorageInfoModal" class="info-modal modal-overlay hidden" onclick="if(event.target === this) StorageManager.closePersistentStorageInfo()">
        <div class="modal-content">
            <div class="modal-header">
                ğŸ“š æ•°æ®æŒä¹…åŒ–å­˜å‚¨è¯´æ˜
            </div>
            <div class="modal-body">
                <p><strong>ä»€ä¹ˆæ˜¯æ•°æ®æŒä¹…åŒ–å­˜å‚¨ï¼Ÿ</strong></p>
                <p>æ•°æ®æŒä¹…åŒ–å­˜å‚¨ï¼Œä»£è¡¨æ•°æ®ä¸ä¼šè½»æ˜“è¢«è®¾å¤‡/æµè§ˆå™¨æ¸…é™¤ã€‚</p>
                
                <p><strong>ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ</strong></p>
                <p>è‹¥æœªæŒä¹…å­˜å‚¨ï¼Œåˆ™å¯èƒ½ä¼šè¢«éšæ—¶æ¸…ç†ï¼Œå¯¼è‡´æ•°æ®ä¸¢å¤±ã€‚</p>
                
                <p><strong>å¦‚ä½•è·å¾—ï¼Ÿ</strong></p>
                <p>è¯·å°è¯•"ç”³è¯·æŒä¹…åŒ–æ•°æ®åº“"æŒ‰é’®ã€‚è‹¥ç”³è¯·æœªé€šè¿‡ï¼Œå¯ä»¥å°è¯•ï¼š</p>
                <ul>
                    <li>å¤šè®¿é—®ç½‘é¡µï¼Œå¢åŠ ä½¿ç”¨é¢‘ç‡</li>
                    <li>ç­‰å‡ å¤©å†å°è¯•ç”³è¯·</li>
                    <li>å°†ç½‘ç«™æ·»åŠ åˆ°ä¹¦ç­¾</li>
                </ul>
                
                <p><strong>æœŸé—´å»ºè®®</strong></p>
                <p>ç”³è¯·æœŸé—´ï¼Œè¯·é¢‘ç¹å¤‡ä»½æ•°æ®ä»¥é˜²ä¸¢å¤±ã€‚</p>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn" onclick="StorageManager.closePersistentStorageInfo()">
                    æˆ‘çŸ¥é“äº†
                </button>
            </div>
        </div>
    </div>
</body>
</html>
