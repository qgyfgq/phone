<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Whale-LLT 小手机</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="AI聊天助手">
    <meta name="theme-color" content="#07c160">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Whale-LLT">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Whale-LLT">
    
    <!-- PWA Icons -->
    <link rel="apple-touch-icon" sizes="152x152" href="./assets/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./assets/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./assets/icon-16x16.png">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#07c160">
    <meta name="msapplication-TileColor" content="#07c160">
    
    <!-- Manifest -->
    <link rel="manifest" href="./assets/manifest.json">
    
    
    <!-- 字体按需加载 - 移除预加载的CSS，改为动态加载 -->
    
    <script>
/**
 * 云同步配置 - 自动检测部署环境
 */
class SyncConfig {
    /**
     * 获取API基础URL
     */
    static getApiBaseUrl() {
        // 如果在浏览器环境中
        if (typeof window !== 'undefined') {
            const hostname = window.location.hostname;
            
            // Vercel部署检测
            if (hostname.includes('.vercel.app') || hostname.includes('vercel')) {
                return ''; // 相对路径，使用当前域名的API
            }
            
            // Netlify部署检测 - 改为直接调用Vercel API
            if (hostname.includes('.netlify.app') || hostname.includes('netlify')) {
                // 直接使用生产环境Vercel域名，不再通过Netlify Functions代理
                return 'https://chat.whale-llt.top';
            }
            
            // 本地开发环境
            if (hostname === 'localhost' || hostname === '127.0.0.1') {
                // 如果是在Vercel Dev环境
                if (window.location.port === '3000') {
                    return ''; // 使用本地Vercel API
                }
                // 如果是其他本地环境，调用已部署的Vercel API
                return 'https://chat.whale-llt.top';
            }
            
            // 自定义域名 - 默认使用相对路径
            return '';
        }
        
        // Node.js环境（服务端）- 默认相对路径
        return '';
    }
    
    /**
     * 获取完整的API URL
     */
    static getApiUrl(endpoint) {
        const baseUrl = this.getApiBaseUrl();
        
        // 所有情况都使用标准API路径，不再使用Netlify函数代理
        return `${baseUrl}/api/sync/${endpoint}`;
    }
    
    /**
     * 检查当前是否为Vercel环境（有API能力）
     */
    static isVercelEnvironment() {
        if (typeof window !== 'undefined') {
            const hostname = window.location.hostname;
            return hostname.includes('.vercel.app') || 
                   hostname.includes('vercel') ||
                   (hostname === 'localhost' && window.location.port === '3000');
        }
        return false;
    }
    
    /**
     * 获取密钥生成器URL
     */
    static getKeyGeneratorUrl() {
        const baseUrl = this.getApiBaseUrl();
        return `${baseUrl}/sync-key-generator.html`;
    }
}
// 导出配置
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SyncConfig;
} else {
    window.SyncConfig = SyncConfig;
}
</script>
    <script>
/**
 * 环境配置系统 - 支持构建时环境变量注入
 * 支持 Vercel 和 Netlify 部署平台
 */
class EnvironmentConfig {
    /**
     * 环境指示器关键词配置
     * 当环境标签包含这些关键词时，将显示环境指示器
     */
    static INDICATOR_KEYWORDS = ['测试', '开发', 'test', 'dev'];

    /**
     * 构建时环境变量占位符
     * 这些将在构建过程中被实际值替换
     */
    static BUILD_TIME_CONFIG = {
        // 环境类型: development, staging, production
        ENVIRONMENT: 'production',
        // 应用版本
        APP_VERSION: '1.0.0',
        // 构建时间戳
        BUILD_TIMESTAMP: '2025-09-15T15:34:10.370Z',
        // Git 提交哈希
        GIT_COMMIT: '4e267410f8c8f2ca802f712b0c44b36b73ab3f07',
        // 是否为开发版本
        IS_DEVELOPMENT: 'false',
        // 自定义标签
        ENVIRONMENT_LABEL: ''
    };

    /**
     * 获取当前环境配置
     */
    static getEnvironment() {
        // 优先使用构建时注入的环境变量
        let environment = this.BUILD_TIME_CONFIG.ENVIRONMENT;
        let isDevelopment = this.BUILD_TIME_CONFIG.IS_DEVELOPMENT;
        let environmentLabel = this.BUILD_TIME_CONFIG.ENVIRONMENT_LABEL;

        // 如果没有被替换（仍然包含花括号），则回退到运行时检测
        if (environment.includes('{{')) {
            environment = this.detectEnvironmentFromURL();
            isDevelopment = environment !== 'production';
            environmentLabel = this.getDefaultEnvironmentLabel(environment);
        } else {
            // 处理字符串形式的布尔值
            isDevelopment = isDevelopment === 'true' || isDevelopment === true;
        }

        return {
            environment,
            isDevelopment,
            environmentLabel,
            version: this.getVersion(),
            buildTime: this.getBuildTime(),
            gitCommit: this.getGitCommit()
        };
    }

    /**
     * 通过URL检测环境（回退方案）
     */
    static detectEnvironmentFromURL() {
        if (typeof window === 'undefined') return 'production';

        const hostname = window.location.hostname;

        // 本地开发环境
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('192.168.')) {
            return 'development';
        }

        // Vercel Preview 部署
        if (hostname.includes('-git-') || hostname.includes('.vercel.app')) {
            // 检查是否是 dev 分支或包含 dev 相关标识
            if (hostname.includes('-dev-') || hostname.includes('-develop-') || 
                hostname.includes('-test-') || hostname.includes('-staging-')) {
                return 'staging';
            }
            // Vercel 的主分支部署通常是生产环境
            return hostname.includes('main') ? 'production' : 'staging';
        }

        // Netlify 部署
        if (hostname.includes('.netlify.app')) {
            // 检查域名中是否包含开发相关关键词
            if (hostname.includes('dev') || hostname.includes('test') || 
                hostname.includes('staging') || hostname.includes('preview')) {
                return 'staging';
            }
            
            // Netlify 的 branch 部署检测（格式：branch--sitename.netlify.app）
            if (hostname.includes('--')) {
                const parts = hostname.split('--');
                const branchName = parts[0];
                if (branchName && (branchName.includes('dev') || branchName.includes('test'))) {
                    return 'staging';
                }
            }
            
            // 默认为生产环境
            return 'production';
        }

        // 自定义域名默认为生产环境
        return 'production';
    }

    /**
     * 获取默认环境标签
     */
    static getDefaultEnvironmentLabel(environment) {
        switch (environment) {
            case 'development':
                return '开发环境';
            case 'staging':
                return '测试环境';
            case 'production':
            default:
                return null; // 生产环境不显示标签
        }
    }

    /**
     * 获取应用版本
     */
    static getVersion() {
        // 优先使用 git commit hash 的前7位作为版本显示
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        if (gitCommit !== 'unknown' && gitCommit.length >= 7) {
            return gitCommit.substring(0, 7);
        }
        
        // 如果没有有效的 git commit hash，回退到应用版本号
        let version = this.BUILD_TIME_CONFIG.APP_VERSION;
        return version.includes('{{') ? 'dev' : version;
    }

    /**
     * 获取构建时间
     */
    static getBuildTime() {
        let buildTime = this.BUILD_TIME_CONFIG.BUILD_TIMESTAMP;
        return buildTime.includes('{{') ? new Date().toISOString() : buildTime;
    }

    /**
     * 获取 Git 提交哈希
     */
    static getGitCommit() {
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        return gitCommit.includes('{{') ? 'unknown' : gitCommit;
    }

    /**
     * 检查是否应该显示环境指示器
     * 在以下情况下显示：
     * 1. 非生产环境
     * 2. 环境标签包含"测试"或"开发"关键词
     */
    static shouldShowEnvironmentIndicator() {
        const config = this.getEnvironment();
        
        // 非生产环境始终显示
        if (config.environment !== 'production') {
            return true;
        }
        
        // 检查环境标签是否包含指示器关键词
        if (config.environmentLabel) {
            const label = config.environmentLabel.toLowerCase();
            return this.INDICATOR_KEYWORDS.some(keyword => label.includes(keyword));
        }
        
        return false;
    }

    /**
     * 获取环境指示器配置
     * 根据shouldShowEnvironmentIndicator的逻辑决定是否返回配置
     */
    static getEnvironmentIndicatorConfig() {
        const config = this.getEnvironment();
        
        // 使用shouldShowEnvironmentIndicator方法统一判断逻辑
        if (!this.shouldShowEnvironmentIndicator()) {
            return null;
        }

        // 返回环境指示器配置
        return {
            text: config.environmentLabel ? `${config.environmentLabel} - 开发中内容，不代表最终成果` : '开发中内容，不代表最终成果',
            version: config.version,
            environment: config.environment
        };
    }

    /**
     * 打印环境信息到控制台
     */
    static printEnvironmentInfo() {
        const config = this.getEnvironment();
        console.group('🌍 Environment Info');
        console.log('Environment:', config.environment);
        console.log('Development Mode:', config.isDevelopment);
        console.log('Version:', config.version);
        console.log('Build Time:', config.buildTime);
        console.log('Git Commit:', config.gitCommit);
        if (config.environmentLabel) {
            console.log('Label:', config.environmentLabel);
        }
        console.groupEnd();
    }
}

// 导出配置
if (typeof module !== 'undefined' && module.exports) {
    module.exports = EnvironmentConfig;
} else {
    window.EnvironmentConfig = EnvironmentConfig;
}

</script>
    <script>
/**
 * 环境指示器组件
 * 在非生产环境下显示环境提示信息
 */
class EnvironmentIndicator {
    constructor() {
        this.indicator = null;
        this.isVisible = false;
    }

    /**
     * 初始化环境指示器
     */
    init() {
        // 确保 EnvironmentConfig 已加载
        if (typeof EnvironmentConfig === 'undefined') {
            console.warn('EnvironmentConfig not loaded, environment indicator disabled');
            return;
        }

        // 调试：打印当前环境信息
        console.log('🌍 Environment Indicator Initializing...');
        const envInfo = EnvironmentConfig.getEnvironment();
        console.log('Environment Info:', envInfo);

        const config = EnvironmentConfig.getEnvironmentIndicatorConfig();
        console.log('Indicator Config:', config);
        
        if (config) {
            this.createIndicator(config);
            this.show();
            console.log('✅ Environment indicator created and shown');
            
            // 打印环境信息到控制台
            EnvironmentConfig.printEnvironmentInfo();
        } else {
            console.log('❌ Environment indicator not shown (production or disabled)');
        }
    }

    /**
     * 创建指示器DOM元素
     */
    createIndicator(config) {
        // 避免重复创建
        if (this.indicator) {
            this.indicator.remove();
        }

        const indicator = document.createElement('div');
        indicator.className = 'environment-indicator';
        indicator.innerHTML = `
            <div class="environment-indicator-content">
                <span class="environment-text">${config.text}</span>
                <span class="environment-version">${config.version}</span>
            </div>
        `;

        // 设置样式
        this.setIndicatorStyles(indicator, config);
        
        this.indicator = indicator;
        document.body.appendChild(indicator);
    }

    /**
     * 设置指示器样式
     */
    setIndicatorStyles(element, config) {
        // 使用 setProperty 方法应用关键样式以确保优先级
        element.style.setProperty('position', 'fixed', 'important');
        element.style.setProperty('bottom', '52px', 'important');
        element.style.setProperty('left', '50%', 'important');
        element.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
        element.style.setProperty('backgroundColor', 'transparent', 'important');
        element.style.setProperty('color', '#ff6600', 'important');
        element.style.setProperty('z-index', '999999', 'important');
        element.style.setProperty('pointer-events', 'none', 'important');
        
        // 应用其他样式
        const additionalStyles = {
            padding: '4px 0',
            borderRadius: '0',
            fontSize: '11px',
            fontWeight: '500',
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            boxShadow: 'none',
            userSelect: 'none',
            opacity: '0.8',
            maxWidth: '300px',
            lineHeight: '1.1',
            textAlign: 'center',
            transition: 'opacity 0.3s ease-in-out',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
        };

        Object.assign(element.style, additionalStyles);

        // 为内容容器设置样式
        const content = element.querySelector('.environment-indicator-content');
        if (content) {
            Object.assign(content.style, {
                display: 'inline', // 改为内联显示
                gap: '0'
            });
        }

        // 为版本号设置样式
        const version = element.querySelector('.environment-version');
        if (version) {
            Object.assign(version.style, {
                fontSize: '10px',
                opacity: '0.7',
                fontWeight: 'normal',
                marginLeft: '4px'
            });
        }
    }

    /**
     * 显示指示器
     */
    show() {
        if (this.indicator && !this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
            this.indicator.style.setProperty('opacity', '0.8', 'important');
            this.isVisible = true;
        }
    }

    /**
     * 隐藏指示器
     */
    hide() {
        if (this.indicator && this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(100%)', 'important');
            this.indicator.style.setProperty('opacity', '0', 'important');
            this.isVisible = false;
            
            // 延迟移除元素
            setTimeout(() => {
                if (this.indicator && this.indicator.parentNode) {
                    this.indicator.parentNode.removeChild(this.indicator);
                }
                this.indicator = null;
            }, 300);
        }
    }

    /**
     * 切换显示状态
     */
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.init();
        }
    }

    /**
     * 销毁指示器
     */
    destroy() {
        this.hide();
    }
}

/**
 * 全局环境指示器实例
 */
window.environmentIndicator = new EnvironmentIndicator();

/**
 * DOM加载完成后自动初始化
 */
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.environmentIndicator.init();
    });
} else {
    // 如果DOM已经加载完成
    window.environmentIndicator.init();
}

/**
 * 开发调试功能
 * 在控制台中可以使用以下命令：
 * - environmentIndicator.toggle() - 切换显示
 * - environmentIndicator.hide() - 隐藏指示器  
 * - environmentIndicator.show() - 显示指示器
 * - EnvironmentConfig.printEnvironmentInfo() - 打印环境信息
 */
if (typeof EnvironmentConfig !== 'undefined') {
    const config = EnvironmentConfig.getEnvironment();
    if (config.isDevelopment) {
        console.log('🔧 Environment Indicator Debug Commands:');
        console.log('  environmentIndicator.toggle() - Toggle indicator');
        console.log('  environmentIndicator.hide() - Hide indicator');
        console.log('  environmentIndicator.show() - Show indicator');
        console.log('  EnvironmentConfig.printEnvironmentInfo() - Print env info');
    }
}
</script>
    <script>
/**
 * API配置管理器
 * 支持多组API配置的增删改查和切换
 * 包含API Key使用统计功能
 * 遵循项目的IndexedDB存储规范
 */
class APIConfigManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.dbVersion = 14; // 需要与主项目保持一致
        this.settingsStore = 'apiSettings'; // 统一使用apiSettings表存储所有配置
        // 不再使用实例变量存储db连接，直接使用window.db
        this.defaultConfigKey = 'settings'; // 默认配置使用'settings'键保持兼容性
        
        // 默认配置模板 - 移除模型字段
        this.defaultConfig = {
            id: '',
            name: '默认配置',
            url: '',
            key: '',
            contextMessageCount: 10,
            timeout: 60,
            isDefault: false,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        // 全局模型配置键
        this.globalModelConfigKey = 'global_model_config';
        
        // 当前激活的配置ID
        this.activeConfigId = null;
        this.availableModels = new Map(); // 缓存每个配置的可用模型列表
        
        // API Key统计功能
        this.statsStorageKey = 'apiKeyUsageStats';
        // console.log(`[API统计调试] APIConfigManager构造函数被调用，statsStorageKey=${this.statsStorageKey}`);
        this.stats = this.loadStats();
        // console.log(`[API统计调试] 构造函数中加载的stats:`, JSON.stringify(this.stats, null, 2));
        this.cleanupInterval = null;
    }

    /**
     * 初始化配置管理器
     */
    async init() {
        return await ensureDBReady(async () => {
            // 不再缓存 window.db，直接使用全局变量
            await this.migrateExistingConfig();
            await this.loadActiveConfig();

            // 初始化全局模型配置
            await this.initGlobalModelConfig();

            // 启动统计功能
            this.startAutoCleanup();
            console.log('API配置管理器初始化完成');
            return { success: true };
        }, 'API配置管理器初始化');
    }

    /**
     * 初始化多配置系统，不需要迁移，直接复用现有settings
     */
    async migrateExistingConfig() {
        try {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const existingSettings = await promisifyRequest(store.get(this.defaultConfigKey), '检查现有API设置');
            
            if (existingSettings && existingSettings.url && existingSettings.key) {
                // 为现有settings添加多配置系统需要的元数据
                const enhancedSettings = {
                    ...existingSettings,
                    configName: '默认配置',
                    isDefault: true,
                    createdAt: existingSettings.createdAt || Date.now(),
                    updatedAt: Date.now()
                };
                
                // 更新现有settings以包含多配置元数据
                const writeTransaction = window.db.transaction([this.settingsStore], 'readwrite');
                const writeStore = writeTransaction.objectStore(this.settingsStore);
                await promisifyRequest(writeStore.put(enhancedSettings), '增强现有配置');
                
                // 设置为当前激活配置
                this.activeConfigId = this.defaultConfigKey;
                await this.saveActiveConfigId(this.defaultConfigKey);
                console.log('现有配置已增强为多配置系统');
            }
        } catch (error) {
            console.log('配置初始化跳过（可能是新安装）:', error.message);
        }
    }

    /**
     * 生成新的配置ID
     */
    generateConfigId() {
        return 'config_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * 判断是否为配置键
     */
    isConfigKey(key) {
        return key === this.defaultConfigKey || key.startsWith('config_');
    }

    /**
     * 获取所有配置
     */
    async getAllConfigs() {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const allItems = await promisifyRequest(store.getAll(), '获取所有API配置');
            
            // 筛选出配置项并添加configId字段
            const configs = allItems
                .filter(item => this.isConfigKey(item.id))
                .map(item => ({
                    ...item,
                    configId: item.id,
                    configName: item.configName || (item.id === this.defaultConfigKey ? '默认配置' : '未命名配置')
                }))
                .sort((a, b) => {
                    // 默认配置排在最前
                    if (a.id === this.defaultConfigKey) return -1;
                    if (b.id === this.defaultConfigKey) return 1;
                    return (b.updatedAt || 0) - (a.updatedAt || 0);
                });
            
            return configs;
        }, '获取所有API配置');
    }

    /**
     * 根据ID获取配置
     */
    async getConfigById(id) {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const config = await promisifyRequest(store.get(id), '获取API配置');
            if (config && this.isConfigKey(id)) {
                return {
                    ...config,
                    configId: id,
                    configName: config.configName || (id === this.defaultConfigKey ? '默认配置' : '未命名配置')
                };
            }
            return null;
        }, '获取指定API配置');
    }

    /**
     * 保存配置
     */
    async saveConfig(config) {
        return await ensureDBReady(async () => {
            const now = Date.now();
            let configId = config.configId || config.id;
            
            if (!configId) {
                configId = this.generateConfigId();
            }
            
            // 使用传入的apiKeys结构，如果没有则构建默认结构
            let apiKeys;
            if (config.apiKeys && Array.isArray(config.apiKeys)) {
                // 使用前端传入的完整apiKeys结构
                apiKeys = config.apiKeys;
                console.log('[APIConfigManager] 使用前端传入的apiKeys结构，启用的key:', 
                    apiKeys.filter(k => k.enabled).map(k => `index${k.index}:${k.key.substring(0, 10)}...`));
            } else {
                // 兼容旧的additionalKeys格式
                apiKeys = [
                    {
                        key: config.key || '',
                        name: '主Key',
                        enabled: true,
                        index: 0
                    },
                    ...(config.additionalKeys || []).map((keyItem, index) => {
                        // 处理不同的数据格式：可能是字符串或对象
                        const keyValue = typeof keyItem === 'string' ? keyItem : (keyItem.key || keyItem);
                        const keyName = typeof keyItem === 'object' && keyItem.name ? keyItem.name : `Key ${index + 1}`;
                        const keyEnabled = typeof keyItem === 'object' && keyItem.enabled ? keyItem.enabled : false;
                        
                        return {
                            key: keyValue,
                            name: keyName,
                            enabled: keyEnabled,
                            index: index + 1
                        };
                    })
                ];
                console.log('[APIConfigManager] 使用兼容性apiKeys结构');
            }

            // API配置数据 - 仅保存连接相关信息
            const configData = {
                id: configId,
                url: config.url || '',
                key: config.key || '',
                contextMessageCount: config.contextMessageCount || 10,
                timeout: config.timeout || 60,
                apiKeys: apiKeys,
                configName: config.configName || config.name || '未命名配置',
                isDefault: config.isDefault || false,
                createdAt: config.createdAt || now,
                updatedAt: now
            };

            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(configData), '保存API配置');
            
            // 清除该配置的模型缓存
            this.availableModels.delete(configId);
            
            console.log('API配置保存完成:', configData.configName);
            return configData;
        }, '保存API配置');
    }

    /**
     * 删除配置
     */
    async deleteConfig(id) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(id);
            if (!config) {
                throw new Error('配置不存在');
            }
            
            if (id === this.defaultConfigKey) {
                throw new Error('不能删除默认配置');
            }

            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.delete(id), '删除API配置');
            
            // 清除模型缓存
            this.availableModels.delete(id);
            
            // 如果删除的是当前激活配置，切换到默认配置
            if (this.activeConfigId === id) {
                const configs = await this.getAllConfigs();
                const defaultConfig = configs.find(c => c.id === this.defaultConfigKey);
                if (defaultConfig) {
                    await this.switchToConfig(this.defaultConfigKey);
                }
            }
            
            console.log('API配置删除完成:', config.configName || config.name);
            return true;
        }, '删除API配置');
    }

    /**
     * 切换到指定配置
     */
    async switchToConfig(configId) {
        const config = await this.getConfigById(configId);
        if (!config) {
            throw new Error('配置不存在');
        }

        this.activeConfigId = configId;
        await this.saveActiveConfigId(configId);
        
        // 更新全局apiSettings - 只包含API连接信息
        Object.assign(window.apiSettings, {
            url: config.url || '',
            key: this.getEnabledKey(config),
            contextMessageCount: config.contextMessageCount || 10,
            timeout: config.timeout || 60
        });

        // 清空全局模型配置，切换API配置时重置模型选择
        await this.clearGlobalModelConfig();

        // 触发配置切换事件
        window.dispatchEvent(new CustomEvent('apiConfigChanged', {
            detail: { configId, config }
        }));
        
        console.log('已切换到配置:', config.configName || config.name);
        return config;
    }

    /**
     * 获取当前激活的配置
     */
    async getActiveConfig() {
        if (this.activeConfigId) {
            return await this.getConfigById(this.activeConfigId);
        }
        
        // 如果没有激活配置，尝试获取默认配置
        const configs = await this.getAllConfigs();
        const defaultConfig = configs.find(c => c.id === this.defaultConfigKey) || configs[0];
        
        if (defaultConfig) {
            await this.switchToConfig(defaultConfig.id);
            return defaultConfig;
        }
        
        return null;
    }

    /**
     * 测试配置连接并缓存可用模型
     */
    async testConfigConnection(configId) {
        const config = await this.getConfigById(configId);
        if (!config || !config.url || !config.key) {
            throw new Error('配置不完整');
        }

        try {
            const data = await window.apiService.testConnection(config.url, config.key);
            const models = data.data ? data.data.map(m => m.id).sort() : [];
            
            // 缓存模型列表
            this.availableModels.set(configId, models);
            
            return { success: true, models, config };
        } catch (error) {
            throw new Error(`连接测试失败: ${error.message}`);
        }
    }

    /**
     * 获取配置的可用模型列表
     */
    async getConfigModels(configId) {
        // 先检查缓存
        if (this.availableModels.has(configId)) {
            return this.availableModels.get(configId);
        }

        // 如果没有缓存，测试连接获取
        try {
            const result = await this.testConfigConnection(configId);
            return result.models;
        } catch (error) {
            console.warn('获取模型列表失败:', error.message);
            return [];
        }
    }

    /**
     * 获取配置中启用的key
     */
    getEnabledKey(config) {
        if (!config.apiKeys || config.apiKeys.length === 0) {
            return config.key || '';
        }
        
        const enabledKey = config.apiKeys.find(k => k.enabled);
        return enabledKey ? enabledKey.key : (config.key || '');
    }

    /**
     * 设置配置中的key启用状态
     */
    async setKeyEnabled(configId, keyIndex, enabled) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(configId);
            if (!config || !config.apiKeys || keyIndex >= config.apiKeys.length) {
                throw new Error('配置或key不存在');
            }

            if (enabled) {
                // 启用指定key，禁用其他key
                config.apiKeys.forEach((key, index) => {
                    key.enabled = (index === keyIndex);
                });
            } else {
                // 禁用指定key
                config.apiKeys[keyIndex].enabled = false;
                // 如果禁用的是当前启用的key，启用第一个可用的key
                const hasEnabledKey = config.apiKeys.some(k => k.enabled);
                if (!hasEnabledKey && config.apiKeys.length > 0) {
                    config.apiKeys[0].enabled = true;
                }
            }

            config.updatedAt = Date.now();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(config), '更新key启用状态');

            // 如果是当前激活的配置，更新全局apiSettings
            if (this.activeConfigId === configId) {
                const enabledKey = this.getEnabledKey(config);
                window.apiSettings.key = enabledKey;
            }

            return config;
        }, '设置key启用状态');
    }

    /**
     * 添加新的key到配置
     */
    async addKeyToConfig(configId, keyValue, keyName) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(configId);
            if (!config) {
                throw new Error('配置不存在');
            }

            if (!config.apiKeys) {
                config.apiKeys = [];
            }

            const newIndex = config.apiKeys.length;
            config.apiKeys.push({
                key: keyValue,
                name: keyName || `Key ${newIndex + 1}`,
                enabled: false,
                index: newIndex
            });

            config.updatedAt = Date.now();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(config), '添加新key');

            return config;
        }, '添加新key');
    }

    /**
     * 从配置中删除key
     */
    async removeKeyFromConfig(configId, keyIndex) {
        return await ensureDBReady(async () => {
            const config = await this.getConfigById(configId);
            if (!config || !config.apiKeys || keyIndex >= config.apiKeys.length) {
                throw new Error('配置或key不存在');
            }

            // 不能删除最后一个key
            if (config.apiKeys.length <= 1) {
                throw new Error('至少需要保留一个key');
            }

            const removedKey = config.apiKeys[keyIndex];
            config.apiKeys.splice(keyIndex, 1);

            // 重新设置index
            config.apiKeys.forEach((key, index) => {
                key.index = index;
            });

            // 如果删除的是启用的key，启用第一个key
            if (removedKey.enabled && config.apiKeys.length > 0) {
                config.apiKeys[0].enabled = true;
            }

            config.updatedAt = Date.now();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put(config), '删除key');

            // 如果是当前激活的配置，更新全局apiSettings
            if (this.activeConfigId === configId) {
                const enabledKey = this.getEnabledKey(config);
                window.apiSettings.key = enabledKey;
            }

            return config;
        }, '删除key');
    }

    /**
     * 保存当前激活配置ID
     */
    async saveActiveConfigId(configId) {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            await promisifyRequest(store.put({ 
                id: 'activeConfigId', 
                value: configId,
                updatedAt: Date.now()
            }), '保存当前配置ID');
        }, '保存当前配置ID');
    }

    /**
     * 加载当前激活配置ID
     */
    async loadActiveConfig() {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const result = await promisifyRequest(store.get('activeConfigId'), '加载当前配置ID');
            
            if (result && result.value) {
                this.activeConfigId = result.value;
            }
        }, '加载当前配置ID');
    }

    /**
     * 复制配置
     */
    async duplicateConfig(id) {
        const originalConfig = await this.getConfigById(id);
        if (!originalConfig) {
            throw new Error('源配置不存在');
        }

        const duplicatedConfig = {
            ...originalConfig,
            configId: undefined, // 将生成新ID
            configName: (originalConfig.configName || originalConfig.name || '未命名配置') + ' - 副本',
            isDefault: false,
            createdAt: undefined,
            updatedAt: undefined
        };

        return await this.saveConfig(duplicatedConfig);
    }

    // ========== 全局模型配置管理 ==========

    /**
     * 保存全局模型配置
     */
    async saveGlobalModelConfig(modelConfig) {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);

            const globalModelData = {
                id: this.globalModelConfigKey,
                apiConfigId: modelConfig.apiConfigId || '',
                primaryModel: modelConfig.primaryModel || '',
                secondaryModel: modelConfig.secondaryModel || '',
                updatedAt: Date.now()
            };

            await promisifyRequest(store.put(globalModelData), '保存全局模型配置');

            // 更新全局变量
            if (!window.modelSettings) {
                window.modelSettings = {};
            }
            window.modelSettings.apiConfigId = globalModelData.apiConfigId;
            window.modelSettings.primaryModel = globalModelData.primaryModel;
            window.modelSettings.secondaryModel = globalModelData.secondaryModel;

            console.log('全局模型配置保存完成:', globalModelData);
            return globalModelData;
        }, '保存全局模型配置');
    }

    /**
     * 获取全局模型配置
     */
    async getGlobalModelConfig() {
        return await ensureDBReady(async () => {
            const transaction = window.db.transaction([this.settingsStore], 'readonly');
            const store = transaction.objectStore(this.settingsStore);
            const modelConfig = await promisifyRequest(store.get(this.globalModelConfigKey), '获取全局模型配置');

            if (modelConfig) {
                return {
                    apiConfigId: modelConfig.apiConfigId || '',
                    primaryModel: modelConfig.primaryModel || '',
                    secondaryModel: modelConfig.secondaryModel || ''
                };
            }

            // 返回默认空配置
            return {
                apiConfigId: '',
                primaryModel: '',
                secondaryModel: ''
            };
        }, '获取全局模型配置');
    }

    /**
     * 清空全局模型配置（切换API配置时调用）
     */
    async clearGlobalModelConfig() {
        await this.saveGlobalModelConfig({
            apiConfigId: '',
            primaryModel: '',
            secondaryModel: ''
        });
        console.log('全局模型配置已清空');
    }

    /**
     * 获取当前使用的完整API连接信息（结合API配置和模型配置）
     */
    async getCurrentApiConnection() {
        const modelConfig = await this.getGlobalModelConfig();

        if (!modelConfig.apiConfigId) {
            throw new Error('未设置全局模型配置');
        }

        const apiConfig = await this.getConfigById(modelConfig.apiConfigId);
        if (!apiConfig) {
            throw new Error('API配置不存在');
        }

        return {
            // API连接信息
            url: apiConfig.url,
            key: this.getEnabledKey(apiConfig),
            timeout: apiConfig.timeout || 60,
            contextMessageCount: apiConfig.contextMessageCount || 10,
            // 模型信息
            primaryModel: modelConfig.primaryModel,
            secondaryModel: modelConfig.secondaryModel,
            // 配置信息
            apiConfigId: modelConfig.apiConfigId,
            configName: apiConfig.configName
        };
    }

    /**
     * 初始化全局模型配置（应用启动时调用）
     */
    async initGlobalModelConfig() {
        try {
            const modelConfig = await this.getGlobalModelConfig();

            // 初始化全局modelSettings变量
            if (!window.modelSettings) {
                window.modelSettings = {};
            }

            window.modelSettings.apiConfigId = modelConfig.apiConfigId;
            window.modelSettings.primaryModel = modelConfig.primaryModel;
            window.modelSettings.secondaryModel = modelConfig.secondaryModel;

            console.log('全局模型配置初始化完成:', modelConfig);
        } catch (error) {
            console.warn('全局模型配置初始化失败:', error);
            // 初始化为空配置
            if (!window.modelSettings) {
                window.modelSettings = {
                    apiConfigId: '',
                    primaryModel: '',
                    secondaryModel: ''
                };
            }
        }
    }

    /**
     * 设置默认配置
     */
    async setDefaultConfig(id) {
        return await ensureDBReady(async () => {
            // 先取消所有配置的默认状态
            const configs = await this.getAllConfigs();
            const transaction = window.db.transaction([this.settingsStore], 'readwrite');
            const store = transaction.objectStore(this.settingsStore);
            
            for (const config of configs) {
                if (config.isDefault) {
                    config.isDefault = false;
                    await promisifyRequest(store.put(config), '更新配置默认状态');
                }
            }
            
            // 设置新的默认配置
            const targetConfig = configs.find(c => c.id === id);
            if (targetConfig) {
                targetConfig.isDefault = true;
                targetConfig.updatedAt = Date.now();
                await promisifyRequest(store.put(targetConfig), '设置默认配置');
            }
            
            console.log('默认配置已更新');
            return targetConfig;
        }, '设置默认配置');
    }

    // ========== API Key 使用统计功能 ==========

    /**
     * 从localStorage加载统计数据
     */
    loadStats() {
        try {
            // console.log(`[API统计调试] 从localStorage加载统计数据，storageKey=${this.statsStorageKey}`);
            const stored = localStorage.getItem(this.statsStorageKey);
            // console.log(`[API统计调试] localStorage中的原始数据:`, stored);
            if (stored) {
                const parsed = JSON.parse(stored);
                // console.log(`[API统计调试] 解析后的统计数据:`, JSON.stringify(parsed, null, 2));
                return parsed;
            } else {
                console.log(`[API统计调试] localStorage中没有找到统计数据`);
            }
        } catch (error) {
            console.warn('加载API Key统计失败:', error);
        }
        console.log(`[API统计调试] 返回默认统计数据`);
        return this.getDefaultStats();
    }

    /**
     * 获取默认的统计结构
     */
    getDefaultStats() {
        return {
            version: 1,
            lastCleanup: Date.now(),
            keyStats: {} // keyId -> { calls: [], totalCalls: number, successCalls: number }
        };
    }

    /**
     * 保存统计数据到localStorage
     */
    saveStats() {
        try {
            // console.log(`[API统计调试] 保存统计数据到localStorage:`, JSON.stringify(this.stats, null, 2));
            localStorage.setItem(this.statsStorageKey, JSON.stringify(this.stats));
            console.log(`[API统计调试] 保存成功`);
        } catch (error) {
            console.error('保存API Key统计失败:', error);
        }
    }

    /**
     * 记录一次API调用
     */
    recordCall(configId, keyIndex, keyValue, success = true) {
        // console.log(`[API统计调试] 记录API调用: configId=${configId}, keyIndex=${keyIndex}, success=${success}`);
        console.log(`[API统计调试] API Key前缀: ${keyValue.substring(0, 10)}...`);
        
        const keyId = this.generateKeyId(configId, keyIndex, keyValue);
        const now = Date.now();
                
        if (!this.stats.keyStats[keyId]) {
            this.stats.keyStats[keyId] = {
                configId,
                keyIndex,
                keyValueHash: this.hashKey(keyValue),
                calls: [],
                totalCalls: 0,
                successCalls: 0
            };
        }
        
        const keyStat = this.stats.keyStats[keyId];
        
        keyStat.calls.push({
            timestamp: now,
            success
        });
        
        keyStat.totalCalls++;
        if (success) {
            keyStat.successCalls++;
        }
                
        this.saveStats();
        
        window.dispatchEvent(new CustomEvent('apiKeyStatsUpdated', {
            detail: { keyId, stats: keyStat }
        }));
    }

    /**
     * 生成key的唯一ID
     */
    generateKeyId(configId, keyIndex, keyValue) {
        return `${configId}_${keyIndex}_${this.hashKey(keyValue)}`;
    }

    /**
     * 生成key的hash（用于安全存储）
     */
    hashKey(keyValue) {
        let hash = 0;
        for (let i = 0; i < keyValue.length; i++) {
            const char = keyValue.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
    }

    /**
     * 获取指定key在近24小时内的调用统计
     */
    getKeyStats(configId, keyIndex, keyValue) {
        
        const keyId = this.generateKeyId(configId, keyIndex, keyValue);
        
        const keyStat = this.stats.keyStats[keyId];
        
        if (!keyStat) {
            console.log(`[API统计调试] 未找到统计记录，返回默认值`);
            return {
                totalCalls: 0,
                recentCalls: 0,
                successRate: 0
            };
        }
        
        const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
        const recentCalls = keyStat.calls.filter(call => call.timestamp >= twentyFourHoursAgo);
        const recentSuccessCalls = recentCalls.filter(call => call.success);
        
        const result = {
            totalCalls: keyStat.totalCalls,
            recentCalls: recentCalls.length,
            recentSuccessCalls: recentSuccessCalls.length,
            successRate: recentCalls.length > 0 ? (recentSuccessCalls.length / recentCalls.length * 100).toFixed(1) : 0,
            lastUsed: recentCalls.length > 0 ? recentCalls[recentCalls.length - 1].timestamp : null
        };
        
        // console.log(`[API统计调试] 返回的统计结果:`, result);
        return result;
    }

    /**
     * 掩码显示Key（只显示前3位和后3位）
     */
    maskKey(keyValue) {
        // 确保keyValue是字符串
        if (typeof keyValue === 'object') {
            keyValue = keyValue.key || keyValue.toString();
        }
        
        if (typeof keyValue !== 'string') {
            keyValue = String(keyValue);
        }
        
        if (!keyValue || keyValue.length <= 8) {
            return '*'.repeat(keyValue.length || 8);
        }
        return keyValue.substring(0, 3) + '*'.repeat(keyValue.length - 6) + keyValue.substring(keyValue.length - 3);
    }

    /**
     * 清理超过24小时的记录
     */
    cleanup() {
        const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
        let cleanedCount = 0;
        
        for (const [keyId, keyStat] of Object.entries(this.stats.keyStats)) {
            const originalLength = keyStat.calls.length;
            keyStat.calls = keyStat.calls.filter(call => call.timestamp >= twentyFourHoursAgo);
            
            if (keyStat.calls.length < originalLength) {
                cleanedCount++;
                
                if (keyStat.calls.length === 0) {
                    keyStat.totalCalls = 0;
                    keyStat.successCalls = 0;
                } else {
                    keyStat.totalCalls = keyStat.calls.length;
                    keyStat.successCalls = keyStat.calls.filter(call => call.success).length;
                }
            }
        }
        
        if (cleanedCount > 0) {
            this.stats.lastCleanup = Date.now();
            this.saveStats();
            console.log(`API Key统计清理完成，清理了 ${cleanedCount} 个key的过期记录`);
        }
    }

    /**
     * 启动自动清理任务
     */
    startAutoCleanup() {
        this.cleanupInterval = setInterval(() => {
            this.cleanup();
        }, 60 * 60 * 1000); // 每小时清理一次
        
        this.cleanup(); // 立即执行一次清理
    }

    /**
     * 停止自动清理任务
     */
    stopAutoCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
    }
}

// 全局实例
window.apiConfigManager = new APIConfigManager();

// 导出
if (typeof module !== 'undefined' && module.exports) {
    module.exports = APIConfigManager;
}
</script>
    <script>
/**
 * 模型能力检测器
 * 用于检测AI模型是否支持图像视觉能力
 */
class ModelCapabilityDetector {
    constructor() {
        // 支持视觉能力的模型列表 - 使用关键词模糊匹配
        this.visionSupportedModels = [
            // OpenAI
            'chatgpt-4o-latest',
            'gpt-4-turbo',
            'gpt-4-vision',
            'gpt-4.1',
            'gpt-4.5-preview',
            'gpt-4o',
            'gpt-5',
            'o1',
            'o3',
            'o4-mini',
            // Claude
            'claude-3',
            'claude-opus-4',
            'claude-sonnet-4',
            // Cohere
            'c4ai-aya-vision',
            'command-a-vision',
            // Google AI Studio
            'gemini-1.5',
            'gemini-2.0',
            'gemini-2.5',
            'gemini-exp-1206',
            'learnlm',
            // MistralAI
            'mistral-small-2503',
            'mistral-small-2506',
            'mistral-small-latest',
            'mistral-medium-latest',
            'mistral-medium-2505',
            'mistral-medium-2508',
            'pixtral',
            // xAI (Grok)
            'grok-4',
            'grok-2-vision',
            'grok-vision',
            // Moonshot
            'moonshot-v1-8k-vision-preview',
            'moonshot-v1-32k-vision-preview',
            'moonshot-v1-128k-vision-preview',
        ];
        
        console.log(`[ModelCapabilityDetector] 初始化完成，支持 ${this.visionSupportedModels.length} 种视觉模型`);
    }

    /**
     * 检测模型是否支持图像视觉能力，返回匹配的模型或null
     * 使用模糊匹配：提取关键词（除标点），检查是否全部匹配
     * @param {string} modelName - 要检查的模型名称
     * @returns {string|null} 匹配的支持模型名称，如果不支持则返回null
     */
    _findMatchedVisionModel(modelName) {
        if (!modelName || typeof modelName !== 'string') {
            return null;
        }

        // 规范化输入的模型名称：转小写，提取关键词
        const inputKeywords = this.extractKeywords(modelName.toLowerCase());
        
        // 遍历支持的模型列表，进行模糊匹配
        for (const supportedModel of this.visionSupportedModels) {
            const supportedKeywords = this.extractKeywords(supportedModel.toLowerCase());
            
            // 检查支持模型的所有关键词是否都在输入模型中出现
            const isMatch = supportedKeywords.every(keyword => 
                inputKeywords.includes(keyword)
            );
            
            if (isMatch) {
                console.log(`[ModelCapabilityDetector] 模型 "${modelName}" 匹配到支持视觉的模型 "${supportedModel}"`);
                return supportedModel;
            }
        }
        
        console.log(`[ModelCapabilityDetector] 模型 "${modelName}" 不支持视觉能力`);
        return null;
    }

    /**
     * 检测模型是否支持图像视觉能力
     * @param {string} modelName - 要检查的模型名称
     * @returns {boolean} 是否支持视觉能力
     */
    supportsVision(modelName) {
        return this._findMatchedVisionModel(modelName) !== null;
    }

    /**
     * 提取关键词：移除标点符号，按分隔符拆分
     * @param {string} modelName - 模型名称
     * @returns {string[]} 关键词数组
     */
    extractKeywords(modelName) {
        // 移除常见标点符号，保留字母数字和连字符
        const cleaned = modelName.replace(/[^\w\-\.]/g, ' ');
        
        // 按空格、连字符、点号分割，过滤空字符串
        const keywords = cleaned
            .split(/[\s\-\.]+/)
            .filter(word => word.length > 0)
            .map(word => word.toLowerCase());
            
        return keywords;
    }

    /**
     * 获取所有支持视觉的模型列表
     * @returns {string[]} 支持视觉的模型列表
     */
    getSupportedVisionModels() {
        return [...this.visionSupportedModels];
    }

    /**
     * 检查模型名称并返回详细信息
     * @param {string} modelName - 模型名称
     * @returns {Object} 检查结果详情
     */
    checkModelCapability(modelName) {
        const matchedModel = this._findMatchedVisionModel(modelName);
        const supportsVision = matchedModel !== null;
        const inputKeywords = this.extractKeywords(modelName?.toLowerCase() || '');
        
        return {
            modelName: modelName || '',
            supportsVision,
            matchedModel,
            inputKeywords,
            supportedModelsCount: this.visionSupportedModels.length
        };
    }
}

// 导出类
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ModelCapabilityDetector;
} else {
    // 浏览器环境，挂载到window对象
    window.ModelCapabilityDetector = ModelCapabilityDetector;
}
</script>
    <script>
/**
 * 字体按需加载管理器
 * 根据用户自定义气泡配置中的字体设置，动态加载对应的字体文件
 */

class FontLoader {
    constructor() {
        // 字体名称到CDN URL的映射
        this.fontUrlMapping = {
            'Inter': null, // 默认字体，无需加载额外CSS
            'Source Han Serif CN VF': 'https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css',
            'LXGW WenKai': 'https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css',
            'DouyinSansBold': 'https://chinese-fonts-cdn.deno.dev/packages/dymh/dist/DouyinSansBold/result.css',
            '汇文明朝体': 'https://chinese-fonts-cdn.deno.dev/packages/hwmct/dist/汇文明朝体/result.css',
            'ToneOZ-PinyinW-Kai-Simplified': 'https://chinese-fonts-cdn.deno.dev/packages/ToneOZ-Pinyin-Kai/dist/ToneOZ-PinyinW-Kai-Simplified/result.css',
            'ChillRoundFBold': 'https://chinese-fonts-cdn.deno.dev/packages/hcqyt/dist/ChillRoundFBold/result.css',
            '峄山碑篆体': 'https://chinese-fonts-cdn.deno.dev/packages/ysbzt/dist/峄山碑篆体/result.css',
            'YuFanXinYu-Medium': 'https://chinese-fonts-cdn.deno.dev/packages/yfxy/dist/YuFanXinYu-Medium/result.css'
        };
        
        // 记录已加载的字体，避免重复加载
        this.loadedFonts = new Set();
        
        // 记录加载中的字体，避免并发加载同一字体
        this.loadingFonts = new Map();
    }

    /**
     * 根据字体名称获取对应的CDN URL
     * @param {string} fontFamily - 字体名称
     * @returns {string|null} CDN URL或null（对于默认字体）
     */
    getFontUrl(fontFamily) {
        return this.fontUrlMapping[fontFamily] || null;
    }

    /**
     * 动态加载字体CSS文件
     * @param {string} fontFamily - 字体名称
     * @returns {Promise<boolean>} 是否加载成功
     */
    async loadFont(fontFamily) {
        // 如果是默认字体或已经加载过，直接返回成功
        if (!fontFamily || fontFamily === 'Inter' || this.loadedFonts.has(fontFamily)) {
            return true;
        }

        // 如果正在加载中，等待加载完成
        if (this.loadingFonts.has(fontFamily)) {
            return await this.loadingFonts.get(fontFamily);
        }

        const fontUrl = this.getFontUrl(fontFamily);
        if (!fontUrl) {
            console.warn(`未找到字体 ${fontFamily} 的CDN映射`);
            return false;
        }

        // 创建加载Promise
        const loadingPromise = this._loadFontStylesheet(fontUrl, fontFamily);
        this.loadingFonts.set(fontFamily, loadingPromise);

        try {
            const success = await loadingPromise;
            if (success) {
                this.loadedFonts.add(fontFamily);
                console.log(`字体加载成功: ${fontFamily}`);
            }
            return success;
        } finally {
            // 清理加载状态
            this.loadingFonts.delete(fontFamily);
        }
    }

    /**
     * 实际加载字体样式表的私有方法
     * @param {string} url - CSS文件URL
     * @param {string} fontFamily - 字体名称（用于日志）
     * @returns {Promise<boolean>} 是否加载成功
     */
    _loadFontStylesheet(url, fontFamily) {
        return new Promise((resolve) => {
            // 检查是否已经存在相同URL的链接
            const existingLink = document.querySelector(`link[href="${url}"]`);
            if (existingLink) {
                console.log(`字体样式表已存在: ${fontFamily}`);
                resolve(true);
                return;
            }

            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            link.crossOrigin = 'anonymous'; // 添加跨域支持

            link.onerror = () => {
                console.error(`字体样式表加载失败: ${fontFamily} (${url})`);
                resolve(false);
            };

            // 设置超时，避免长时间等待
            const timeout = setTimeout(() => {
                console.warn(`字体加载超时: ${fontFamily}`);
                resolve(false);
            }, 10000); // 10秒超时

            link.onload = () => {
                clearTimeout(timeout);
                console.log(`字体样式表加载完成: ${fontFamily}`);
                resolve(true);
            };

            // 插入到head中
            document.head.appendChild(link);
        });
    }

    /**
     * 从IndexedDB加载用户配置并加载对应字体
     * @returns {Promise<void>}
     */
    async loadFontsFromUserConfig() {
        try {
            // 确保数据库已就绪
            if (!window.isIndexedDBReady || !window.db) {
                console.warn('数据库未就绪，跳过字体加载');
                return;
            }

            // 读取用户的气泡配置
            const [bubbleStyleSelf, bubbleStyleKare] = await Promise.all([
                this._loadConfigFromDB('bubbleStyleSelf'),
                this._loadConfigFromDB('bubbleStyle')
            ]);

            // 收集需要加载的字体
            const fontsToLoad = new Set();
            
            if (bubbleStyleSelf?.fontFamily) {
                fontsToLoad.add(bubbleStyleSelf.fontFamily);
            }
            
            if (bubbleStyleKare?.fontFamily) {
                fontsToLoad.add(bubbleStyleKare.fontFamily);
            }

            // 如果没有配置，使用默认字体
            if (fontsToLoad.size === 0) {
                console.log('未找到字体配置，使用默认字体');
                return;
            }

            console.log('开始加载用户配置的字体:', Array.from(fontsToLoad));

            // 并行加载所有需要的字体
            const loadPromises = Array.from(fontsToLoad).map(font => this.loadFont(font));
            const results = await Promise.all(loadPromises);
            
            const successCount = results.filter(Boolean).length;
            console.log(`字体加载完成: ${successCount}/${fontsToLoad.size} 成功`);

        } catch (error) {
            console.error('从用户配置加载字体失败:', error);
        }
    }

    /**
     * 从IndexedDB加载配置的私有方法
     * @param {string} configKey - 配置键名
     * @returns {Promise<Object|null>} 配置对象或null
     */
    _loadConfigFromDB(configKey) {
        return new Promise((resolve) => {
            try {
                const transaction = window.db.transaction(['themeConfig'], 'readonly');
                const store = transaction.objectStore('themeConfig');
                const request = store.get(configKey);

                request.onsuccess = () => {
                    const result = request.result;
                    if (result && result.enabled !== false) {
                        resolve(result);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = () => {
                    console.warn(`读取配置失败: ${configKey}`, request.error);
                    resolve(null);
                };

                transaction.onerror = () => {
                    console.warn(`事务失败: ${configKey}`, transaction.error);
                    resolve(null);
                };
            } catch (error) {
                console.warn(`数据库操作异常: ${configKey}`, error);
                resolve(null);
            }
        });
    }

    /**
     * 预加载指定的字体
     * @param {string|string[]} fonts - 字体名称或字体数组
     * @returns {Promise<boolean[]>} 加载结果数组
     */
    async preloadFonts(fonts) {
        const fontArray = Array.isArray(fonts) ? fonts : [fonts];
        const loadPromises = fontArray.map(font => this.loadFont(font));
        return await Promise.all(loadPromises);
    }

    /**
     * 获取已加载的字体列表
     * @returns {string[]} 已加载的字体名称数组
     */
    getLoadedFonts() {
        return Array.from(this.loadedFonts);
    }

    /**
     * 清理加载状态（用于调试）
     */
    reset() {
        this.loadedFonts.clear();
        this.loadingFonts.clear();
    }
}

// 创建全局实例
window.fontLoader = new FontLoader();

// 在数据库就绪后自动加载字体
document.addEventListener('DOMContentLoaded', async () => {
    // 使用 ensureDBReady 确保数据库已就绪
    if (typeof ensureDBReady === 'function') {
        try {
            await ensureDBReady(async () => {
                await window.fontLoader.loadFontsFromUserConfig();
            }, '按需加载字体');
        } catch (error) {
            console.error('按需字体加载失败:', error);
        }
    } else {
        // 降级方案：直接尝试加载
        setTimeout(async () => {
            await window.fontLoader.loadFontsFromUserConfig();
        }, 2000);
    }
});

// 导出到全局作用域，方便其他模块使用
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FontLoader;
}
</script>

    <!-- Analytics -->
    <script defer src="https://umami.whale-llt.top/script.js" data-website-id="00c95749-7c0d-4333-9ec1-2ad2701799a3"></script>

  <style rel="stylesheet" crossorigin>:root{--theme-primary: #07c160;--theme-primary-light: rgba(7, 193, 96, .1);--theme-primary-hover: #06a84f;--theme-secondary: #1890ff;--theme-secondary-hover: #0078d4;--theme-secondary-active: #106ebe;--theme-gradient-direction: to right;--theme-gradient: linear-gradient(var(--theme-gradient-direction), var(--theme-primary), var(--theme-secondary));--use-gradient: 0;--bg-primary: #ffffff;--bg-secondary: #f5f5f5;--bg-tertiary: #ededed;--text-primary: #333333;--text-secondary: #666666;--text-tertiary: #999999;--border-color: #e0e0e0;--shadow-color: rgba(0, 0, 0, .1);--input-bg: #ffffff;--modal-bg: #ffffff;--overlay-bg: rgba(0, 0, 0, .5)}.dark-mode{--bg-primary: #1a1a1a;--bg-secondary: #2d2d2d;--bg-tertiary: #363636;--text-primary: #ffffff;--text-secondary: #cccccc;--text-tertiary: #999999;--border-color: #404040;--shadow-color: rgba(0, 0, 0, .3);--input-bg: #2d2d2d;--modal-bg: #1a1a1a;--overlay-bg: rgba(0, 0, 0, .7);--theme-secondary-hover: #4dabf7;--theme-secondary-active: #339af0}@media (prefers-color-scheme: dark){.system-theme{--bg-primary: #1a1a1a;--bg-secondary: #2d2d2d;--bg-tertiary: #363636;--text-primary: #ffffff;--text-secondary: #cccccc;--text-tertiary: #999999;--border-color: #404040;--shadow-color: rgba(0, 0, 0, .3);--input-bg: #2d2d2d;--modal-bg: #1a1a1a;--overlay-bg: rgba(0, 0, 0, .7);--theme-secondary-hover: #4dabf7;--theme-secondary-active: #339af0}}.gradient-mode{--theme-background: var(--theme-gradient)}.gradient-mode .apply-custom-color-btn,.gradient-mode .apply-gradient-btn,.gradient-mode .send-btn,.gradient-mode .memory-panel-btn:active,.gradient-mode .generate-moment-btn,.gradient-mode .form-submit,.gradient-mode .header-btn,.gradient-mode .song-item.active{background:var(--theme-gradient)!important}*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Helvetica Neue,Helvetica,Arial,sans-serif;background-color:var(--bg-tertiary);color:var(--text-primary);height:100vh;overflow:hidden;position:relative;transition:background-color .3s ease,color .3s ease}.main-container{position:relative;height:100vh;height:var(--viewport-height, 100vh);padding-bottom:var(--nav-height, 50px)}.contact-list-page,.moments-page,.profile-page,.weibo-page,.data-management-page,.memory-management-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out,background-color .3s ease;background-color:var(--bg-secondary);display:flex;flex-direction:column;padding-left:var(--safe-area-left, 0px);padding-right:var(--safe-area-right, 0px);padding-bottom:var(--safe-area-bottom, 0px);overflow:hidden}.chat-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out,background-color .3s ease;background-color:var(--bg-tertiary);display:flex;flex-direction:column;padding-left:var(--safe-area-left, 0px);padding-right:var(--safe-area-right, 0px);overflow:hidden}.contact-list-page.active,.chat-page.active,.moments-page.active,.profile-page.active,.weibo-page.active,.data-management-page.active,.memory-management-page.active{opacity:1;pointer-events:auto;z-index:10}.chat-page.active{z-index:50}.contact-list-page{background-color:var(--bg-primary)}.contact-list-page .wechat-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:background-color .3s ease,color .3s ease,border-color .3s ease}.contact-list-page:not(.active) .wechat-header,.chat-page:not(.active) .chat-header,.moments-page:not(.active) .moments-header,.profile-page:not(.active) .chat-header,.data-management-page:not(.active) .chat-header,.memory-management-page:not(.active) .chat-header{display:none}.interactive-page:not(.active){display:none}.header-title{font-size:17px;font-weight:500}.header-actions{display:flex;gap:20px}.header-icon{width:20px;height:20px;cursor:pointer}.search-bar{padding:8px 15px;background-color:var(--bg-tertiary);flex-shrink:0;transition:background-color .3s ease}.search-input{width:100%;height:32px;background-color:var(--input-bg);color:var(--text-primary);border:1px solid var(--border-color);border-radius:4px;padding:0 10px;font-size:14px;transition:all .3s ease}.search-input::placeholder{color:var(--text-tertiary)}.search-input:focus{outline:none;border-color:var(--theme-primary);box-shadow:0 0 0 2px #07c1601a}#contactList{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-bottom:var(--nav-height, 50px)}.contact-item{display:flex;align-items:center;padding:12px 15px;background-color:var(--bg-primary);border-bottom:.5px solid var(--border-color);cursor:pointer;position:relative;transition:all .3s ease}.contact-item:active{background-color:var(--bg-secondary)}.contact-avatar{width:48px;height:48px;border-radius:4px;margin-right:12px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:20px;flex-shrink:0;overflow:hidden}.contact-avatar img{width:100%;height:100%;object-fit:cover}.contact-info{flex:1;overflow:hidden}.contact-name{font-size:17px;color:var(--text-primary);margin-bottom:4px;transition:color .3s ease}.contact-message{font-size:13px;color:var(--text-secondary);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;transition:color .3s ease}.contact-time{position:absolute;right:15px;top:15px;font-size:12px;color:var(--text-tertiary);transition:color .3s ease}.chat-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:all .3s ease}.chat-header-spacer{width:24px;height:24px;flex-shrink:0}.memory-panel-header{padding-top:10px}.back-btn{display:flex;align-items:center;gap:5px;font-size:17px;color:var(--theme-primary);cursor:pointer;transition:color .3s ease}.chat-title{position:absolute;left:50%;transform:translate(-50%);font-size:17px;font-weight:500;color:var(--text-primary);transition:color .3s ease}.chat-header-actions{display:flex;align-items:center;gap:15px}.chat-more,.memory-btn{width:24px;height:24px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:700}.chat-messages{flex:1;overflow-y:auto;padding:15px;padding-bottom:calc(80px + var(--safe-area-bottom, 0px));background-size:cover;background-position:center;background-repeat:no-repeat;-webkit-overflow-scrolling:touch;scroll-behavior:smooth}.messages-scroll-content{transform:translateZ(0)}.message-timestamp{text-align:center;color:#999;font-size:12px;margin:0 auto 15px;padding:2px 8px;background-color:#0000000d;border-radius:4px;display:inline-block;left:50%;position:relative;transform:translate(-50%)}.message{display:flex;margin-bottom:15px;align-items:flex-start;animation:slideInFromBottom .3s ease-out}@keyframes slideInFromBottom{0%{transform:translateY(15px);opacity:0}to{transform:translateY(0);opacity:1}}.message.new-message{animation:slideInFromBottom .5s cubic-bezier(.25,.46,.45,.94)}#typingIndicator{animation:slideInFromBottom .4s ease-out}.message.sent{flex-direction:row-reverse}.message-avatar{width:40px;height:40px;border-radius:4px;margin:0 10px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:16px;flex-shrink:0;overflow:hidden}.message-avatar img{width:100%;height:100%;object-fit:cover}.message-bubble,.custom-bubble-container{max-width:calc(100% - 120px);position:relative}.message-content{padding:10px 12px;border-radius:8px;font-size:16px;line-height:1.5;word-wrap:break-word;position:relative}.custom-bubble-container *{word-wrap:break-word!important;overflow-wrap:break-word!important}.message.received .message-content{background-color:#fff;color:#000}.message.sent .message-content{background-color:#95ec69;color:#000}.message-content:before{content:"";position:absolute;top:10px;width:0;height:0;border-style:solid}.message.received .message-content:before{left:-5px;border-width:6px 6px 6px 0;border-color:transparent #fff transparent transparent}.message.sent .message-content:before{right:-5px;border-width:6px 0 6px 6px;border-color:transparent transparent transparent #95ec69}.message-emoji{max-width:100px;max-height:100px;border-radius:8px;display:block}.message-content.red-packet{background-color:#fa9d3b;color:#fff;padding:0;width:240px;cursor:pointer;border-radius:8px;overflow:hidden}.red-packet-body{display:flex;align-items:center;padding:12px}.red-packet-icon{width:40px;height:40px;margin-right:10px}.red-packet-text{flex:1}.red-packet-text div:first-child{font-size:15px;font-weight:500;margin-bottom:2px}.red-packet-text div:last-child{font-size:14px}.red-packet-footer{background-color:#fff;color:#999;font-size:12px;padding:4px 12px;border-top:.5px solid rgba(0,0,0,.05)}.message.sent .message-content.red-packet:before,.message.received .message-content.red-packet:before{border-color:transparent transparent transparent #fa9d3b}.message.received .message-content.red-packet:before{border-color:transparent #fa9d3b transparent transparent}.message-content.chat-image{padding:0;background:none;border:none;border-radius:0;overflow:visible;max-width:280px}.chat-image-content{width:100%;max-width:280px;max-height:200px;border-radius:0;border:none;object-fit:cover;cursor:pointer;transition:transform .2s ease;display:block}.chat-image-content:hover{transform:scale(1.02)}.message-content.chat-image-placeholder,.message-content.chat-image-error{padding:20px;text-align:center;background:var(--bg-secondary);border-radius:12px;color:var(--text-secondary);max-width:200px}.message-content.chat-image-placeholder .image-placeholder{display:flex;flex-direction:column;align-items:center;gap:8px}.message-content.chat-image-placeholder span{font-size:24px}.image-error{padding:20px;text-align:center;background:var(--bg-secondary);border-radius:8px;color:var(--text-secondary)}.message.sent .message-content.chat-image:before,.message.received .message-content.chat-image:before{display:none}.chat-input-area{background-color:var(--bg-primary);border-top:.5px solid var(--border-color);padding:8px 10px 10px;padding-bottom:calc(10px + var(--safe-area-bottom, 0px));padding-left:calc(10px + var(--safe-area-left, 0px));padding-right:calc(10px + var(--safe-area-right, 0px));display:flex;align-items:flex-end;gap:6px;flex-shrink:0;position:fixed;bottom:0;left:0;right:0;transition:all .3s ease;z-index:102}.input-actions{display:flex;align-items:center;gap:4px;flex-shrink:0}.action-btn{width:28px;height:28px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:50%;background-color:var(--bg-primary);font-size:20px;transition:background-color .3s ease}.action-btn:active{background-color:var(--bg-secondary)}.chat-input{flex:1;min-height:36px;max-height:120px;min-width:0;padding:8px 12px;border:1px solid var(--border-color);border-radius:4px;background-color:var(--input-bg);color:var(--text-primary);font-size:16px;resize:none;outline:none;transition:all .3s ease}.chat-input::placeholder{color:var(--text-tertiary)}.chat-input:focus{border-color:var(--theme-primary);box-shadow:0 0 0 2px #07c1601a}.send-btn{padding:8px 12px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:4px;font-size:14px;cursor:pointer;flex-shrink:0;white-space:nowrap}.send-btn:active{background-color:#06a652}.send-btn:disabled{background-color:#ccc;cursor:not-allowed}.memory-panel{position:absolute;top:0;left:0;right:0;bottom:0;background-color:#f7f7f7;z-index:100;transform:translateY(100%);transition:transform .3s ease-in-out,visibility 0s linear .3s,opacity .3s ease-in-out;overflow-y:auto;-webkit-overflow-scrolling:touch;visibility:hidden;opacity:0;pointer-events:none}.memory-panel.active{transform:translateY(0);visibility:visible;opacity:1;pointer-events:auto;transition:transform .3s ease-in-out,visibility 0s linear 0s,opacity .3s ease-in-out}.memory-panel-header{padding:10px 15px;display:flex;justify-content:space-between;align-items:center;background-color:#ededed;border-bottom:.5px solid #d9d9d9;position:sticky;top:0;z-index:1}.memory-panel-title{font-size:17px;font-weight:500}.memory-panel-actions{display:flex;gap:15px}.memory-panel-btn{font-size:16px;color:#576b95;cursor:pointer;background:none;border:none;padding:5px}.memory-panel-btn:active{color:var(--theme-primary)}.memory-panel-content{padding:15px;background-color:#f7f7f7}.memory-textarea{width:100%;height:calc(100vh - 150px);border:1px solid #ddd;border-radius:4px;outline:none;resize:none;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif;font-size:14px;line-height:1.6;background-color:#fff;color:#333;padding:10px}.memory-table-view{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif;color:#333;line-height:1.6}.memory-table-view h1,.memory-table-view h2,.memory-table-view h3,.memory-table-view h4{font-weight:600;color:#111;margin-top:24px;margin-bottom:16px}.memory-table-view h1{font-size:1.5em}.memory-table-view h2{font-size:1.3em}.memory-table-view h3{font-size:1.1em}.memory-table-view h4{font-size:1em}.memory-table-view p{margin-bottom:16px}.memory-table-view ul{padding-left:20px;margin-bottom:16px}.memory-table-view table{width:100%;border-collapse:collapse;margin-bottom:24px;background-color:#fff;border-radius:8px;overflow:hidden;box-shadow:0 1px 3px #0000000d;table-layout:fixed}.memory-table-view th,.memory-table-view td{padding:12px 15px;text-align:left;border-bottom:1px solid #f0f0f0;word-wrap:break-word;word-break:break-word;white-space:pre-wrap;max-width:0;overflow-wrap:break-word}.memory-table-view th{background-color:#fafafa;font-weight:600;color:#555}.memory-table-view tr:last-child th,.memory-table-view tr:last-child td{border-bottom:none}.memory-table-view hr{border:none;border-top:1px solid #e5e5e5;margin:24px 0}.bottom-nav{position:fixed;bottom:0;left:0;right:0;height:var(--nav-height, 50px);padding-bottom:var(--safe-area-bottom, 0px);padding-left:var(--safe-area-left, 0px);padding-right:var(--safe-area-right, 0px);background-color:var(--bg-primary);border-top:.5px solid var(--border-color);display:flex;justify-content:space-around;align-items:center;z-index:200;transition:all .3s ease}body:has(.chat-page.active) .bottom-nav{display:none}body.chat-active .bottom-nav,body.no-has-support.chat-active .bottom-nav{display:none!important}.nav-item{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;cursor:pointer;position:relative}.nav-icon{width:24px;height:24px}.nav-text{font-size:10px;color:var(--text-tertiary);transition:color .3s ease}.nav-item.active .nav-text{color:var(--theme-primary)}.moments-page{position:fixed;top:0;left:0;right:0;bottom:50px;background-color:#f5f5f5;display:flex;flex-direction:column;z-index:120;padding-bottom:calc(50px + env(safe-area-inset-bottom));padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right)}.moment-images-preview{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-top:10px;max-width:300px}.moment-image-item{position:relative;aspect-ratio:1;border-radius:4px;overflow:hidden;border:1px solid #e0e0e0}.moment-image-item img{width:100%;height:100%;object-fit:cover}.moment-image-remove{position:absolute;top:2px;right:2px;width:18px;height:18px;background-color:#f00c;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;cursor:pointer}.moment-images-grid{display:grid;gap:4px;margin:10px 0;border-radius:8px;overflow:hidden}.moment-images-grid.grid-1{grid-template-columns:1fr;max-width:200px}.moment-images-grid.grid-2{grid-template-columns:repeat(2,1fr);max-width:200px}.moment-images-grid.grid-3,.moment-images-grid.grid-4,.moment-images-grid.grid-5,.moment-images-grid.grid-6,.moment-images-grid.grid-7,.moment-images-grid.grid-8,.moment-images-grid.grid-9{grid-template-columns:repeat(3,1fr);max-width:200px}.moment-image-container{position:relative;width:100%;aspect-ratio:1;overflow:hidden}.moment-grid-image{width:100%;height:100%;object-fit:cover;cursor:pointer}.moment-image-error{position:absolute;top:0;left:0;width:100%;height:100%;background-color:#f5f5f5;border:1px solid #e0e0e0;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#999;font-size:12px}.image-error-icon{font-size:24px;margin-bottom:4px;opacity:.6}.image-error-text{font-size:10px;text-align:center}.comment-time{font-size:11px;color:#999;margin-left:8px}.moment-menu-btn{position:absolute;top:8px;right:8px;width:24px;height:24px;background-color:#0000001a;color:#666;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:16px;cursor:pointer;font-weight:700;transition:background-color .2s}.moment-menu-btn:hover{background-color:#0003;color:#333}.moment-menu{position:absolute;top:32px;right:0;background:#fff;border:1px solid #e0e0e0;border-radius:8px;box-shadow:0 2px 10px #0000001a;z-index:1000;min-width:120px}.moment-menu-item{padding:12px 16px;cursor:pointer;font-size:14px;color:#333;border-bottom:1px solid #f0f0f0;transition:background-color .2s}.moment-menu-item:last-child{border-bottom:none}.moment-menu-item:hover{background-color:#f5f5f5}.moment-menu-item:first-child:hover{color:#e53e3e}.moment-header{position:relative}.moments-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:all .3s ease}.moments-content{flex:1;overflow-y:auto;padding:15px;padding-bottom:calc(var(--nav-height, 50px) + 15px);-webkit-overflow-scrolling:touch;background-color:var(--bg-secondary);transition:background-color .3s ease}.moments-empty{text-align:center;padding:50px 20px;color:var(--text-secondary);transition:color .3s ease}.moments-empty-icon{font-size:48px;margin-bottom:15px}.moments-empty-text{font-size:16px;margin-bottom:20px}.moments-empty-btn{background-color:var(--theme-primary);color:#fff;border:none;border-radius:20px;padding:10px 20px;font-size:14px;cursor:pointer}.moments-list{display:flex;flex-direction:column;gap:15px}.moment-item{background-color:var(--bg-primary);color:var(--text-primary);border-radius:8px;padding:15px;box-shadow:0 1px 3px var(--shadow-color);margin-top:8px;transition:all .3s ease}.moment-header{display:flex;align-items:center;margin-bottom:10px}.moment-avatar img{width:100%;height:100%;object-fit:cover}.moment-info{flex:1}.moment-name{font-size:16px;font-weight:500;margin-bottom:2px;color:var(--text-primary);transition:color .3s ease}.moment-time{font-size:12px;color:var(--text-tertiary);transition:color .3s ease}.moment-time-location,.user-profile-moment-time-location{font-size:12px;color:var(--text-tertiary);display:flex;align-items:center;gap:8px}.moment-location{color:var(--theme-primary);font-weight:500}.moment-content{font-size:15px;line-height:1.5;word-wrap:break-word;word-break:break-word;overflow-wrap:break-word;white-space:pre-wrap;color:var(--text-primary);transition:color .3s ease}.moment-image{width:100%;max-width:300px;border-radius:8px;margin-bottom:10px}.publish-moment-modal{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background-color:#00000080;z-index:2000}.publish-moment-content{position:absolute;bottom:0;left:0;right:0;background-color:#fff;border-radius:12px 12px 0 0;max-height:80vh;overflow-y:auto;animation:slideUp .3s ease}.publish-moment-header{padding:15px;border-bottom:.5px solid #e5e5e5;display:flex;justify-content:space-between;align-items:center}.publish-moment-title{font-size:17px;font-weight:500}.publish-moment-close{font-size:14px;color:#576b95;cursor:pointer}.publish-moment-body{padding:15px}.generate-moment-section{text-align:center;padding:20px;background-color:#f8f9fa;border-radius:8px;margin-bottom:20px}.generate-moment-btn{background-color:var(--theme-primary);color:#fff;border:none;border-radius:8px;padding:12px 24px;font-size:16px;cursor:pointer;margin-bottom:10px}.generate-moment-hint{font-size:14px;color:#666;line-height:1.5}.moment-preview{display:none;border:1px solid #e5e5e5;border-radius:8px;padding:15px;margin-bottom:20px;background-color:#f8f9fa}.moment-preview-title{font-size:14px;font-weight:500;margin-bottom:10px;color:#333}.moment-preview-content{font-size:15px;line-height:1.5;margin-bottom:10px}.moment-preview-image{width:100%;max-width:200px;border-radius:8px}.unsplash-key-section{margin-bottom:20px}.unsplash-key-label{font-size:14px;color:#333;margin-bottom:8px;display:block}.unsplash-key-input{width:100%;padding:10px;border:1px solid #e5e5e5;border-radius:4px;font-size:16px;outline:none}.unsplash-key-input:focus{border-color:var(--theme-primary)}.publish-moment-submit{width:100%;padding:12px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:4px;font-size:16px;cursor:pointer}.publish-moment-submit:active{background-color:#06a652}.publish-moment-submit:disabled{background-color:#ccc;cursor:not-allowed}.modal{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background-color:var(--overlay-bg);z-index:2000;transition:background-color .3s ease}.modal-content{position:absolute;bottom:0;left:0;right:0;background-color:var(--modal-bg);color:var(--text-primary);border-radius:12px 12px 0 0;max-height:80vh;overflow-y:auto;animation:slideUp .3s ease;transition:background-color .3s ease,color .3s ease}@keyframes slideUp{0%{transform:translateY(100%)}to{transform:translateY(0)}}.modal-header{padding:15px;border-bottom:.5px solid #e5e5e5;display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:17px;font-weight:500}.modal-close{font-size:14px;color:#576b95;cursor:pointer}.modal-body{padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #eee}#updateModal .modal-body{max-height:60vh;overflow-y:auto;padding-right:20px}#updateModal .modal-footer{display:none}#updateModal .modal-footer.visible{display:block}.form-group{margin-bottom:15px}.form-label{font-size:14px;color:var(--text-primary);margin-bottom:8px;display:block;transition:color .3s ease}.form-input,.form-textarea{width:100%;padding:10px;background-color:var(--input-bg);color:var(--text-primary);border:1px solid var(--border-color);border-radius:4px;font-size:16px;outline:none;transition:all .3s ease}.form-input::placeholder,.form-textarea::placeholder{color:var(--text-tertiary)}.form-input:focus,.form-textarea:focus{border-color:var(--theme-primary);box-shadow:0 0 0 2px #07c1601a}.form-textarea{min-height:80px;resize:vertical}.api-key-row{display:flex;gap:10px;align-items:center}.api-key-input{flex:1}.timeout-group{display:flex;align-items:center;gap:4px;white-space:nowrap}.timeout-label{font-size:12px;color:#666}.timeout-input{width:50px;padding:8px 4px;border:1px solid #e5e5e5;border-radius:4px;font-size:14px;outline:none;text-align:center}.timeout-input:focus{border-color:var(--theme-primary)}.timeout-unit{font-size:12px;color:#666}.api-provider-row{border-left:3px solid #e1e5e9;margin-left:8px;background-color:#f8f9fa;border-radius:4px;padding:12px;margin-bottom:8px}.api-provider-row.enabled{border-left:3px solid #28a745;background-color:#28a7450d}.remove-provider-btn{background:#ff4757;color:#fff;border:none;border-radius:50%;width:20px;height:20px;font-size:14px;cursor:pointer;margin-left:8px;line-height:1;display:inline-flex;align-items:center;justify-content:center}.remove-provider-btn:hover{background:#ff3838}.model-selection-row{display:flex;gap:10px;align-items:center}.model-config-select{flex:1;min-width:120px}.model-select{flex:2;min-width:180px}.config-list{padding:16px}.config-list-empty{text-align:center;padding:40px 20px;color:#666}.empty-icon{font-size:48px;margin-bottom:16px}.empty-text{font-size:16px;margin-bottom:20px}.empty-action-btn{background:var(--theme-primary);color:#fff;border:none;border-radius:8px;padding:12px 24px;font-size:14px;cursor:pointer}.config-item{background:#fff;border:1px solid #e5e5e5;border-radius:8px;padding:16px;margin-bottom:12px;cursor:pointer}.config-item:hover{background:#f8f9fa}.config-item-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}.config-item-name{font-weight:700;font-size:16px}.config-item-actions{display:flex;gap:8px}.config-item-btn{background:none;border:none;font-size:18px;cursor:pointer;padding:4px}.config-item-edit{color:#007bff}.config-item-delete{color:#dc3545}.config-item-url{color:#666;font-size:14px;margin-bottom:4px}.config-item-status{font-size:12px;padding:2px 8px;border-radius:12px;color:#fff}.config-item-status.active{background:#28a745}.config-item-status.inactive{background:#6c757d}.config-form{position:fixed;top:0;left:0;right:0;bottom:0;background:#fff;z-index:1000;padding:16px;overflow-y:auto}.config-form-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:16px;border-bottom:1px solid #e5e5e5}.close-form-btn{background:none;border:none;font-size:24px;cursor:pointer;color:#666}.form-actions{display:flex;gap:12px;margin-top:24px}.form-button{flex:1;padding:12px;border:none;border-radius:8px;font-size:16px;cursor:pointer}.form-button.primary{background:var(--theme-primary);color:#fff}.form-button.secondary{background:#6c757d;color:#fff}.form-submit{width:100%;padding:12px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:4px;font-size:16px;cursor:pointer}.form-submit:active{background-color:#06a652}.emoji-panel{display:none;position:absolute;bottom:100%;left:0;right:0;background-color:var(--bg-primary);border-top:.5px solid var(--border-color);max-height:250px;overflow-y:auto;margin-bottom:8px;box-shadow:0 -2px 10px var(--shadow-color);transition:all .3s ease}.emoji-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:10px}.emoji-item{aspect-ratio:1;display:flex;align-items:center;justify-content:center;background-color:#fff;border-radius:8px;cursor:pointer;overflow:hidden;position:relative}.emoji-item:active{background-color:#e5e5e5}.emoji-item img{width:100%;height:100%;object-fit:cover}.emoji-delete-btn{position:absolute;top:2px;right:2px;width:20px;height:20px;background-color:#f00c;color:#fff;border-radius:50%;display:none;align-items:center;justify-content:center;font-size:12px;cursor:pointer}.emoji-item:hover .emoji-delete-btn{display:flex}.add-emoji-btn{grid-column:span 4;padding:10px;background-color:var(--bg-primary);border:1px dashed var(--theme-primary);border-radius:8px;color:var(--theme-primary);text-align:center;cursor:pointer;transition:all .3s ease}.add-emoji-btn:hover{background-color:var(--theme-primary-light)}.contact-settings-page{display:none;position:fixed;top:0;left:0;width:100%;height:var(--viewport-height, 100vh);background-color:var(--bg-secondary);z-index:1000;transform:translate(100%);transition:transform .3s ease-in-out}.contact-settings-page.active{display:block;transform:translate(0)}.contact-settings-content{padding:0;height:calc(100vh - 60px);overflow-y:auto;background-color:var(--bg-secondary)}.settings-section{background-color:var(--bg-primary);margin:15px 0;border-radius:12px;overflow:hidden;box-shadow:0 2px 8px var(--shadow-color)}.settings-section-title{padding:15px 20px 12px;font-size:14px;font-weight:600;color:var(--text-secondary);background-color:var(--bg-secondary);border-bottom:1px solid var(--border-color)}.settings-item{display:flex;align-items:center;padding:16px 20px;cursor:pointer;transition:background-color .2s;border-bottom:1px solid var(--border-color)}.settings-item:last-child{border-bottom:none}.settings-item:hover{background-color:var(--bg-tertiary)}.settings-item:active{background-color:var(--theme-primary-light)}.settings-item-icon{font-size:20px;margin-right:15px;display:flex;align-items:center;justify-content:center;width:32px;height:32px;border-radius:8px;background-color:var(--theme-primary-light)}.settings-item-content{flex:1;display:flex;flex-direction:column;gap:2px}.settings-item-label{font-size:16px;font-weight:500;color:var(--text-primary)}.settings-item-desc{font-size:13px;color:var(--text-secondary);line-height:1.4}.settings-item-arrow{font-size:18px;color:var(--text-tertiary);margin-left:8px}.settings-item.danger-item .settings-item-icon{background-color:#f5222d1a;color:#f5222d}.settings-item.danger-item .settings-item-label{color:#f5222d}.settings-item.danger-item:hover{background-color:#f5222d0d}.settings-item.danger-item:active{background-color:#f5222d1a}.dark-mode .settings-section{box-shadow:0 2px 8px #0006}.dark-mode .settings-item.danger-item .settings-item-icon{background-color:#f5222d33}.dark-mode .settings-item.danger-item:hover{background-color:#f5222d1a}.dark-mode .settings-item.danger-item:active{background-color:#f5222d26}.settings-menu{display:none;position:fixed;top:50px;right:10px;background-color:#4c4c4c;border-radius:4px;padding:8px 0;min-width:120px;box-shadow:0 2px 10px #0003;z-index:1500}.settings-menu:before{content:"";position:absolute;top:-6px;right:20px;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:6px solid #4c4c4c}.menu-item{padding:10px 20px;color:#fff;font-size:14px;cursor:pointer}.menu-item:active{background-color:#3c3c3c}.menu-item.delete-item{color:#f44}.menu-item.delete-item:active{background-color:#8b0000}.typing-indicator{display:flex;align-items:center;gap:4px;padding:10px}.typing-dot{width:8px;height:8px;background-color:#999;border-radius:50%;animation:typing 1.4s infinite}.typing-dot:nth-child(2){animation-delay:.2s}.typing-dot:nth-child(3){animation-delay:.4s}@keyframes typing{0%,60%,to{opacity:.3}30%{opacity:1}}.toast{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#000c;color:#fff;padding:12px 24px;border-radius:6px;font-size:14px;z-index:3000;display:none;max-width:400px;text-align:center;box-shadow:0 4px 12px #00000026}.toast.show{display:block;animation:fadeInOut 2s ease}.toast.toast-error{background-color:#dc3545;color:#fff}.toast.toast-success{background-color:#28a745;color:#fff}.toast.toast-warning{background-color:#ffc107;color:#212529}.toast.toast-info{background-color:#17a2b8;color:#fff}@keyframes fadeInOut{0%,to{opacity:0}10%,90%{opacity:1}}.top-notification{position:fixed;top:20px;left:50%;transform:translate(-50%);background-color:#000c;color:#fff;padding:10px 20px;border-radius:20px;font-size:14px;z-index:3000;display:none}.top-notification.show{display:block;animation:slideDown 1.5s ease}@keyframes slideDown{0%{opacity:0;transform:translate(-50%) translateY(-20px)}20%{opacity:1;transform:translate(-50%) translateY(0)}80%{opacity:1;transform:translate(-50%) translateY(0)}to{opacity:0;transform:translate(-50%) translateY(-20px)}}.model-list{max-height:200px;overflow-y:auto;border:1px solid #e5e5e5;border-radius:4px;margin-top:10px}.model-item{padding:12px;border-bottom:.5px solid #e5e5e5;cursor:pointer;font-size:14px}.model-item:last-child{border-bottom:none}.model-item:active{background-color:#f5f5f5}.model-item.selected{background-color:#e8f5e9;color:var(--theme-primary)}.loading-text{text-align:center;padding:20px;color:#999;font-size:14px}.prompt-section{margin-top:20px;padding-top:20px;border-top:1px solid #e5e5e5}.prompt-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.prompt-title{font-size:14px;font-weight:500}.prompt-actions{display:flex;gap:10px}.prompt-btn{padding:5px 10px;background-color:#f5f5f5;border:1px solid #e5e5e5;border-radius:4px;font-size:12px;cursor:pointer}.prompt-btn:active{background-color:#e5e5e5}.file-input{display:none}.profile-page{position:fixed;top:0;left:0;right:0;bottom:50px;background-color:var(--bg-secondary);z-index:150;overflow-y:auto;padding-top:env(safe-area-inset-top);padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);transition:background-color .3s ease}.profile-header{background-color:var(--bg-primary);padding:20px 15px;text-align:center;border-bottom:10px solid var(--bg-secondary);transition:all .3s ease}.profile-avatar{width:80px;height:80px;border-radius:8px;margin:0 auto 15px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:32px;overflow:hidden}.profile-avatar img{width:100%;height:100%;object-fit:cover}.profile-name{font-size:18px;font-weight:500;margin-bottom:5px;color:var(--text-primary);transition:color .3s ease}.profile-id{font-size:14px;color:var(--text-secondary);transition:color .3s ease}.profile-section{background-color:var(--bg-primary);margin-bottom:10px;transition:background-color .3s ease}.profile-item{display:flex;align-items:center;padding:15px;border-bottom:.5px solid var(--border-color);cursor:pointer;background-color:var(--bg-primary);transition:all .3s ease}.profile-item:last-child{border-bottom:none}.profile-item:active{background-color:var(--bg-secondary)}.profile-item-label{flex:1;font-size:16px;color:var(--text-primary);transition:color .3s ease}.profile-item-value{color:var(--text-secondary);font-size:14px;margin-right:5px;transition:color .3s ease}.profile-item-arrow{color:var(--text-tertiary);transition:color .3s ease}.profile-version{text-align:center;padding:15px;margin-top:10px;background-color:transparent}.profile-version #profileVersionText{font-size:12px;color:#999;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;-webkit-user-select:none;user-select:none;opacity:.8}.feature-hint{position:absolute;bottom:60px;right:15px;background:var(--theme-primary);color:#fff;padding:8px 12px;border-radius:18px;font-size:12px;z-index:150;box-shadow:0 2px 8px #0000001a;animation:pulse 2s infinite}@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.05)}to{transform:scale(1)}}.context-control{background-color:#fff;padding:12px 15px;border-radius:8px;margin-top:10px;box-shadow:0 1px 3px #0000001a;position:relative}.context-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.context-title{font-size:15px;font-weight:500;color:#333}.context-value{font-size:14px;color:var(--theme-primary);font-weight:700;min-width:40px;text-align:right}.context-slider{width:100%;height:6px;-webkit-appearance:none;background:#e0e0e0;border-radius:3px;outline:none;margin-top:10px}.context-slider::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;border-radius:50%;background:var(--theme-primary);cursor:pointer;box-shadow:0 2px 5px #0003}.context-info{font-size:12px;color:#666;margin-top:10px;line-height:1.4}.music-modal{display:none;position:fixed;z-index:2000;left:0;top:0;width:100%;height:100%;background-color:#0006}.music-modal-content{background-color:var(--bg-primary);margin:5% auto;padding:20px;border:1px solid #888;width:90%;max-width:600px;border-radius:10px;max-height:80vh;overflow-y:auto}.close-btn{color:#aaa;float:right;font-size:28px;font-weight:700;cursor:pointer}.close-btn:hover{color:#000}.playlist-container{margin:20px 0;border:1px solid #ddd;border-radius:5px;padding:10px;max-height:200px;overflow-y:auto}.song-item{padding:10px;margin:5px 0;background:#f0f0f0;border-radius:5px;cursor:pointer;display:flex;justify-content:space-between;align-items:center}.song-item:hover{background:#e0e0e0}.song-item.active{background:var(--theme-primary);color:#fff}.delete-song{color:#f44;cursor:pointer;padding:0 10px}.player-controls{margin:20px 0;padding:15px;background:#f9f9f9;border-radius:5px}.progress-bar{width:100%;height:4px;background:#ddd;border-radius:2px;margin:10px 0;cursor:pointer}.progress-fill{height:100%;background:var(--theme-primary);border-radius:2px;width:0%;transition:width .1s}.time-display{display:flex;justify-content:space-between;font-size:12px;color:#666}.floating-lyrics{position:fixed;bottom:100px;left:50%;transform:translate(-50%);background:#000c;color:#fff;padding:12px 24px;border-radius:25px;font-size:16px;z-index:999;transition:all .3s ease;max-width:80%;text-align:center;box-shadow:0 4px 6px #0000001a}.debug-info{position:fixed;top:20px;right:10px;background:#ffffffe6;padding:10px;border-radius:5px;font-size:12px;box-shadow:0 2px 4px #0000001a}.group-avatar{width:48px;height:48px;border-radius:4px;margin-right:12px;background-color:#4a90e2;display:flex;align-items:center;justify-content:center;color:#fff;font-size:20px;flex-shrink:0;overflow:hidden;position:relative}.group-avatar-inner{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:repeat(2,1fr);grid-template-rows:repeat(2,1fr)}.group-avatar-item{display:flex;align-items:center;justify-content:center;font-size:12px;overflow:hidden;border:1px solid white;background-color:var(--theme-primary)}.group-avatar-item img{width:100%;height:100%;object-fit:cover}.create-group-section{margin-top:20px;padding-top:20px;border-top:1px solid #e5e5e5}.group-member-list{max-height:200px;overflow-y:auto;border:1px solid #e5e5e5;border-radius:4px;margin-top:10px;padding:10px}.group-member-item{display:flex;align-items:center;padding:8px;border-bottom:.5px solid #eee;cursor:pointer}.group-member-item:last-child{border-bottom:none}.group-member-item.selected{background-color:#e6f7ff}.group-member-avatar{width:32px;height:32px;border-radius:4px;margin-right:10px;background-color:var(--theme-primary);display:flex;align-items:center;justify-content:center;color:#fff;font-size:14px;overflow:hidden}.group-member-avatar img{width:100%;height:100%;object-fit:cover}.group-member-name{flex:1;font-size:14px}.group-member-checkbox{width:20px;height:20px;border-radius:4px;border:1px solid #ddd;display:flex;align-items:center;justify-content:center}.group-member-checkbox.selected{background-color:var(--theme-primary);color:#fff;border-color:var(--theme-primary)}.group-message-header{display:flex;align-items:center;margin-bottom:4px}.group-message-name{font-size:12px;font-weight:700;color:#576b95}.group-message-time{font-size:10px;color:#999;margin-left:8px}.group-info-hint{background-color:#f0f0f0;color:#666;font-size:12px;text-align:center;padding:8px;border-radius:4px;margin:10px 0}.weibo-page{background-color:var(--bg-secondary)}.weibo-header{background-color:var(--bg-tertiary);color:var(--text-primary);padding:10px 15px;padding-top:calc(10px + var(--safe-area-top, 0px));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);flex-shrink:0;min-height:calc(44px + var(--safe-area-top, 0px));transition:all .3s ease}.weibo-page:not(.active) .weibo-header{display:none}.weibo-container{max-width:600px;margin:0 auto;background:var(--bg-secondary);transition:background-color .3s ease;flex:1;display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow-y:auto;padding-bottom:calc(var(--nav-height, 50px) + 15px);-webkit-overflow-scrolling:touch}.weibo-scroll-content{transform:translateZ(0)}.weibo-container>.post{min-width:0;max-width:100%}.post{background:var(--bg-primary);color:var(--text-primary);margin-bottom:8px;padding:16px;width:100%;box-sizing:border-box;flex-shrink:0;transform:translateZ(0);transition:all .3s ease}.post-header{display:flex;align-items:flex-start;margin-bottom:12px;position:relative}.post-menu{position:absolute;top:16px;right:16px;width:24px;height:24px;display:flex;align-items:center;justify-content:center;font-size:20px;color:#666;cursor:pointer;border-radius:50%}.post-menu:hover{background-color:var(--bg-secondary)}.post-menu-dropdown{display:none;position:absolute;top:100%;right:0;background-color:var(--bg-primary);border-radius:4px;box-shadow:0 2px 10px var(--shadow-color);z-index:10;min-width:80px;padding:4px 0;transition:all .3s ease}.post-menu-dropdown .menu-item{padding:8px 12px;font-size:14px;color:var(--text-primary);cursor:pointer;transition:all .3s ease}.post-menu-dropdown .menu-item:hover{background-color:var(--bg-secondary)}.avatar{width:50px;height:50px;border-radius:50%;background:linear-gradient(45deg,#ff8a80,#ff5722);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;margin-right:12px;font-size:16px;flex-shrink:0;overflow:hidden}.avatar img{width:100%;height:100%;object-fit:cover}.post-info{flex:1}.user-name{font-size:16px;color:var(--text-primary);font-weight:500;margin-bottom:4px;transition:color .3s ease}.vip-badge{display:inline-block;background:linear-gradient(45deg,#ffb74d,#ff9800);color:#fff;padding:1px 4px;border-radius:2px;font-size:10px;margin-left:4px;vertical-align:middle}.post-time{font-size:12px;color:var(--text-tertiary);margin-bottom:4px;transition:color .3s ease}.post-source{font-size:12px;color:var(--text-tertiary);transition:color .3s ease}.post-content{font-size:15px;line-height:1.6;margin-bottom:12px;color:var(--text-primary);word-wrap:break-word;transition:color .3s ease}.hashtag,.mention{color:var(--theme-primary);text-decoration:none}.post-image-desc{width:120px;height:120px;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:8px;margin:12px 0;display:flex;align-items:center;justify-content:center;font-size:10px;color:var(--text-secondary);transition:all .3s ease;text-align:center;padding:12px;line-height:1.2;overflow:hidden;word-wrap:break-word;-webkit-hyphens:auto;hyphens:auto}.post-actions{display:flex;justify-content:space-around;align-items:center;padding-top:12px;border-top:1px solid #f0f0f0;margin-top:12px}.action-btn-weibo{display:flex;align-items:center;color:#666;font-size:13px;text-decoration:none;padding:4px 8px;border-radius:4px;transition:background-color .2s}.action-btn-weibo:hover{background-color:#f5f5f5}.action-icon{margin-right:4px;font-size:16px}.comments-section{background:var(--bg-secondary);margin:12px -16px -16px;padding:12px 16px;transition:background-color .3s ease}.comment{margin-bottom:8px;font-size:14px;line-height:1.5}.comment:last-child{margin-bottom:0}.comment-user{color:var(--theme-primary);font-weight:500;margin-right:4px;transition:color .3s ease}.comment-content{color:var(--text-primary);transition:color .3s ease}.comment-time{color:var(--text-tertiary);font-size:12px;margin-left:8px;transition:color .3s ease}.load-more-messages{text-align:center;padding:10px;color:#576b95;font-size:14px;cursor:pointer;margin-bottom:10px}.load-more-messages:hover{text-decoration:underline}.load-more-posts{text-align:center;padding:15px;color:#576b95;font-size:14px;cursor:pointer;margin:10px 0;border:1px dashed #d0d0d0;border-radius:8px;background:#f9f9f9}.load-more-posts:hover{background:#f0f0f0;text-decoration:underline}.data-management-container{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-bottom:calc(var(--nav-height, 50px) + 15px);background-color:var(--bg-secondary);transition:background-color .3s ease}.virtual-spacer-top,.virtual-spacer-bottom{width:100%;background:transparent;flex-shrink:0;box-sizing:border-box;margin:0;padding:0}.confirm-dialog-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:4000}#updateModalBody{max-height:60vh;overflow-y:auto;padding-bottom:15px}#updateModalBody h2{font-size:1.2em;margin-top:1em;margin-bottom:.5em;text-align:center}#updateModalBody h3{font-size:1.1em;margin-top:1em;margin-bottom:.5em;color:var(--theme-primary)}#updateModalBody ul{padding-left:20px;margin-bottom:1em}#updateModalBody li{margin-bottom:.5em;line-height:1.6}.modal-footer{padding:15px;border-top:.5px solid #e5e5e5}.reply-box{margin-top:12px;padding-top:12px;padding-bottom:60px;border-top:1px solid #f0f0f0;display:flex;gap:8px}.reply-input{flex:1;padding:8px 12px;border:1px solid #e1e8ed;border-radius:18px;font-size:14px;resize:none;outline:none;transition:border-color .2s}.reply-input:focus{border-color:#4a90e2}.reply-button{padding:8px 16px;background-color:#4a90e2;color:#fff;border:none;border-radius:18px;font-size:14px;cursor:pointer;transition:background-color .2s}.reply-button:hover{background-color:#357bd8}.reply-button:disabled{background-color:#ccc;cursor:not-allowed}.confirm-dialog{background-color:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px #0000001a;width:80%;max-width:300px;text-align:center}.confirm-dialog-title{font-size:18px;font-weight:500;margin-bottom:10px}.confirm-dialog-message{font-size:14px;color:#666;margin-bottom:20px}.confirm-dialog-buttons{display:flex;justify-content:space-between}.confirm-dialog-btn{flex:1;padding:10px;border:none;border-radius:4px;font-size:16px;cursor:pointer}.confirm-dialog-btn.cancel{background-color:#f0f0f0;color:#333;margin-right:10px}.confirm-dialog-btn.confirm{background-color:#f44;color:#fff}.post-choice-container{display:flex;flex-direction:column;gap:15px}.choice-option{padding:20px;border:2px solid var(--border-color);border-radius:12px;cursor:pointer;transition:all .3s ease;text-align:center;background-color:var(--bg-primary);color:var(--text-primary)}.choice-option:hover{border-color:var(--theme-primary);background-color:var(--theme-primary-light)}.choice-option:active{transform:scale(.98)}.choice-icon{font-size:32px;margin-bottom:10px}.choice-title{font-size:18px;font-weight:600;margin-bottom:8px;color:#333}.choice-description{font-size:14px;color:#666;line-height:1.4}#manualPostModal .form-input{width:100%}#manualPostModal textarea.form-input{resize:vertical;min-height:80px}#manualPostAuthor{background-color:#f5f5f5;color:#666}.message-selected{background-color:#ff636333!important;border-left:4px solid #ff6b6b!important}.message-selected .message-bubble{background-color:#ff636326!important}.multi-select-buttons{position:fixed;bottom:0;left:0;right:0;display:none;justify-content:space-around;align-items:center;z-index:1001;height:80px;background:#fffffffa;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border-top:1px solid rgba(0,0,0,.1)}.multi-select-btn{padding:12px 30px;border:none;border-radius:25px;font-size:16px;font-weight:600;cursor:pointer;transition:all .3s ease;min-width:120px;height:45px}.multi-select-btn.cancel-btn{background-color:#6c757d;color:#fff}.multi-select-btn.cancel-btn:hover{background-color:#5a6268}.multi-select-btn.delete-btn{background-color:#dc3545;color:#fff}.multi-select-btn.delete-btn:hover{background-color:#c82333}.voice-message{position:relative;cursor:pointer;transition:opacity .2s}.voice-message:hover{opacity:.9}.voice-icon{display:inline-block;margin-right:6px;margin-left:2px;vertical-align:middle;line-height:1;-webkit-user-select:none;user-select:none;color:inherit}.voice-icon svg{display:inline-block;vertical-align:middle;width:16px;height:16px;stroke:currentColor}.voice-message.playing .voice-icon{animation:pulse 1.5s infinite}@keyframes pulse{0%,to{opacity:1;transform:scale(1)}50%{opacity:.7;transform:scale(1.1)}}.voice-message.loading .voice-icon{animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.voice-player,.play-button,.waveform,.duration{display:none!important}.message-content.has-voice-player{border-top:none;padding-top:0;margin-top:0}.debug-log-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out;background-color:#f5f5f5;display:flex;flex-direction:column;overflow-y:auto;-webkit-overflow-scrolling:touch}.debug-log-page.active{opacity:1;pointer-events:auto;z-index:10}.debug-log-container{flex:1;display:flex;flex-direction:column;padding:15px 15px 70px;background-color:var(--bg-secondary);transition:background-color .3s ease}.database-stats{background:var(--bg-primary)!important;color:var(--text-primary);padding:15px;border-radius:8px;margin:15px;transition:all .3s ease;border:1px solid var(--border-color)}.import-export-actions>div{background:var(--bg-primary)!important;color:var(--text-primary)!important;border-color:var(--border-color)!important}.context-control{background-color:var(--bg-primary)!important;color:var(--text-primary)!important;border-color:var(--border-color)!important}.import-warning{background-color:var(--bg-secondary)!important;color:var(--text-primary)!important;border-color:var(--border-color)!important}#migrationStatusDetails,#chatEmojiMigrationStatusDetails,#imageKeywordConfigStatus,#databaseStatsContent{background-color:var(--bg-primary)!important;color:var(--text-primary)!important;border:1px solid var(--border-color)!important}#syncKeyInput{background-color:var(--input-bg)!important;color:var(--text-primary)!important;border:1px solid var(--border-color)!important}#syncKeyInput::placeholder{color:var(--text-tertiary)!important}#characterSelector{background-color:var(--input-bg)!important;color:var(--text-primary)!important;border:1px solid var(--border-color)!important}.debug-log-info{margin-bottom:15px}.debug-log-stats{font-size:14px;color:var(--text-secondary);margin-bottom:5px;transition:color .3s ease}.debug-log-hint{font-size:12px;color:var(--text-tertiary);line-height:1.4;transition:color .3s ease}.debug-log-content{flex:1;background:var(--bg-primary);border-radius:8px;padding:10px;max-height:calc(100vh - 200px);transition:background-color .3s ease;overflow-y:auto;-webkit-overflow-scrolling:touch}.debug-log-empty{text-align:center;color:#999;padding:40px 20px;font-size:14px}.debug-log-item{margin-bottom:8px;padding:8px;border-radius:4px;border-left:3px solid var(--border-color);background-color:var(--bg-secondary);color:var(--text-primary);font-size:13px;word-break:break-all;transition:all .3s ease}.debug-log-item.debug-log-error{background:#e53e3e1a;border-left-color:#e53e3e}.debug-log-item.debug-log-warn{background:#dd6b201a;border-left-color:#dd6b20}.debug-log-item.debug-log-info{background:#3182ce1a;border-left-color:#3182ce}.debug-log-item.debug-log-log{background:var(--bg-secondary);border-left-color:#718096}.debug-log-item.debug-log-debug{background:#38a1691a;border-left-color:#38a169}.debug-log-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}.debug-log-time{color:var(--text-tertiary);font-size:11px;transition:color .3s ease}.debug-log-level{font-size:10px;font-weight:600;padding:2px 6px;border-radius:3px;text-transform:uppercase}.debug-log-error .debug-log-level{background:#e53e3e;color:#fff}.debug-log-warn .debug-log-level{background:#dd6b20;color:#fff}.debug-log-info .debug-log-level{background:#3182ce;color:#fff}.debug-log-log .debug-log-level{background:#718096;color:#fff}.debug-log-debug .debug-log-level{background:#38a169;color:#fff}.debug-log-message{font-family:Monaco,Menlo,Ubuntu Mono,monospace;line-height:1.4;white-space:pre-wrap;color:var(--text-primary);transition:color .3s ease}.header-btn{background:var(--theme-primary);color:#fff;border:none;padding:6px 12px;border-radius:4px;font-size:12px;cursor:pointer;margin-left:8px}.header-btn:hover{background:#06ad56}.header-actions{display:flex;align-items:center}.memory-management-container{flex:1;display:flex;flex-direction:column;padding-bottom:70px;overflow:hidden}.memory-tabs{display:flex;background:var(--bg-primary);border-bottom:1px solid var(--border-color);transition:all .3s ease}.memory-tab{flex:1;padding:15px;border:none;background:none;font-size:16px;cursor:pointer;color:var(--text-secondary);border-bottom:2px solid transparent;transition:all .3s ease}.memory-tab.active{color:var(--theme-primary);border-bottom-color:var(--theme-primary);font-weight:600}.memory-content{flex:1;display:flex;flex-direction:column;overflow:hidden}.memory-section{flex:1;display:flex;flex-direction:column;padding:15px;overflow:hidden}.memory-section.hidden,.hidden{display:none}.character-selector{margin-bottom:15px}.character-selector select{width:100%;padding:12px;border:1px solid #e0e0e0;border-radius:8px;font-size:16px;background:#fff}.memory-list{flex:1;display:flex;flex-direction:column;gap:10px;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-bottom:15px}.memory-empty{text-align:center;color:#999;font-size:14px;padding:40px 20px}.memory-item{background:#fff;border-radius:8px;border:1px solid #e0e0e0;margin-bottom:8px;transition:all .3s ease}.memory-item:hover{border-color:var(--theme-primary);box-shadow:0 2px 8px var(--theme-primary-light)}.memory-item.single-item{padding:12px 15px}.memory-single-content{display:flex;flex-direction:column;gap:8px}.memory-text{font-size:14px;color:#333;line-height:1.5;word-break:break-word}.memory-meta{display:flex;justify-content:space-between;align-items:center;padding-top:8px;border-top:1px solid #f0f0f0}.memory-date{font-size:12px;color:#999}.memory-header{padding:12px 15px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;background:#f9f9f9;border-bottom:1px solid #e0e0e0}.memory-title{font-size:14px;color:#333;font-weight:500;flex:1}.memory-expand-icon{font-size:14px;color:#666;transition:transform .3s ease}.memory-item.expanded .memory-expand-icon{transform:rotate(90deg)}.memory-content-wrapper{max-height:0;overflow:hidden;transition:max-height .3s ease}.memory-item.expanded .memory-content-wrapper{max-height:500px}.memory-content-text{padding:15px;color:#333;line-height:1.6;font-size:14px}.memory-content-text h1,.memory-content-text h2,.memory-content-text h3{margin:0 0 8px;font-weight:600}.memory-content-text h1{font-size:18px}.memory-content-text h2{font-size:16px}.memory-content-text h3{font-size:14px}.memory-content-text ul,.memory-content-text ol{margin:8px 0;padding-left:20px}.memory-content-text li{margin:4px 0}.memory-actions{padding:10px 15px;background:#f9f9f9;display:flex;gap:10px;justify-content:flex-end;border-top:1px solid #e0e0e0}.memory-edit-btn{padding:8px 16px;border:1px solid #e0e0e0;border-radius:4px;background:#fff;color:#333;font-size:12px;cursor:pointer;transition:all .3s ease;min-width:60px}.memory-btn:hover{border-color:var(--theme-primary);color:var(--theme-primary)}.memory-btn.delete{color:#e53e3e;border-color:#e53e3e}.memory-btn.delete:hover{background:#e53e3e;color:#fff}.form-hint{font-size:12px;color:#999;margin-top:5px}.user-profile-page{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;pointer-events:none;transition:opacity .15s ease-in-out;background-color:#f5f5f5;display:flex;flex-direction:column;overflow:visible}.user-profile-page.active{opacity:1;pointer-events:auto;z-index:10}.user-profile-header{background-color:var(--bg-primary);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);padding:10px 15px;padding-top:calc(10px + env(safe-area-inset-top));padding-left:calc(15px + env(safe-area-inset-left));padding-right:calc(15px + env(safe-area-inset-right));display:flex;align-items:center;justify-content:space-between;border-bottom:.5px solid var(--border-color);position:absolute;top:0;left:0;right:0;z-index:100;height:calc(44px + env(safe-area-inset-top));transition:all .3s ease}.dark-mode .user-profile-header{background-color:#1a1a1af2}.system-theme .user-profile-header{background-color:var(--bg-primary)}.user-profile-content{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding-top:calc(44px + env(safe-area-inset-top));padding-bottom:calc(50px + env(safe-area-inset-bottom));position:relative;z-index:0}.user-profile-banner{width:100%;height:30vh;background:linear-gradient(135deg,#667eea,#764ba2);position:relative;overflow:visible;z-index:2}.user-profile-avatar-container{position:absolute;right:20px;bottom:0;display:flex;flex-direction:row;align-items:flex-end;gap:15px;z-index:20}.user-profile-avatar{width:80px;height:80px;border-radius:8px;background-color:#fff;display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:700;color:#333;border:3px solid #fff;box-shadow:0 2px 8px #00000026;background-size:cover;background-position:center;transform:translateY(50%);z-index:25;position:relative}.user-profile-name{color:#fff;font-size:20px;font-weight:700;text-shadow:0 1px 3px rgba(0,0,0,.3);text-align:right;max-width:200px;word-wrap:break-word;align-self:flex-end;margin-bottom:13px}.user-profile-moments{background-color:var(--bg-secondary);min-height:60vh;padding-top:40px;position:relative;z-index:1;overflow:visible;transition:background-color .3s ease}.user-profile-moments-empty{text-align:center;padding:80px 20px;color:var(--text-secondary);transition:color .3s ease}.user-profile-moments-list{padding:0 15px;background-color:var(--bg-secondary);overflow:visible;transition:background-color .3s ease}.user-profile-moment-item{background-color:var(--bg-primary);margin-bottom:8px;padding:15px;border-radius:8px;box-shadow:0 1px 3px var(--shadow-color);position:relative;overflow:visible;transition:all .3s ease}.user-profile-moment-content{font-size:14px;line-height:1.4;color:var(--text-primary);margin-bottom:10px;transition:color .3s ease}.user-profile-moment-images{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-bottom:10px}.user-profile-moment-image{width:100%;aspect-ratio:1;object-fit:cover;border-radius:4px}.user-profile-moment-meta{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:#999}.user-profile-moment-time{flex:1}.user-profile-moment-actions{display:flex;gap:15px}.user-profile-moment-action{color:var(--text-tertiary);cursor:pointer;transition:color .3s ease}.user-profile-moment-action:hover{color:var(--theme-primary)}.moment-actions-container{position:relative;display:inline-block}.moment-collapse-btn{display:inline-flex;align-items:center;justify-content:center;width:40px;height:20px;background:var(--bg-secondary);border:none;border-radius:10px;transition:background-color .3s ease;font-size:12px;color:var(--text-secondary);cursor:pointer;-webkit-user-select:none;user-select:none}.moment-collapse-btn:hover{background:#e0e0e0;color:#333}.moment-actions-menu{position:absolute;display:flex;background:#fff;border-radius:15px;box-shadow:0 2px 8px #00000026;opacity:0;visibility:hidden;bottom:120%;left:50%;transform:translate(-50%,10px);transition:opacity .2s ease,transform .2s ease;z-index:9999}.moment-actions-menu.active{opacity:1;visibility:visible;transform:translate(-50%)}.moment-action-btn{display:flex;align-items:center;justify-content:center;width:40px;height:30px;border:none;background:transparent;font-size:16px;cursor:pointer;transition:background-color .3s ease;-webkit-user-select:none;user-select:none}.moment-action-btn:first-child{border-radius:15px 0 0 15px}.moment-action-btn:last-child{border-radius:0 15px 15px 0}.moment-action-btn:only-child{border-radius:15px}.moment-action-btn:hover{background:#f5f5f5}.moment-likes{margin-top:8px;padding:8px 0;font-size:13px;color:#576b95;border-bottom:1px solid #f0f0f0}.moment-likes:empty{display:none}.moment-comment{color:var(--text-primary);margin-left:4px;transition:color .3s ease}.profile-moment-comments{margin-top:8px}.profile-moment-comment-item{align-items:flex-start}.profile-moment-comment{margin-bottom:8px;padding:8px;background:var(--bg-secondary);border-radius:4px;font-size:13px;position:relative;word-wrap:break-word;word-break:break-word;overflow-wrap:break-word;white-space:pre-wrap;transition:background-color .3s ease}.profile-moment-comment-author{color:var(--theme-primary);font-weight:700;cursor:pointer;line-height:16px;margin:0;transition:color .3s ease}.profile-moment-comment-text{font-size:14px;color:var(--text-primary);word-wrap:break-word;word-break:break-word;overflow-wrap:break-word;line-height:18px;margin:0;transition:color .3s ease}.profile-moment-comment-reply-btn{position:absolute;top:8px;right:8px;background:none;border:none;color:var(--text-tertiary);font-size:12px;cursor:pointer;padding:2px 6px;border-radius:3px;transition:all .3s ease}.profile-moment-comment-reply-btn:hover{background:var(--bg-tertiary);color:var(--text-secondary)}.moment-reply-input-container{margin-top:8px;padding:8px;background:var(--bg-primary);border:1px solid var(--border-color);border-radius:4px;display:none!important;transition:all .3s ease}.moment-reply-input-container.active{display:block!important}.moment-reply-input-container:not(.active) .moment-reply-input{display:none!important}.moment-reply-input-container:not(.active) .moment-reply-actions{display:none!important}.moment-reply-input{width:100%;border:none;outline:none;resize:none;font-size:13px;padding:8px;min-height:60px;border-radius:4px;background:var(--input-bg);color:var(--text-primary);transition:all .3s ease}.moment-reply-input::placeholder{color:var(--text-tertiary)}} .moment-reply-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:8px}.moment-reply-btn{padding:6px 12px;border:none;border-radius:4px;font-size:12px;cursor:pointer;transition:all .3s ease}.moment-reply-submit{background:var(--theme-primary);color:#fff}.moment-reply-submit:hover{background:#06ad56}.moment-reply-cancel{background:#f0f0f0;color:#666}.moment-reply-cancel:hover{background:#e0e0e0}.user-profile-banner:hover .banner-upload-hint{opacity:1!important}.banner-upload-container{margin-bottom:20px}.banner-upload-area{border:2px dashed #ddd;border-radius:8px;padding:40px 20px;text-align:center;cursor:pointer;transition:all .3s ease;background:#fafafa}.banner-upload-area:hover{border-color:#667eea;background:#f8f9ff}.banner-upload-area.dragover{border-color:#667eea;background:#e8f0ff}.banner-upload-icon{font-size:48px;margin-bottom:15px;opacity:.6}.banner-upload-text{font-size:16px;color:#333;margin-bottom:8px;font-weight:500}.banner-upload-hint{font-size:12px;color:#999}.banner-preview-container{margin-top:20px}.banner-preview-title{font-size:16px;color:#333;margin-bottom:15px;font-weight:500}.banner-preview-wrapper{border:2px solid #ddd;border-radius:8px;overflow:hidden;margin-bottom:15px;background:#f5f5f5;display:flex;justify-content:center;align-items:center}#bannerPreviewCanvas{display:block;max-width:100%;height:auto}.banner-crop-controls{margin-bottom:20px;display:flex;align-items:center;gap:10px}.banner-crop-controls label{font-size:14px;color:#333;min-width:100px}#bannerCropSlider{flex:1;height:6px;border-radius:3px;background:#ddd;outline:none;-webkit-appearance:none}#bannerCropSlider::-webkit-slider-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;background:#667eea;cursor:pointer;border:2px solid #fff;box-shadow:0 2px 4px #0003}#bannerCropSlider::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:#667eea;cursor:pointer;border:2px solid #fff;box-shadow:0 2px 4px #0003}.banner-upload-buttons{display:flex;gap:10px;justify-content:flex-end}.btn-secondary{padding:8px 16px;border:1px solid #ddd;border-radius:4px;background:#fff;color:#666;cursor:pointer;font-size:14px;transition:all .3s ease}.btn-secondary:hover{background:#f5f5f5;border-color:#bbb}.btn-primary{padding:8px 16px;border:none;border-radius:4px;background:#667eea;color:#fff;cursor:pointer;font-size:14px;transition:all .3s ease}.btn-primary:hover{background:#5a67d8}.appearance-management-page{position:absolute;top:0;left:0;width:100%;height:var(--viewport-height, 100vh);background-color:var(--bg-secondary);z-index:10;display:none;transition:background-color .3s ease}.appearance-management-page.active{display:block}.appearance-content{padding:20px;overflow-y:auto;height:calc(100vh - 60px)}.appearance-section{background:var(--bg-primary);border-radius:12px;padding:16px;margin-bottom:16px;box-shadow:0 2px 8px var(--shadow-color);transition:all .3s ease}.appearance-section-title{font-size:16px;font-weight:600;color:var(--text-primary);margin-bottom:6px;transition:color .3s ease}.appearance-section-desc{color:var(--text-secondary);font-size:13px;margin-bottom:12px;line-height:1.4;transition:color .3s ease}.theme-mode-grid{display:grid;grid-template-columns:1fr;gap:12px;margin-bottom:24px}.theme-mode-option{display:flex;align-items:flex-start;cursor:pointer;padding:16px;border-radius:12px;transition:all .3s ease;border:2px solid var(--border-color);background-color:var(--bg-primary);color:var(--text-primary)}.theme-mode-option:hover{border-color:var(--theme-primary);background-color:var(--theme-primary-light);transform:translateY(-2px);box-shadow:0 4px 12px var(--shadow-color)}.theme-mode-option.active{border-color:var(--theme-primary);background-color:var(--theme-primary-light);box-shadow:0 2px 8px var(--shadow-color)}.theme-mode-icon{font-size:24px;margin-right:12px;flex-shrink:0}.theme-mode-content{flex:1}.theme-mode-name{font-size:16px;font-weight:500;color:var(--text-primary);margin-bottom:4px}.theme-mode-desc{font-size:13px;color:var(--text-secondary)}.theme-color-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:16px}.theme-color-option{display:flex;flex-direction:column;align-items:center;cursor:pointer;padding:8px;border-radius:8px;transition:all .2s ease;border:2px solid transparent}.theme-color-option:hover{background-color:var(--bg-secondary);transform:translateY(-2px)}.theme-color-option.active{border-color:var(--theme-primary);background-color:var(--theme-primary-light)}.theme-color-preview{width:32px;height:32px;border-radius:50%;margin-bottom:6px;box-shadow:0 2px 6px #00000026;position:relative}.theme-color-option.active .theme-color-preview:after{content:"✓";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-weight:700;font-size:14px;text-shadow:0 1px 2px rgba(0,0,0,.3)}.theme-color-name{font-size:11px;color:var(--text-secondary);text-align:center;transition:color .3s ease}.theme-color-option.active .theme-color-name{color:var(--theme-primary);font-weight:600}.custom-color-section{border-top:1px solid var(--border-color);padding-top:16px;transition:border-color .3s ease}.custom-color-label{display:block;font-size:14px;font-weight:600;color:var(--text-primary);margin-bottom:8px;transition:color .3s ease}.custom-color-desc{color:var(--text-secondary);transition:color .3s ease;font-size:12px;margin-bottom:16px;line-height:1.4}.custom-color-preview-row{display:flex;align-items:center;gap:12px;margin-bottom:12px;flex-wrap:wrap}@media (max-width: 480px){.custom-color-preview-row{flex-direction:column;gap:16px;align-items:stretch}}.custom-color-preview-container{display:flex;flex-direction:column;align-items:center;gap:8px}.custom-color-preview-circle{width:60px;height:60px;border-radius:50%;border:3px solid #e0e0e0;cursor:pointer;transition:all .2s ease;position:relative;overflow:hidden;box-shadow:0 2px 8px #0000001a}.custom-color-preview-circle:hover{transform:scale(1.05);border-color:var(--theme-primary)}.custom-color-picker-hidden{position:absolute;top:-5px;left:-5px;width:70px;height:70px;border:none;background:none;opacity:0;cursor:pointer}.custom-color-picker-hidden::-webkit-color-swatch-wrapper{padding:0}.custom-color-picker-hidden::-webkit-color-swatch{border:none}.custom-color-preview-label{font-size:12px;color:#666;font-weight:500}.custom-color-input-container{display:flex;align-items:center;gap:8px;flex:1;min-width:0}@media (max-width: 480px){.custom-color-input-container{width:100%}}.custom-color-text{flex:1;padding:12px 16px;border:2px solid var(--border-color);border-radius:8px;background-color:var(--input-bg);color:var(--text-primary);font-family:SF Mono,Monaco,Inconsolata,Roboto Mono,monospace;font-size:14px;font-weight:500;text-transform:uppercase;transition:all .2s ease}.custom-color-text::placeholder{color:var(--text-tertiary)}.custom-color-text:focus{outline:none;border-color:var(--theme-primary);box-shadow:0 0 0 3px var(--theme-primary-light)}.custom-color-text.invalid{border-color:#ff4d4f;background-color:#fff2f0}.apply-custom-color-btn{padding:12px 16px;background-color:var(--theme-primary);color:#fff;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;min-width:60px;white-space:nowrap}@media (max-width: 480px){.apply-custom-color-btn{width:100%;margin-top:8px}}.apply-custom-color-btn:hover{background-color:var(--theme-primary-hover);transform:translateY(-1px)}.apply-custom-color-btn:active{transform:translateY(0)}.apply-custom-color-btn:disabled{background-color:#ccc;cursor:not-allowed;transform:none}.color-input-tips{margin-top:12px;padding:8px 12px;background-color:#f8f9fa;border-radius:6px;border-left:3px solid var(--theme-primary)}.color-input-tips small{color:#666;font-size:12px}.gradient-toggle-container{margin-bottom:20px}.gradient-toggle-label{display:flex;align-items:center;gap:12px;cursor:pointer;font-size:16px;font-weight:600;color:var(--text-primary);transition:color .3s ease}.gradient-toggle-input{display:none}.gradient-toggle-slider{width:50px;height:26px;background-color:#ccc;border-radius:13px;position:relative;transition:all .3s ease}.gradient-toggle-slider:before{content:"";position:absolute;width:20px;height:20px;border-radius:50%;background-color:#fff;top:3px;left:3px;transition:all .3s ease;box-shadow:0 2px 4px #0003}.gradient-toggle-input:checked+.gradient-toggle-slider{background-color:var(--theme-primary)}.gradient-toggle-input:checked+.gradient-toggle-slider:before{transform:translate(24px)}.gradient-settings{border-top:1px solid #eee;padding-top:20px;margin-top:20px}.gradient-color-row{display:flex;gap:20px;margin-bottom:20px}@media (max-width: 480px){.gradient-color-row{flex-direction:column;gap:16px}}.gradient-color-group{flex:1}.gradient-color-label{display:block;font-size:14px;font-weight:600;color:#333;margin-bottom:8px}.gradient-color-picker-container{display:flex;align-items:center;gap:8px}.gradient-color-preview{width:40px;height:40px;border-radius:8px;border:2px solid #e0e0e0;cursor:pointer;transition:all .2s ease;position:relative;overflow:hidden}.gradient-color-preview:hover{transform:scale(1.05);border-color:var(--theme-primary)}.gradient-color-picker-hidden{position:absolute;top:-2px;left:-2px;width:44px;height:44px;border:none;background:none;opacity:0;cursor:pointer}.gradient-color-text{flex:1;padding:10px 12px;border:2px solid #e0e0e0;border-radius:6px;font-family:SF Mono,Monaco,Inconsolata,Roboto Mono,monospace;font-size:13px;font-weight:500;text-transform:uppercase;transition:all .2s ease}.gradient-color-text:focus{outline:none;border-color:var(--theme-primary);box-shadow:0 0 0 2px var(--theme-primary-light)}.gradient-preview-container{margin-bottom:20px}.gradient-preview-label{display:block;font-size:14px;font-weight:600;color:#333;margin-bottom:8px}.gradient-preview-demo{height:80px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(to right,#07c160,#1890ff);box-shadow:0 4px 12px #0000001a}.gradient-preview-text{color:#fff;font-size:16px;font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,.3)}.gradient-direction-container{margin-bottom:20px}.gradient-direction-label{display:block;font-size:14px;font-weight:600;color:#333;margin-bottom:12px}.gradient-direction-options{display:flex;gap:12px;flex-wrap:wrap}.gradient-direction-option{display:flex;align-items:center;gap:6px;cursor:pointer;padding:8px 12px;border:2px solid #e0e0e0;border-radius:8px;transition:all .2s ease;background-color:#fff}.gradient-direction-option:hover{border-color:var(--theme-primary);background-color:#f8f9fa}.gradient-direction-option input[type=radio]{margin:0}.gradient-direction-option input[type=radio]:checked+.gradient-direction-text{color:var(--theme-primary);font-weight:600}.gradient-direction-option:has(input[type=radio]:checked){border-color:var(--theme-primary);background-color:var(--theme-primary-light)}.gradient-direction-text{font-size:14px;color:#666;transition:all .2s ease}.apply-gradient-btn{width:100%;padding:14px 20px;background:linear-gradient(135deg,var(--theme-primary),var(--theme-primary-hover));color:#fff;border:none;border-radius:10px;font-size:16px;font-weight:600;cursor:pointer;transition:all .2s ease;box-shadow:0 4px 12px #0000001a}.apply-gradient-btn:hover{transform:translateY(-2px);box-shadow:0 6px 16px #00000026}.apply-gradient-btn:active{transform:translateY(0)}.bubble-designer-option{margin-top:12px}.bubble-designer-btn{display:flex;align-items:center;width:100%;padding:16px;background:linear-gradient(135deg,#667eea,#764ba2);border:none;border-radius:12px;color:#fff;cursor:pointer;transition:all .3s ease;position:relative;overflow:hidden}.bubble-designer-btn:hover{transform:translateY(-2px);box-shadow:0 8px 25px #667eea66}.bubble-designer-btn:active{transform:translateY(0)}.bubble-designer-btn:before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);transition:left .5s}.bubble-designer-btn:hover:before{left:100%}.bubble-designer-icon{font-size:28px;margin-right:16px;flex-shrink:0;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}.bubble-designer-info{flex:1;text-align:left}.bubble-designer-title{font-size:16px;font-weight:600;margin-bottom:4px;line-height:1.2}.bubble-designer-desc{font-size:13px;opacity:.9;line-height:1.3}.bubble-designer-arrow{font-size:20px;margin-left:12px;flex-shrink:0;opacity:.8}.coming-soon{display:flex;flex-direction:column;align-items:center;padding:40px 20px;color:#999}.coming-soon-icon{font-size:48px;margin-bottom:16px}.coming-soon-text{font-size:16px}html[data-keyboard-visible=true]{overflow:hidden}html[data-keyboard-visible=true] body{height:100vh;height:var(--viewport-height, 100vh)}html[data-keyboard-visible=true] .chat-input-area{transform:translateY(calc(-1 * var(--keyboard-height, 0px)));transition:transform .25s ease-out}html[data-keyboard-visible=true] .chat-messages{max-height:calc(var(--chat-content-height, 100vh) - var(--keyboard-height, 0px) - 60px);transition:max-height .25s ease-out}input,textarea,[contenteditable=true]{-webkit-user-select:text!important;-moz-user-select:text!important;-ms-user-select:text!important;user-select:text!important;-webkit-touch-callout:default!important}.chat-input:focus,input:focus,textarea:focus{outline:none;scroll-margin:20px}html{scroll-behavior:smooth;overscroll-behavior:contain}body{overscroll-behavior-y:contain;touch-action:pan-x pan-y}@supports (-webkit-touch-callout: none){.main-container{overscroll-behavior:none;-webkit-overflow-scrolling:touch}.chat-page{position:fixed;transform:translateZ(0)}}#qixiRetryModal .modal-content{background:linear-gradient(135deg,#ff9a9e,#fecfef,#fecfef);color:#8b5cf6;border-radius:20px;box-shadow:0 20px 40px #ff69b44d;animation:qixiModalShow .4s ease-out}#qixiRetryModal .modal-header{background:transparent;border-bottom:2px solid rgba(255,255,255,.3);padding:20px 24px 16px}#qixiRetryModal .modal-title{font-size:20px;font-weight:700;text-align:center;color:#8b5cf6;text-shadow:0 1px 2px rgba(255,255,255,.8)}#qixiRetryModal .modal-close{background:#ffffff4d;color:#8b5cf6;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:16px;font-weight:700;transition:all .3s ease}#qixiRetryModal .modal-close:hover{background:#ffffff80;transform:scale(1.1)}.qixi-retry-content{text-align:center;padding:20px 24px 24px}.qixi-retry-icon{font-size:48px;margin-bottom:16px;animation:qixiHeartbeat 1.5s ease-in-out infinite}.qixi-retry-message{color:#8b5cf6;line-height:1.6}.qixi-retry-message p{margin-bottom:12px;font-size:16px}.qixi-retry-message strong{color:#7c3aed;font-weight:600}.qixi-retry-buttons{display:flex;gap:12px;padding:0 24px 24px;flex-direction:column}.qixi-retry-btn{background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;border:none;border-radius:12px;padding:14px 20px;font-size:16px;font-weight:600;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 15px #8b5cf64d}.qixi-retry-btn:hover{transform:translateY(-2px);box-shadow:0 6px 20px #8b5cf666}.qixi-cancel-btn{background:#ffffffb3;color:#8b5cf6;border:2px solid rgba(139,92,246,.3);border-radius:12px;padding:12px 20px;font-size:14px;font-weight:500;cursor:pointer;transition:all .3s ease}.qixi-cancel-btn:hover{background:#ffffffe6;border-color:#8b5cf680}@keyframes qixiModalShow{0%{opacity:0;transform:translateY(20px) scale(.95)}to{opacity:1;transform:translateY(0) scale(1)}}@keyframes qixiHeartbeat{0%,to{transform:scale(1)}50%{transform:scale(1.1)}}@media (max-width: 480px){.qixi-retry-buttons{flex-direction:column;gap:8px}.qixi-retry-icon{font-size:40px}.qixi-retry-message p{font-size:15px}}.config-management-section{margin-bottom:24px;padding:16px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-color)}.config-selector-row{display:flex;align-items:end;gap:12px}.config-selector-group{flex:1}.config-actions{display:flex;gap:6px}.config-action-btn{width:36px;height:36px;border:1px solid var(--border-color);background:var(--bg-primary);color:var(--text-primary);border-radius:6px;cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;transition:all .2s ease}.config-action-btn:hover{background:var(--theme-primary-light);border-color:var(--theme-primary)}.config-delete-btn:hover{background:#ff4d4f1a;border-color:#ff4d4f;color:#ff4d4f}.config-section{margin-bottom:20px;padding:16px;border:1px solid var(--border-color);border-radius:8px;background:var(--bg-secondary)}.config-section-title{font-weight:600;font-size:16px;color:var(--text-primary);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border-color)}.form-actions{margin-top:20px;padding-top:16px;border-top:1px solid var(--border-color)}#configSelector{font-weight:500}#configSelector option[data-is-default=true]{font-weight:600;color:var(--theme-primary)}.key-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}.key-header .form-label{margin:0;flex:1}.compact-key-row{display:flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid #e1e5e9;border-radius:6px;background:#f8f9fa;margin-top:5px;position:relative}.main-key-row{background:#f8f9fa;border-color:#e1e5e9}.main-key-row.enabled{background:linear-gradient(135deg,#e8f5e8,#f0f8f0);border-color:#28a745}.additional-key-row{background:#f5f5f5}.compact-key-input{flex:1;min-width:120px;font-size:14px;padding:6px 8px;border:1px solid #ddd;border-radius:4px}.timeout-group{display:flex;align-items:center;gap:2px;white-space:nowrap}.timeout-input{width:40px;padding:4px;border:1px solid #ddd;border-radius:3px;font-size:12px;text-align:center}.timeout-unit{font-size:12px;color:#666;min-width:8px}.key-status-btn,.key-enable-btn{width:24px;height:24px;border:none;border-radius:50%;font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;background:#6c757d}.key-enable-btn:hover{opacity:.8}.main-key-status{background:transparent!important;cursor:default}.key-stats-compact{position:absolute;bottom:2px;right:8px;font-size:10px;color:#666;text-align:right;line-height:1.2}.key-masked-compact{font-family:monospace;font-size:9px;color:#777;margin-bottom:1px}.stats-compact{font-size:9px;color:#888}.remove-provider-btn{background:#dc3545;color:#fff;border:none;border-radius:50%;width:18px;height:18px;font-size:11px;cursor:pointer;margin-left:6px;padding:0;line-height:18px;display:inline-flex;align-items:center;justify-content:center;vertical-align:middle;box-sizing:border-box;flex-shrink:0;position:relative;z-index:10;pointer-events:auto}.remove-provider-btn:hover{background:#c82333}.remove-provider-btn:active{transform:scale(.95)}@media (max-width: 480px){.config-selector-row{flex-direction:column;align-items:stretch;gap:8px}.config-actions{justify-content:center;margin-top:8px}.config-section{margin-bottom:16px;padding:12px}.compact-key-row{flex-wrap:wrap;padding:6px 8px;gap:6px}.compact-key-input{min-width:100px;font-size:14px}.timeout-group{order:3}.key-status-btn,.key-enable-btn{order:2}.key-stats-compact{position:static;order:4;width:100%;text-align:left;margin-top:4px;font-size:11px}.timeout-input{width:35px}}#persistentStatusIndicator[data-status=persistent]{color:#28a745}#persistentStatusIndicator[data-status=not-persistent]{color:#ffc107}#persistentStatusIndicator[data-status=unknown],#persistentStatusIndicator[data-status=requesting]{color:#6c757d}#persistentStatusIndicator[data-status=error]{color:#dc3545}.info-modal.modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background-color:var(--overlay-bg);display:flex;align-items:center;justify-content:center;z-index:10000;padding:20px;transition:opacity .2s ease-in-out}.info-modal.modal-overlay.hidden{display:none}.info-modal .modal-content{background:var(--modal-bg);border-radius:8px;padding:0;max-width:400px;max-height:80vh;overflow:hidden;box-shadow:0 4px 12px var(--shadow-color);color:var(--text-primary);animation:infoModalSlideIn .2s ease-out}@keyframes infoModalSlideIn{0%{opacity:0;transform:translateY(-20px)}to{opacity:1;transform:translateY(0)}}.info-modal .modal-header{font-size:16px;font-weight:700;padding:20px 20px 15px;color:var(--text-primary);border-bottom:1px solid var(--border-color)}.info-modal .modal-body{padding:20px;font-size:14px;line-height:1.6;color:var(--text-secondary);max-height:50vh;overflow-y:auto}.info-modal .modal-body p{margin-bottom:10px}.info-modal .modal-body ul{margin:8px 0;padding-left:20px}.info-modal .modal-body li{margin-bottom:4px}.info-modal .modal-footer{padding:15px 20px;border-top:1px solid var(--border-color);display:flex;justify-content:flex-end}.info-modal .modal-close-btn{flex:1;padding:10px;background:var(--theme-secondary);color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:14px;transition:background-color .2s ease}.info-modal .modal-close-btn:hover{background:var(--theme-secondary-hover)}.info-modal .modal-close-btn:active{background:var(--theme-secondary-active)}.info-button{width:18px;height:18px;border-radius:50%;background:var(--theme-primary);color:#fff;border:none;cursor:pointer;font-size:10px;display:flex;align-items:center;justify-content:center;font-weight:700;transition:background-color .2s ease}.info-button:hover{background:var(--theme-primary-hover)}.info-button:active{background:var(--theme-primary);transform:scale(.95)}.request-persistent-btn{padding:5px 10px;font-size:12px;background:#17a2b8;color:#fff;border:none;border-radius:4px;cursor:pointer;transition:background-color .2s ease}.request-persistent-btn:hover{background:#138496}.request-persistent-btn:disabled{background:#6c757d;cursor:not-allowed}.request-persistent-btn:active{background:#117a8b}@media (max-width: 480px){.info-modal .modal-content{max-width:90vw;margin:0 auto}.info-modal .modal-header{font-size:15px;padding:15px}.info-modal .modal-body{padding:15px;font-size:13px}.info-modal .modal-footer{padding:15px}.chat-input-area{padding:6px 8px 8px;gap:4px}.input-actions{gap:2px}.action-btn{width:26px;height:26px;font-size:18px}.chat-input{padding:6px 10px;font-size:16px}.send-btn{padding:6px 10px;font-size:13px}}@media (max-width: 360px){.chat-input-area{padding:4px 6px 6px;gap:3px}.input-actions{gap:1px}.action-btn{width:24px;height:24px;font-size:16px}.send-btn{padding:4px 8px;font-size:12px}.chat-input{padding:4px 8px}}.form-step-hint{display:none;margin-top:10px;padding:8px 12px;background-color:#e8f5e8;border-radius:4px;font-size:12px;color:#2d5a2d;border-left:3px solid #28a745;animation:slideInDown .3s ease-out}.form-step-reminder{padding:10px 15px;background-color:#fff3cd;border-left:4px solid #ffc107;border-radius:4px;font-size:13px;color:#856404;margin-bottom:15px;animation:fadeIn .5s ease-out}.form-submit small{opacity:.8;font-weight:400;font-size:11px}@keyframes slideInDown{0%{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.form-step-reminder strong{color:#d4470b;font-weight:600}.form-step-hint:before{content:"";display:inline-block;width:4px;height:4px;background-color:#28a745;border-radius:50%;margin-right:6px;animation:pulse 1.5s infinite}@keyframes pulse{0%{opacity:1}50%{opacity:.5}to{opacity:1}}.dark-mode .form-step-hint{background-color:#1a2f1a;color:#8bc48b;border-left-color:#28a745}.dark-mode .form-step-reminder{background-color:#2a2516;color:#d4c669;border-left-color:#ffc107}.dark-mode .form-step-reminder strong{color:#f8a15b}.final-step-hint{margin:15px 0 10px;padding:8px 12px;background-color:#f0f8ff;border-left:3px solid #0066cc;border-radius:4px;font-size:13px;color:#06c;animation:fadeIn .5s ease-out}.dark-mode .final-step-hint{background-color:#1a2a3a;color:#66b3ff;border-left-color:#09f}@keyframes slideInDown{0%{opacity:0;transform:translate(-50%) translateY(-20px)}to{opacity:1;transform:translate(-50%) translateY(0)}}@keyframes slideOutUp{0%{opacity:1;transform:translate(-50%) translateY(0)}to{opacity:0;transform:translate(-50%) translateY(-20px)}}.image-container{position:relative;display:inline-block}.vision-support-indicator{position:absolute;top:4px;right:4px;width:20px;height:20px;background:var(--theme-primary);color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700;box-shadow:0 2px 4px #0003;border:2px solid white;z-index:10;animation:fadeIn .3s ease-in-out}.gradient-mode .vision-support-indicator{background:var(--theme-gradient)}.dark-mode .vision-support-indicator{border-color:var(--bg-primary);box-shadow:0 2px 4px #0006}</style>
</head>
<body>
    <!-- 页面主体内容保持不变 -->
    <div class="main-container">
        <div class="contact-list-page active" id="contactListPage">
            <div class="wechat-header">
                <div class="header-title">Whale-LLT</div>
                <div class="header-actions">
                    <span class="header-icon" id="apiSettingsIcon">⚙️</span>
                    <span class="header-icon" id="musicIcon" onclick="showMusicModal()" data-umami-event="Music Open">🎵</span>
                    <span class="header-icon" onclick="showAddContactModal()" data-umami-event="Add Contact Open">➕</span>
                    <span class="header-icon" onclick="showCreateGroupModal()" data-umami-event="Create Group Open">👥</span>
                </div>
            </div>
            
            <div class="search-bar">
                <input type="text" class="search-input" placeholder="搜索">
            </div>
            
            <div id="contactList"></div>
        </div>

        <div class="chat-page" id="chatPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>‹</span>
                    <span>Whale-LLT</span>
                </div>
                <div class="chat-title" id="chatTitle">聊天</div>
                <div class="chat-header-actions">
                    <div class="memory-btn" onclick="event.stopPropagation(); toggleMemoryPanel()">
                        <svg t="1689237694389" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4338" width="24" height="24"><path d="M896 96H128C110.4 96 96 110.4 96 128v768c0 17.6 14.4 32 32 32h768c17.6 0 32-14.4 32-32V128c0-17.6-14.4-32-32-32zM384 832H192v-64h192v64z m0-192H192v-64h192v64z m0-192H192v-64h192v64z m448 384H448v-64h384v64z m0-192H448v-64h384v64z m0-192H448v-64h384v64z" p-id="4339" fill="#515151"></path></svg>
                    </div>
                    <div class="chat-more" onclick="openContactSettingsPage()">⋯</div>
                </div>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="messages-scroll-content"></div>
            </div>
            
            <div class="chat-input-area">
                <div class="feature-hint" id="featureHint">按Enter发送消息，点"发送"按钮获取AI回复</div>
                <div class="input-actions">
                    <div class="action-btn" onclick="toggleEmojiPanel()" data-umami-event="Emoji Panel Toggle">😊</div>
                    <div class="action-btn" onclick="showRedPacketModal()" data-umami-event="Red Packet Open">🧧</div>
                    <div class="action-btn" onclick="triggerImageUpload()" data-umami-event="Image Upload Open">🏞️</div>
                </div>
                
                <!-- 隐藏的文件输入框 -->
                <input type="file" id="chatImageInput" accept="image/*" style="display: none;" onchange="handleChatImageUpload(event)">
                <textarea class="chat-input" id="chatInput" placeholder="输入消息" rows="1"></textarea>
                <button class="send-btn" id="sendBtn" onclick="sendMessage()" data-umami-event="Message Send">发送</button>
                
                <div class="emoji-panel" id="emojiPanel">
                    <div class="emoji-grid" id="emojiGrid">
                        <div class="add-emoji-btn" onclick="showAddEmojiModal()">+ 添加表情</div>
                    </div>
                </div>
            </div>

            <div class="memory-panel" id="memoryPanel">
                <div class="memory-panel-header">
                    <div class="memory-panel-title">记忆表格</div>
                    <div class="memory-panel-actions">
                         <button id="memoryEditBtn" class="memory-panel-btn" onclick="toggleMemoryEditMode()" data-umami-event="Memory Table Edit Toggle">编辑</button>
                         <button class="memory-panel-btn" onclick="event.stopPropagation(); toggleMemoryPanel()">关闭</button>
                    </div>
                </div>
                <div class="memory-panel-content">
                    <div id="memoryTableView" class="memory-table-view"></div>
                    <textarea id="memoryTextarea" class="memory-textarea" style="display: none;"></textarea>
                </div>
            </div>
        </div>

        <div class="moments-page" id="momentsPage">
            <div class="moments-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="chat-title">朋友圈</div>
                <div class="chat-more" onclick="showPublishMomentModal()">➕</div>
            </div>
            
            <div class="moments-content" id="momentsContent">
                <div class="moments-empty" id="momentsEmpty">
                    <div class="moments-empty-icon">📝</div>
                    <div class="moments-empty-text">还没有朋友圈动态</div>
                    <button class="moments-empty-btn" onclick="showPublishMomentModal()">发布第一条动态</button>
                </div>
                
                <div class="moments-list" id="momentsList" style="display: none;"></div>
            </div>
        </div>

        <div class="interactive-page" id="interactivePage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>‹</span>
                    <span>互动界面</span>
                </div>
                <div class="header-actions">
                    <div class="sync-btn" onclick="syncInteractiveData()" title="同步角色数据">🔄</div>
                </div>
            </div>
            <div class="interactive-content">
                <iframe id="interactiveFrame" srcdoc="<!DOCTYPE html>
<html lang=&quot;zh-CN&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;>
    <title>互动页面</title>
    <script src=&quot;https://cdn.tailwindcss.com&quot;></script>
    <script src=&quot;https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js&quot;></script>
    
    <!-- Environment Configuration -->
    <script>
/**
 * 环境配置系统 - 支持构建时环境变量注入
 * 支持 Vercel 和 Netlify 部署平台
 */
class EnvironmentConfig {
    /**
     * 环境指示器关键词配置
     * 当环境标签包含这些关键词时，将显示环境指示器
     */
    static INDICATOR_KEYWORDS = ['测试', '开发', 'test', 'dev'];

    /**
     * 构建时环境变量占位符
     * 这些将在构建过程中被实际值替换
     */
    static BUILD_TIME_CONFIG = {
        // 环境类型: development, staging, production
        ENVIRONMENT: 'production',
        // 应用版本
        APP_VERSION: '1.0.0',
        // 构建时间戳
        BUILD_TIMESTAMP: '2025-09-15T15:34:10.370Z',
        // Git 提交哈希
        GIT_COMMIT: '4e267410f8c8f2ca802f712b0c44b36b73ab3f07',
        // 是否为开发版本
        IS_DEVELOPMENT: 'false',
        // 自定义标签
        ENVIRONMENT_LABEL: ''
    };

    /**
     * 获取当前环境配置
     */
    static getEnvironment() {
        // 优先使用构建时注入的环境变量
        let environment = this.BUILD_TIME_CONFIG.ENVIRONMENT;
        let isDevelopment = this.BUILD_TIME_CONFIG.IS_DEVELOPMENT;
        let environmentLabel = this.BUILD_TIME_CONFIG.ENVIRONMENT_LABEL;

        // 如果没有被替换（仍然包含花括号），则回退到运行时检测
        if (environment.includes('{{')) {
            environment = this.detectEnvironmentFromURL();
            isDevelopment = environment !== 'production';
            environmentLabel = this.getDefaultEnvironmentLabel(environment);
        } else {
            // 处理字符串形式的布尔值
            isDevelopment = isDevelopment === 'true' || isDevelopment === true;
        }

        return {
            environment,
            isDevelopment,
            environmentLabel,
            version: this.getVersion(),
            buildTime: this.getBuildTime(),
            gitCommit: this.getGitCommit()
        };
    }

    /**
     * 通过URL检测环境（回退方案）
     */
    static detectEnvironmentFromURL() {
        if (typeof window === 'undefined') return 'production';

        const hostname = window.location.hostname;

        // 本地开发环境
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('192.168.')) {
            return 'development';
        }

        // Vercel Preview 部署
        if (hostname.includes('-git-') || hostname.includes('.vercel.app')) {
            // 检查是否是 dev 分支或包含 dev 相关标识
            if (hostname.includes('-dev-') || hostname.includes('-develop-') || 
                hostname.includes('-test-') || hostname.includes('-staging-')) {
                return 'staging';
            }
            // Vercel 的主分支部署通常是生产环境
            return hostname.includes('main') ? 'production' : 'staging';
        }

        // Netlify 部署
        if (hostname.includes('.netlify.app')) {
            // 检查域名中是否包含开发相关关键词
            if (hostname.includes('dev') || hostname.includes('test') || 
                hostname.includes('staging') || hostname.includes('preview')) {
                return 'staging';
            }
            
            // Netlify 的 branch 部署检测（格式：branch--sitename.netlify.app）
            if (hostname.includes('--')) {
                const parts = hostname.split('--');
                const branchName = parts[0];
                if (branchName &amp;&amp; (branchName.includes('dev') || branchName.includes('test'))) {
                    return 'staging';
                }
            }
            
            // 默认为生产环境
            return 'production';
        }

        // 自定义域名默认为生产环境
        return 'production';
    }

    /**
     * 获取默认环境标签
     */
    static getDefaultEnvironmentLabel(environment) {
        switch (environment) {
            case 'development':
                return '开发环境';
            case 'staging':
                return '测试环境';
            case 'production':
            default:
                return null; // 生产环境不显示标签
        }
    }

    /**
     * 获取应用版本
     */
    static getVersion() {
        // 优先使用 git commit hash 的前7位作为版本显示
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        if (gitCommit !== 'unknown' &amp;&amp; gitCommit.length >= 7) {
            return gitCommit.substring(0, 7);
        }
        
        // 如果没有有效的 git commit hash，回退到应用版本号
        let version = this.BUILD_TIME_CONFIG.APP_VERSION;
        return version.includes('{{') ? 'dev' : version;
    }

    /**
     * 获取构建时间
     */
    static getBuildTime() {
        let buildTime = this.BUILD_TIME_CONFIG.BUILD_TIMESTAMP;
        return buildTime.includes('{{') ? new Date().toISOString() : buildTime;
    }

    /**
     * 获取 Git 提交哈希
     */
    static getGitCommit() {
        let gitCommit = this.BUILD_TIME_CONFIG.GIT_COMMIT;
        return gitCommit.includes('{{') ? 'unknown' : gitCommit;
    }

    /**
     * 检查是否应该显示环境指示器
     * 在以下情况下显示：
     * 1. 非生产环境
     * 2. 环境标签包含&quot;测试&quot;或&quot;开发&quot;关键词
     */
    static shouldShowEnvironmentIndicator() {
        const config = this.getEnvironment();
        
        // 非生产环境始终显示
        if (config.environment !== 'production') {
            return true;
        }
        
        // 检查环境标签是否包含指示器关键词
        if (config.environmentLabel) {
            const label = config.environmentLabel.toLowerCase();
            return this.INDICATOR_KEYWORDS.some(keyword => label.includes(keyword));
        }
        
        return false;
    }

    /**
     * 获取环境指示器配置
     * 根据shouldShowEnvironmentIndicator的逻辑决定是否返回配置
     */
    static getEnvironmentIndicatorConfig() {
        const config = this.getEnvironment();
        
        // 使用shouldShowEnvironmentIndicator方法统一判断逻辑
        if (!this.shouldShowEnvironmentIndicator()) {
            return null;
        }

        // 返回环境指示器配置
        return {
            text: config.environmentLabel ? `${config.environmentLabel} - 开发中内容，不代表最终成果` : '开发中内容，不代表最终成果',
            version: config.version,
            environment: config.environment
        };
    }

    /**
     * 打印环境信息到控制台
     */
    static printEnvironmentInfo() {
        const config = this.getEnvironment();
        console.group('🌍 Environment Info');
        console.log('Environment:', config.environment);
        console.log('Development Mode:', config.isDevelopment);
        console.log('Version:', config.version);
        console.log('Build Time:', config.buildTime);
        console.log('Git Commit:', config.gitCommit);
        if (config.environmentLabel) {
            console.log('Label:', config.environmentLabel);
        }
        console.groupEnd();
    }
}

// 导出配置
if (typeof module !== 'undefined' &amp;&amp; module.exports) {
    module.exports = EnvironmentConfig;
} else {
    window.EnvironmentConfig = EnvironmentConfig;
}

</script>
    <script>
/**
 * 环境指示器组件
 * 在非生产环境下显示环境提示信息
 */
class EnvironmentIndicator {
    constructor() {
        this.indicator = null;
        this.isVisible = false;
    }

    /**
     * 初始化环境指示器
     */
    init() {
        // 确保 EnvironmentConfig 已加载
        if (typeof EnvironmentConfig === 'undefined') {
            console.warn('EnvironmentConfig not loaded, environment indicator disabled');
            return;
        }

        // 调试：打印当前环境信息
        console.log('🌍 Environment Indicator Initializing...');
        const envInfo = EnvironmentConfig.getEnvironment();
        console.log('Environment Info:', envInfo);

        const config = EnvironmentConfig.getEnvironmentIndicatorConfig();
        console.log('Indicator Config:', config);
        
        if (config) {
            this.createIndicator(config);
            this.show();
            console.log('✅ Environment indicator created and shown');
            
            // 打印环境信息到控制台
            EnvironmentConfig.printEnvironmentInfo();
        } else {
            console.log('❌ Environment indicator not shown (production or disabled)');
        }
    }

    /**
     * 创建指示器DOM元素
     */
    createIndicator(config) {
        // 避免重复创建
        if (this.indicator) {
            this.indicator.remove();
        }

        const indicator = document.createElement('div');
        indicator.className = 'environment-indicator';
        indicator.innerHTML = `
            <div class=&quot;environment-indicator-content&quot;>
                <span class=&quot;environment-text&quot;>${config.text}</span>
                <span class=&quot;environment-version&quot;>${config.version}</span>
            </div>
        `;

        // 设置样式
        this.setIndicatorStyles(indicator, config);
        
        this.indicator = indicator;
        document.body.appendChild(indicator);
    }

    /**
     * 设置指示器样式
     */
    setIndicatorStyles(element, config) {
        // 使用 setProperty 方法应用关键样式以确保优先级
        element.style.setProperty('position', 'fixed', 'important');
        element.style.setProperty('bottom', '52px', 'important');
        element.style.setProperty('left', '50%', 'important');
        element.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
        element.style.setProperty('backgroundColor', 'transparent', 'important');
        element.style.setProperty('color', '#ff6600', 'important');
        element.style.setProperty('z-index', '999999', 'important');
        element.style.setProperty('pointer-events', 'none', 'important');
        
        // 应用其他样式
        const additionalStyles = {
            padding: '4px 0',
            borderRadius: '0',
            fontSize: '11px',
            fontWeight: '500',
            fontFamily: '-apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, sans-serif',
            boxShadow: 'none',
            userSelect: 'none',
            opacity: '0.8',
            maxWidth: '300px',
            lineHeight: '1.1',
            textAlign: 'center',
            transition: 'opacity 0.3s ease-in-out',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
        };

        Object.assign(element.style, additionalStyles);

        // 为内容容器设置样式
        const content = element.querySelector('.environment-indicator-content');
        if (content) {
            Object.assign(content.style, {
                display: 'inline', // 改为内联显示
                gap: '0'
            });
        }

        // 为版本号设置样式
        const version = element.querySelector('.environment-version');
        if (version) {
            Object.assign(version.style, {
                fontSize: '10px',
                opacity: '0.7',
                fontWeight: 'normal',
                marginLeft: '4px'
            });
        }
    }

    /**
     * 显示指示器
     */
    show() {
        if (this.indicator &amp;&amp; !this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(0)', 'important');
            this.indicator.style.setProperty('opacity', '0.8', 'important');
            this.isVisible = true;
        }
    }

    /**
     * 隐藏指示器
     */
    hide() {
        if (this.indicator &amp;&amp; this.isVisible) {
            this.indicator.style.setProperty('transform', 'translateX(-50%) translateY(100%)', 'important');
            this.indicator.style.setProperty('opacity', '0', 'important');
            this.isVisible = false;
            
            // 延迟移除元素
            setTimeout(() => {
                if (this.indicator &amp;&amp; this.indicator.parentNode) {
                    this.indicator.parentNode.removeChild(this.indicator);
                }
                this.indicator = null;
            }, 300);
        }
    }

    /**
     * 切换显示状态
     */
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.init();
        }
    }

    /**
     * 销毁指示器
     */
    destroy() {
        this.hide();
    }
}

/**
 * 全局环境指示器实例
 */
window.environmentIndicator = new EnvironmentIndicator();

/**
 * DOM加载完成后自动初始化
 */
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.environmentIndicator.init();
    });
} else {
    // 如果DOM已经加载完成
    window.environmentIndicator.init();
}

/**
 * 开发调试功能
 * 在控制台中可以使用以下命令：
 * - environmentIndicator.toggle() - 切换显示
 * - environmentIndicator.hide() - 隐藏指示器  
 * - environmentIndicator.show() - 显示指示器
 * - EnvironmentConfig.printEnvironmentInfo() - 打印环境信息
 */
if (typeof EnvironmentConfig !== 'undefined') {
    const config = EnvironmentConfig.getEnvironment();
    if (config.isDevelopment) {
        console.log('🔧 Environment Indicator Debug Commands:');
        console.log('  environmentIndicator.toggle() - Toggle indicator');
        console.log('  environmentIndicator.hide() - Hide indicator');
        console.log('  environmentIndicator.show() - Show indicator');
        console.log('  EnvironmentConfig.printEnvironmentInfo() - Print env info');
    }
}
</script>
    
    <!-- 🔥 统一数据库管理器 - 替代所有数据库相关模块 -->
    <script>
/**
 * 🔥 统一数据库管理器 - 终极简化版
 * 
 * 设计目标：
 * 1. 单一责任：所有数据库操作的唯一入口
 * 2. 状态同步：自动处理跨页面状态同步
 * 3. 简单可靠：单一初始化方法，自动错误恢复
 * 4. 功能完整：整合所有现有数据库功能
 * 5. 向后兼容：保持现有API接口不变
 * 
 * ⚠️ ARCHITECTURAL DEBT WARNING:
 * This file currently mixes database operations with UI concerns (DOM manipulation,
 * alerts, confirm dialogs, toast notifications). This violates separation of concerns
 * and harms maintainability and testability.
 * 
 * TODO - Future Refactoring Plan:
 * 1. Create DatabaseUIManager class for all UI interactions
 * 2. Keep UnifiedDBManager focused only on pure database operations
 * 3. Move StorageManager, DatabaseManager UI functions to separate UI layer
 * 4. Use event system or callbacks for UI notifications instead of direct coupling
 * 5. Make functions pure and testable by removing side effects
 */

class UnifiedDBManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.version = 14; // 版本升级到14，支持图片分类功能
        this.db = null;
        this.isReady = false;
        this.initPromise = null;
        this.urlCache = new Map(); // 文件URL缓存
        
        // 定义不参与手动导入导出的存储（图片等大数据） - 与原始dataMigrator.js完全一致
        this.excludedFromManualExport = ['emojiImages', 'fileStorage', 'imageUsageMetadata'];
        
        // 文件类型映射
        this.mimeTypes = {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg', 
            'png': 'image/png',
            'gif': 'image/gif',
            'webp': 'image/webp',
            'bmp': 'image/bmp',
            'svg': 'image/svg+xml'
        };

        // 图片使用类型枚举
        this.imageUsageTypes = {
            PERMANENT: 'permanent',     // 持续使用的表情包
            TEMPORARY: 'temporary',     // 临时性图片（朋友圈等）
            RECENT: 'recent',          // 最近使用
            ARCHIVE: 'archive'         // 归档（不常用）
        };

        // 定义完整的数据库模式 - 与原始dataMigrator.js完全一致
        this.stores = {
            songs: { keyPath: 'id', autoIncrement: true },
            contacts: { keyPath: 'id' },
            apiSettings: { keyPath: 'id' },
            emojis: { keyPath: 'id' },
            emojiImages: { keyPath: 'tag' }, // 存储表情图片的base64数据（将逐步迁移到fileStorage）
            backgrounds: { keyPath: 'id' },
            userProfile: { keyPath: 'id' },
            moments: { keyPath: 'id' },
            weiboPosts: { keyPath: 'id', autoIncrement: true },
            hashtagCache: { keyPath: 'id' },
            characterMemories: { keyPath: 'contactId' },
            conversationCounters: { keyPath: 'id' },
            globalMemory: { keyPath: 'id' },
            memoryProcessedIndex: { keyPath: 'contactId' },
            fileStorage: { keyPath: 'fileId' }, // 新增：存储原始文件Blob数据
            fileReferences: { keyPath: 'referenceId' }, // 新增：存储文件引用关系
            themeConfig: { keyPath: 'type' }, // 新增：存储主题配置（颜色、渐变等）
            imageUsageMetadata: { keyPath: 'fileId' } // 新增：图片使用元数据表
        };
        
        console.log('🔥 [UnifiedDB] 统一数据库管理器已创建');
    }

    /**
     * 初始化数据库 - 唯一入口方法
     */
    async init() {
        // 如果已经初始化过，直接返回
        if (this.isReady &amp;&amp; this.db) {
            console.log('🔥 [UnifiedDB] 数据库已初始化，直接返回');
            this.syncToGlobal();
            return this.db;
        }

        // 如果正在初始化，等待现有初始化完成
        if (this.initPromise) {
            console.log('🔥 [UnifiedDB] 正在初始化中，等待完成...');
            return await this.initPromise;
        }

        // 开始新的初始化流程
        console.log('🔥 [UnifiedDB] 开始数据库初始化...');
        this.initPromise = this._performInit();
        
        try {
            const result = await this.initPromise;
            this.initPromise = null;
            return result;
        } catch (error) {
            this.initPromise = null;
            throw error;
        }
    }

    /**
     * 执行实际的初始化工作
     */
    async _performInit() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => {
                const error = new Error(`数据库打开失败: ${request.error?.message}`);
                console.error('🔥 [UnifiedDB]', error);
                reject(error);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                this.isReady = true;
                
                console.log(`🔥 [UnifiedDB] 初始化成功，版本: ${this.db.version}`);
                console.log(`🔥 [UnifiedDB] 可用存储:`, Array.from(this.db.objectStoreNames));
                
                // 同步到全局状态
                this.syncToGlobal();
                
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                console.log('🔥 [UnifiedDB] 数据库需要升级...');
                const db = event.target.result;
                this._createStores(db, event.oldVersion);
            };
        });
    }

    /**
     * 创建所有必要的对象存储 - 完全遵循原始dataMigrator.js逻辑
     */
    _createStores(db, oldVersion) {
        console.log(`🔥 [UnifiedDB] 数据库升级: 版本${oldVersion} -> 版本${this.version}`);
        
        try {
            // 处理废弃存储的删除 - 与原始逻辑完全一致
            if (this.version >= 12) {
                // 版本12及以上移除了bubbleDesignerStickers
                if (db.objectStoreNames.contains('bubbleDesignerStickers')) {
                    db.deleteObjectStore('bubbleDesignerStickers');
                    console.log('🔥 [UnifiedDB] 删除废弃的 bubbleDesignerStickers 存储');
                }
            }
            
            // 创建所有对象存储（如果不存在）
            Object.entries(this.stores).forEach(([storeName, config]) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    try {
                        const store = db.createObjectStore(storeName, config);
                        console.log(`🔥 [UnifiedDB] 创建 ${storeName} 存储成功`);
                        
                        // 为特定存储添加索引
                        if (storeName === 'fileReferences') {
                            // 为文件引用表添加category索引，方便按类型查询
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('fileId', 'fileId', { unique: false });
                            console.log('🔥 [UnifiedDB] 为 fileReferences 添加索引');
                        }
                        
                        if (storeName === 'imageUsageMetadata') {
                            // 为图片使用元数据表添加简化的索引
                            store.createIndex('usageType', 'usageType', { unique: false });
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('createdAt', 'createdAt', { unique: false });
                            console.log('🔥 [UnifiedDB] 为 imageUsageMetadata 添加索引');
                        }
                        
                    } catch (storeError) {
                        console.error(`🔥 [UnifiedDB] 创建存储 ${storeName} 失败:`, storeError);
                        throw storeError;
                    }
                }
            });
            
            console.log('🔥 [UnifiedDB] 数据库结构升级完成');
            
        } catch (upgradeError) {
            console.error('🔥 [UnifiedDB] 数据库升级过程中出错:', upgradeError);
            throw upgradeError;
        }
    }

    /**
     * 同步状态到全局对象 - 简化的跨页面通信
     */
    syncToGlobal() {
        if (typeof window !== 'undefined') {
            // 设置全局数据库状态
            window.db = this.db;
            window.isIndexedDBReady = this.isReady;
            // 移除混乱的实例赋值 - 统一使用 window.unifiedDB 作为实例引用
            
            // 🔥 简化的跨页面通知：只使用localStorage事件
            try {
                // 写入状态信息
                const dbStatus = {
                    isReady: true,
                    version: this.db.version,
                    timestamp: Date.now(),
                    page: window.location.pathname
                };
                localStorage.setItem('dbStatus', JSON.stringify(dbStatus));
                
                // 触发跨页面事件
                localStorage.setItem('dbSyncTrigger', Date.now().toString());
                localStorage.removeItem('dbSyncTrigger');
                
                console.log('🔥 [UnifiedDB] 已同步状态到全局并触发跨页面事件');
            } catch (e) {
                console.warn('🔥 [UnifiedDB] localStorage 同步失败:', e);
            }
        }
    }

    /**
     * 等待数据库就绪
     */
    static async waitForReady(timeout = 8000) {
        console.log('🔥 [UnifiedDB] 开始等待数据库就绪...');
        
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            let resolved = false;
            let timeoutId = null;

            // 监听localStorage事件
            const storageListener = (event) => {
                if (event.key === 'dbSyncTrigger' &amp;&amp; !resolved) {
                    console.log('🔥 [UnifiedDB] 收到跨页面同步事件');
                    setTimeout(checkReady, 50);
                }
            };

            // 清理函数 - 确保在所有退出路径中都调用
            const cleanup = () => {
                window.removeEventListener('storage', storageListener);
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
            };

            // 成功解析函数
            const resolveWithCleanup = (result) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    resolve(result);
                }
            };

            // 失败拒绝函数
            const rejectWithCleanup = (error) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    reject(error);
                }
            };

            const checkReady = () => {
                if (resolved) return;

                // 检查全局状态
                if (window.isIndexedDBReady &amp;&amp; window.db &amp;&amp; window.db.version >= 14) {
                    console.log('🔥 [UnifiedDB] 检测到数据库已就绪');
                    resolveWithCleanup(window.db);
                    return;
                }

                // 检查localStorage状态  
                try {
                    const dbStatus = JSON.parse(localStorage.getItem('dbStatus') || '{}');
                    if (dbStatus.isReady &amp;&amp; dbStatus.version >= 14) {
                        console.log('🔥 [UnifiedDB] 从localStorage检测到数据库状态，尝试建立连接...');
                        
                        // 尝试为当前页面建立数据库连接
                        if (window.unifiedDB) {
                            window.unifiedDB.init().then(db => {
                                resolveWithCleanup(db);
                            }).catch(err => {
                                console.warn('🔥 [UnifiedDB] 连接建立失败:', err);
                                rejectWithCleanup(err);
                            });
                        }
                        // 移除了不可达的 getInstance 逻辑 - window.unifiedDB 检查已经处理了所有情况
                    }
                } catch (e) {
                    console.warn('🔥 [UnifiedDB] localStorage读取失败:', e);
                }

                // 超时检查
                if (Date.now() - startTime > timeout) {
                    rejectWithCleanup(new Error(`等待数据库就绪超时 (${timeout}ms)`));
                    return;
                }

                // 继续检查
                setTimeout(checkReady, 100);
            };

            // 注册事件监听器
            window.addEventListener('storage', storageListener);
            
            // 设置超时
            timeoutId = setTimeout(() => {
                rejectWithCleanup(new Error(`等待数据库就绪超时 (${timeout}ms)`));
            }, timeout);

            // 立即检查一次
            checkReady();
        });
    }

    /**
     * 获取全局实例 - 正确的单例模式实现
     */
    static getInstance() {
        if (!window.unifiedDB) {
            window.unifiedDB = new UnifiedDBManager();
        }
        return window.unifiedDB;
    }

    /**
     * 检查数据库是否就绪
     */
    static isReady() {
        return window.isIndexedDBReady &amp;&amp; window.db &amp;&amp; window.db.version >= 14;
    }

    // ============================================
    // 数据库操作方法 - 统一API
    // ============================================

    /**
     * 通用数据库操作封装
     */
    async _dbOperation(storeName, mode, operation, description) {
        if (!this.db) {
            await this.init();
        }

        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], mode);
                const store = transaction.objectStore(storeName);

                transaction.onerror = (event) => {
                    console.error(`🔥 [UnifiedDB] Transaction failed for ${description}:`, event.target.error);
                    reject(event.target.error);
                };

                const result = operation(store);

                if (mode === 'readwrite') {
                    // For write operations, the transaction's completion is the source of truth.
                    let operationResult;
                    const resultPromise = Promise.resolve(result);
                    
                    resultPromise.then(res => {
                        operationResult = res;
                    }).catch(reject); // Propagate errors from the inner promise.

                    transaction.oncomplete = () => {
                        resolve(operationResult);
                    };
                } else { // readonly
                    if (result &amp;&amp; typeof result.then === 'function') {
                        result.then(resolve).catch(reject);
                    } else if (result &amp;&amp; result.onsuccess !== undefined) {
                        result.onsuccess = () => resolve(result.result);
                        result.onerror = (event) => reject(event.target.error);
                    } else {
                        resolve(result);
                    }
                }
            } catch (error) {
                console.error(`🔥 [UnifiedDB] ${description || '数据库操作'}失败:`, error);
                reject(error);
            }
        });
    }

    /**
     * 获取数据
     */
    async get(storeName, key) {
        return this._dbOperation(storeName, 'readonly', store => store.get(key), `获取数据 ${storeName}:${key}`);
    }

    /**
     * 获取所有数据
     */
    async getAll(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.getAll(), `获取所有数据 ${storeName}`);
    }

    /**
     * 保存数据
     */
    async put(storeName, data) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.put(data);
            // Return a promise that resolves when the put operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `保存数据到 ${storeName}`);
    }

    /**
     * 删除数据
     */
    async delete(storeName, key) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.delete(key);
            // Return a promise that resolves when the delete operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `删除数据 ${storeName}:${key}`);
    }

    /**
     * 计数数据
     */
    async count(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.count(), `计数 ${storeName}`);
    }

    /**
     * 导出整个数据库 - 完全遵循原始dataMigrator.js格式
     */
    async exportDatabase(options = {}) {
        try {
            if (!this.db) {
                await this.init();
            }

            const { stores = null, includeMetadata = true } = options;
            const exportData = {};
            
            // 添加元数据
            if (includeMetadata) {
                exportData._metadata = await this.getDatabaseInfo();
            }

            // 确定要导出的存储
            const storesToExport = stores || Array.from(this.db.objectStoreNames);
            
            // 导出每个对象存储的数据
            for (const storeName of storesToExport) {
                if (this.db.objectStoreNames.contains(storeName)) {
                    exportData[storeName] = await this.exportStore(storeName);
                }
            }

            return exportData;
            
        } catch (error) {
            console.error('🔥 [UnifiedDB] 数据库导出失败:', error);
            throw new Error(`导出失败: ${error.message}`);
        }
    }

    /**
     * 导出单个对象存储
     */
    async exportStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                let result = request.result;
                
                // 为保护用户隐私，在导出时移除API密钥
                if (storeName === 'apiSettings') {
                    result = result.map(item => {
                        const sanitized = { ...item };
                        // 清理敏感信息
                        if (sanitized.apiKey) delete sanitized.apiKey;
                        if (sanitized.password) delete sanitized.password;
                        return sanitized;
                    });
                }
                
                resolve(result);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 获取数据库版本信息
     */
    async getDatabaseInfo() {
        if (!this.db) {
            await this.init();
        }
        
        return {
            name: this.db.name,
            version: this.db.version,  // 这里使用实际数据库版本，不是目标版本
            stores: Array.from(this.db.objectStoreNames),
            exportTime: new Date().toISOString()
        };
    }

    /**
     * 导入数据库数据 - 完全遵循原始dataMigrator.js逻辑
     */
    async importDatabase(importData, options = {}) {
        try {
            const { 
                overwrite = false, 
                validateVersion = true,
                stores = null,
                enableMigration = true
            } = options;

            if (!this.db) {
                await this.init();
            }

            // 验证数据格式
            if (!importData || typeof importData !== 'object') {
                throw new Error('导入数据格式无效');
            }

            // 版本检查和迁移处理
            let migratedData = importData;
            if (importData._metadata &amp;&amp; importData._metadata.version !== this.version) {
                if (enableMigration &amp;&amp; importData._metadata.version < this.version) {
                    console.log(`🔥 [UnifiedDB] 检测到版本 ${importData._metadata.version}，开始迁移到版本 ${this.version}`);
                    migratedData = await this.migrateData(importData);
                } else if (validateVersion) {
                    throw new Error(`数据库版本不匹配。当前版本: ${this.version}, 导入版本: ${importData._metadata.version}`);
                }
            }

            // 确定要导入的存储
            const storesToImport = stores || Object.keys(migratedData).filter(key => key !== '_metadata');
            
            // 清空现有数据（如果选择覆盖）
            if (overwrite) {
                for (const storeName of storesToImport) {
                    if (this.db.objectStoreNames.contains(storeName)) {
                        await this.clearStore(storeName);
                    }
                }
            }

            // 导入数据
            const importResults = {};
            for (const storeName of storesToImport) {
                if (this.db.objectStoreNames.contains(storeName) &amp;&amp; migratedData[storeName]) {
                    const result = await this.importStore(storeName, migratedData[storeName], overwrite);
                    importResults[storeName] = result;
                }
            }

            return { success: true, importedStores: storesToImport, results: importResults, migrated: migratedData !== importData };
            
        } catch (error) {
            console.error('🔥 [UnifiedDB] 数据库导入失败:', error);
            throw new Error(`导入失败: ${error.message}`);
        }
    }

    /**
     * 导入单个存储的数据
     */
    async importStore(storeName, data, overwrite = false) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            let addedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;

            // 批量导入数据
            data.forEach(item => {
                const request = overwrite ? store.put(item) : store.add(item);
                
                request.onsuccess = () => {
                    addedCount++;
                };
                
                request.onerror = () => {
                    if (request.error.name === 'ConstraintError') {
                        skippedCount++;
                    } else {
                        errorCount++;
                    }
                };
            });

            transaction.oncomplete = () => {
                resolve({
                    total: data.length,
                    added: addedCount,
                    skipped: skippedCount,
                    errors: errorCount
                });
            };

            transaction.onerror = () => reject(transaction.error);
        });
    }

    /**
     * 清空指定存储的所有数据
     */
    async clearStore(storeName) {
        if (!this.db) {
            await this.init();
        }
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                
                const store = transaction.objectStore(storeName);
                store.clear();
            } catch (error) {
                console.error(`🔥 [UnifiedDB] 清空存储 ${storeName} 失败:`, error);
                reject(error);
            }
        });
    }

    /**
     * 数据迁移函数 - 完全遵循原始dataMigrator.js逻辑
     */
    async migrateData(importData) {
        const { _metadata } = importData;
        const fromVersion = _metadata ? _metadata.version : 1;
        const toVersion = this.version;
        
        console.log(`🔥 [UnifiedDB] 开始数据迁移：从版本 ${fromVersion} 到版本 ${toVersion}`);
        
        // 创建迁移后的数据副本
        const migratedData = JSON.parse(JSON.stringify(importData));
        
        // 更新元数据版本
        migratedData._metadata.version = toVersion;
        migratedData._metadata.migrationTime = new Date().toISOString();
        migratedData._metadata.originalVersion = fromVersion;
        
        // 根据版本差异进行迁移
        if (fromVersion <= 4 &amp;&amp; toVersion >= 5) {
            // 版本4到5的迁移：添加缺失的存储
            this.migrateFrom4To5(migratedData);
        }
        
        if (fromVersion <= 5 &amp;&amp; toVersion >= 6) {
            // 版本5到6的迁移（如果有需要的话）
            this.migrateFrom5To6(migratedData);
        }
        
        if (fromVersion <= 6 &amp;&amp; toVersion >= 7) {
            // 版本6到7的迁移（如果有需要的话）
            this.migrateFrom6To7(migratedData);
        }
        
        if (fromVersion <= 7 &amp;&amp; toVersion >= 8) {
            // 版本7到8的迁移：添加文件存储系统
            this.migrateFrom7To8(migratedData);
        }
        
        if (fromVersion <= 8 &amp;&amp; toVersion >= 9) {
            // 版本8到9的迁移：完善文件存储系统
            this.migrateFrom8To9(migratedData);
        }
        
        if (fromVersion <= 9 &amp;&amp; toVersion >= 10) {
            // 版本9到10的迁移：添加主题配置系统
            this.migrateFrom9To10(migratedData);
        }
        
        if (fromVersion <= 10 &amp;&amp; toVersion >= 11) {
            // 版本10到11的迁移：添加气泡设计器贴图库
            this.migrateFrom10To11(migratedData);
        }
        
        if (fromVersion <= 11 &amp;&amp; toVersion >= 12) {
            // 版本11到12的迁移：移除气泡设计器贴图库
            this.migrateFrom11To12(migratedData);
        }
        
        if (fromVersion <= 12 &amp;&amp; toVersion >= 13) {
            // 版本12到13的迁移：优化数据结构
            this.migrateFrom12To13(migratedData);
        }
        
        if (fromVersion <= 13 &amp;&amp; toVersion >= 14) {
            // 版本13到14的迁移：添加图片分类功能
            await this.migrateFrom13To14(migratedData);
        }
        
        console.log(`🔥 [UnifiedDB] 数据迁移完成：版本 ${fromVersion} -> ${toVersion}`);
        return migratedData;
    }

    // 迁移方法占位符 - 需要时可以实现具体逻辑
    migrateFrom4To5(data) {
        console.log('🔥 [UnifiedDB] 执行 4->5 版本迁移');
        // 添加缺失的存储初始化
        if (!data.characterMemories) data.characterMemories = [];
        if (!data.globalMemory) data.globalMemory = [];
    }

    migrateFrom5To6(data) {
        console.log('🔥 [UnifiedDB] 执行 5->6 版本迁移');
        // 可以添加具体迁移逻辑
    }

    migrateFrom6To7(data) {
        console.log('🔥 [UnifiedDB] 执行 6->7 版本迁移');
        // 可以添加具体迁移逻辑
    }

    migrateFrom7To8(data) {
        console.log('🔥 [UnifiedDB] 执行 7->8 版本迁移');
        // 添加文件存储系统
        if (!data.fileStorage) data.fileStorage = [];
        if (!data.fileReferences) data.fileReferences = [];
    }

    migrateFrom8To9(data) {
        console.log('🔥 [UnifiedDB] 执行 8->9 版本迁移');
        // 完善文件存储系统
    }

    migrateFrom9To10(data) {
        console.log('🔥 [UnifiedDB] 执行 9->10 版本迁移');
        // 添加主题配置系统
        if (!data.themeConfig) data.themeConfig = [];
    }

    migrateFrom10To11(data) {
        console.log('🔥 [UnifiedDB] 执行 10->11 版本迁移');
        // 添加气泡设计器贴图库（已在v12中移除）
    }

    migrateFrom11To12(data) {
        console.log('🔥 [UnifiedDB] 执行 11->12 版本迁移');
        // 移除气泡设计器贴图库
        if (data.bubbleDesignerStickers) {
            delete data.bubbleDesignerStickers;
        }
    }

    migrateFrom12To13(data) {
        console.log('🔥 [UnifiedDB] 执行 12->13 版本迁移');
        // 优化数据结构
    }

    /**
     * 版本13到14的迁移：添加图片使用元数据表
     * @param {Object} data - 数据
     */
    async migrateFrom13To14(data) {
        console.log('🔥 [UnifiedDB] 执行 13->14 版本迁移：添加图片分类功能');
        // imageUsageMetadata 表会在 _createStores 中自动创建
        
        try {
            // 为现有的表情包创建简化的 metadata（不区分 temp/permanent）
            if (data.emojis &amp;&amp; Array.isArray(data.emojis)) {
                console.log('🔥 [UnifiedDB] 为现有表情包创建图库元数据');
                for (const emoji of data.emojis) {
                    if (emoji.id &amp;&amp; emoji.tag) {
                        // 查找对应的文件记录
                        const fileReferences = data.fileReferences || [];
                        const emojiFile = fileReferences.find(ref => 
                            ref.referenceType === 'emoji' &amp;&amp; ref.referenceKey === emoji.tag
                        );
                        
                        if (emojiFile &amp;&amp; emojiFile.fileId) {
                            await this.setImageUsageMetadata(emojiFile.fileId, 'general', {
                                category: 'emoji',
                                tags: [emoji.tag],
                                createdAt: emoji.createdAt || new Date().toISOString(),
                                fileName: emoji.tag
                            });
                        }
                    }
                }
            }
            
            // 为现有的朋友圈图片创建简化的 metadata
            if (data.moments &amp;&amp; Array.isArray(data.moments)) {
                console.log('🔥 [UnifiedDB] 为现有朋友圈图片创建图库元数据');
                for (const moment of data.moments) {
                    if (moment.imageFileIds &amp;&amp; Array.isArray(moment.imageFileIds)) {
                        for (let i = 0; i < moment.imageFileIds.length; i++) {
                            const fileId = moment.imageFileIds[i];
                            await this.setImageUsageMetadata(fileId, 'general', {
                                category: 'moments',
                                tags: ['朋友圈', moment.authorName || '未知'],
                                createdAt: moment.timestamp || new Date().toISOString(),
                                fileName: `moment_${moment.id}_${i + 1}.jpg`
                            });
                        }
                    }
                }
            }
            
            console.log('🔥 [UnifiedDB] 历史图片元数据迁移完成');
        } catch (error) {
            console.error('🔥 [UnifiedDB] 迁移历史图片元数据失败:', error);
            // 迁移失败不影响整体升级
        }
    }

    // ============================================
    // 文件存储功能
    // ============================================

    /**
     * 生成唯一的文件ID
     */
    generateFileId() {
        return 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * 从base64字符串中提取MIME类型
     */
    getMimeTypeFromBase64(base64String) {
        const match = base64String.match(/^data:([^;]+);base64,/);
        return match ? match[1] : 'image/jpeg';
    }

    /**
     * 将base64字符串转换为Blob
     */
    base64ToBlob(base64String) {
        try {
            const mimeType = this.getMimeTypeFromBase64(base64String);
            const base64Data = base64String.split(',')[1];
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('🔥 [UnifiedDB] base64转换Blob失败:', error);
            return null;
        }
    }

    /**
     * 存储文件到数据库
     */
    async storeFile(fileData, metadata = {}) {
        let blob;
        
        if (typeof fileData === 'string' &amp;&amp; fileData.startsWith('data:')) {
            // base64字符串
            blob = this.base64ToBlob(fileData);
            if (!blob) {
                throw new Error('无法转换base64数据');
            }
        } else if (fileData instanceof File || fileData instanceof Blob) {
            // File或Blob对象
            blob = fileData;
        } else {
            throw new Error(`不支持的文件数据类型: ${typeof fileData}`);
        }

        const fileId = this.generateFileId();
        const fileRecord = {
            fileId: fileId,
            blob: blob,
            type: blob.type,
            size: blob.size,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileStorage', fileRecord);
        
        console.log('🔥 [UnifiedDB] 文件存储成功，ID:', fileId);
        return {
            fileId: fileId,
            type: blob.type,
            size: blob.size
        };
    }

    /**
     * 获取文件
     */
    async getFile(fileId) {
        const result = await this.get('fileStorage', fileId);
        if (!result) {
            throw new Error(`文件不存在: ${fileId}`);
        }
        return result;
    }

    /**
     * 创建文件的临时URL
     */
    async createFileURL(fileId) {
        try {
            // 检查缓存
            if (this.urlCache.has(fileId)) {
                return this.urlCache.get(fileId);
            }

            const fileRecord = await this.getFile(fileId);
            
            // 更宽松的blob检查 - 兼容IndexedDB序列化的blob
            if (!fileRecord.blob) {
                throw new Error(`文件记录中缺少blob数据: ${fileId}`);
            }
            
            let blob = fileRecord.blob;
            
            // 如果不是标准Blob实例，尝试重新构造
            if (!(blob instanceof Blob)) {
                try {
                    // 检查是否是类似Blob的对象
                    if (blob.size !== undefined &amp;&amp; blob.type !== undefined) {
                        // 如果有size和type属性，可能是序列化的Blob，尝试重新构造
                        console.log(`🔥 [UnifiedDB] 检测到非标准Blob对象，尝试重新构造: ${fileId}`);
                        
                        // 如果blob有stream方法，说明它仍然是有效的Blob-like对象
                        if (typeof blob.stream === 'function' || typeof blob.arrayBuffer === 'function') {
                            // 直接使用，可能是浏览器内部的Blob表示
                            console.log(`🔥 [UnifiedDB] 使用类Blob对象创建URL: ${fileId}`);
                        } else {
                            throw new Error('Blob对象缺少必要的方法');
                        }
                    } else {
                        throw new Error('无效的blob数据结构');
                    }
                } catch (reconstructError) {
                    throw new Error(`无法处理blob数据: ${reconstructError.message}`);
                }
            }
            
            const url = URL.createObjectURL(blob);
            
            // 缓存URL
            this.urlCache.set(fileId, url);
            
            return url;
        } catch (error) {
            console.error(`🔥 [UnifiedDB] 创建文件URL失败 (${fileId}):`, error);
            return '';
        }
    }

    /**
     * 清理文件URL缓存
     */
    revokeFileURL(fileId) {
        if (this.urlCache.has(fileId)) {
            const url = this.urlCache.get(fileId);
            URL.revokeObjectURL(url);
            this.urlCache.delete(fileId);
        }
    }

    // === 图片使用元数据管理方法 ===

    /**
     * 创建或更新图片使用元数据
     * @param {string} fileId - 文件ID
     * @param {string} usageType - 使用类型 (permanent/temporary/recent/archive)
     * @param {Object} metadata - 额外元数据
     */
    async setImageUsageMetadata(fileId, usageType, metadata = {}) {
        const usageData = {
            fileId: fileId,
            usageType: usageType,
            createdAt: metadata.createdAt || new Date().toISOString(),
            category: metadata.category || 'general', // emoji, moment, chat, avatar, background
            tags: metadata.tags || [],
            size: metadata.size || 0,
            fileName: metadata.fileName || null
        };

        await this.put('imageUsageMetadata', usageData);
        console.log(`🔥 [UnifiedDB] 设置图片使用元数据: ${fileId} -> ${usageType}`);
        return usageData;
    }


    /**
     * 获取图片使用元数据
     * @param {string} fileId - 文件ID
     */
    async getImageUsageMetadata(fileId) {
        return await this.get('imageUsageMetadata', fileId);
    }

    /**
     * 根据使用类型查询图片
     * @param {string} usageType - 使用类型
     * @param {number} limit - 限制数量
     */
    async getImagesByUsageType(usageType, limit = 100) {
        return await this._dbOperation('imageUsageMetadata', 'readonly', (store) => {
            const index = store.index('usageType');
            const request = index.getAll(usageType);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const results = request.result.slice(0, limit);
                    resolve(results);
                };
                request.onerror = () => reject(request.error);
            });
        }, `查询${usageType}类型图片`);
    }

    /**
     * 清理过期的临时图片
     * @param {string[]} fileIds - 要删除的文件ID数组
     */
    async cleanupSelectedImages(fileIds) {
        if (!Array.isArray(fileIds) || fileIds.length === 0) {
            return { deletedCount: 0, errors: [] };
        }

        try {
            let deletedCount = 0;
            const errors = [];

            for (const fileId of fileIds) {
                try {
                    // 删除文件
                    await this.deleteFile(fileId);
                    // 删除元数据
                    await this.delete('imageUsageMetadata', fileId);
                    // 删除相关引用
                    await this.cleanupFileReferences(fileId);
                    deletedCount++;
                    console.log(`🔥 [UnifiedDB] 已删除图片: ${fileId}`);
                } catch (error) {
                    console.warn(`删除图片失败: ${fileId}`, error);
                    errors.push({ fileId, error: error.message });
                }
            }

            console.log(`🔥 [UnifiedDB] 手动清理图片完成: ${deletedCount}/${fileIds.length}`);
            return { deletedCount, totalRequested: fileIds.length, errors };
        } catch (error) {
            console.error('批量删除图片失败:', error);
            throw error;
        }
    }

    /**
     * 清理指定文件的所有引用
     * @param {string} fileId - 文件ID
     */
    async cleanupFileReferences(fileId) {
        return await this._dbOperation('fileReferences', 'readwrite', (store) => {
            return new Promise((resolve, reject) => {
                try {
                    const index = store.index('fileId');
                    const request = index.openCursor(IDBKeyRange.only(fileId));
                    let deletedCount = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            deletedCount++;
                            cursor.continue();
                        } else {
                            // 所有匹配的记录都已处理完成
                            console.log(`🔥 [UnifiedDB] 清理文件引用: ${fileId} (${deletedCount}个引用)`);
                            resolve(deletedCount);
                        }
                    };

                    request.onerror = (event) => {
                        console.warn('清理文件引用失败:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.warn('清理文件引用失败:', error);
                    reject(error);
                }
            });
        }, `清理文件引用: ${fileId}`);
    }

    /**
     * 获取图片使用统计
     */
    async getImageUsageStats() {
        try {
            const allMetadata = await this.getAll('imageUsageMetadata');
            const stats = {
                total: allMetadata.length,
                byType: {},
                byCategory: {},
                totalSize: 0
            };

            allMetadata.forEach(meta => {
                // 按类型统计
                stats.byType[meta.usageType] = (stats.byType[meta.usageType] || 0) + 1;
                
                // 按分类统计
                stats.byCategory[meta.category] = (stats.byCategory[meta.category] || 0) + 1;
                
                // 总大小
                stats.totalSize += meta.size || 0;
            });

            return stats;
        } catch (error) {
            console.error('获取图片使用统计失败:', error);
            return null;
        }
    }

    /**
     * 删除文件
     */
    async deleteFile(fileId) {
        await this.delete('fileStorage', fileId);
        this.revokeFileURL(fileId);
        console.log(`🔥 [UnifiedDB] 文件删除成功: ${fileId}`);
    }

    /**
     * 创建文件引用关系
     */
    async createFileReference(fileId, referenceType, referenceKey, metadata = {}) {
        const referenceId = `${referenceType}_${referenceKey}`;
        const reference = {
            referenceId: referenceId,
            fileId: fileId,
            category: referenceType,
            referenceKey: referenceKey,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileReferences', reference);
        console.log('🔥 [UnifiedDB] 文件引用存储成功:', reference);
        return reference;
    }

    /**
     * 获取文件引用
     */
    async getFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        return await this.get('fileReferences', referenceId);
    }

    /**
     * 删除文件引用
     */
    async deleteFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        await this.delete('fileReferences', referenceId);
        console.log(`🔥 [UnifiedDB] 文件引用删除成功: ${referenceId}`);
    }

    // ============================================
    // 向后兼容的辅助方法和错误处理
    // ============================================

    /**
     * 兼容旧的promisifyRequest方法
     */
    promisifyRequest(request, description = '') {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => {
                console.error(`🔥 [UnifiedDB] ${description}失败:`, request.error);
                reject(request.error);
            };
        });
    }

    /**
     * 兼容旧的ensureDBReady方法
     */
    async ensureDBReady(operation, description = '') {
        if (!this.isReady) {
            await this.init();
        }
        
        try {
            return await operation();
        } catch (error) {
            console.error(`🔥 [UnifiedDB] ${description}失败:`, error);
            throw error;
        }
    }

    /**
     * 重试机制 - 向后兼容
     */
    async retryWithBackoff(operation, context, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                lastError = error;
                console.warn(`🔥 [UnifiedDB] ${context} - 尝试 ${attempt}/${maxRetries} 失败:`, error);
                
                if (attempt < maxRetries) {
                    // 指数退避延迟
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.error(`🔥 [UnifiedDB] ${context} - 所有重试失败`);
                    throw lastError;
                }
            }
        }
        
        throw lastError;
    }
}

// ============================================
// 全局导出和兼容性设置 - 立即执行
// ============================================

/**
 * 显示数据库错误对话框 - 向后兼容
 */
function showDatabaseErrorDialog(error, isRetrying = false) {
    const title = isRetrying ? '数据库重试中...' : '数据库连接失败';
    const message = isRetrying 
        ? `数据库连接异常，正在自动重试...\n\n错误信息: ${error.message}`
        : `数据库连接失败。\n\n错误信息: ${error.message}\n\n建议:\n1. 刷新页面重试\n2. 清除浏览器缓存\n3. 检查浏览器是否支持IndexedDB`;
    
    console.error('🔥 [UnifiedDB] 数据库错误:', error);
    
    // Event-driven error dialog - replace direct alert() with custom event
    window.dispatchEvent(new CustomEvent('database:errorDialog', {
        detail: {
            title: title,
            message: message,
            error: error,
            isRetrying: isRetrying,
            suggestions: isRetrying ? [] : [
                '刷新页面重试',
                '清除浏览器缓存', 
                '检查浏览器是否支持IndexedDB'
            ]
        }
    }));
}

/**
 * 重试执行函数 - 向后兼容
 */
async function executeWithRetry(operation, context = '数据库操作') {
    if (window.unifiedDB &amp;&amp; typeof window.unifiedDB.retryWithBackoff === 'function') {
        return await window.unifiedDB.retryWithBackoff(operation, context);
    }
    
    // 简单重试逻辑作为后备
    try {
        return await operation();
    } catch (error) {
        console.error(`🔥 [UnifiedDB] ${context} 失败:`, error);
        throw error;
    }
}

// 🔥 立即导出这些函数到全局作用域，确保其他脚本可以使用
if (typeof window !== 'undefined') {
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
}

// 获取全局单例实例
const unifiedDB = UnifiedDBManager.getInstance();

// 创建命名空间以减少全局污染
const AppDB = {
    // 核心管理器
    UnifiedDBManager: UnifiedDBManager,
    unifiedDB: unifiedDB,
    
    // 工具函数
    executeWithRetry: executeWithRetry,
    showDatabaseErrorDialog: showDatabaseErrorDialog,
    promisifyRequest: (request, description) => unifiedDB.promisifyRequest(request, description),
    ensureDBReady: (operation, description) => unifiedDB.ensureDBReady(operation, description),
    initUnifiedDB: () => unifiedDB.init(),
    
    // 管理器对象（将在下面定义）
    StorageManager: null,
    DatabaseManager: null,
    
    // 导入导出函数（将在下面定义）
    exportDatabase: null,
    exportFileStorage: null,
    importDatabase: null,
    performImport: null,
    
    // 文件处理函数（纯业务逻辑）
    performFileStorageImport: null,
    importPrompts: null,
    
    // UI函数现在由UIManager处理
    // handleFileSelect, handleFileStorageImport, confirmFileExport, cancelFileExport, refreshDatabaseStats
    // triggerFileSelect, triggerFileStorageImport
    
    // 文件存储管理器别名
    FileStorageManager: unifiedDB
};

// 导出到window对象
if (typeof window !== 'undefined') {
    window.AppDB = AppDB;
    
    // 向后兼容：保留关键的直接window导出
    window.UnifiedDBManager = UnifiedDBManager;
    window.unifiedDB = unifiedDB;
    window.promisifyRequest = AppDB.promisifyRequest;
    window.ensureDBReady = AppDB.ensureDBReady;
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
    window.initUnifiedDB = AppDB.initUnifiedDB;
    
    // 🔥 完整的 StorageManager 对象
    AppDB.StorageManager = {
        /**
         * 申请持久化存储（纯业务逻辑，不涉及UI）
         */
        async requestPersistentStorage() {
            try {
                console.log('[StorageManager] 申请持久化存储...');
                
                if (!navigator.storage || !navigator.storage.persist) {
                    const result = { success: false, error: '浏览器不支持持久化存储功能' };
                    window.dispatchEvent(new CustomEvent('storage:persistentUnsupported', { detail: result }));
                    return result;
                }

                // 申请持久化存储
                const granted = await navigator.storage.persist();
                const estimate = await navigator.storage.estimate();
                
                const result = {
                    success: true,
                    granted: granted,
                    estimate: estimate,
                    message: granted ? '持久化存储申请成功' : '持久化存储申请被拒绝'
                };

                // 发出事件通知UI层
                const eventType = granted ? 'storage:persistentGranted' : 'storage:persistentDenied';
                window.dispatchEvent(new CustomEvent(eventType, { detail: result }));
                
                console.log(`[StorageManager] 持久化存储申请${granted ? '成功' : '被拒绝'}`);
                
                // 通知需要刷新统计信息
                window.dispatchEvent(new CustomEvent('storage:statsRefreshNeeded'));
                
                return result;

            } catch (error) {
                console.error('[StorageManager] 申请持久化存储失败:', error);
                const result = { success: false, error: error.message };
                window.dispatchEvent(new CustomEvent('storage:persistentError', { detail: result }));
                return result;
            }
        },

        /**
         * 检查持久化存储状态
         */
        async checkPersistentStorageStatus() {
            try {
                if (!navigator.storage || !navigator.storage.persisted) {
                    return false;
                }
                return await navigator.storage.persisted();
            } catch (error) {
                console.error('[StorageManager] 检查持久化存储状态失败:', error);
                return false;
            }
        },

        /**
         * 获取存储使用情况
         */
        async getStorageUsage() {
            try {
                if (!navigator.storage || !navigator.storage.estimate) {
                    return null;
                }
                return await navigator.storage.estimate();
            } catch (error) {
                console.error('[StorageManager] 获取存储使用情况失败:', error);
                return null;
            }
        },

        /**
         * 检查IndexedDB是否为持久化存储
         */
        async checkPersistentStorage() {
            try {
                if ('storage' in navigator &amp;&amp; 'persisted' in navigator.storage) {
                    const isPersistent = await navigator.storage.persisted();
                    const estimate = await navigator.storage.estimate();
                    
                    return {
                        success: true,
                        isPersistent: isPersistent,
                        estimate: estimate
                    };
                } else {
                    return {
                        success: false,
                        error: '浏览器不支持Storage API',
                        isPersistent: false
                    };
                }
            } catch (error) {
                console.error('检查持久化存储状态失败:', error);
                return {
                    success: false,
                    error: error.message,
                    isPersistent: false
                };
            }
        },

        // 删除重复方法 - requestPersistentStorage() 已在上面定义
    };

    // 向后兼容：保留 StorageManager 的直接 window 访问
    window.StorageManager = AppDB.StorageManager;

    // 🔥 完整的 DatabaseManager 对象
    AppDB.DatabaseManager = {
        init: () => unifiedDB.init(),
        
        /**
         * 检查数据库健康状态并提供修复选项
         */
        async checkAndOfferRepair() {
            try {
                console.log('[DatabaseManager] 开始数据库健康检查...');
                
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    console.warn('[DatabaseManager] 数据库未就绪，跳过健康检查');
                    return { success: false, error: '数据库未就绪' };
                }

                // 检查所有预期的存储是否存在
                const expectedStores = [
                    'contacts', 'apiSettings', 'emojis', 'backgrounds', 
                    'userProfile', 'moments', 'weiboPosts', 'hashtagCache',
                    'characterMemories', 'globalMemory', 'conversationCounters', 
                    'memoryProcessedIndex', 'themeConfig'
                ];

                const db = window.unifiedDB.db;
                const missingStores = expectedStores.filter(storeName => 
                    !db.objectStoreNames.contains(storeName)
                );

                if (missingStores.length > 0) {
                    console.warn('[DatabaseManager] 发现缺失的存储:', missingStores);
                    
                    // 发出事件，让UI层决定是否修复
                    const repairResult = await new Promise((resolve) => {
                        const eventData = { missingStores, resolve };
                        window.dispatchEvent(new CustomEvent('database:repairNeeded', { detail: eventData }));
                    });
                    
                    if (repairResult) {
                        return await this.repairDatabase(missingStores);
                    }
                    
                    return { success: false, message: '用户取消修复', missingStores };
                } else {
                    console.log('[DatabaseManager] 数据库结构完整');
                    return { success: true, message: '数据库结构完整' };
                }

                return { success: true, message: '健康检查完成' };

            } catch (error) {
                console.error('[DatabaseManager] 健康检查失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 修复数据库结构
         */
        async repairDatabase(missingStores) {
            try {
                console.log('[DatabaseManager] 开始修复数据库...');
                
                // 关闭现有连接
                if (window.unifiedDB &amp;&amp; window.unifiedDB.db) {
                    window.unifiedDB.db.close();
                }

                // 重新初始化数据库以创建缺失的存储
                await window.unifiedDB.init();
                
                // 发出修复成功事件
                window.dispatchEvent(new CustomEvent('database:repairSuccess', {
                    detail: { message: '数据库修复完成' }
                }));

                return { success: true, message: '数据库修复完成' };

            } catch (error) {
                console.error('[DatabaseManager] 数据库修复失败:', error);
                
                // 发出修复失败事件
                window.dispatchEvent(new CustomEvent('database:repairError', {
                    detail: { error: error.message }
                }));

                return { success: false, error: error.message };
            }
        },

        /**
         * 获取数据库统计信息
         */
        async getStats() {
            try {
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    return { success: false, error: '数据库未就绪' };
                }

                const db = window.unifiedDB.db;
                const stats = {};

                // 遍历所有对象存储获取记录数
                const storeNames = Array.from(db.objectStoreNames);
                
                for (const storeName of storeNames) {
                    try {
                        const count = await window.unifiedDB.count(storeName);
                        stats[storeName] = count;
                    } catch (error) {
                        console.warn(`[DatabaseManager] 获取存储 ${storeName} 统计失败:`, error);
                        stats[storeName] = 0;
                    }
                }

                return { success: true, stats };

            } catch (error) {
                console.error('[DatabaseManager] 获取统计信息失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 重置应用状态 - 清空内存中的全局变量
         * 在数据库导入后使用，确保应用状态与数据库同步
         */
        resetApplicationState() {
            // 联系人相关
            if (typeof window.contacts !== 'undefined') {
                window.contacts = [];
            }
            if (typeof window.currentContact !== 'undefined') {
                window.currentContact = null;
            }
            
            // 表情相关
            if (typeof window.emojis !== 'undefined') {
                window.emojis = [];
            }
            
            // 背景相关
            if (typeof window.backgrounds !== 'undefined') {
                window.backgrounds = {};
            }
            
            // 用户资料
            if (typeof window.userProfile !== 'undefined') {
                window.userProfile = { name: '我的昵称', avatar: '', personality: '' };
            }
            
            // 动态相关
            if (typeof window.moments !== 'undefined') {
                window.moments = [];
            }
            if (typeof window.weiboPosts !== 'undefined') {
                window.weiboPosts = [];
            }
            
            console.log('[DatabaseManager] 应用状态已重置');
        },

        /**
         * 导出并下载数据库
         */
        async exportAndDownload() {
            try {
                console.log('[DatabaseManager] 开始导出数据库...');
                
                const exportData = await window.unifiedDB.exportDatabase();
                
                // 创建下载链接
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `freeapp_backup_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                return { success: true, message: '数据库导出成功' };

            } catch (error) {
                console.error('[DatabaseManager] 导出数据库失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 从文件导入数据库
         */
        async importFromFile(file, overwrite = false) {
            try {
                console.log('[DatabaseManager] 开始导入数据库...');
                
                const text = await this.readFileAsText(file);
                const importData = JSON.parse(text);
                
                const result = await window.unifiedDB.importDatabase(importData, { overwrite });
                
                return { 
                    success: true, 
                    message: '数据库导入成功',
                    result: result
                };

            } catch (error) {
                console.error('[DatabaseManager] 导入数据库失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 读取文件内容为文本
         */
        readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('文件读取失败'));
                reader.readAsText(file);
            });
        }
    };

    // 向后兼容：保留 DatabaseManager 的直接 window 访问
    window.DatabaseManager = AppDB.DatabaseManager;

    // 🔥 数据库统计刷新函数（纯业务逻辑，UI分离）
    AppDB.refreshDatabaseStats = async function() {
        try {
            // 发出刷新开始事件
            window.dispatchEvent(new CustomEvent('database:statsRefreshStart'));
            
            const [result, persistentResult] = await Promise.all([
                window.DatabaseManager.getStats(),
                window.StorageManager.checkPersistentStorage()
            ]);
            
            if (result.success) {
                // 发出成功事件，让UI层处理显示
                window.dispatchEvent(new CustomEvent('database:statsRefreshSuccess', {
                    detail: { result, persistentResult }
                }));
                return { success: true, result, persistentResult };
            } else {
                // 发出错误事件
                window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                    detail: { error: result.error }
                }));
                return { success: false, error: result.error };
            }
            
        } catch (error) {
            console.error('刷新数据库统计失败:', error);
            // 发出错误事件
            window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                detail: { error: error.message }
            }));
            return { success: false, error: error.message };
        }
    };

    // 向后兼容：refreshDatabaseStats 现在通过 UIManager 处理
    // window.refreshDatabaseStats is now assigned in uiManager.js

    // 🔥 数据库导出函数（纯业务逻辑）
    AppDB.exportDatabase = async function() {
        try {
            // 发出导出开始事件
            window.dispatchEvent(new CustomEvent('database:exportStart'));
            
            const result = await window.DatabaseManager.exportAndDownload();
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:exportSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:exportError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('导出出错:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:exportError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // 🔥 文件存储导出函数 - 纯业务逻辑，配置通过事件获取
    AppDB.exportFileStorage = async function() {
        try {
            // 通过事件请求导出配置
            const config = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:exportConfigNeeded', {
                    detail: { resolve }
                }));
            });

            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportStart', {
                detail: { config }
            }));

            const exporter = new FileStorageExporter();
            const result = await exporter.downloadFileStorageAsZip(config);

            if (result.success) {
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:exportSuccess', {
                    detail: { 
                        message: '文件存储导出成功！',
                        result: result
                    }
                }));
            } else {
                throw new Error(result.error || '导出失败');
            }

        } catch (error) {
            console.error('文件存储导出失败:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
        }
    };

    // 🔥 处理文件选择函数 - 纯业务逻辑，UI操作移至UIManager
    AppDB.handleFileSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: '未选择文件' };
        }
        
        console.log('选择的文件:', file.name, file.type, file.size);
        
        try {
            const result = await window.importDatabase(file);
            
            // 发出文件处理完成事件，让UI层处理清空操作
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('导入过程中出错:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('database:importError', {
                detail: {
                    error: error,
                    type: 'import_operation'
                }
            }));
            
            // 即使出错也要清空文件输入
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // 🔥 处理文件存储选择函数 - 纯业务逻辑，UI操作通过事件处理
    AppDB.handleFileStorageSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: '未选择文件' };
        }
        
        console.log('选择的文件存储文件:', file.name, file.type, file.size);
        
        try {
            // 请求UI提供导入选项
            const options = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:importOptionsNeeded', {
                    detail: { resolve }
                }));
            });
            
            // 调用业务逻辑执行导入
            const result = await window.performFileStorageImport(file, options);
            
            // 发出文件处理完成事件，让UI层处理清空操作
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('文件存储导入过程中出错:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:importError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
            
            // 即使出错也要清空文件输入
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // 🔥 数据库导入函数（纯业务逻辑）
    AppDB.importDatabase = async function(file) {
        if (!file) {
            return { success: false, error: '未提供文件' };
        }
        
        try {
            // 请求UI确认
            const confirmed = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('database:importConfirmationNeeded', { 
                    detail: { file, resolve } 
                }));
            });
            
            if (!confirmed) {
                console.log('用户取消导入');
                return { success: false, message: '用户取消导入' };
            }
            
            // 发出导入开始事件
            window.dispatchEvent(new CustomEvent('database:importStart', { 
                detail: { fileName: file.name } 
            }));
            
            // 🎯 确保performImport函数已就绪
            if (!window.performImport || typeof window.performImport !== 'function') {
                console.log('⏳ [Import] performImport未就绪，等待初始化...');
                await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        console.warn('⚠️ [Import] performImport等待超时，尝试继续');
                        resolve();
                    }, 3000);

                    const checkReady = () => {
                        if (window.performImport &amp;&amp; typeof window.performImport === 'function') {
                            clearTimeout(timeout);
                            console.log('✅ [Import] performImport已就绪');
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }

            const overwrite = true;
            const result = await window.performImport(file, overwrite);

            // 🔍 宽容的结果检查 - 允许undefined返回，通常刷新后会正常
            if (result === undefined) {
                console.warn('⚠️ [Import] performImport返回undefined，这通常在刷新后会自行修复');
                return {
                    success: false,
                    error: '导入功能暂时不可用，请刷新页面后重试',
                    needsRefresh: true
                };
            }
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:importSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:importError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('导入失败:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:importError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // 🔥 执行导入函数 - 重构为事件驱动架构
    AppDB.performImport = async function(file, overwrite) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('database:importProgress', {
                detail: { message: '正在导入数据库...', stage: 'starting' }
            }));
            
            if (!window.DatabaseManager) {
                console.error('window.DatabaseManager 不存在！');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('数据库管理器未初始化，请刷新页面后重试'),
                        type: 'initialization_error',
                        critical: true
                    }
                }));
                return;
            }
            
            if (!window.DatabaseManager.importFromFile) {
                console.error('importFromFile 方法不存在！');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('导入功能不可用，请检查代码'),
                        type: 'function_missing',
                        critical: true
                    }
                }));
                return;
            }
            
            const result = await window.DatabaseManager.importFromFile(file, overwrite);
            
            if (result.success) {
                // 刷新统计信息
                if (typeof window.refreshDatabaseStats === 'function') {
                    window.refreshDatabaseStats();
                }
                
                // 重置应用状态，确保数据同步
                window.DatabaseManager.resetApplicationState();
                
                // Event-driven success notification with reload intent
                window.dispatchEvent(new CustomEvent('database:importSuccess', {
                    detail: { 
                        message: '数据库导入成功！页面将在3秒后自动刷新...',
                        result: result,
                        autoReload: true,
                        reloadDelay: 3000
                    }
                }));
                
                // 延迟刷新页面以确保用户看到成功消息
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
                
            } else {
                throw new Error(result.error || '导入失败');
            }
            
        } catch (error) {
            console.error('导入失败:', error.message);
            throw error; // 重新抛出以便上层处理
        }
    };

    // 🔥 执行文件存储导入函数 - 纯业务逻辑（UI交互已移至UIManager）
    AppDB.performFileStorageImport = async function(file, options) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:importProgress', {
                detail: { message: '正在导入文件存储...', stage: 'starting' }
            }));

            const importer = new FileStorageImporter();
            const response = await importer.importFromZipFile(file, options);

            if (response.success) {
                // 映射返回结果格式以保持兼容性
                const result = {
                    imported: response.results.created,
                    skipped: response.results.skipped,
                    failed: response.results.failed,
                    matched: response.results.matched,
                    processed: response.results.processed,
                    totalFiles: response.results.totalFiles
                };

                const detailedMessage = `文件存储导入成功！\n\n导入统计：\n• 成功导入 ${result.imported} 个文件\n• 跳过 ${result.skipped} 个文件\n• 失败 ${result.failed} 个文件`;
                
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:importSuccess', {
                    detail: { 
                        message: '文件存储导入成功！',
                        detailedMessage: detailedMessage,
                        stats: {
                            imported: result.imported,
                            skipped: result.skipped,
                            failed: result.failed
                        },
                        result: result
                    }
                }));
                
                // 刷新统计信息
                if (typeof window.refreshDatabaseStats === 'function') {
                    setTimeout(() => {
                        window.refreshDatabaseStats();
                    }, 1000);
                }

            } else {
                throw new Error(response.error || '导入失败');
            }

        } catch (error) {
            console.error('文件存储导入失败:', error);
            throw error; // 重新抛出以便上层处理
        }
    };

    // 🔥 确认文件导出函数 - 纯业务逻辑，UI操作移至UIManager
    AppDB.confirmFileExport = async function() {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportProgress', {
                detail: { message: '正在导出文件存储...', stage: 'confirming' }
            }));

            // 发出隐藏选项面板事件
            window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));

            const result = await window.exportFileStorage();
            return result;

        } catch (error) {
            console.error('确认文件导出失败:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'confirmation_error'
                }
            }));
            return { success: false, error: error.message };
        }
    };

    // 🔥 取消文件导出函数 - 纯业务逻辑，UI操作移至UIManager
    AppDB.cancelFileExport = function() {
        // 发出隐藏选项面板事件
        window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));
        
        // Event-driven cancellation notification
        window.dispatchEvent(new CustomEvent('fileStorage:exportCancelled', {
            detail: { message: '用户取消了文件导出' }
        }));
        
        return { success: true, message: '用户取消了文件导出' };
    };

    // 🔥 导入提示词函数 - 重构为事件驱动架构
    AppDB.importPrompts = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                const prompts = JSON.parse(content);
                
                if (Array.isArray(prompts)) {
                    localStorage.setItem('customPrompts', JSON.stringify(prompts));
                    // Event-driven success notification
                    window.dispatchEvent(new CustomEvent('prompts:importSuccess', {
                        detail: { 
                            message: `成功导入 ${prompts.length} 个提示词`,
                            count: prompts.length,
                            prompts: prompts
                        }
                    }));
                } else {
                    throw new Error('文件格式不正确，应为提示词数组');
                }
            } catch (error) {
                console.error('导入提示词失败:', error);
                // Event-driven error notification
                window.dispatchEvent(new CustomEvent('prompts:importError', {
                    detail: {
                        error: error,
                        type: 'format_error'
                    }
                }));
            }
        };
        reader.readAsText(file);
        
        // 清空文件输入
        event.target.value = '';
    };
    
    // 向后兼容：保留所有函数的直接 window 访问
    window.exportDatabase = AppDB.exportDatabase;
    window.exportFileStorage = AppDB.exportFileStorage;
    // Pure database operations that remain in UnifiedDBManager
    window.importDatabase = AppDB.importDatabase;
    window.performImport = AppDB.performImport;
    window.performFileStorageImport = AppDB.performFileStorageImport;
    window.importPrompts = AppDB.importPrompts;
    
    // UI-related functions are now handled by UIManager
    // window.triggerFileSelect, window.triggerFileStorageImport, etc. are assigned in uiManager.js
    
    window.FileStorageManager = unifiedDB; // 直接映射到统一管理器
    
    console.log('🔥 [UnifiedDB] 统一数据库管理器已全局导出，包含所有数据库相关功能');

    // 🎯 通知所有依赖函数已就绪 - 解决单文件构建时序问题
    setTimeout(() => {
        window.dispatchEvent(new CustomEvent('unifieddb:ready', {
            detail: {
                timestamp: Date.now(),
                message: '所有导入导出功能已就绪',
                functions: ['performImport', 'importDatabase', 'exportDatabase', 'performFileStorageImport']
            }
        }));
        console.log('✅ [UnifiedDB] 就绪事件已发送，导入功能可用');
    }, 0);
}

// 🔥 Module export removed for browser compatibility
// ES Module导出 (removed for standard script loading)

/*
================================================================================
📚 EVENT-DRIVEN UI ARCHITECTURE DOCUMENTATION
================================================================================

本文档说明了重构后的事件驱动UI架构。所有UI交互现在通过自定义事件进行，
实现了业务逻辑与UI层的完全分离。

🎯 核心优势：
- ✅ 纯业务逻辑，可单元测试
- ✅ 灵活的UI实现（可用任何框架）  
- ✅ 一致的错误处理模式
- ✅ 更好的用户体验（非阻塞交互）

📋 事件类型汇总：

🗂️ 文件存储相关事件：
- fileStorage:importOptionsNeeded - 需要用户选择导入选项
- fileStorage:importError - 文件存储导入错误
- fileStorage:importProgress - 导入进度通知
- fileStorage:importSuccess - 导入成功
- fileStorage:exportStart - 导出开始
- fileStorage:exportProgress - 导出进度
- fileStorage:exportSuccess - 导出成功  
- fileStorage:exportError - 导出错误
- fileStorage:exportCancelled - 导出取消

🗄️ 数据库相关事件：
- database:importConfirmationNeeded - 需要用户确认导入
- database:importProgress - 导入进度通知
- database:importStart - 导入开始
- database:importSuccess - 导入成功
- database:importError - 导入错误
- database:exportStart - 导出开始
- database:exportSuccess - 导出成功
- database:exportError - 导出错误
- database:repairNeeded - 需要数据库修复
- database:repairSuccess - 修复成功
- database:repairError - 修复失败
- database:errorDialog - 显示错误对话框

💡 提示词相关事件：
- prompts:importSuccess - 提示词导入成功
- prompts:importError - 提示词导入错误

🏪 存储相关事件：
- storage:persistentGranted - 持久化存储已授权
- storage:persistentDenied - 持久化存储被拒绝
- storage:persistentUnsupported - 不支持持久化存储
- storage:persistentError - 持久化存储错误
- storage:statsRefreshNeeded - 需要刷新统计信息

================================================================================
📖 UI层实现示例
================================================================================

以下是推荐的UI层实现模式：

// 🎯 1. 基础错误通知处理
window.addEventListener('fileStorage:importError', (event) => {
    const { error, type } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(error.message, 'error');
    } else {
        // 降级到原生对话框
        alert(error.message);
    }
});

// 🎯 2. 用户确认对话框
window.addEventListener('fileStorage:importOptionsNeeded', (event) => {
    const { resolve, messages } = event.detail;
    
    // 现代UI实现示例
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: '导入选项',
            message: messages.overwrite,
            buttons: [
                { text: '覆盖', style: 'primary', value: true },
                { text: '保留', style: 'secondary', value: false }
            ]
        }).then(overwrite => {
            return showCustomDialog({
                title: '处理缺失文件',
                message: messages.skipMissing,
                buttons: [
                    { text: '跳过', style: 'primary', value: true },
                    { text: '占位符', style: 'secondary', value: false }
                ]
            }).then(skipMissing => {
                resolve({ overwrite, skipMissing });
            });
        });
    } else {
        // 降级到原生对话框
        const overwrite = confirm(messages.overwrite);
        const skipMissing = confirm(messages.skipMissing);
        resolve({ overwrite, skipMissing });
    }
});

// 🎯 3. 进度通知处理
window.addEventListener('database:importProgress', (event) => {
    const { message, stage } = event.detail;
    
    if (typeof showProgressToast === 'function') {
        showProgressToast(message);
    } else if (typeof showToast === 'function') {
        showToast(message);
    }
});

// 🎯 4. 成功通知处理
window.addEventListener('database:importSuccess', (event) => {
    const { message, autoReload, reloadDelay } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(message);
    }
    
    // 自动刷新已经在业务逻辑中处理，UI层可以添加额外的视觉反馈
    if (autoReload &amp;&amp; typeof showCountdownNotification === 'function') {
        showCountdownNotification('页面将自动刷新', reloadDelay);
    }
});

// 🎯 5. 数据库修复确认对话框
window.addEventListener('database:repairNeeded', (event) => {
    const { missingStores, resolve } = event.detail;
    
    const message = `发现数据库结构问题，缺失以下存储：\n${missingStores.join(', ')}\n\n是否立即修复？`;
    
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: '数据库修复',
            message: message,
            type: 'warning',
            buttons: [
                { text: '立即修复', style: 'primary', value: true },
                { text: '稍后处理', style: 'secondary', value: false }
            ]
        }).then(resolve);
    } else {
        const shouldRepair = confirm(message);
        resolve(shouldRepair);
    }
});

// 🎯 6. 复杂统计信息展示
window.addEventListener('fileStorage:importSuccess', (event) => {
    const { message, stats, detailedMessage } = event.detail;
    
    if (typeof showDetailedNotification === 'function') {
        showDetailedNotification({
            title: '导入完成',
            message: message,
            details: `成功：${stats.imported}，跳过：${stats.skipped}，失败：${stats.failed}`,
            type: 'success'
        });
    } else if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(detailedMessage);
    }
});

================================================================================
🔧 UI框架集成指南
================================================================================

🎨 Vue.js 集成示例：
// 在Vue组件中
mounted() {
    // 监听数据库事件
    window.addEventListener('database:importError', this.handleImportError);
    window.addEventListener('database:importSuccess', this.handleImportSuccess);
},
methods: {
    handleImportError(event) {
        this.$toast.error(event.detail.error.message);
    },
    handleImportSuccess(event) {
        this.$toast.success(event.detail.message);
        if (event.detail.autoReload) {
            this.showCountdown(event.detail.reloadDelay);
        }
    }
}

⚛️ React 集成示例：
// 在React组件中
useEffect(() => {
    const handleImportError = (event) => {
        toast.error(event.detail.error.message);
    };
    
    window.addEventListener('database:importError', handleImportError);
    return () => window.removeEventListener('database:importError', handleImportError);
}, []);

🍰 Vanilla JS 集成示例：
// 创建统一的事件处理管理器
class UIEventManager {
    constructor() {
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // 错误处理
        ['database:importError', 'fileStorage:importError', 'prompts:importError']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleError.bind(this));
            });
            
        // 成功处理
        ['database:importSuccess', 'fileStorage:importSuccess', 'prompts:importSuccess']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleSuccess.bind(this));
            });
    }
    
    handleError(event) {
        const { error, type } = event.detail;
        this.showNotification(error.message, 'error');
    }
    
    handleSuccess(event) {
        const { message } = event.detail;
        this.showNotification(message, 'success');
    }
}

// 启用事件管理器
document.addEventListener('DOMContentLoaded', () => {
    new UIEventManager();
});

================================================================================
💯 最佳实践
================================================================================

1. ✅ 降级策略：始终提供原生对话框作为降级方案
2. ✅ 错误分类：使用 detail.type 区分不同类型的错误
3. ✅ 进度反馈：长时间操作提供进度通知
4. ✅ 一致性：所有UI交互使用相同的事件模式
5. ✅ 可访问性：确保事件包含足够的上下文信息
6. ✅ 清理：组件销毁时移除事件监听器
7. ✅ 测试友好：事件可以轻松模拟和测试

通过遵循这些模式，你可以创建一个完全解耦、可测试、可维护的应用架构！

================================================================================
*/
// export default UnifiedDBManager;
// export { unifiedDB };
</script>
    
    <!-- 文件和图片处理模块 -->
    <script>
/**
 * 详细错误类 - 提供错误类型和用户友好的错误消息
 */
class DetailedError extends Error {
    constructor(code, message) {
        super(message);
        this.name = 'DetailedError';
        this.code = code;
    }
}

/**
 * 图片存储API - 高级接口
 * 提供简单易用的图片存储和获取接口，封装底层的文件存储管理器
 */

class ImageStorageAPI {
    constructor() {
        this.fileManager = null;
        this.isInitialized = false;
        this.initPromise = null;
    }

    /**
     * 初始化图片存储API
     */
    async init() {
        if (this.isInitialized) {
            return this.fileManager;
        }

        if (this.initPromise) {
            return this.initPromise;
        }

        this.initPromise = this._initInternal();
        return this.initPromise;
    }

    async _initInternal() {
        try {
            // 确保UnifiedDBManager已加载（通过FileStorageManager兼容性映射）
            if (!window.FileStorageManager) {
                throw new Error('UnifiedDBManager未加载或FileStorageManager映射未设置');
            }

            this.fileManager = window.FileStorageManager;
            await this.fileManager.init();
            
            this.isInitialized = true;
            // 图片存储API初始化完成
            return this.fileManager;
        } catch (error) {
            console.error('图片存储API初始化失败:', error);
            throw error;
        }
    }

    /**
     * 存储头像图片
     * @param {string|File|Blob} imageData - 图片数据（base64字符串、File对象或Blob对象）
     * @param {string} entityType - 实体类型（'user' 或 'contact'）
     * @param {string} entityId - 实体ID（用户ID或联系人ID）
     * @returns {Promise<string>} 返回fileId
     */
    async storeAvatar(imageData, entityType, entityId) {
        await this.init();

        try {
            // 验证输入参数
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', '没有选择文件');
            }
            
            if (!entityType || !entityId) {
                throw new DetailedError('PARAM_MISSING', '缺少必要的参数');
            }

            // 检查文件大小（如果是File或Blob对象）
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', '文件大小超过10MB限制');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', '请选择图片文件');
                }
            }

            // 存储文件
            const result = await this.fileManager.storeFile(imageData, {
                type: 'avatar',
                entityType: entityType,
                entityId: entityId
            });

            // 创建引用关系
            await this.fileManager.createFileReference(
                result.fileId,
                `avatar_${entityType}`,
                entityId,
                {
                    originalType: entityType,
                    storedAt: new Date().toISOString()
                }
            );

            // 头像存储成功
            return result.fileId;

        } catch (error) {
            console.error(`存储${entityType}头像失败:`, error);
            console.error('详细错误信息:', {
                errorName: error.name,
                errorCode: error.code,
                errorMessage: error.message,
                originalError: error.originalError,
                stackTrace: error.stack,
                entityType: entityType,
                entityId: entityId,
                fileType: imageData instanceof File ? imageData.type : 'unknown',
                fileSize: imageData instanceof File ? imageData.size : 'unknown'
            });
            
            // 如果是我们自定义的DetailedError或者已经有code属性，直接抛出
            if (error instanceof DetailedError || error.name === 'DetailedError' || error.code) {
                throw error;
            }
            
            // 处理其他类型的错误
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', '存储空间不足，请清理数据后重试');
            }
            
            if (error.name === 'InvalidStateError' || (error.message &amp;&amp; error.message.includes('database'))) {
                throw new DetailedError('DATABASE_ERROR', '数据库操作失败，请刷新页面后重试');
            }
            
            if (error.message &amp;&amp; (error.message.includes('UnifiedDBManager未加载') || error.message.includes('FileStorageManager未加载'))) {
                throw new DetailedError('SYSTEM_ERROR', '文件存储系统未就绪，请刷新页面');
            }
            
            if (error.message &amp;&amp; error.message.includes('表不存在')) {
                throw new DetailedError('DATABASE_SCHEMA_ERROR', '数据库表结构不完整，请刷新页面重新初始化');
            }
            
            // 默认错误 - 提供更多调试信息
            const errorMsg = error.message || error.toString() || '未知错误';
            throw new DetailedError('UNKNOWN_ERROR', `头像上传失败: ${errorMsg}`);
        }
    }

    /**
     * 获取头像图片URL
     * @param {string} entityType - 实体类型（'user' 或 'contact'）
     * @param {string} entityId - 实体ID
     * @returns {Promise<string>} 返回图片URL，如果不存在返回空字符串
     */
    async getAvatarURL(entityType, entityId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(`avatar_${entityType}`, entityId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error(`获取${entityType}头像失败:`, error);
            return '';
        }
    }

    /**
     * 存储背景图片
     * @param {string|File|Blob} imageData - 图片数据
     * @param {string} backgroundId - 背景ID
     * @returns {Promise<string>} 返回fileId
     */
    async storeBackground(imageData, backgroundId) {
        await this.init();

        try {
            // 验证输入参数
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', '没有选择背景图片');
            }
            
            if (!backgroundId) {
                throw new DetailedError('PARAM_MISSING', '背景ID不能为空');
            }

            // 检查文件大小和类型
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 15 * 1024 * 1024; // 15MB（背景图片可以稍大）
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', '背景图片大小超过15MB限制');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', '请选择图片文件作为背景');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'background',
                backgroundId: backgroundId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'background',
                backgroundId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // 背景图片存储成功
            return result.fileId;

        } catch (error) {
            console.error('存储背景图片失败:', error);
            
            // 如果是我们自定义的DetailedError，直接抛出
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // 处理其他类型的错误
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', '存储空间不足，请清理数据后重试');
            }
            
            if (error.name === 'InvalidStateError' || error.message &amp;&amp; error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', '数据库操作失败，请刷新页面后重试');
            }
            
            if (error.message &amp;&amp; (error.message.includes('UnifiedDBManager未加载') || error.message.includes('FileStorageManager未加载'))) {
                throw new DetailedError('SYSTEM_ERROR', '文件存储系统未就绪，请刷新页面');
            }
            
            // 默认错误
            throw new DetailedError('UNKNOWN_ERROR', `背景图片上传失败: ${error.message || '未知错误'}`);
        }
    }

    /**
     * 获取背景图片URL
     * @param {string} backgroundId - 背景ID
     * @returns {Promise<string>} 返回图片URL
     */
    async getBackgroundURL(backgroundId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('background', backgroundId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('获取背景图片失败:', error);
            return '';
        }
    }

    /**
     * 存储表情包图片
     * @param {string|File|Blob} imageData - 图片数据
     * @param {string} emojiTag - 表情标签
     * @returns {Promise<string>} 返回fileId
     */
    async storeEmoji(imageData, emojiTag) {
        await this.init();

        try {
            // 验证输入参数
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', '没有选择表情包图片');
            }
            
            if (!emojiTag) {
                throw new DetailedError('PARAM_MISSING', '表情包标签不能为空');
            }

            // 检查文件大小和类型
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
                const maxSize = 5 * 1024 * 1024; // 5MB（表情包通常较小）
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', '表情包大小超过5MB限制');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', '请选择图片文件作为表情包');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'emoji',
                tag: emojiTag
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'emoji',
                emojiTag,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // 设置图片使用元数据 - 表情包分类
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'emoji',
                tags: [emojiTag],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`表情包存储成功并设置分类: ${emojiTag} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('存储表情包失败:', error);
            
            // 如果是我们自定义的DetailedError，直接抛出
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // 处理其他类型的错误
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', '存储空间不足，请清理数据后重试');
            }
            
            if (error.name === 'InvalidStateError' || error.message &amp;&amp; error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', '数据库操作失败，请刷新页面后重试');
            }
            
            if (error.message &amp;&amp; (error.message.includes('UnifiedDBManager未加载') || error.message.includes('FileStorageManager未加载'))) {
                throw new DetailedError('SYSTEM_ERROR', '文件存储系统未就绪，请刷新页面');
            }
            
            // 默认错误
            throw new DetailedError('UNKNOWN_ERROR', `表情包上传失败: ${error.message || '未知错误'}`);
        }
    }

    /**
     * 获取表情包图片URL
     * @param {string} emojiTag - 表情标签
     * @returns {Promise<string>} 返回图片URL
     */
    async getEmojiURL(emojiTag) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('emoji', emojiTag);
            if (!reference) {
                return '';
            }


            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('获取表情包失败:', error);
            return '';
        }
    }

    /**
     * 存储朋友圈图片
     * @param {string|File|Blob} imageData - 图片数据
     * @param {string} momentId - 朋友圈动态ID
     * @returns {Promise<string>} 返回fileId
     */
    async storeMomentImage(imageData, momentId) {
        await this.init();

        try {
            // 获取文件大小用于元数据
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'moment',
                momentId: momentId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'moment_image',
                momentId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // 设置朋友圈图片分类
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'moments',
                tags: ['朋友圈', momentId],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`朋友圈图片存储成功并设置分类: ${momentId} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('存储朋友圈图片失败:', error);
            throw error;
        }
    }

    /**
     * 获取朋友圈图片URL
     * @param {string} momentId - 朋友圈动态ID
     * @returns {Promise<string>} 返回图片URL
     */
    async getMomentImageURL(momentId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('moment_image', momentId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('获取朋友圈图片失败:', error);
            return '';
        }
    }

    /**
     * 存储朋友圈多图片
     * @param {Array} imageDataArray - 图片数据数组
     * @param {string} momentId - 朋友圈动态ID
     * @returns {Promise<Array>} 返回fileId数组
     */
    async storeMomentImages(imageDataArray, momentId) {
        await this.init();

        try {
            const fileIds = [];

            for (let i = 0; i < imageDataArray.length; i++) {
                const imageData = imageDataArray[i];
                
                // 获取文件大小
                let fileSize = 0;
                if (imageData instanceof File || imageData instanceof Blob) {
                    fileSize = imageData.size;
                }

                const result = await this.fileManager.storeFile(imageData, {
                    type: 'moment',
                    momentId: momentId,
                    imageIndex: i
                });

                await this.fileManager.createFileReference(
                    result.fileId,
                    'moment_image',
                    `${momentId}_${i}`, // 使用索引区分多张图片
                    {
                        storedAt: new Date().toISOString(),
                        imageIndex: i,
                        momentId: momentId
                    }
                );

                // 设置朋友圈图片分类
                await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                    category: 'moments',
                    tags: ['朋友圈', momentId, `图片${i + 1}`],
                    size: fileSize,
                    createdAt: new Date().toISOString()
                });

                fileIds.push(result.fileId);
            }

            console.log(`朋友圈多图片存储成功并设置分类: ${fileIds.length}张图片`);
            return fileIds;

        } catch (error) {
            console.error('存储朋友圈多图片失败:', error);
            throw error;
        }
    }

    /**
     * 获取朋友圈多图片URLs
     * @param {string} momentId - 朋友圈动态ID
     * @param {number} imageCount - 图片数量
     * @returns {Promise<Array>} 返回图片URL数组
     */
    async getMomentImagesURLs(momentId, imageCount) {
        await this.init();

        try {
            const urls = [];
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                const reference = await this.fileManager.getFileReference('moment_image', referenceKey);
                if (reference) {
                    const url = await this.fileManager.createFileURL(reference.fileId);
                    urls.push(url);
                } else {
                    console.warn(`朋友圈图片不存在: ${referenceKey}`);
                }
            }
            return urls;
        } catch (error) {
            console.error('获取朋友圈多图片失败:', error);
            return [];
        }
    }

    /**
     * 删除朋友圈所有图片
     * @param {string} momentId - 朋友圈动态ID
     * @param {number} imageCount - 图片数量
     */
    async deleteMomentImages(momentId, imageCount) {
        await this.init();

        try {
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                await this.deleteImage('moment_image', referenceKey);
            }
            console.log(`朋友圈图片删除成功: ${momentId}`);
        } catch (error) {
            console.error('删除朋友圈图片失败:', error);
            throw error;
        }
    }

    /**
     * 删除图片
     * @param {string} referenceType - 引用类型
     * @param {string} referenceKey - 引用键
     */
    async deleteImage(referenceType, referenceKey) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(referenceType, referenceKey);
            if (reference) {
                // 删除文件
                await this.fileManager.deleteFile(reference.fileId);
                // 删除引用
                await this.fileManager.deleteFileReference(referenceType, referenceKey);
                console.log(`图片删除成功: ${referenceType}/${referenceKey}`);
            }
        } catch (error) {
            console.error('删除图片失败:', error);
            throw error;
        }
    }

    /**
     * 批量迁移base64数据到Blob存储
     * @param {string} sourceType - 源数据类型（'avatars', 'backgrounds', 'emojis'）
     * @param {Array} dataArray - 要迁移的数据数组
     * @param {Function} progressCallback - 进度回调函数
     */
    async migrateBulkData(sourceType, dataArray, progressCallback = null) {
        await this.init();

        const results = {
            success: 0,
            failed: 0,
            errors: []
        };

        for (let i = 0; i < dataArray.length; i++) {
            const item = dataArray[i];
            
            try {
                if (progressCallback) {
                    progressCallback({
                        current: i + 1,
                        total: dataArray.length,
                        item: item,
                        type: sourceType
                    });
                }

                let fileId = null;

                switch (sourceType) {
                    case 'avatars':
                        if (item.avatar &amp;&amp; item.avatar.startsWith('data:')) {
                            const entityType = item.type || 'contact'; // 假设默认为contact
                            fileId = await this.storeAvatar(item.avatar, entityType, item.id);
                            // 清除原始base64数据
                            item.avatar = '';
                            item.avatarFileId = fileId;
                        }
                        break;

                    case 'backgrounds':
                        if (item.data &amp;&amp; item.data.startsWith('data:')) {
                            fileId = await this.storeBackground(item.data, item.id);
                            // 清除原始base64数据
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'emojis':
                        if (item.data &amp;&amp; item.data.startsWith('data:')) {
                            fileId = await this.storeEmoji(item.data, item.tag);
                            // 清除原始base64数据
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'moments':
                        if (item.image &amp;&amp; item.image.startsWith('data:')) {
                            fileId = await this.storeMomentImage(item.image, item.id);
                            // 清除原始base64数据
                            item.image = '';
                            item.imageFileId = fileId;
                        }
                        break;
                }

                if (fileId) {
                    results.success++;
                } else {
                    // 没有需要迁移的数据
                }

            } catch (error) {
                results.failed++;
                results.errors.push({
                    item: item,
                    error: error.message
                });
                console.error(`迁移数据失败 (${sourceType}):`, error, item);
            }
        }

        return results;
    }

    /**
     * 获取存储统计信息
     */
    async getStorageStats() {
        await this.init();
        return await this.fileManager.getStorageStats();
    }

    /**
     * 清理未使用的文件
     */
    async cleanupUnusedFiles() {
        await this.init();
        return await this.fileManager.cleanupUnusedFiles();
    }

    /**
     * 清理临时头像引用
     * 清理所有以 'temp_' 开头的头像引用
     */
    async cleanupTempAvatarReferences() {
        await this.init();
        
        try {
            // 获取所有头像引用
            const transaction = window.db.transaction(['fileReferences'], 'readwrite');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('avatar_contact');
            
            request.onsuccess = async () => {
                const references = request.result;
                const tempReferences = references.filter(ref => 
                    ref.referenceKey &amp;&amp; ref.referenceKey.startsWith('temp_')
                );
                
                console.log(`找到 ${tempReferences.length} 个临时头像引用，开始清理...`);
                
                for (const ref of tempReferences) {
                    try {
                        // 删除文件引用
                        await this.fileManager.deleteFileReference('avatar_contact', ref.referenceKey);
                        // 尝试删除对应的文件
                        if (ref.fileId) {
                            await this.fileManager.deleteFile(ref.fileId);
                        }
                        console.log(`清理临时引用: ${ref.referenceId}`);
                    } catch (error) {
                        console.warn(`清理临时引用失败: ${ref.referenceId}`, error);
                    }
                }
                
                console.log('临时头像引用清理完成');
            };
            
            request.onerror = () => {
                console.error('获取头像引用失败:', request.error);
            };
            
        } catch (error) {
            console.error('清理临时头像引用失败:', error);
        }
    }

    // === 图片分类管理方法 ===




    /**
     * 手动设置图片分类
     * @param {string} fileId - 文件ID
     * @param {string} usageType - 新的使用类型
     * @param {Object} metadata - 额外元数据
     */
    async setImageClassification(fileId, usageType, metadata = {}) {
        await this.init();
        return await this.fileManager.setImageUsageMetadata(fileId, usageType, metadata);
    }




    /**
     * 检查是否需要数据迁移
     */
    async needsMigration() {
        try {
            // 检查是否存在旧的base64数据
            if (!window.db || !window.isIndexedDBReady) {
                return false;
            }

            const transaction = window.db.transaction(['contacts', 'emojiImages', 'backgrounds', 'userProfile', 'moments'], 'readonly');
            
            // 检查contacts中是否有avatar base64数据
            const contactsStore = transaction.objectStore('contacts');
            const contactsRequest = contactsStore.getAll();
            
            return new Promise((resolve) => {
                contactsRequest.onsuccess = () => {
                    const contacts = contactsRequest.result;
                    const hasBase64Avatars = contacts.some(contact => 
                        contact.avatar &amp;&amp; contact.avatar.startsWith('data:')
                    );
                    
                    resolve(hasBase64Avatars);
                };
                
                contactsRequest.onerror = () => {
                    resolve(false);
                };
            });

        } catch (error) {
            console.error('检查迁移需求失败:', error);
            return false;
        }
    }

    /**
     * 存储banner图片
     * @param {string|File|Blob} imageData - 图片数据（base64字符串、File对象或Blob对象）
     * @param {string} bannerId - banner标识符
     * @returns {Promise<string>} 文件ID
     */
    async storeBanner(imageData, bannerId) {
        await this.init();
        
        try {
            console.log('开始存储banner图片，bannerId:', bannerId);
            
            // 处理不同类型的图片数据
            let blob;
            if (imageData instanceof Blob) {
                blob = imageData;
                console.log('处理Blob数据，大小:', blob.size);
            } else if (imageData instanceof File) {
                blob = imageData;
                console.log('处理File数据，大小:', blob.size);
            } else if (typeof imageData === 'string' &amp;&amp; imageData.startsWith('data:image/')) {
                // 处理base64数据
                blob = await this._base64ToBlob(imageData);
                console.log('处理base64数据，转换后大小:', blob.size);
            } else {
                throw new Error('不支持的图片数据格式');
            }

            // 存储文件
            const fileResult = await this.fileManager.storeFile(blob, 'image/jpeg');
            console.log('文件存储完成，结果:', fileResult);
            
            const fileId = fileResult.fileId; // 提取实际的文件ID字符串
            console.log('提取的文件ID字符串:', fileId);
            
            // 创建引用
            const referenceId = `banner_${bannerId}`;
            console.log('创建文件引用，引用ID:', referenceId, '文件ID:', fileId);
            await this.fileManager.createFileReference(fileId, 'banner', bannerId);
            
            console.log(`Banner图片存储成功: ${bannerId} -> ${fileId}`);
            return fileId;
            
        } catch (error) {
            console.error('存储banner图片失败:', error);
            throw error;
        }
    }

    /**
     * 获取banner图片URL
     * @param {string} bannerId - banner标识符
     * @returns {Promise<string|null>} 图片URL，如果不存在返回null
     */
    async getBannerURL(bannerId) {
        await this.init();
        
        try {
            console.log('查找banner，bannerId:', bannerId);
            const referenceResult = await this.fileManager.getFileReference('banner', bannerId);
            console.log('获取到的引用结果:', referenceResult);
            
            if (!referenceResult || !referenceResult.fileId) {
                console.log('未找到banner文件引用或文件ID');
                return null;
            }
            
            const fileId = referenceResult.fileId;
            console.log('提取的文件ID:', fileId);
            const url = await this.fileManager.createFileURL(fileId);
            console.log('生成的banner URL:', url);
            return url;
            
        } catch (error) {
            console.error('获取banner图片URL失败:', error);
            return null;
        }
    }

    /**
     * 将base64转换为Blob
     * @private
     */
    async _base64ToBlob(base64) {
        try {
            const [header, data] = base64.split(',');
            const mimeType = header.match(/data:(.+?);/)[1];
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('base64转Blob失败:', error);
            throw new Error('base64数据格式错误');
        }
    }
}

// === 文件上传处理函数 ===

/**
 * 通用文件上传函数
 */
async function handleFileUpload(inputId, targetUrlInputId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);
    const targetUrlInput = document.getElementById(targetUrlInputId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    // 使用 FileReader 将图片转为 Base64
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
        targetUrlInput.value = reader.result;
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('图片已加载');
    };
    reader.onerror = (error) => {
        console.error('文件读取失败:', error);
        if (statusElement) statusElement.textContent = '读取失败';
        if (typeof showToast === 'function') showToast(`读取失败: ${error.message}`);
    };
}

/**
 * 处理头像上传
 */
async function handleAvatarUpload(inputId, entityType, entityId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    try {
        // 使用新的文件系统存储头像
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI 未初始化');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeAvatar(file, entityType, entityId);
        
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('头像已保存', 'success');
        
        // 返回文件ID用于后续处理
        return fileId;
    } catch (error) {
        console.error('头像上传失败:', error);
        if (statusElement) statusElement.textContent = '上传失败';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * 处理背景图片上传
 */
async function handleBackgroundUpload(inputId, contactId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    try {
        // 使用新的文件系统存储背景图片
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI 未初始化');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeBackground(file, contactId);
        
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('背景图片已保存', 'success');
        
        // 返回文件ID用于后续处理
        return fileId;
    } catch (error) {
        console.error('背景图片上传失败:', error);
        if (statusElement) statusElement.textContent = '上传失败';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * 处理表情包上传
 */
async function handleEmojiUpload(inputId, emojiTag, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    try {
        // 使用新的文件系统存储表情包
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI 未初始化');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('表情包已保存', 'success');
        
        // 返回文件ID用于后续处理
        return fileId;
    } catch (error) {
        console.error('表情包上传失败:', error);
        if (statusElement) statusElement.textContent = '上传失败';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

// 全局变量存储临时上传的表情包文件
let tempEmojiFile = null;

/**
 * 处理表情包文件上传
 */
async function handleEmojiFileUpload(event) {
    try {
        const fileInput = document.getElementById('emojiUploadInput');
        const file = fileInput.files[0];
        
        if (!file) {
            if (typeof showToast === 'function') showToast('请先选择一个文件');
            return;
        }
        
        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('请上传图片文件');
            return;
        }
        
        // 简单存储文件对象，等待保存时处理
        tempEmojiFile = file;
        window.ImageUploadHandlers.tempEmojiFile = file;  // 同步更新到暴露的对象中
        
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = '图片已选择';
            statusElement.style.color = '#07c160';
        }
        
        // 生成临时URL用于预览
        const tempUrl = URL.createObjectURL(file);
        document.getElementById('emojiUrl').value = `temp:${tempUrl}`;
        
        if (typeof showToast === 'function') showToast('图片已选择，填写意思后点击添加');
        
    } catch (error) {
        console.error('表情包文件选择失败:', error);
        if (typeof showToast === 'function') showToast('文件选择失败，请重试');
    }
}

/**
 * 使用文件系统存储表情包的辅助函数
 */
async function storeEmojiWithMeaning(file, emojiTag, statusElement) {
    try {
        if (statusElement) statusElement.textContent = '正在存储...';
        
        // 直接传递File对象给ImageStorageAPI，让它处理数据类型转换
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (fileId) {
            document.getElementById('emojiUrl').value = `file:${fileId}`;
            
            if (statusElement) {
                statusElement.textContent = '存储成功';
                statusElement.style.color = '#07c160';
            }
            
            return fileId;
        } else {
            throw new Error('存储返回空的文件ID');
        }
    } catch (error) {
        console.error('表情包存储失败:', error);
        if (statusElement) {
            statusElement.textContent = '存储失败';
            statusElement.style.color = '#ff3b30';
        }
        if (typeof showToast === 'function') showToast('存储失败: ' + error.message);
        throw error;
    }
}

/**
 * 特定的上传处理函数 - 联系人头像
 */
async function handleContactAvatarUpload(event, editingContact) {
    try {
        const fileInput = document.getElementById('avatarUploadInput');
        const file = fileInput.files[0];
        const statusElement = document.getElementById('avatarUploadStatus');

        if (!file) {
            if (typeof showToast === 'function') showToast('请先选择一个文件');
            return;
        }

        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('请上传图片文件');
            fileInput.value = '';
            return;
        }

        if (editingContact) {
            // 编辑模式：立即上传和保存
            const contactId = editingContact.id;

            // 如果之前有头像，先删除旧的文件引用
            if (editingContact.avatarFileId) {
                try {
                    if (window.ImageStorageAPI) {
                        await window.ImageStorageAPI.deleteImage(`avatar_contact`, contactId);
                    }
                } catch (deleteError) {
                    console.warn('删除旧头像失败，继续上传新头像:', deleteError);
                }
            }

            const fileId = await handleAvatarUpload('avatarUploadInput', 'contact', contactId, 'avatarUploadStatus');

            if (fileId) {
                document.getElementById('contactAvatar').value = `file:${fileId}`;
                editingContact.avatarFileId = fileId;
                editingContact.avatar = '';

                // 同步更新当前联系人对象
                if (window.currentContact &amp;&amp; window.currentContact.id === contactId) {
                    window.currentContact.avatarFileId = fileId;
                    window.currentContact.avatar = '';
                }

                // 刷新UI显示
                if (window.ImageDisplayHelper) {
                    window.ImageDisplayHelper.clearCacheByType(`avatar_contact_${contactId}`);
                }

                if (typeof renderContactList === 'function') {
                    try {
                        await renderContactList();
                    } catch (error) {
                        console.warn('刷新联系人列表失败:', error);
                    }
                }
            }
        } else {
            // 新建模式：类似emoji的临时存储
            window.tempContactAvatarFile = file;

            // 生成临时URL用于预览
            const tempUrl = URL.createObjectURL(file);
            document.getElementById('contactAvatar').value = `temp:${tempUrl}`;

            if (statusElement) {
                statusElement.textContent = '头像已选择';
                statusElement.style.color = '#07c160';
            }

            if (typeof showToast === 'function') showToast('头像已选择，填写完信息后点击确定');
        }

    } catch (error) {
        console.error('联系人头像处理失败:', error);
        const statusElement = document.getElementById('avatarUploadStatus');
        if (statusElement) {
            statusElement.textContent = '处理失败';
            statusElement.style.color = '#ff3b30';
        }
    }
}

/**
 * 特定的上传处理函数 - 用户头像
 */
async function handleProfileAvatarUpload(event) {
    try {
        const fileId = await handleAvatarUpload('profileUploadInput', 'user', 'profile', 'profileUploadStatus');
        
        if (fileId) {
            // 更新隐藏的URL输入框为文件ID引用
            document.getElementById('profileAvatarInput').value = `file:${fileId}`;
            
            // 清理头像缓存
            if (window.ImageDisplayHelper) {
                window.ImageDisplayHelper.clearCacheByType('avatar_user_');
            }
            
            // 设置持久状态提示
            const statusElement = document.getElementById('profileUploadStatus');
            if (statusElement) {
                statusElement.textContent = '已上传';
                statusElement.style.color = '#07c160';
            }
            
            // 立即更新UI
            if (typeof updateUserProfileUI === 'function') {
                await updateUserProfileUI();
            }
        }
    } catch (error) {
        console.error('个人头像上传失败:', error);
    }
}

/**
 * 特定的上传处理函数 - 背景图片
 */
async function handleBgUpload(event) {
    try {
        // 从全局变量获取currentContact
        const currentContact = window.currentContact;
        if (!currentContact) {
            if (typeof showToast === 'function') showToast('请先选择联系人');
            return;
        }
        
        const fileId = await handleBackgroundUpload('bgUploadInput', currentContact.id, 'bgUploadStatus');
        
        if (fileId) {
            // 更新隐藏的URL输入框为文件ID引用
            document.getElementById('backgroundUrl').value = `file:${fileId}`;
        }
    } catch (error) {
        console.error('背景图片上传失败:', error);
    }
}

// 创建全局实例
const imageStorageAPI = new ImageStorageAPI();

// 导出到window对象
window.ImageStorageAPI = imageStorageAPI;

// 创建命名空间并暴露上传处理函数
window.ImageUploadHandlers = {
    handleFileUpload,
    handleAvatarUpload,
    handleBackgroundUpload,
    handleEmojiUpload,
    handleEmojiFileUpload,
    storeEmojiWithMeaning,
    handleContactAvatarUpload,
    handleProfileAvatarUpload,
    handleBgUpload,
    tempEmojiFile
};

// 为了向后兼容，保留主要的全局引用
// TODO: Remove these global assignments once all code is updated to use ImageUploadHandlers.
window.handleContactAvatarUpload = handleContactAvatarUpload;
window.handleProfileAvatarUpload = handleProfileAvatarUpload;

// 图片存储API已加载
</script>
    <script>
/**
 * 图片显示帮助工具
 * 提供向后兼容的图片URL获取功能，支持新的文件存储系统和旧的base64格式
 */

class ImageDisplayHelper {
    constructor() {
        this.urlCache = new Map();
        this.imageAPI = null;
    }

    /**
     * 初始化
     */
    async init() {
        if (!this.imageAPI &amp;&amp; window.ImageStorageAPI) {
            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
        }
    }

    /**
     * 获取头像URL（支持联系人和用户）
     * @param {Object} entity - 联系人或用户对象
     * @param {string} entityType - 'contact' 或 'user'
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getAvatarURL(entity, entityType = 'contact') {
        if (!entity) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (entity.avatarFileId &amp;&amp; this.imageAPI) {
                // 为用户类型使用固定的id，因为用户对象通常没有id字段
                const entityId = entityType === 'user' ? 'profile' : entity.id;
                const cacheKey = `avatar_${entityType}_${entityId}`;
                
                // 检查缓存，但如果有新的avatarFileId，先清理旧缓存
                if (this.urlCache.has(cacheKey)) {
                    const cachedUrl = this.urlCache.get(cacheKey);
                    // 获取当前实际的文件引用，检查是否有变化
                    const currentReference = await this.imageAPI.getAvatarURL(entityType, entityId);
                    if (currentReference &amp;&amp; currentReference !== cachedUrl) {
                        // 文件引用已变化，清理旧缓存
                        URL.revokeObjectURL(cachedUrl);
                        this.urlCache.delete(cacheKey);
                    } else if (cachedUrl) {
                        return cachedUrl;
                    }
                }
                
                const url = await this.imageAPI.getAvatarURL(entityType, entityId);
                if (url) {
                    this.urlCache.set(cacheKey, url);
                }
                return url;
            }
            
            // 回退到旧的base64格式
            if (entity.avatar &amp;&amp; entity.avatar.startsWith('data:')) {
                return entity.avatar;
            }
            
            return '';
            
        } catch (error) {
            console.warn(`获取${entityType}头像失败:`, error);
            // 回退到旧格式
            return entity.avatar || '';
        }
    }

    /**
     * 获取背景图片URL
     * @param {Object} background - 背景对象
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getBackgroundURL(background) {
        if (!background) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (background.fileId &amp;&amp; this.imageAPI) {
                const cacheKey = `background_${background.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getBackgroundURL(background.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // 回退到旧格式
            if (background.data &amp;&amp; background.data.startsWith('data:')) {
                return background.data;
            }
            
            return background.url || '';
            
        } catch (error) {
            console.warn('获取背景图片失败:', error);
            return background.data || background.url || '';
        }
    }

    /**
     * 获取表情包URL
     * @param {Object} emoji - 表情包对象
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getEmojiURL(emoji) {
        if (!emoji) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (emoji.fileId &amp;&amp; this.imageAPI) {
                const cacheKey = `emoji_${emoji.tag}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getEmojiURL(emoji.tag);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // 回退到旧格式
            if (emoji.data &amp;&amp; emoji.data.startsWith('data:')) {
                return emoji.data;
            }
            
            return emoji.url || '';
            
        } catch (error) {
            console.warn('获取表情包失败:', error);
            return emoji.data || emoji.url || '';
        }
    }

    /**
     * 获取朋友圈图片URL
     * @param {Object} moment - 朋友圈动态对象
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getMomentImageURL(moment) {
        if (!moment) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (moment.imageFileId &amp;&amp; this.imageAPI) {
                const cacheKey = `moment_${moment.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getMomentImageURL(moment.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // 回退到旧格式
            if (moment.image &amp;&amp; moment.image.startsWith('data:')) {
                return moment.image;
            }
            
            return moment.imageUrl || '';
            
        } catch (error) {
            console.warn('获取朋友圈图片失败:', error);
            return moment.image || moment.imageUrl || '';
        }
    }

    /**
     * 创建头像HTML元素（向后兼容）
     * @param {Object} entity - 联系人或用户对象  
     * @param {string} entityType - 'contact' 或 'user'
     * @param {string} className - CSS类名（可选）
     * @returns {Promise<string>} 返回HTML字符串
     */
    async createAvatarHTML(entity, entityType = 'contact', className = '') {
        if (!entity) return '';
        
        const avatarURL = await this.getAvatarURL(entity, entityType);
        const classAttr = className ? ` class=&quot;${className}&quot;` : '';
        
        if (avatarURL) {
            return `<img src=&quot;${avatarURL}&quot;${classAttr}>`;
        } else {
            // 使用首字符作为默认头像
            const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? '我' : '?');
            return `<span${classAttr}>${firstChar}</span>`;
        }
    }

    /**
     * 清理URL缓存
     */
    clearCache() {
        this.urlCache.clear();
    }

    /**
     * 清理特定类型的缓存
     * @param {string} type - 缓存类型前缀（如 'avatar_', 'background_'）
     */
    clearCacheByType(type) {
        for (const [key, url] of this.urlCache) {
            if (key.startsWith(type)) {
                // 释放Blob URL以防止内存泄漏
                if (url &amp;&amp; url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
                this.urlCache.delete(key);
            }
        }
    }
}

// 创建全局实例
const imageDisplayHelper = new ImageDisplayHelper();

// 导出到window对象
window.ImageDisplayHelper = imageDisplayHelper;

// 图片显示帮助工具已加载
</script>
    
    <link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;>
    <link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin>
    <link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;display=swap&quot; rel=&quot;stylesheet&quot;>
    <style>
        :root {
            --blur-value: 12px;
            --body-bg: #fdf2f8;
            --glass-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.2));
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-shadow: rgba(236, 72, 153, 0.25);
            --text-primary: #831843;
            --text-secondary: #be185d;
            --accent-color: #ec4899;
            --accent-gradient: linear-gradient(135deg, #fb7185, #ec4899);
            --char-bubble-bg: #ffffff;
            --char-bubble-text: #1f2937;
            --control-bg: rgba(255, 255, 255, 0.3);
            --control-bg-active: #ffffff;
            --list-hover-bg: rgba(255, 255, 255, 0.7);
        }
        body.theme-blue-purple {
            --body-bg: #37306B; --glass-bg: linear-gradient(135deg, rgba(173, 169, 217, 0.25), rgba(94, 91, 142, 0.1));
            --glass-border: rgba(255, 255, 255, 0.1); --glass-shadow: rgba(27, 24, 64, 0.4);
            --text-primary: #E0E7FF; --text-secondary: #C7D2FE; --accent-color: #818cf8;
            --accent-gradient: linear-gradient(135deg, #a5b4fc, #818cf8); --char-bubble-bg: rgba(255,255,255,0.1);
            --char-bubble-text: #E0E7FF; --control-bg: rgba(255, 255, 255, 0.1);
            --control-bg-active: rgba(255, 255, 255, 0.3); --list-hover-bg: rgba(255, 255, 255, 0.2);
        }
        body.theme-black-white {
            --body-bg: #111827; --glass-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            --glass-border: rgba(255, 255, 255, 0.15); --glass-shadow: rgba(0, 0, 0, 0.5);
            --text-primary: #f3f4f6; --text-secondary: #d1d5db; --accent-color: #f9fafb;
            --accent-gradient: linear-gradient(135deg, #9ca3af, #6b7280); --char-bubble-bg: rgba(255,255,255,0.1);
            --char-bubble-text: #f3f4f6; --control-bg: rgba(255, 255, 255, 0.1);
            --control-bg-active: rgba(255, 255, 255, 0.2); --list-hover-bg: rgba(255, 255, 255, 0.15);
        }
        html, body { height: 100%; overflow: hidden; font-family: 'Noto Sans SC', sans-serif; background-color: var(--body-bg); transition: background-color 0.5s ease; }
        #main-container { background-size: cover; background-position: center; height: 100%; width: 100%; position: relative; }
        #image-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-size: contain; background-position: center; touch-action: none; background-repeat: no-repeat; }
        .touch-zone { position: absolute; border: 2px dashed rgba(255, 255, 255, 0.7); background-color: rgba(29, 78, 216, 0.4); color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; user-select: none; text-shadow: 1px 1px 2px black; border-radius: 8px; box-sizing: border-box; transition: background-color 0.2s, border-color 0.2s; cursor: move; }
        .resize-handle, .rotate-handle, .delete-zone-btn { position: absolute; background-color: rgba(255, 255, 255, 0.8); border: 1px solid #333; border-radius: 50%; display: none; box-sizing: border-box; z-index: 10; }
        .resize-handle { width: 16px; height: 16px; right: -8px; bottom: -8px; cursor: se-resize; }
        .rotate-handle { width: 16px; height: 16px; left: 50%; top: -20px; transform: translateX(-50%); cursor: alias; }
        .rotate-handle::before { content: ''; position: absolute; width: 1px; height: 12px; background: #333; left: 50%; top: -12px; }
        .delete-zone-btn { width: 20px; height: 20px; right: -10px; top: -10px; cursor: pointer; display: none; align-items: center; justify-content: center; background-color: #ef4444; color: white; font-weight: bold; line-height: 18px; }
        #image-container.edit-mode .touch-zone { border-color: rgba(255, 255, 255, 0.7); cursor: move; }
        #image-container.edit-mode .touch-zone:hover { border-style: solid; }
        #image-container.edit-mode .resize-handle, #image-container.edit-mode .rotate-handle, #image-container.edit-mode .delete-zone-btn { display: flex; }
        #image-container.use-mode .touch-zone { background-color: transparent; border-color: transparent; color: transparent; text-shadow: none; cursor: pointer; z-index: 25; }
        .glassmorphism { background: var(--glass-bg); backdrop-filter: blur(var(--blur-value)); -webkit-backdrop-filter: blur(var(--blur-value)); border: 1px solid var(--glass-border); box-shadow: 0 8px 32px 0 var(--glass-shadow); transition: background 0.5s ease, border 0.5s ease, box-shadow 0.5s ease; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem; }
        .chat-bubble { max-width: 75%; padding: 0.5rem 0.75rem; border-radius: 1rem; word-break: break-word; }
        .chat-bubble-user { background: var(--accent-gradient); color: white; border-bottom-right-radius: 0.25rem; }
        .chat-bubble-char { background-color: var(--char-bubble-bg); color: var(--char-bubble-text); border: 1px solid var(--glass-border); }
        .theme-selector div { cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s; }
        .theme-selector div.selected { border-color: var(--accent-color); }
        .button-gradient { background: var(--accent-gradient); transition: filter 0.2s ease-in-out; }
        .button-gradient:hover { filter: brightness(1.1); }
        .segmented-control { display: flex; background-color: var(--control-bg); border-radius: 9px; padding: 3px; width: 100%; }
        .settings-tab { flex: 1; text-align: center; padding: 6px 4px; border-radius: 7px; font-weight: 500; cursor: pointer; color: var(--text-secondary); transition: background-color 0.3s, color 0.3s; border-bottom: none; }
        .settings-tab.active { background-color: var(--control-bg-active); color: var(--text-primary); box-shadow: 0 1px 4px rgba(0,0,0,0.1); }
        select { color: #1f2937; }
        select option { background-color: #ffffff; color: #111827; }
        #floating-pomodoro-display { position: absolute; top: 1rem; left: 1rem; z-index: 20; pointer-events: none; display: none; flex-direction: column; gap: 0.5rem; }
        .floating-timer-block { padding: 0.5rem 1rem; border-radius: 0.75rem; min-width: 200px; }
        .floating-timer-block .task-name { font-weight: bold; font-size: 0.875rem; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-shadow: 0 0 4px rgba(0,0,0,0.5); }
        .floating-timer-block .time { font-family: 'Noto Sans SC', sans-serif, monospace; font-size: 1.5rem; line-height: 2rem; color: var(--text-primary); text-shadow: 0 0 4px rgba(0,0,0,0.5); }
        #char-pomodoro-display, #user-pomodoro-display { text-shadow: 0 0 8px rgba(0, 0, 0, 0.3); }
        .diary-list-item { cursor: pointer; padding: 0.75rem 0.5rem; border-radius: 0.5rem; transition: background-color 0.2s; }
        .diary-list-item:hover { background-color: var(--list-hover-bg); }
        #diary-list-panel { transform: translateX(-100%); transition: transform 0.3s ease-in-out; box-shadow: 4px 0px 15px rgba(0,0,0,0.2); }
        #diary-modal.panel-open #diary-list-panel { transform: translateX(0); }
        #diary-panel-overlay { transition: opacity 0.3s ease-in-out; }
    </style>
    <!-- Analytics -->
    <script defer src=&quot;https://umami.whale-llt.top/script.js&quot; data-website-id=&quot;00c95749-7c0d-4333-9ec1-2ad2701799a3&quot;></script>
</head>
<body class=&quot;theme-pink-white&quot;>

    <audio id=&quot;tts-audio-player&quot; class=&quot;hidden&quot;></audio>

    <div id=&quot;main-container&quot;>
        <div id=&quot;image-container&quot; class=&quot;edit-mode&quot;>
            <div id=&quot;upload-prompt&quot; class=&quot;absolute inset-0 flex items-center justify-center text-gray-600 pointer-events-none text-center p-4&quot;>
                <p class=&quot;text-[var(--text-secondary)]&quot;>点击右下角设定按钮 (⚙️)<br>开始配置</p>
            </div>
        </div>
    </div>
    
    <div id=&quot;floating-pomodoro-display&quot;>
        <div id=&quot;floating-char-timer&quot; class=&quot;glassmorphism floating-timer-block hidden&quot;>
            <p class=&quot;task-name&quot; id=&quot;floating-char-task-name&quot;>角色的任务</p>
            <p class=&quot;time&quot; id=&quot;floating-char-time&quot;>25:00</p>
        </div>
        <div id=&quot;floating-user-timer&quot; class=&quot;glassmorphism floating-timer-block hidden&quot;>
            <p class=&quot;task-name&quot; id=&quot;floating-user-task-name&quot;>你的任务</p>
            <p class=&quot;time&quot; id=&quot;floating-user-time&quot;>25:00</p>
        </div>
    </div>

    <div id=&quot;top-right-selectors&quot; class=&quot;absolute top-4 right-4 z-20 flex flex-col space-y-2 items-end&quot;>
        <select id=&quot;active-character-select&quot; class=&quot;glassmorphism w-48 px-3 py-2 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-[var(--accent-color)]&quot;></select>
    </div>

    <footer id=&quot;dialogue-box-container&quot; class=&quot;fixed left-0 right-0 p-4 z-20&quot; style=&quot;bottom: 60px;&quot;>
        <div id=&quot;dialogue-box&quot; class=&quot;glassmorphism w-full h-24 p-3 rounded-2xl overflow-y-auto&quot;>
            <p id=&quot;dialogue-text&quot; class=&quot;text-[var(--text-primary)]&quot;>角色将会在这里回应...</p>
        </div>
    </footer>

    <div class=&quot;absolute bottom-28 right-4 z-30 flex flex-col items-center space-y-3&quot;>
        <button id=&quot;chat-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;><path fill-rule=&quot;evenodd&quot; d=&quot;M18 5v8a2 2 0 01-2 2h-5l-5 4v-4H4a2 2 0 01-2-2V5a2 2 0 012-2h12a2 2 0 012 2zM7 8H5v2h2V8zm2 0h2v2H9V8zm6 0h-2v2h2V8z&quot; clip-rule=&quot;evenodd&quot; /></svg></button>
        <button id=&quot;diary-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;><path d=&quot;M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z&quot; /></svg></button>
        <button id=&quot;pomodoro-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z&quot; /></svg></button>
        <div class=&quot;flex items-center glassmorphism p-2 rounded-full shadow-lg space-x-2&quot;>
            <label for=&quot;mode-toggle&quot; class=&quot;relative inline-flex items-center cursor-pointer&quot;>
                <input type=&quot;checkbox&quot; id=&quot;mode-toggle&quot; class=&quot;sr-only peer&quot; checked>
                <div class=&quot;w-11 h-6 bg-gray-400 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--accent-color)]&quot;></div>
            </label>
        </div>
        <button id=&quot;settings-btn&quot; class=&quot;glassmorphism text-[var(--text-primary)] p-3 rounded-full shadow-lg&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot; /><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot; /></svg></button>
    </div>

    <div id=&quot;settings-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div class=&quot;glassmorphism rounded-2xl p-4 w-full max-w-lg max-h-[90vh] overflow-y-auto relative flex flex-col&quot;>
            <div class=&quot;flex-shrink-0 mb-4&quot;>
                <nav class=&quot;segmented-control&quot;>
                    <button data-tab=&quot;scene-settings-tab&quot; class=&quot;settings-tab active&quot;>场景设置</button>
                    <button data-tab=&quot;touch-settings-tab&quot; class=&quot;settings-tab&quot;>互动区域</button>
                    <button data-tab=&quot;theme-settings-tab&quot; class=&quot;settings-tab&quot;>主题与语音</button>
                </nav>
            </div>
            <div id=&quot;settings-content&quot; class=&quot;flex-grow overflow-y-auto pr-2&quot;></div>
            <button id=&quot;close-settings-modal-btn&quot; class=&quot;absolute top-4 right-4 text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-3xl&quot;>&amp;times;</button>
        </div>
    </div>
    
    <div id=&quot;chat-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div class=&quot;glassmorphism rounded-2xl w-full max-w-lg h-[90vh] flex flex-col p-4&quot;>
            <div class=&quot;flex-shrink-0 flex justify-between items-center border-b border-[var(--glass-border)] pb-2 mb-2&quot;>
                <h2 class=&quot;text-xl font-bold text-[var(--text-primary)]&quot;>聊天</h2>
                <div class=&quot;flex items-center space-x-4&quot;>
                    <button id=&quot;clear-chat-btn&quot; class=&quot;bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-sm&quot;>清除记录</button>
                    <button id=&quot;close-chat-modal-btn&quot; class=&quot;text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-2xl&quot;>&amp;times;</button>
                </div>
            </div>
            <div id=&quot;chat-history&quot; class=&quot;flex-grow overflow-y-auto space-y-4 p-2&quot;></div>
            <div class=&quot;flex-shrink-0 mt-2 flex space-x-2&quot;>
                <input type=&quot;text&quot; id=&quot;chat-input&quot; class=&quot;flex-grow bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 focus:outline-none text-[var(--text-primary)] placeholder-[var(--text-secondary)]&quot; placeholder=&quot;输入消息...&quot;>
                <button id=&quot;chat-send-btn&quot; class=&quot;button-gradient text-white px-4 py-2 rounded-lg&quot;>发送</button>
            </div>
        </div>
    </div>
    
    <div id=&quot;diary-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div id=&quot;diary-main-content&quot; class=&quot;w-full max-w-2xl h-auto max-h-[90vh] flex flex-col glassmorphism rounded-2xl relative overflow-hidden&quot;>
             <div class=&quot;flex-shrink-0 flex items-center justify-between border-b border-[var(--glass-border)] p-4&quot;>
                 <button id=&quot;show-diary-panel-btn&quot; class=&quot;text-[var(--text-primary)] p-2 rounded-full hover:bg-black/10&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M4 6h16M4 12h16M4 18h16&quot; /></svg></button>
                 <h2 id=&quot;diary-title&quot; class=&quot;text-xl font-bold text-[var(--text-primary)] text-center flex-grow mx-4&quot;>角色日记</h2>
                 <div class=&quot;flex items-center space-x-2&quot;>
                    <button id=&quot;generate-diary-btn&quot; class=&quot;text-[var(--text-primary)] p-2 rounded-full hover:bg-black/10&quot;><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;><path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M4 4v5h5M20 20v-5h-5M4 4l16 16&quot; /></svg></button>
                    <button id=&quot;close-diary-modal-btn&quot; class=&quot;text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-3xl&quot;>&amp;times;</button>
                 </div>
             </div>
             <div id=&quot;diary-content-wrapper&quot; class=&quot;flex-grow overflow-y-auto p-6&quot;>
                 <div id=&quot;diary-content&quot; class=&quot;text-[var(--text-primary)] whitespace-pre-wrap leading-relaxed&quot;>请在左侧选择一篇日记查看，或生成今日日记。</div>
             </div>
        </div>
        <div id=&quot;diary-panel-overlay&quot; class=&quot;hidden absolute inset-0 bg-black/30 z-10&quot;></div>
        <div id=&quot;diary-list-panel&quot; class=&quot;absolute top-0 left-0 h-full w-full max-w-xs glassmorphism p-4 z-20 flex flex-col space-y-4&quot;>
             <h3 class=&quot;text-xl font-bold text-[var(--text-primary)] border-b border-[var(--glass-border)] pb-2&quot;>日记列表</h3>
             <div id=&quot;diary-list&quot; class=&quot;flex-grow overflow-y-auto text-[var(--text-primary)] space-y-1&quot;></div>
        </div>
    </div>
    
    <div id=&quot;pomodoro-modal&quot; class=&quot;modal-overlay hidden&quot;>
        <div class=&quot;glassmorphism rounded-2xl w-full max-w-lg h-auto flex flex-col p-6 space-y-4&quot;>
            <div class=&quot;flex justify-between items-center border-b border-[var(--glass-border)] pb-3 mb-3&quot;>
                 <h2 class=&quot;text-2xl font-bold text-[var(--text-primary)]&quot;>番茄钟</h2>
                 <button id=&quot;close-pomodoro-modal-btn&quot; class=&quot;text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-3xl&quot;>&amp;times;</button>
            </div>
            <div class=&quot;p-4 rounded-lg border border-[var(--glass-border)] space-y-3&quot;>
                <h3 class=&quot;font-bold text-lg text-[var(--text-primary)]&quot;>角色的任务</h3>
                <div class=&quot;text-center&quot;>
                    <p id=&quot;char-pomodoro-display&quot; class=&quot;text-5xl font-mono text-[var(--text-primary)]&quot;>25:00</p>
                    <p id=&quot;char-task-display&quot; class=&quot;text-sm text-[var(--text-secondary)] mt-1&quot;>未开始</p>
                </div>
                <div class=&quot;flex flex-col sm:flex-row gap-2&quot;>
                    <input type=&quot;text&quot; id=&quot;char-task-input&quot; class=&quot;flex-grow bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]&quot; placeholder=&quot;任务名称 (例如: 看书)&quot;>
                    <input type=&quot;number&quot; id=&quot;char-duration-input&quot; class=&quot;w-24 bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)]&quot; placeholder=&quot;分钟&quot; value=&quot;25&quot;>
                    <button id=&quot;char-pomodoro-btn&quot; class=&quot;button-gradient text-white px-4 py-2 rounded-lg&quot;>开始</button>
                </div>
            </div>
            <div class=&quot;p-4 rounded-lg border border-[var(--glass-border)] space-y-3&quot;>
                <h3 class=&quot;font-bold text-lg text-[var(--text-primary)]&quot;>你的任务</h3>
                <div class=&quot;text-center&quot;>
                    <p id=&quot;user-pomodoro-display&quot; class=&quot;text-5xl font-mono text-[var(--text-primary)]&quot;>25:00</p>
                    <p id=&quot;user-task-display&quot; class=&quot;text-sm text-[var(--text-secondary)] mt-1&quot;>未开始</p>
                </div>
                <div class=&quot;flex flex-col sm:flex-row gap-2&quot;>
                    <input type=&quot;text&quot; id=&quot;user-task-input&quot; class=&quot;flex-grow bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]&quot; placeholder=&quot;任务名称 (例如: 写代码)&quot;>
                    <input type=&quot;number&quot; id=&quot;user-duration-input&quot; class=&quot;w-24 bg-white/30 border border-gray-300/50 rounded-lg px-3 py-2 text-[var(--text-primary)]&quot; placeholder=&quot;分钟&quot; value=&quot;25&quot;>
                    <button id=&quot;user-pomodoro-btn&quot; class=&quot;button-gradient text-white px-4 py-2 rounded-lg&quot;>开始</button>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // =========================================================================
    // 数据库访问统一管理 - 使用主应用的数据库系统
    // =========================================================================
    
    // 互动界面数据管理助手
    const interactiveDataHelper = {
        // 等待主应用数据库准备就绪
        // 🔥 简化的数据库初始化 - 使用统一数据库管理器
        async ensureReady() {
            if (this.isReady) {
                return;
            }

            console.log('🔥 [interact.html] 使用统一数据库管理器等待数据库就绪...');
            
            try {
                // 使用统一数据库管理器等待数据库就绪
                await window.UnifiedDBManager.waitForReady(8000);
                
                console.log('🔥 [interact.html] 数据库状态确认:', {
                    isReady: window.isIndexedDBReady,
                    dbExists: !!window.db,
                    dbVersion: window.db?.version
                });
                
                this.isReady = true;
                console.log('🔥 [interact.html] 互动界面数据库助手已就绪');
                
            } catch (error) {
                console.error('🔥 [interact.html] 数据库初始化失败:', error);
                alert('数据库初始化失败，请刷新页面重试');
                throw error;
            }
        },

        // 获取单个联系人数据
        async getContact(contactName) {
            await this.ensureReady();
            return await window.ensureDBReady(async () => {
                const transaction = window.db.transaction(['contacts'], 'readonly');
                const store = transaction.objectStore('contacts');
                const contacts = await window.promisifyRequest(store.getAll(), '获取联系人列表');
                return contacts.find(c => c.name === contactName);
            }, `获取联系人 ${contactName}`);
        },

        // 获取所有联系人数据
        async getAllContacts() {
            await this.ensureReady();
            return await window.ensureDBReady(async () => {
                const transaction = window.db.transaction(['contacts'], 'readonly');
                const store = transaction.objectStore('contacts');
                return await window.promisifyRequest(store.getAll(), '获取所有联系人');
            }, '获取联系人列表');
        },

        // 更新联系人数据
        async updateContact(contactData) {
            await this.ensureReady();
            return await window.ensureDBReady(async () => {
                const transaction = window.db.transaction(['contacts'], 'readwrite');
                const store = transaction.objectStore('contacts');
                return await window.promisifyRequest(store.put(contactData), `更新联系人 ${contactData.name}`);
            }, `保存联系人数据 ${contactData.name}`);
        }
    };


    // --- 接收父窗口数据 ---
    let parentAppSettings = null; 

    // --- 数据同步处理 ---
    async function handleBulkDataSync(data) {
        console.log('正在处理批量同步数据...', data);
        const { characters: receivedCharacters, userProfile: receivedUserProfile } = data;

        // 设置用户人设
        currentUserPersona = { name: receivedUserProfile.name, text: receivedUserProfile.personality };
        
        console.log('数据同步完成！角色数据来自主应用contacts表。');
        
        // 刷新角色列表（数据已经在主应用中同步）
        await populateCharacterList(activeCharacterSelect);
        
        // 如果有角色，加载第一个角色
        const chars = await getCharacters();
        const charNames = Object.keys(chars);
        if (charNames.length > 0 &amp;&amp; !currentCharacterName) {
            await loadCharacter(charNames[0]);
        }
    }

    // --- 消息监听 ---
    window.addEventListener('message', (event) => {
        const data = event.data;
        if (!data || !data.type) return;

        switch (data.type) {
            case 'BULK_DATA_SYNC':
                parentAppSettings = {
                    apiSettings: data.apiSettings,
                    userPersona: data.userProfile,
                    character: {}
                };
                console.log(&quot;已接收并应用全局设置: &quot;, parentAppSettings);

                handleBulkDataSync(data).then(async () => {
                    const chars = await getCharacters();
                    const syncedChars = Object.keys(chars);
                    if (syncedChars.length > 0 &amp;&amp; !currentCharacterName) {
                        await loadCharacter(syncedChars[0]);
                    }
                });
                break;
            default:
                console.warn('收到未知的消息类型:', data.type);
                break;
        }
    });
    
    // --- DOM Elements ---
    const getUI = (id) => document.getElementById(id);
    const body = document.body;
    const imageContainer = getUI('image-container');
    const dialogueText = getUI('dialogue-text');
    const modeToggle = getUI('mode-toggle');
    const settingsBtn = getUI('settings-btn');
    const chatBtn = getUI('chat-btn');
    const diaryBtn = getUI('diary-btn');
    const settingsModal = getUI('settings-modal');
    const chatModal = getUI('chat-modal');
    const diaryModal = getUI('diary-modal');
    const closeSettingsModalBtn = getUI('close-settings-modal-btn');
    const closeChatModalBtn = getUI('close-chat-modal-btn');
    const closeDiaryModalBtn = getUI('close-diary-modal-btn');
    const uploadPrompt = getUI('upload-prompt');
    const chatHistoryEl = getUI('chat-history');
    const chatInput = getUI('chat-input');
    const chatSendBtn = getUI('chat-send-btn');
    const settingsContent = getUI('settings-content');
    const activeCharacterSelect = getUI('active-character-select');
    const topRightSelectors = getUI('top-right-selectors');
    const clearChatBtn = getUI('clear-chat-btn');
    const diaryTitle = getUI('diary-title');
    const generateDiaryBtn = getUI('generate-diary-btn');
    const diaryList = getUI('diary-list');
    const diaryContent = getUI('diary-content');
    const showDiaryPanelBtn = getUI('show-diary-panel-btn');
    const diaryListPanel = getUI('diary-list-panel');
    const diaryPanelOverlay = getUI('diary-panel-overlay');
    const diaryMainContent = getUI('diary-main-content');
    const pomodoroBtn = getUI('pomodoro-btn');
    const pomodoroModal = getUI('pomodoro-modal');
    const closePomodoroModalBtn = getUI('close-pomodoro-modal-btn');
    const charPomodoroDisplay = getUI('char-pomodoro-display');
    const charTaskDisplay = getUI('char-task-display');
    const charTaskInput = getUI('char-task-input');
    const charDurationInput = getUI('char-duration-input');
    const charPomodoroBtn = getUI('char-pomodoro-btn');
    const userPomodoroDisplay = getUI('user-pomodoro-display');
    const userTaskDisplay = getUI('user-task-display');
    const userTaskInput = getUI('user-task-input');
    const userDurationInput = getUI('user-duration-input');
    const userPomodoroBtn = getUI('user-pomodoro-btn');
    const floatingPomodoroDisplay = getUI('floating-pomodoro-display');
    const floatingCharTimer = getUI('floating-char-timer');
    const floatingUserTimer = getUI('floating-user-timer');
    const floatingCharTaskName = getUI('floating-char-task-name');
    const floatingCharTime = getUI('floating-char-time');
    const floatingUserTaskName = getUI('floating-user-task-name');
    const floatingUserTime = getUI('floating-user-time');
    const ttsAudioPlayer = getUI('tts-audio-player');

    // --- State Variables ---
    const DEFAULT_ZONES = [&quot;头发&quot;, &quot;耳朵&quot;, &quot;眼睛&quot;, &quot;脸颊&quot;, &quot;鼻子&quot;, &quot;脖子&quot;, &quot;锁骨&quot;, &quot;胸口&quot;, &quot;小腹&quot;, &quot;大臂&quot;, &quot;小臂&quot;, &quot;胯部&quot;, &quot;大腿&quot;, &quot;小腿&quot;, &quot;脚&quot;];
    let currentZones = [...DEFAULT_ZONES];
    let touchHistory = [];
    let messageHistory = [];
    const HISTORY_LIMIT = 20; 
    const CONTEXT_LIMIT = 10;
    let currentBackgroundFileId = '';
    let currentUserPersona = { name: '默认', text: '一个温柔的探索者' };
    let currentCharacterName = '';
    let currentCharacterPersonaText = '';
    let currentDiaryDate = '';
    let pomodoroState = {
        char: { timerId: null, endTime: 0, task: '', isRunning: false },
        user: { timerId: null, endTime: 0, task: '', isRunning: false }
    };

    // --- Templates for Settings Tabs ---
    const sceneSettingsHTML = `
        <div id=&quot;scene-settings-tab&quot; class=&quot;space-y-4&quot;>
            <div>
                <label class=&quot;block text-sm font-bold text-[var(--text-primary)] mb-2&quot;>当前角色</label>
                <div class=&quot;p-3 bg-white/20 border border-gray-300/50 rounded-md&quot;>
                    <div class=&quot;text-[var(--text-primary)] font-bold&quot; id=&quot;character-name-display&quot;>请先选择或同步角色</div>
                </div>
            </div>
            <div>
                <label for=&quot;image-upload&quot; class=&quot;block text-sm font-medium text-[var(--text-secondary)]&quot;>互动背景图</label>
                <input type=&quot;file&quot; id=&quot;image-upload&quot; accept=&quot;image/*&quot; class=&quot;mt-1 block w-full text-sm text-[var(--text-secondary)] file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-white/30 file:text-[var(--text-primary)] hover:file:bg-white/50&quot;>
                <p class=&quot;text-xs text-slate-500 mt-1&quot;>为该角色上传在互动场景中使用的专属图片。</p>
                <button id=&quot;save-char-btn&quot; class=&quot;mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full&quot;>保存场景设置</button>
            </div>
        </div>`;

    const touchSettingsHTML = `
        <div id=&quot;touch-settings-tab&quot; class=&quot;space-y-4 hidden&quot;>
            <div>
                <label for=&quot;custom-zone-name&quot; class=&quot;block text-sm font-medium text-[var(--text-secondary)]&quot;>添加自定义区域</label>
                <div class=&quot;flex space-x-2 mt-1&quot;>
                    <input type=&quot;text&quot; id=&quot;custom-zone-name&quot; class=&quot;flex-grow px-3 py-2 bg-white/30 border border-gray-300/50 rounded-md shadow-sm text-[var(--text-primary)] placeholder-[var(--text-secondary)] focus:outline-none focus:ring-2 focus:ring-[var(--accent-color)]&quot; placeholder=&quot;例如：手腕&quot;>
                    <button id=&quot;add-zone-btn&quot; class=&quot;button-gradient text-white font-bold py-2 px-4 rounded-lg&quot;>添加</button>
                </div>
            </div>
            <button id=&quot;reset-zones-btn&quot; class=&quot;w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg mt-4&quot;>重置所有触发框</button>
        </div>`;

    const themeSettingsHTML = `
        <div id=&quot;theme-settings-tab&quot; class=&quot;space-y-4 hidden&quot;>
            <div>
                <label class=&quot;block text-sm font-medium text-[var(--text-secondary)] mb-2&quot;>主题选择</label>
                <div class=&quot;theme-selector flex space-x-2&quot;>
                    <div data-theme=&quot;theme-pink-white&quot; class=&quot;selected w-10 h-10 rounded-full bg-gradient-to-br from-pink-200 to-pink-400&quot;></div>
                    <div data-theme=&quot;theme-blue-purple&quot; class=&quot;w-10 h-10 rounded-full bg-gradient-to-br from-indigo-300 to-purple-500&quot;></div>
                    <div data-theme=&quot;theme-black-white&quot; class=&quot;w-10 h-10 rounded-full bg-gradient-to-br from-gray-400 to-gray-800&quot;></div>
                </div>
            </div>
            <div class=&quot;flex items-center justify-between&quot;>
                <label for=&quot;tts-toggle&quot; class=&quot;text-sm font-medium text-[var(--text-secondary)]&quot;>自动播放角色语音</label>
                <label for=&quot;tts-toggle&quot; class=&quot;relative inline-flex items-center cursor-pointer&quot;>
                    <input type=&quot;checkbox&quot; id=&quot;tts-toggle&quot; class=&quot;sr-only peer&quot;>
                    <div class=&quot;w-11 h-6 bg-gray-400 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--accent-color)]&quot;></div>
                </label>
            </div>
            <div class=&quot;p-3 bg-yellow-50 border border-yellow-200 rounded-md text-yellow-800&quot;>
                <p class=&quot;text-sm&quot;>语音播放使用主应用设置的Minimax API和角色的语音ID。</p>
            </div>
        </div>`;
    
    // --- Function Definitions ---
    const openModal = (modal) => modal.classList.remove('hidden');
    const closeModal = (modal) => {
        modal.classList.add('hidden');
        if (modal === diaryModal) closeDiaryPanel();
    };
    const addMessageToChatUI = (sender, text) => {
        const bubble = document.createElement('div');
        bubble.className = `w-full flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
        bubble.innerHTML = `<div class=&quot;chat-bubble ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-char'}&quot;>${text.replace(/\n/g, '<br>')}</div>`;
        chatHistoryEl.appendChild(bubble);
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
    };
    const applyTheme = (themeClass) => {
        body.className = themeClass;
        if (settingsModal.querySelector('.theme-selector')) {
            settingsModal.querySelectorAll('.theme-selector div').forEach(s => s.classList.remove('selected'));
            settingsModal.querySelector(`[data-theme=&quot;${themeClass}&quot;]`)?.classList.add('selected');
        }
    };
    const sendChatMessage = () => {
        const text = chatInput.value.trim();
        if (!text) return;
        addMessageToChatUI('user', text);
        addToHistory(messageHistory, { sender: 'user', text: text });
        chatInput.value = '';
        callAI({ type: 'chat', content: text });
    };

    function attachEventListeners() {
        settingsBtn.addEventListener('click', openSettings);
        chatBtn.addEventListener('click', () => openModal(chatModal));
        diaryBtn.addEventListener('click', openDiaryModal);
        closeSettingsModalBtn.addEventListener('click', () => closeModal(settingsModal));
        closeChatModalBtn.addEventListener('click', () => closeModal(chatModal));
        closeDiaryModalBtn.addEventListener('click', () => closeModal(diaryModal));
        pomodoroBtn.addEventListener('click', () => openModal(pomodoroModal));
        closePomodoroModalBtn.addEventListener('click', () => closeModal(pomodoroModal));
        clearChatBtn.addEventListener('click', clearChatHistory);
        chatSendBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendChatMessage(); });
        modeToggle.addEventListener('change', () => {
            imageContainer.classList.toggle('edit-mode', modeToggle.checked);
            imageContainer.classList.toggle('use-mode', !modeToggle.checked);
            topRightSelectors.style.display = modeToggle.checked ? 'flex' : 'none';
        });
        activeCharacterSelect.addEventListener('change', (e) => loadCharacter(e.target.value));
        generateDiaryBtn.addEventListener('click', generateDiary);
        showDiaryPanelBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            diaryModal.classList.add('panel-open');
            diaryPanelOverlay.classList.remove('hidden');
        });
        diaryPanelOverlay.addEventListener('click', closeDiaryPanel);
        diaryMainContent.addEventListener('click', (e) => {
            if (diaryModal.classList.contains('panel-open') &amp;&amp; !diaryListPanel.contains(e.target)) {
                closeDiaryPanel();
            }
        });
        charPomodoroBtn.addEventListener('click', () => {
            if (pomodoroState.char.isRunning) stopTimer('char', false); else startTimer('char');
        });
        userPomodoroBtn.addEventListener('click', () => {
            if (pomodoroState.user.isRunning) stopTimer('user', false); else startTimer('user');
        });
    }
    
    const openSettings = async () => {
        settingsContent.innerHTML = sceneSettingsHTML + touchSettingsHTML + themeSettingsHTML;
        
        settingsModal.querySelectorAll('.settings-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                settingsModal.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                settingsContent.querySelectorAll('#settings-content > div').forEach(c => c.classList.add('hidden'));
                getUI(tab.dataset.tab)?.classList.remove('hidden');
            });
        });
        
        getUI('image-upload').addEventListener('change', handleImageUpload);
        getUI('save-char-btn').addEventListener('click', saveCurrentCharacter);
        getUI('add-zone-btn').addEventListener('click', addCustomZone);
        getUI('reset-zones-btn').addEventListener('click', () => {
            currentZones = [...DEFAULT_ZONES];
            createAllZones();
        });
        settingsModal.querySelectorAll('.theme-selector div').forEach(selector => {
            selector.addEventListener('click', async () => {
                const theme = selector.dataset.theme;
                applyTheme(theme);
                await updateCharacterSetting({ theme: theme }, '保存主题设置');
            });
        });
        getUI('tts-toggle').addEventListener('change', async () => {
            const ttsEnabled = getUI('tts-toggle').checked;
            await updateCharacterSetting({ ttsEnabled: ttsEnabled }, '保存TTS设置');
        });
        
        getUI('character-name-display').textContent = currentCharacterName || &quot;未选择角色&quot;;
        const characters = await getCharacters();
        if (currentCharacterName &amp;&amp; characters[currentCharacterName]) {
            getUI('tts-toggle').checked = characters[currentCharacterName].ttsEnabled === true;
            applyTheme(characters[currentCharacterName].theme || 'theme-pink-white');
        }

        openModal(settingsModal);
    };

    // 安全的 postMessage 函数，适配本地文件环境
    const safePostMessage = (data, targetWindow = window.parent) => {
        if (!targetWindow || targetWindow === window) return;

        try {
            // 获取当前环境的 origin
            let targetOrigin = window.location.origin;

            // 在本地文件环境下，origin 为 &quot;null&quot;，需要使用 &quot;*&quot; 进行通信
            if (targetOrigin === &quot;null&quot; || window.location.protocol === &quot;file:&quot;) {
                targetOrigin = &quot;*&quot;;
            }

            targetWindow.postMessage(data, targetOrigin);
        } catch (error) {
            console.warn('postMessage 发送失败:', error);
            // 作为降级方案，尝试使用 &quot;*&quot; 作为 targetOrigin
            try {
                targetWindow.postMessage(data, &quot;*&quot;);
            } catch (fallbackError) {
                console.error('postMessage 降级方案也失败:', fallbackError);
            }
        }
    };

    const addToHistory = async (historyArray, item) => {
        historyArray.push(item);
        if (historyArray.length > HISTORY_LIMIT) historyArray.shift();
        if (historyArray === messageHistory) {
            await saveChatHistory();
        } else if (historyArray === touchHistory) {
            await saveTouchHistory();
        }
    };

    // 通用的角色设置更新函数
    const updateCharacterSetting = async (updateData, errorContext = '更新角色设置') => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            if (contact) {
                // 批量更新属性
                Object.assign(contact, updateData);
                await interactiveDataHelper.updateContact(contact);
                
                // 同步到主应用
                if (window.parent &amp;&amp; window.parent !== window) {
                    const syncData = {
                        type: 'UPDATE_CONTACT',
                        contactId: currentCharacterName,
                        updateData: updateData
                    };
                    safePostMessage(syncData);
                }
            }
        } catch (error) {
            console.error(`${errorContext}失败:`, error);
        }
    };

    const saveChatHistory = async () => {
        await updateCharacterSetting({ interactiveChatHistory: messageHistory }, '保存聊天记录');
    };

    const saveTouchHistory = async () => {
        await updateCharacterSetting({ interactiveTouchHistory: touchHistory }, '保存触摸记录');
    };

    const loadChatHistory = async () => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            messageHistory = contact ? (contact.interactiveChatHistory || []) : [];
            chatHistoryEl.innerHTML = '';
            messageHistory.forEach(msg => addMessageToChatUI(msg.sender, msg.text));
        } catch (error) {
            console.error('加载聊天记录失败:', error);
            messageHistory = [];
        }
    };

    const loadTouchHistory = async () => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            touchHistory = contact ? (contact.interactiveTouchHistory || []) : [];
        } catch (error) {
            console.error('加载触摸记录失败:', error);
            touchHistory = [];
        }
    };
    
    const clearChatHistory = async () => {
        if (!currentCharacterName) return alert('没有加载任何角色。');
        if (confirm(`确定要清除角色&quot;${currentCharacterName}&quot;的所有聊天记录吗？此操作不可撤销。`)) {
            messageHistory = [];
            chatHistoryEl.innerHTML = '';
            await saveChatHistory(); 
            alert('聊天记录已清除。');
        }
    };

    const getDiaryEntries = async () => {
        if (!currentCharacterName) return {};
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            return contact ? (contact.diaryEntries || {}) : {};
        } catch (error) {
            console.error('获取日记失败:', error);
            return {};
        }
    };

    const saveDiaryEntry = async (dateKey, content) => {
        if (!currentCharacterName) return;
        try {
            const contact = await interactiveDataHelper.getContact(currentCharacterName);
            if (!contact) return;
            
            // 更新日记记录
            contact.diaryEntries = contact.diaryEntries || {};
            contact.diaryEntries[dateKey] = content;
            
            // 保存到数据库
            await interactiveDataHelper.updateContact(contact);
        } catch (error) {
            console.error('保存日记失败:', error);
        }
    };
    
    const deleteDiaryEntry = async (dateKey) => {
        if (!currentCharacterName) return;
        if (confirm(`确定要删除 ${dateKey} 的日记吗？`)) {
            try {
                const contact = await interactiveDataHelper.getContact(currentCharacterName);
                if (contact &amp;&amp; contact.diaryEntries &amp;&amp; contact.diaryEntries[dateKey]) {
                    delete contact.diaryEntries[dateKey];
                    await interactiveDataHelper.updateContact(contact);
                    await populateDiaryList();
                    if (currentDiaryDate === dateKey) {
                        const entries = await getDiaryEntries();
                        const dates = Object.keys(entries).sort((a, b) => new Date(b) - new Date(a));
                        await loadDiaryContent(dates.length > 0 ? dates[0] : null);
                    }
                }
            } catch (error) {
                console.error('删除日记失败:', error);
            }
        }
    };

    const clearCharacterForm = (silent = false) => {
        currentCharacterName = '';
        currentCharacterPersonaText = '';
        if(getUI('image-upload')) getUI('image-upload').value = null;
        currentBackgroundFileId = '';
        imageContainer.style.backgroundImage = 'none';
        uploadPrompt.style.display = 'flex';
        if(getUI('reset-zones-btn')) getUI('reset-zones-btn').click();
        activeCharacterSelect.selectedIndex = -1;
        messageHistory = [];
        touchHistory = [];
        chatHistoryEl.innerHTML = '';
        if (!silent) alert('已清空角色表单，您可以创建新角色了。');
    };

    const getCharacters = async () => {
        try {
            const contacts = await interactiveDataHelper.getAllContacts();
            const charsMap = {};
            contacts.forEach(contact => {
                // 只返回私聊类型的联系人（AI角色）
                if (contact.type === 'private') {
                    charsMap[contact.name] = {
                        name: contact.name,
                        personality: contact.personality,
                        voiceId: contact.voiceId || '',
                        backgroundFileId: contact.interactiveBackgroundFileId || '',
                        theme: contact.theme || 'theme-pink-white',
                        ttsEnabled: contact.ttsEnabled || false,
                        zones: contact.touchZones || [],
                        diaryEntries: contact.diaryEntries || {},
                        interactiveChatHistory: contact.interactiveChatHistory || [],
                        interactiveTouchHistory: contact.interactiveTouchHistory || []
                    };
                }
            });
            return charsMap;
        } catch (error) {
            console.error('获取角色数据失败:', error);
            return {};
        }
    };

    const populateCharacterList = async (selectElement) => {
        const characters = await getCharacters();
        const currentVal = selectElement.value;
        selectElement.innerHTML = '';
        const charNames = Object.keys(characters);
        if (charNames.length === 0) {
            selectElement.innerHTML = '<option>无已存角色</option>';
            selectElement.disabled = true;
        } else {
            charNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectElement.appendChild(option);
            });
            selectElement.disabled = false;
        }
        if (characters[currentVal]) selectElement.value = currentVal;
    };

    const getCurrentZoneData = () => Array.from(imageContainer.querySelectorAll('.touch-zone')).map(zoneEl => ({
        name: zoneEl.dataset.name,
        x: parseFloat(zoneEl.dataset.x) || 0, y: parseFloat(zoneEl.dataset.y) || 0,
        width: zoneEl.offsetWidth, height: zoneEl.offsetHeight,
        angle: parseFloat(zoneEl.dataset.angle) || 0,
    }));

    const saveCurrentCharacter = async () => {
        const name = currentCharacterName;
        if (!name) return alert('没有当前活动角色，无法保存！');
        
        try {
            // 从主应用数据库获取联系人数据
            const contact = await interactiveDataHelper.getContact(name);
            if (!contact) {
                return alert('角色不存在，请先在主应用中创建！');
            }
            
            // 更新互动相关字段
            contact.theme = body.className;
            contact.interactiveBackgroundFileId = currentBackgroundFileId;
            contact.touchZones = getCurrentZoneData();
            
            // 获取当前的TTS设置状态
            const ttsToggle = getUI('tts-toggle');
            if (ttsToggle) {
                contact.ttsEnabled = ttsToggle.checked;
            } else {
                contact.ttsEnabled = contact.ttsEnabled || false;
            }
            
            // 保存到主应用数据库
            await interactiveDataHelper.updateContact(contact);
            
            // 向主应用发送数据更新通知
            if (window.parent &amp;&amp; window.parent !== window) {
                const updateData = {
                    type: 'UPDATE_CONTACT',
                    contactId: name,
                    updateData: {
                        interactiveBackgroundFileId: contact.interactiveBackgroundFileId,
                        touchZones: contact.touchZones,
                        theme: contact.theme,
                        ttsEnabled: contact.ttsEnabled
                    }
                };
                safePostMessage(updateData);
                console.log('场景设置已同步到主应用:', updateData);
            }
            
            alert(`角色 &quot;${name}&quot; 的场景设置已保存并同步！`);
        } catch (error) {
            console.error('保存角色数据失败:', error);
            alert(`保存失败: ${error.message}`);
        }
    };

    const loadCharacter = async (name) => {
        const characters = await getCharacters();
        const charData = characters[name];
        if (!charData) return console.error(`Character &quot;${name}&quot; not found.`);
        
        currentCharacterName = name;
        currentCharacterPersonaText = charData.personality || '';
        applyTheme(charData.theme || 'theme-pink-white');
        
        if (parentAppSettings) {
            parentAppSettings.character = {
                name: charData.name,
                persona: charData.personality,
                voiceId: charData.voiceId || ''
            };
        }
        
        currentBackgroundFileId = charData.backgroundFileId;
        if (currentBackgroundFileId) {
            try {
                const backgroundUrl = await window.ImageStorageAPI.getBackgroundURL(currentCharacterName);
                if (backgroundUrl) {
                    imageContainer.style.backgroundImage = `url('${backgroundUrl}')`;
                    uploadPrompt.style.display = 'none';
                }
            } catch (error) {
                console.warn('加载背景图片失败:', error);
                imageContainer.style.backgroundImage = 'none';
                uploadPrompt.style.display = 'flex';
            }
        } else {
            imageContainer.style.backgroundImage = 'none';
            uploadPrompt.style.display = 'flex';
        }

        imageContainer.querySelectorAll('.touch-zone').forEach(z => z.remove());
        if (charData.zones &amp;&amp; charData.zones.length > 0) {
            currentZones = charData.zones.map(z => z.name);
            charData.zones.forEach(zoneData => createSingleZone(zoneData, true));
        } else {
            currentZones = [...DEFAULT_ZONES];
            createAllZones();
        }
        
        if(activeCharacterSelect.value !== name) activeCharacterSelect.value = name;
        await loadChatHistory();
        await loadTouchHistory();
    };

    const createSingleZone = (zoneData, fromLoad = false) => {
        const containerRect = imageContainer.getBoundingClientRect();
        const zone = document.createElement('div');
        zone.className = 'touch-zone';
        zone.textContent = zoneData.name;
        zone.dataset.name = zoneData.name;
        
        const zoneWidth = fromLoad ? zoneData.width : 100;
        const zoneHeight = fromLoad ? zoneData.height : 50;
        zone.style.width = `${zoneWidth}px`;
        zone.style.height = `${zoneHeight}px`;

        if (fromLoad) {
            zone.dataset.x = zoneData.x;
            zone.dataset.y = zoneData.y;
            zone.dataset.angle = zoneData.angle;
        } else {
            zone.dataset.x = (containerRect.width / 2) - (zoneWidth / 2);
            zone.dataset.y = (containerRect.height / 2) - (zoneHeight / 2);
            zone.dataset.angle = 0;
        }
        zone.style.transform = `translate(${zone.dataset.x}px, ${zone.dataset.y}px) rotate(${zone.dataset.angle}deg)`;
        
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-zone-btn';
        deleteBtn.innerHTML = '&amp;times;';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentZones = currentZones.filter(z => z !== zone.dataset.name);
            zone.remove();
        });

        zone.appendChild(deleteBtn);
        zone.appendChild(document.createElement('div')).className = 'resize-handle';
        zone.appendChild(document.createElement('div')).className = 'rotate-handle';
        
        imageContainer.appendChild(zone);
    };

    const createAllZones = () => {
        imageContainer.querySelectorAll('.touch-zone').forEach(z => z.remove());
        currentZones.forEach(name => createSingleZone({name}));
    };
    
    const addCustomZone = () => {
        const name = getUI('custom-zone-name').value.trim();
        if (!name) return alert('请输入区域名称！');
        if (currentZones.includes(name)) return alert('该区域已存在！');
        currentZones.push(name);
        createSingleZone({name});
        getUI('custom-zone-name').value = '';
    };

    const handleImageUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        if (!currentCharacterName) {
            alert('请先选择一个角色！');
            return;
        }

        try {
            // 确保ImageStorageAPI已初始化
            await window.ImageStorageAPI.init();
            
            // 存储背景图片，使用角色名作为backgroundId
            const fileId = await window.ImageStorageAPI.storeBackground(file, currentCharacterName);
            
            // 更新当前状态
            currentBackgroundFileId = fileId;
            
            // 获取并显示背景图片
            const backgroundUrl = await window.ImageStorageAPI.getBackgroundURL(currentCharacterName);
            if (backgroundUrl) {
                imageContainer.style.backgroundImage = `url('${backgroundUrl}')`;
                uploadPrompt.style.display = 'none';
            }
            
            // 显示成功提示
            console.log('背景图片上传成功，fileId:', fileId);
            
        } catch (error) {
            console.error('背景图片上传失败:', error);
            alert(`背景图片上传失败: ${error.message || '未知错误'}`);
        }
    };
    
    interact('.touch-zone').draggable({
        listeners: { move(event) {
            const target = event.target;
            const x = (parseFloat(target.dataset.x) || 0) + event.dx;
            const y = (parseFloat(target.dataset.y) || 0) + event.dy;
            target.style.transform = `translate(${x}px, ${y}px) rotate(${parseFloat(target.dataset.angle) || 0}deg)`;
            target.dataset.x = x;
            target.dataset.y = y;
        }},
        modifiers: [interact.modifiers.restrictRect({ restriction: 'parent' })],
        inertia: true
    }).resizable({
        edges: { left: true, right: true, bottom: true, top: true },
        listeners: { move(event) {
            const target = event.target;
            let x = (parseFloat(target.dataset.x) || 0);
            let y = (parseFloat(target.dataset.y) || 0);
            target.style.width = `${event.rect.width}px`;
            target.style.height = `${event.rect.height}px`;
            x += event.deltaRect.left;
            y += event.deltaRect.top;
            target.style.transform = `translate(${x}px, ${y}px) rotate(${parseFloat(target.dataset.angle) || 0}deg)`;
            target.dataset.x = x;
            target.dataset.y = y;
        }},
        modifiers: [interact.modifiers.restrictSize({ min: { width: 30, height: 20 } })],
    }).on('tap', (event) => {
        if (imageContainer.classList.contains('edit-mode') || event.target.classList.contains('delete-zone-btn')) return;
        callAI({ type: 'touch', content: event.currentTarget.dataset.name });
        event.preventDefault();
    });

    interact('.rotate-handle').draggable({
        onstart: (event) => {
            const box = event.target.parentElement;
            const rect = box.getBoundingClientRect();
            box.dataset.centerX = rect.left + rect.width / 2;
            box.dataset.centerY = rect.top + rect.height / 2;
        },
        onmove: (event) => {
            const box = event.target.parentElement;
            const angle = (Math.atan2(event.clientY - parseFloat(box.dataset.centerY), event.clientX - parseFloat(box.dataset.centerX)) * (180 / Math.PI)) + 90;
            box.style.transform = `translate(${parseFloat(box.dataset.x) || 0}px, ${parseFloat(box.dataset.y) || 0}px) rotate(${angle}deg)`;
            box.dataset.angle = angle;
        },
    });

    const formatTime = (seconds) => `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;

    const updateCountdown = (type) => {
        const state = pomodoroState[type];
        const remainingSeconds = Math.round((state.endTime - Date.now()) / 1000);
        const display = type === 'char' ? charPomodoroDisplay : userPomodoroDisplay;
        const floatingTimeDisplay = type === 'char' ? floatingCharTime : floatingUserTime;

        if (remainingSeconds < 0) {
            display.textContent = &quot;00:00&quot;;
            floatingTimeDisplay.textContent = &quot;00:00&quot;;
            stopTimer(type, true);
            return;
        }
        const formattedTime = formatTime(remainingSeconds);
        display.textContent = formattedTime;
        floatingTimeDisplay.textContent = formattedTime;
    };

    const sendEncouragement = async (type) => {
        if (!pomodoroState[type].isRunning) return;
        const prompt = `你正在进行一个角色扮演。**你的角色人设是：**\n${currentCharacterPersonaText.trim()}\n**与你互动的用户人设是：**\n${currentUserPersona.text}\n**当前情景：**\n${type === 'user' ? `用户正在专心进行任务：“${pomodoroState[type].task}”。` : `你正在专心进行任务：“${pomodoroState[type].task}”。`}\n**你的任务：**\n时间已经过去了一段时间，请根据你的角色人设，对用户说一句简短、自然、符合人设的鼓励或关心的话，让他/她能继续坚持下去。`;
        try {
            const encouragementMessage = await makeApiCall(prompt);
            dialogueText.textContent = encouragementMessage;
            addToHistory(messageHistory, { sender: 'char', text: encouragementMessage });
            addMessageToChatUI('char', `(鼓励) ${encouragementMessage}`);
        } catch (error) { console.error(&quot;Encouragement failed:&quot;, error.message); }
    };

    const startTimer = (type) => {
        const state = pomodoroState[type];
        const taskInput = type === 'char' ? charTaskInput : userTaskInput;
        const durationInput = type === 'char' ? charDurationInput : userDurationInput;
        const taskDisplay = type === 'char' ? charTaskDisplay : userTaskDisplay;
        const startBtn = type === 'char' ? charPomodoroBtn : userPomodoroBtn;
        const floatingTimerBlock = type === 'char' ? floatingCharTimer : floatingUserTimer;
        const floatingTaskName = type === 'char' ? floatingCharTaskName : floatingUserTaskName;

        const task = taskInput.value.trim();
        if (!task) return alert('请为任务命名！');
        const durationMinutes = parseInt(durationInput.value, 10);
        if (isNaN(durationMinutes) || durationMinutes <= 0) return alert('请输入有效的持续时间（分钟）！');

        stopTimer(type, false);
        state.isRunning = true;
        state.task = task;
        state.endTime = Date.now() + durationMinutes * 60 * 1000;
        state.timerId = setInterval(() => updateCountdown(type), 1000);
        state.encouragementId = setInterval(() => sendEncouragement(type), 7 * 60 * 1000); // 7 minutes
        taskDisplay.textContent = `进行中: ${task}`;
        startBtn.textContent = '停止';
        taskInput.disabled = true;
        durationInput.disabled = true;
        floatingTaskName.textContent = `${type === 'char' ? '角色' : '你'}: ${task}`;
        floatingTimerBlock.classList.remove('hidden');
        floatingPomodoroDisplay.style.display = 'flex';
        updateCountdown(type);
    };

    const stopTimer = (type, finished) => {
        const state = pomodoroState[type];
        if (!state.isRunning) return;
        clearInterval(state.timerId);
        clearInterval(state.encouragementId);

        const taskDisplay = type === 'char' ? charTaskDisplay : userTaskDisplay;
        const startBtn = type === 'char' ? charPomodoroBtn : userPomodoroBtn;
        const taskInput = type === 'char' ? charTaskInput : userTaskInput;
        const durationInput = type === 'char' ? charDurationInput : userDurationInput;
        const display = type === 'char' ? charPomodoroDisplay : userPomodoroDisplay;
        const floatingTimerBlock = type === 'char' ? floatingCharTimer : floatingUserTimer;
        
        const originalTask = state.task;
        state.isRunning = false; state.timerId = null; state.encouragementId = null; state.task = '';
        taskDisplay.textContent = '未开始';
        startBtn.textContent = '开始';
        taskInput.disabled = false;
        durationInput.disabled = false;
        display.textContent = formatTime(parseInt(durationInput.value, 10) * 60 || 25 * 60);
        floatingTimerBlock.classList.add('hidden');
        if (!pomodoroState.char.isRunning &amp;&amp; !pomodoroState.user.isRunning) {
            floatingPomodoroDisplay.style.display = 'none';
        }
        if (finished) {
            const prompt = `你正在进行一个角色扮演。**你的角色人设是：**\n${currentCharacterPersonaText.trim()}\n**与你互动的用户人设是：**\n${currentUserPersona.text}\n**当前情景：**\n${type === 'user' ? `用户刚刚完成了任务：“${originalTask}”。` : `你刚刚完成了任务：“${originalTask}”。`}\n**你的任务：**\n请根据你的角色人设，对此发表一句祝贺或评论。`;
            callAI({type: 'system', content: prompt});
        }
    };
    
    const getTodayDateKey = () => new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });

    const loadDiaryContent = (dateKey) => {
        if (!dateKey) {
            currentDiaryDate = getTodayDateKey();
            diaryTitle.textContent = `角色日记 - ${currentDiaryDate}`;
            diaryContent.innerHTML = '今天还没有日记。点击右上角按钮生成今日日记。';
            return;
        }
        currentDiaryDate = dateKey;
        diaryTitle.textContent = `角色日记 - ${dateKey}`;
        diaryContent.innerHTML = (getDiaryEntries()[dateKey] || '无法找到该日记。').replace(/\n/g, '<br>');
    };
    
    const openDiaryModal = () => {
        populateDiaryList();
        const entries = getDiaryEntries();
        const dates = Object.keys(entries).sort((a, b) => new Date(b) - new Date(a));
        loadDiaryContent(dates.length > 0 ? dates[0] : null);
        diaryModal.classList.remove('panel-open');
        diaryPanelOverlay.classList.add('hidden');
        openModal(diaryModal);
    };
    
    const closeDiaryPanel = () => {
        diaryModal.classList.remove('panel-open');
        diaryPanelOverlay.classList.add('hidden');
    };

    const populateDiaryList = () => {
        const entries = getDiaryEntries();
        const dates = Object.keys(entries).sort((a, b) => new Date(b) - new Date(a));
        diaryList.innerHTML = '';
        if (dates.length === 0) return diaryList.innerHTML = '<p class=&quot;text-sm text-[var(--text-secondary)] p-2&quot;>没有历史日记。</p>';
        
        dates.forEach(date => {
            const item = document.createElement('div');
            item.className = 'diary-list-item flex justify-between items-center';
            const dateSpan = document.createElement('span');
            dateSpan.textContent = date;
            dateSpan.className = 'flex-grow';
            dateSpan.onclick = () => { loadDiaryContent(date); closeDiaryPanel(); };
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'text-red-400 hover:text-red-600 p-1 rounded-full';
            deleteBtn.innerHTML = `<svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;><path fill-rule=&quot;evenodd&quot; d=&quot;M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z&quot; clip-rule=&quot;evenodd&quot; /></svg>`;
            deleteBtn.onclick = (e) => { e.stopPropagation(); deleteDiaryEntry(date); };
            item.appendChild(dateSpan);
            item.appendChild(deleteBtn);
            diaryList.appendChild(item);
        });
    };

    const generateDiary = async () => {
        if (!currentCharacterName) return alert(&quot;请先加载一个角色。&quot;);
        const dateKey = getTodayDateKey();
        diaryContent.innerHTML = '正在生成日记...';
        const prompt = `你正在扮演以下角色，并需要写一篇日记。**你的角色人设是：**\n${currentCharacterPersonaText.trim()}\n**与你互动的用户人设是：**\n${currentUserPersona.text}\n**今天日期：**\n${dateKey}\n**最近发生的事（作为你写日记的参考）：**\n- 我今天在番茄钟里做了：${pomodoroState.char.task || '没有特别安排任务'}\n- Ta今天在番茄钟里做了：${pomodoroState.user.task || '没有特别安排任务'}\n- 最近被触碰的部位: ${touchHistory.slice(-CONTEXT_LIMIT).join(', ') || '无'}\n- 最近对话记录:\n${messageHistory.slice(-CONTEXT_LIMIT).map(m => `${m.sender === 'user' ? 'Ta' : '我'}说: &quot;${m.text}&quot;`).join('\n') || '无'}\n**你的任务：**\n请完全代入你的角色，以日记的形式，写下你对今天（${dateKey}）的感受和思考。日记的开头不必包含日期。日记内容要自然、符合人设，并且要体现出你内心的想法。请直接输出日记内容，不要包含任何额外的解释或标题。`;
        try {
            const diaryText = await makeApiCall(prompt);
            await saveDiaryEntry(dateKey, diaryText);
            loadDiaryContent(dateKey);
            populateDiaryList();
            
            // 向主应用同步日记数据
            if (window.parent &amp;&amp; window.parent !== window) {
                const updateData = {
                    type: 'UPDATE_CONTACT',
                    contactId: currentCharacterName,
                    updateData: {
                        diaryEntries: { [dateKey]: diaryText }
                    }
                };
                safePostMessage(updateData);
                console.log('日记数据已同步到主应用');
            }
        } catch (error) {
            diaryContent.innerHTML = `生成日记失败: ${error.message}`;
        }
    };

    const filterTextForTts = (text) => text ? text.replace(/\（[^）]*\）/g, &quot;&quot;).replace(/\([^)]*\)/g, &quot;&quot;).trim() : &quot;&quot;;

    const playTtsAudio = async (text) => {
        if (!text) return;
        ttsAudioPlayer.pause();
        ttsAudioPlayer.src = '';
        if (!parentAppSettings) {
            return console.warn(&quot;TTS Aborted: Parent settings not received.&quot;);
        }
        const { minimaxGroupId, minimaxApiKey } = parentAppSettings.apiSettings;
        const { voiceId } = parentAppSettings.character;
        try {
            const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`;
            const requestBody = { &quot;voice_id&quot;: voiceId, &quot;text&quot;: text, &quot;model&quot;: &quot;speech-01&quot;, &quot;speed&quot;: 1.0, &quot;vol&quot;: 1.0, &quot;pitch&quot;: 0 };
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${minimaxApiKey}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) throw new Error(`语音服务错误: ${response.status} - ${await response.text()}`);
            const audioBlob = await response.blob();
            ttsAudioPlayer.src = URL.createObjectURL(audioBlob);
            await ttsAudioPlayer.play();
        } catch (error) {
            console.error('TTS process failed:', error);
            dialogueText.textContent += ` (语音合成失败)`;
        }
    };

    const callAI = async (interaction) => {
        if (interaction.type === 'touch') await addToHistory(touchHistory, interaction.content);
        const prompt = `你正在进行一个角色扮演。**你的角色人设是：**\n${currentCharacterPersonaText.trim()}\n**与你互动的用户人设是：**\n${currentUserPersona.text}\n**当前任务状态:**\n- 你的任务: ${pomodoroState.char.isRunning ? `&quot;${pomodoroState.char.task}&quot;` : '无'}\n- 用户的任务: ${pomodoroState.user.isRunning ? `&quot;${pomodoroState.user.task}&quot;` : '无'}\n**上下文参考:**\n- 最近的触碰历史: ${touchHistory.slice(-CONTEXT_LIMIT).join(', ') || '无'}\n- 最近的对话历史:\n${messageHistory.slice(-CONTEXT_LIMIT).map(m => `${m.sender === 'user' ? '用户' : '你'}说: &quot;${m.text}&quot;`).join('\n') || '无'}\n**${interaction.type === 'touch' ? `当前情景：**\n用户轻轻地触碰了你的&quot;${interaction.content}&quot;部位。` : `用户刚刚对你说了：**\n&quot;${interaction.content}&quot;`}\n**你的任务：**\n请完全代入你的角色，只以角色的口吻和身份，对这个动作或这句话做出自然、符合人设且结合上下文的回应。`;
        dialogueText.textContent = `正在思考...`;
        try {
            const reply = await makeApiCall(prompt);
            dialogueText.textContent = reply;
            await addToHistory(messageHistory, { sender: 'char', text: reply });
            if (interaction.type === 'chat') addMessageToChatUI('char', reply);
            
            const characters = await getCharacters(); // 异步获取
            const ttsEnabled = currentCharacterName &amp;&amp; characters[currentCharacterName] ? characters[currentCharacterName].ttsEnabled : false;
            
            if (ttsEnabled) {
                await playTtsAudio(filterTextForTts(reply));
            }
        } catch (error) {
            const errorMessage = `请求失败: ${error.message}`;
            dialogueText.textContent = errorMessage;
            if (interaction.type === 'chat') addMessageToChatUI('char', errorMessage);
        }
    };

    const makeApiCall = async (prompt) => {
        if (!parentAppSettings || !parentAppSettings.apiSettings) throw new Error('未从主应用获取API配置。');
        const { url: baseUrl, key, model: selectedModel } = parentAppSettings.apiSettings;
        if (!baseUrl || !key || !selectedModel) throw new Error('主应用中的API链接、密钥或模型未配置。');
        if (!currentCharacterPersonaText.trim() || !currentUserPersona.text) throw new Error('角色或用户人设未配置。');
        try {
            const messages = [{ role: &quot;user&quot;, content: prompt }];
            const response = await fetch(`${baseUrl.replace(/\/$/, &quot;&quot;)}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
                body: JSON.stringify({ model: selectedModel, messages: messages, temperature: 0.8, max_tokens: 1500 })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API 请求失败，状态码: ${response.status}`);
            }
            const data = await response.json();
            if (!data.choices || !data.choices[0]?.message) throw new Error(&quot;API返回数据格式不正确。&quot;);
            return data.choices[0].message.content.trim();
        } catch (error) {
            console.error('AI call failed:', error);
            throw error;
        }
    };

    const initializeApp = async () => {
        try {
            // 等待主应用数据库系统就绪
            await interactiveDataHelper.ensureReady();
            
            attachEventListeners();
            await populateCharacterList(activeCharacterSelect);
            
            // 获取角色列表，如果有角色则加载第一个
            const chars = await getCharacters();
            const charNames = Object.keys(chars);
            
            if (charNames.length > 0) {
                await loadCharacter(charNames[0]);
            }
            
            console.log('互动界面初始化完成');
        } catch (error) {
            console.error('互动界面初始化失败:', error);
            alert('初始化失败，请刷新页面重试');
        }
    };

    initializeApp();
});
</script>
</body>
</html>" style="width: 100%; height: calc(100vh - 60px); border: none;"></iframe>
            </div>
        </div>

        <div class="profile-page" id="profilePage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>‹</span>
                    <span>Whale-LLT</span>
                </div>
                <div class="chat-title">个人信息</div>
                <div class="chat-header-spacer"></div>
            </div>
            
            <div class="profile-header">
                <div class="profile-avatar" id="userAvatar">我</div>
                <div class="profile-name" id="userName">我的昵称</div>
                <div class="profile-id">id号：AI_User_001</div>
            </div>
            
            <div class="profile-section">
                <div class="profile-item" onclick="showEditProfileModal()" data-umami-event="Edit Profile Open">
                    <div class="profile-item-label">编辑个人信息</div>
                    <div class="profile-item-arrow">›</div>
                </div>
                <div class="profile-item" onclick="showUserProfile()">
                    <div class="profile-item-label">我的个人主页</div>
                    <div class="profile-item-arrow">›</div>
                </div>
                <div class="profile-item" onclick="showPage('appearanceManagementPage')" data-umami-event="Appearance Management Open">
                    <div class="profile-item-label">外观管理</div>
                    <div class="profile-item-arrow">›</div>
                </div>
                <div class="profile-item" onclick="showPage('dataManagementPage')" data-umami-event="Data Management Open">
                    <div class="profile-item-label">数据管理</div>
                    <div class="profile-item-arrow">›</div>
                </div>
                <div class="profile-item" onclick="showPage('memoryManagementPage')" data-umami-event="Memory Management Open">
                    <div class="profile-item-label">记忆管理</div>
                    <div class="profile-item-arrow">›</div>
                </div>
                <div class="profile-item" onclick="window.SystemUtils.showDebugLogPage()"
                data-umami-event="Debug Log Open">
                    <div class="profile-item-label">查看调试日志</div>
                    <div class="profile-item-arrow">›</div>
                </div>
                
                <!-- 版本号显示 -->
                <div class="profile-version" id="profileVersion">
                    <span id="profileVersionText">-</span>
                </div>
            </div>
        </div>

        <div class="weibo-page" id="weiboPage">
            <div class="weibo-header">
                <div class="back-btn" onclick="showPage('contactListPage')">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="chat-title">论坛</div>
                <div class="chat-more" onclick="showPostChoiceModal()">➕</div>
            </div>
            <div class="weibo-container" id="weiboContainer">
                <div class="weibo-scroll-content"></div>
            </div>
        </div>

        <div class="data-management-page" id="dataManagementPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="chat-title">数据管理</div>
                <div class="chat-header-spacer"></div>
            </div>
            
            <div class="data-management-container">
                <!-- 数据统计信息 -->
                <div class="database-stats" style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 15px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0; font-size: 18px; font-weight: bold; color: #333;">数据统计</h3>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="persistentStatusIndicator" style="font-size: 13px; font-weight: bold;">
                                ⏳ 检查中...
                            </div>
                            <button type="button" class="info-button" 
                                    onclick="StorageManager.showPersistentStorageInfo()" 
                                    title="点击查看持久化存储说明">
                                ?
                            </button>
                        </div>
                    </div>
                    <div id="databaseStatsContent" style="font-size: 13px; color: #666;">
                        <div>正在加载统计信息...</div>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap;">
                        <button type="button" class="refresh-stats-btn" onclick="refreshDatabaseStats()" 
                                style="padding: 5px 10px; font-size: 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            刷新统计
                        </button>
                        <button type="button" class="request-persistent-btn" 
                                onclick="StorageManager.requestPersistentStorageAndRefresh()" 
                                title="申请将数据库设为持久化存储，防止被浏览器清理">
                            💾 申请持久化数据库
                        </button>
                        <button type="button" class="optimize-db-btn" onclick="optimizeEmojiDatabase()" 
                                style="padding: 5px 10px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;" title="将Base64表情转换为标签格式，减小数据库体积">
                            🚀 数据库优化
                        </button>
                        <button type="button" class="clear-localStorage-btn" onclick="showClearLocalStorageConfirmation()" 
                                style="padding: 5px 10px; font-size: 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;" title="清空浏览器本地存储，谨慎操作">
                            🗑️ 清空LocalStorage
                        </button>
                    </div>
                </div>

                
                <!-- 导入导出操作 -->
                <div class="import-export-actions" style="margin: 15px;">
                    <!-- 导入说明 -->
                    <div class="import-warning" style="margin-top: 10px; padding: 10px; background: #f8d7da; border-radius: 4px; border: 1px solid #f5c6cb;">
                        <div style="font-size: 13px; color: #721c24; margin-bottom: 5px;">
                            <strong>⚠️ 重要提醒</strong>
                        </div>
                        <div style="font-size: 12px; color: #721c24;">
                            导入数据将完全覆盖现有的所有数据！请确保已备份重要信息！！
                        </div>
                    </div>
                    <!-- 数据库导入导出 -->
                    <div style="margin-bottom: 15px; padding: 15px; background: #e8f5e8; border: 1px solid #4caf50; border-radius: 4px;">
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #2e7d32;">
                            💾 数据库完整备份
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button type="button" class="form-submit" onclick="exportDatabase()" data-umami-event="Export Database"
                                    style="flex: 1; background-color: #28a745;">
                                📤 导出数据库
                            </button>
                            <button type="button" class="form-submit" onclick="triggerFileSelect()" data-umami-event="Import Database"
                                    style="flex: 1; background-color: #dc3545;">
                                📥 导入数据库
                            </button>
                        </div>
                    </div>

                    <!-- 文件存储导入导出 -->
                    <div style="margin-bottom: 15px; padding: 15px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 4px;">
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #ef6c00;">
                            🖼️ 文件存储迁移（图片、表情包、背景）
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button type="button" class="form-submit" onclick="exportFileStorage()" data-umami-event="Export Media Files"
                                    style="flex: 1; background-color: #ff9800;">
                                📤 导出文件
                            </button>
                            <button type="button" class="form-submit" onclick="triggerFileStorageImport()" data-umami-event="Import Media Files"
                                    style="flex: 1; background-color: #f57c00;">
                                📥 导入文件
                            </button>
                        </div>
                        <div style="font-size: 12px; color: #bf360c; margin-bottom: 10px;">
                            导出为ZIP格式，保持原始文件格式（jpg/png/gif等），在新环境中导入时会自动匹配对应项目
                        </div>
                        
                        <!-- 文件存储导出选项 -->
                        <div id="fileExportOptions" style="display: none; margin-top: 10px; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px;">
                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 8px; color: #333;">选择要导出的文件类型：</div>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                                <input type="checkbox" id="exportAvatars" checked style="margin-right: 5px;">
                                头像图片（联系人和用户头像）
                            </label>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                                <input type="checkbox" id="exportBackgrounds" checked style="margin-right: 5px;">
                                聊天背景图片
                            </label>
                            <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                                <input type="checkbox" id="exportEmojis" checked style="margin-right: 5px;">
                                表情包图片
                            </label>
                            <label style="display: block; margin-bottom: 10px; font-size: 12px;">
                                <input type="checkbox" id="exportMoments" checked style="margin-right: 5px;">
                                朋友圈图片
                            </label>
                            <div style="display: flex; gap: 10px;">
                                <button type="button" class="form-submit" onclick="confirmFileExport()" data-umami-event="Confirm File Export"
                                        style="flex: 1; background-color: #4caf50; font-size: 12px; padding: 6px;">
                                    ✅ 确认导出
                                </button>
                                <button type="button" class="form-submit" onclick="cancelFileExport()" data-umami-event="Cancel File Export"
                                        style="flex: 1; background-color: #f44336; font-size: 12px; padding: 6px;">
                                    ❌ 取消
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 其他功能 -->
                    <div style="margin-bottom: 15px;">
                        <button type="button" class="form-submit" id="shareDataBtn" onclick="handleShareData()" data-umami-event="Transfer Data" 
                                style="width: 100%; background-color: #007bff;">
                            🔗 数据传输
                        </button>
                    </div>

                    <!-- 云同步功能 -->
                    <div style="margin-bottom: 15px; padding: 15px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px;">
                        <div style="margin-bottom: 10px; font-size: 14px; font-weight: bold; color: #1565c0;">
                            🌐 云端数据同步
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button type="button" class="form-submit" onclick="uploadDataToCloud()" 
                                    style="flex: 1; background-color: #4caf50;">
                                ☁️ 上传到云端
                            </button>
                            <button type="button" class="form-submit" onclick="downloadDataFromCloud()" 
                                    style="flex: 1; background-color: #2196f3;">
                                ⬇️ 从云端下载
                            </button>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <input type="text" id="syncKeyInput" placeholder="输入同步标识符" 
                                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        </div>
                        
                        <div id="syncStatus" style="font-size: 12px; color: #666; text-align: center;"></div>
                    </div>
                    
                    
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileSelect(event)">
                    <input type="file" id="fileStorageImportInput" accept=".zip,.json" style="display: none;" onchange="handleFileStorageImport(event)">
                </div>

                <!-- 数据优化功能 -->
                <div class="data-optimization-section" style="margin: 15px;">
                    <!-- 图片存储优化部分 -->
                    <div class="context-control" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f9f9f9;">
                        <div class="context-header">
                            <div class="context-title" style="color: #333; font-weight: bold;">📁 图片存储优化</div>
                            <div class="context-value" id="migrationStatusText">检查中...</div>
                        </div>
                        <div class="context-info" style="margin-top: 10px; font-size: 13px; color: #666;">
                            将现有的base64图片数据转换为高效的文件存储格式，可显著减少存储空间占用并提升性能。
                        </div>
                        
                        <!-- 迁移状态显示 -->
                        <div id="migrationStatusDetails" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; color: #666;">
                            <div>正在检查图片数据状态...</div>
                        </div>

                        <!-- 迁移按钮组 -->
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="form-submit" onclick="checkImageMigrationStatus()" style="flex: 1; font-size: 12px;">
                                🔍 检查状态
                            </button>
                            <button type="button" class="form-submit" id="startMigrationBtn" onclick="startImageMigration()" 
                                    style="flex: 2; font-size: 12px; background-color: #ff9500;" disabled>
                                🚀 开始优化
                            </button>
                        </div>

                        <!-- 迁移进度显示 -->
                        <div id="migrationProgress" style="margin-top: 10px; display: none;">
                            <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden; height: 8px; margin-bottom: 5px;">
                                <div id="migrationProgressBar" style="background: #07c160; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="migrationProgressText" style="font-size: 11px; color: #666;">准备开始...</div>
                        </div>
                    </div>

                    <!-- 聊天记录表情包优化部分 -->
                    <div class="context-control" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f0f8ff;">
                        <div class="context-header">
                            <div class="context-title" style="color: #333; font-weight: bold;">💬 聊天记录表情优化</div>
                            <div class="context-value" id="chatEmojiMigrationStatusText">检查中...</div>
                        </div>
                        <div class="context-info" style="margin-top: 10px; font-size: 13px; color: #666;">
                            优化聊天记录中的表情包存储格式，将base64格式转换为高效的文件存储，同时保持API兼容性。
                        </div>
                        
                        <!-- 迁移状态显示 -->
                        <div id="chatEmojiMigrationStatusDetails" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; color: #666;">
                            <div>正在检查聊天记录中的表情包状态...</div>
                        </div>

                        <!-- 迁移按钮组 -->
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="form-submit" onclick="checkChatEmojiMigrationStatus()" style="flex: 1; font-size: 12px;">
                                🔍 检查状态
                            </button>
                            <button type="button" class="form-submit" id="startChatEmojiMigrationBtn" onclick="startChatEmojiMigration()" 
                                    style="flex: 2; font-size: 12px; background-color: #1890ff;" disabled>
                                💬 开始优化
                            </button>
                        </div>

                        <!-- 迁移进度显示 -->
                        <div id="chatEmojiMigrationProgress" style="margin-top: 10px; display: none;">
                            <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden; height: 8px; margin-bottom: 5px;">
                                <div id="chatEmojiMigrationProgressBar" style="background: #1890ff; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="chatEmojiMigrationProgressText" style="font-size: 11px; color: #666;">准备开始...</div>
                        </div>
                    </div>

                    <!-- Unsplash -->
                    <div class="context-control" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f5f8ff;">
                        <div class="context-header">
                            <div class="context-title" style="color: #333; font-weight: bold;">🎨 文字配图</div>
                            <div class="context-value" id="imageKeywordStatusText">
                                <span id="imageKeywordStatus"></span>
                            </div>
                        </div>
                        <div class="context-info" style="margin-top: 10px; font-size: 13px; color: #666;">
                            使用 Unsplash API 为论坛或朋友圈配图
                        </div>
                        
                        <!-- 配置状态显示 -->
                        <div id="imageKeywordConfigStatus" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; font-size: 12px; color: #666;">
                            <div>正在检查配置状态...</div>
                        </div>

                        <!-- 控制按钮 -->
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="form-submit" onclick="checkImageKeywordStatus()" style="flex: 1; font-size: 12px;">
                                🔍 检查状态
                            </button>
                            <button type="button" class="form-submit" onclick="openImageKeywordSettings()" style="flex: 1; font-size: 12px; background-color: #28a745;">
                                ⚙️ 配置设置
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="debug-log-page" id="debugLogPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="chat-title">调试日志</div>
                <div class="header-actions">
                    <button class="header-btn" onclick="window.SystemUtils.clearDebugLogs()">清空</button>
                    <button class="header-btn" onclick="window.SystemUtils.copyDebugLogs()">复制</button>
                </div>
            </div>
            
            <div class="debug-log-container">
                <div class="debug-log-info">
                    <div class="debug-log-stats">
                        总计 <span id="logCount">0</span> 条日志
                    </div>
                    <div class="debug-log-hint">
                        显示浏览器控制台的实时日志，包括错误、警告和调试信息
                    </div>
                </div>
                
                <div class="debug-log-content" id="debugLogContent">
                    <div class="debug-log-empty">
                        暂无日志记录
                    </div>
                </div>
            </div>
        </div>

        <!-- 外观管理页面 -->
        <div class="appearance-management-page" id="appearanceManagementPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>‹</span>
                </div>
                <div class="chat-title">外观管理</div>
            </div>
            
            <div class="appearance-content">
                <!-- 暗黑模式选择 -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">主题模式</h3>
                    <p class="appearance-section-desc">选择你喜欢的主题模式，支持跟随系统设置</p>
                    
                    <div class="theme-mode-grid">
                        <div class="theme-mode-option active" data-theme="system" onclick="window.UIManager.switchTheme('system')">
                            <div class="theme-mode-icon">🔄</div>
                            <div class="theme-mode-content">
                                <div class="theme-mode-name">跟随系统</div>
                                <div class="theme-mode-desc">自动跟随系统暗色模式</div>
                            </div>
                        </div>
                        <div class="theme-mode-option" data-theme="light" onclick="window.UIManager.switchTheme('light')">
                            <div class="theme-mode-icon">☀️</div>
                            <div class="theme-mode-content">
                                <div class="theme-mode-name">亮色模式</div>
                                <div class="theme-mode-desc">始终使用亮色主题</div>
                            </div>
                        </div>
                        <div class="theme-mode-option" data-theme="dark" onclick="window.UIManager.switchTheme('dark')">
                            <div class="theme-mode-icon">🌙</div>
                            <div class="theme-mode-content">
                                <div class="theme-mode-name">暗黑模式</div>
                                <div class="theme-mode-desc">始终使用暗色主题</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 主题色选择 -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">主题色彩</h3>
                    <p class="appearance-section-desc">选择你喜欢的主题色，个性化你的应用界面</p>
                    
                    <div class="theme-color-grid">
                        <!-- 默认绿色 -->
                        <div class="theme-color-option active" data-color="#07c160" data-name="鲜绿">
                            <div class="theme-color-preview" style="background-color: #07c160;"></div>
                            <div class="theme-color-name">鲜绿</div>
                        </div>
                        <!-- 蓝色 -->
                        <div class="theme-color-option" data-color="#1890ff" data-name="天空蓝">
                            <div class="theme-color-preview" style="background-color: #1890ff;"></div>
                            <div class="theme-color-name">天空蓝</div>
                        </div>
                        <!-- 紫色 -->
                        <div class="theme-color-option" data-color="#722ed1" data-name="深紫">
                            <div class="theme-color-preview" style="background-color: #722ed1;"></div>
                            <div class="theme-color-name">深紫</div>
                        </div>
                        <!-- 红色 -->
                        <div class="theme-color-option" data-color="#f5222d" data-name="火红">
                            <div class="theme-color-preview" style="background-color: #f5222d;"></div>
                            <div class="theme-color-name">火红</div>
                        </div>
                        <!-- 橙色 -->
                        <div class="theme-color-option" data-color="#fa8c16" data-name="橙">
                            <div class="theme-color-preview" style="background-color: #fa8c16;"></div>
                            <div class="theme-color-name">橙</div>
                        </div>
                        <!-- 青色 -->
                        <div class="theme-color-option" data-color="#13c2c2" data-name="清新青">
                            <div class="theme-color-preview" style="background-color: #13c2c2;"></div>
                            <div class="theme-color-name">清新青</div>
                        </div>
                        <!-- 粉色 -->
                        <div class="theme-color-option" data-color="#eb2f96" data-name="亮粉">
                            <div class="theme-color-preview" style="background-color: #eb2f96;"></div>
                            <div class="theme-color-name">亮粉</div>
                        </div>
                        <!-- 深蓝 -->
                        <div class="theme-color-option" data-color="#2f54eb" data-name="海蓝">
                            <div class="theme-color-preview" style="background-color: #2f54eb;"></div>
                            <div class="theme-color-name">海蓝</div>
                        </div>
                    </div>
                    
                    <!-- 自定义颜色选择器 -->
                    <div class="custom-color-section">
                        <label for="customColorPicker" class="custom-color-label">自定义颜色</label>
                        <p class="custom-color-desc">点击颜色圆圈选择，或直接输入十六进制颜色代码</p>
                        
                        <div class="custom-color-preview-row">
                            <div class="custom-color-preview-container">
                                <div class="custom-color-preview-circle" id="customColorPreview" style="background-color: #07c160;">
                                    <input type="color" id="customColorPicker" class="custom-color-picker-hidden" value="#07c160">
                                </div>
                                <span class="custom-color-preview-label">预览</span>
                            </div>
                            
                            <div class="custom-color-input-container">
                                <input type="text" id="customColorText" class="custom-color-text" placeholder="#07c160" maxlength="7">
                                <button type="button" class="apply-custom-color-btn" onclick="applyCustomColor()">应用</button>
                            </div>
                        </div>
                        
                        <div class="color-input-tips">
                            <small>💡 提示：支持格式如 #FF0000、#ff0000 等六位十六进制颜色代码</small>
                        </div>
                    </div>
                </div>
                
                <!-- 渐变主题设置 -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">渐变主题</h3>
                    <p class="appearance-section-desc">开启渐变效果，让界面更具视觉层次感</p>
                    
                    <div class="gradient-toggle-container">
                        <label class="gradient-toggle-label">
                            <input type="checkbox" id="gradientToggle" class="gradient-toggle-input">
                            <span class="gradient-toggle-slider"></span>
                            启用渐变主题
                        </label>
                    </div>
                    
                    <div class="gradient-settings" id="gradientSettings" style="display: none;">
                        <div class="gradient-color-row">
                            <div class="gradient-color-group">
                                <label class="gradient-color-label">主色</label>
                                <div class="gradient-color-picker-container">
                                    <div class="gradient-color-preview" id="gradientPrimaryPreview" style="background-color: #07c160;">
                                        <input type="color" id="gradientPrimaryPicker" class="gradient-color-picker-hidden" value="#07c160">
                                    </div>
                                    <input type="text" id="gradientPrimaryText" class="gradient-color-text" placeholder="#07c160" maxlength="7" value="#07c160">
                                </div>
                            </div>
                            
                            <div class="gradient-color-group">
                                <label class="gradient-color-label">副色</label>
                                <div class="gradient-color-picker-container">
                                    <div class="gradient-color-preview" id="gradientSecondaryPreview" style="background-color: #1890ff;">
                                        <input type="color" id="gradientSecondaryPicker" class="gradient-color-picker-hidden" value="#1890ff">
                                    </div>
                                    <input type="text" id="gradientSecondaryText" class="gradient-color-text" placeholder="#1890ff" maxlength="7" value="#1890ff">
                                </div>
                            </div>
                        </div>
                        
                        <div class="gradient-preview-container">
                            <label class="gradient-preview-label">效果预览</label>
                            <div class="gradient-preview-demo" id="gradientPreviewDemo">
                                <div class="gradient-preview-text">渐变效果预览</div>
                            </div>
                        </div>
                        
                        <div class="gradient-direction-container">
                            <label class="gradient-direction-label">渐变方向</label>
                            <div class="gradient-direction-options">
                                <label class="gradient-direction-option">
                                    <input type="radio" name="gradientDirection" value="to right" checked>
                                    <span class="gradient-direction-text">→ 水平</span>
                                </label>
                                <label class="gradient-direction-option">
                                    <input type="radio" name="gradientDirection" value="to bottom">
                                    <span class="gradient-direction-text">↓ 垂直</span>
                                </label>
                                <label class="gradient-direction-option">
                                    <input type="radio" name="gradientDirection" value="135deg">
                                    <span class="gradient-direction-text">↘ 对角</span>
                                </label>
                            </div>
                        </div>
                        
                        <button type="button" class="apply-gradient-btn" onclick="applyGradientThemeFromUI()">应用渐变主题</button>
                    </div>
                </div>
                
                <!-- 聊天气泡设计器 -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">聊天气泡设计</h3>
                    <p class="appearance-section-desc">设计个性化的聊天气泡样式，添加贴图装饰</p>
                    <div class="bubble-designer-option">
                        <button type="button" class="bubble-designer-btn" onclick="openBubbleDesigner()">
                            <div class="bubble-designer-icon">💬</div>
                            <div class="bubble-designer-info">
                                <div class="bubble-designer-title">气泡样式设计器</div>
                                <div class="bubble-designer-desc">自定义气泡颜色、边框、贴图装饰等</div>
                            </div>
                            <div class="bubble-designer-arrow">›</div>
                        </button>
                    </div>
                </div>
                
                <!-- 预留更多外观设置 -->
                <div class="appearance-section">
                    <h3 class="appearance-section-title">更多设置</h3>
                    <p class="appearance-section-desc">敬请期待更多个性化选项</p>
                    <div class="coming-soon">
                        <div class="coming-soon-icon">🎨</div>
                        <div class="coming-soon-text">更多外观选项即将推出</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="memory-management-page" id="memoryManagementPage">
            <div class="chat-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="chat-title">记忆管理</div>
                <div class="header-actions">
                    <button class="header-btn" onclick="showAddMemoryModal()">添加</button>
                </div>
            </div>
            
            <div class="memory-management-container">
                <div class="memory-tabs">
                    <button class="memory-tab active" onclick="switchMemoryTab('global')">全局记忆</button>
                    <button class="memory-tab" onclick="switchMemoryTab('character')">角色记忆</button>
                </div>
                
                <div class="memory-content">
                    <div class="memory-section" id="globalMemorySection">
                        <div class="memory-list" id="globalMemoryList">
                            <div class="memory-empty">暂无全局记忆</div>
                        </div>
                    </div>
                    
                    <div class="memory-section hidden" id="characterMemorySection">
                        <div class="character-selector">
                            <select id="characterSelector" onchange="loadCharacterMemories()">
                                <option value="">选择角色...</option>
                            </select>
                        </div>
                        <div class="memory-list" id="characterMemoryList">
                            <div class="memory-empty">请先选择角色</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 个人主页页面 -->
        <div class="user-profile-page" id="userProfilePage">
            <div class="user-profile-header">
                <div class="back-btn" onclick="goBackFromUserProfile()">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="user-profile-actions">
                    <span class="header-icon">⋯</span>
                </div>
            </div>
            
            <div class="user-profile-content">
                <div class="user-profile-banner" id="userProfileBanner" onclick="openBannerUploadModal()" style="cursor: pointer;" data-umami-event="Banner Click">
                    <div class="banner-upload-hint" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255,255,255,0.7); font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s;">
                        点击更换背景图片
                    </div>
                    <div class="user-profile-avatar-container" onclick="event.stopPropagation()">
                        <div class="user-profile-name" id="userProfileName">我的昵称</div>
                        <div class="user-profile-avatar" id="userProfileAvatar">我</div>
                    </div>
                </div>
                
                <!-- 朋友圈瀑布流 -->
                <div class="user-profile-moments" id="userProfileMoments">
                    <div class="user-profile-moments-empty">
                        <div class="moments-empty-icon">📝</div>
                        <div class="moments-empty-text">还没有朋友圈动态</div>
                    </div>
                    <div class="user-profile-moments-list" id="userProfileMomentsList"></div>
                </div>
            </div>
        </div>

        <!-- API配置管理页面 -->
        <div class="page" id="apiConfigManagementPage" style="display: none;">
            <div class="page-header">
                <div class="back-btn" onclick="showPage('profilePage')">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="page-title">API配置管理</div>
                <div class="page-actions">
                    <button class="header-btn" onclick="showNewApiConfigForm()">添加</button>
                </div>
            </div>
            <div class="page-content">
                <div class="config-list" id="apiConfigList">
                    <div class="config-list-empty">
                        <div class="empty-icon">⚙️</div>
                        <div class="empty-text">暂无API配置</div>
                        <button class="empty-action-btn" onclick="showNewApiConfigForm()">添加第一个配置</button>
                    </div>
                </div>
                
                <!-- 配置表单 -->
                <div class="config-form" id="apiConfigForm" style="display: none;">
                    <div class="config-form-header">
                        <h3 id="configFormTitle">新增API配置</h3>
                        <button class="close-form-btn" onclick="closeApiConfigForm()">✕</button>
                    </div>
                    
                    <form onsubmit="saveApiConfigInPage(event)" id="apiConfigPageForm">
                        <div class="form-group">
                            <label class="form-label">配置名称</label>
                            <input type="text" class="form-input" id="pageConfigName" required placeholder="给这个配置起个名字">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">API URL</label>
                            <input type="url" class="form-input" id="pageApiUrl" required placeholder="例如: https://api.openai.com/v1">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">API Key</label>
                            <div class="api-key-row">
                                <input type="password" class="form-input api-key-input" id="pageApiKey" required>
                                <div class="timeout-group">
                                    <label class="timeout-label">超时</label>
                                    <input type="number" class="timeout-input" id="pageApiTimeout" min="5" max="300" value="60" placeholder="60">
                                    <span class="timeout-unit">秒</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <button type="button" class="form-submit" onclick="testApiConnectionInPage(event)" style="background-color: #17a2b8; margin-bottom: 10px;">测试连接</button>
                        </div>
                        
                        <div class="form-actions">
                            <button type="button" class="form-button secondary" onclick="closeApiConfigForm()">取消</button>
                            <button type="submit" class="form-button primary">保存配置</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- 新的全屏设置页面 -->
        <div class="contact-settings-page" id="contactSettingsPage">
            <div class="chat-header">
                <div class="back-btn" onclick="closeContactSettingsPage()">
                    <span>‹</span>
                    <span>返回</span>
                </div>
                <div class="chat-title" id="contactSettingsTitle">联系人设置</div>
                <div class="chat-header-spacer"></div>
            </div>
            
            <div class="contact-settings-content">
                <!-- 角色信息设置区 -->
                <div class="settings-section">
                    <div class="settings-section-title">角色信息</div>
                    <div class="settings-item" onclick="showEditContactModal()" data-umami-event="Edit Contact Open">
                        <div class="settings-item-icon">✏️</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">编辑人设</div>
                            <div class="settings-item-desc">修改角色名称、头像、性格描述等</div>
                        </div>
                        <div class="settings-item-arrow">›</div>
                    </div>
                </div>

                <!-- 聊天设置区 -->
                <div class="settings-section">
                    <div class="settings-section-title">聊天设置</div>
                    <div class="settings-item" onclick="showBackgroundModal()" data-umami-event="Background Settings Open">
                        <div class="settings-item-icon">🎨</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">设置背景</div>
                            <div class="settings-item-desc">更换聊天背景图片</div>
                        </div>
                        <div class="settings-item-arrow">›</div>
                    </div>
                </div>

                <!-- 数据管理区 -->
                <div class="settings-section">
                    <div class="settings-section-title">数据管理</div>
                    <div class="settings-item" onclick="clearMessages()" data-umami-event="Clear Messages">
                        <div class="settings-item-icon">🗑️</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">清空聊天</div>
                            <div class="settings-item-desc">删除所有聊天记录，此操作不可撤销</div>
                        </div>
                        <div class="settings-item-arrow">›</div>
                    </div>
                    <div class="settings-item danger-item" onclick="deleteCurrentContact()" data-umami-event="Delete Contact">
                        <div class="settings-item-icon">⚠️</div>
                        <div class="settings-item-content">
                            <div class="settings-item-label">删除联系人</div>
                            <div class="settings-item-desc">永久删除此联系人及所有数据</div>
                        </div>
                        <div class="settings-item-arrow">›</div>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <div class="bottom-nav">
        <div class="nav-item active" onclick="showPage('contactListPage')" data-umami-event="Nav Chat">
            <div class="nav-icon">💬</div>
            <div class="nav-text">聊天</div>
        </div>
        <div class="nav-item" onclick="showPage('weiboPage')" data-umami-event="Nav Forum">
            <div class="nav-icon">
                <svg t="1721063385731" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10099" width="24" height="24"><path d="M822.4 438.4c-3.2-16-16-28.8-32-32-12.8-3.2-25.6-3.2-38.4-3.2-108.8 0-204.8 48-275.2 128-22.4 25.6-41.6 51.2-57.6 80-96-44.8-192-115.2-265.6-204.8-19.2-25.6-48-35.2-76.8-22.4-28.8 12.8-44.8 44.8-35.2 73.6 3.2 9.6 9.6 19.2 16 28.8 48 64 108.8 118.4 179.2 163.2-83.2 16-156.8 64-211.2 131.2-19.2 25.6-16 64 9.6 83.2 25.6 19.2 64 16 83.2-9.6 44.8-54.4 105.6-92.8 172.8-112-6.4 35.2-9.6 70.4-9.6 105.6 0 163.2 102.4 304 249.6 358.4 19.2 6.4 38.4 0 51.2-16 12.8-16 12.8-38.4 0-54.4-115.2-124.8-115.2-300.8 0-425.6 64-70.4 144-112 233.6-121.6 16 0 32-3.2 44.8-9.6 16-9.6 22.4-25.6 19.2-41.6z" fill="#999999" p-id="10100"></path></svg>
            </div>
            <div class="nav-text">论坛</div>
        </div>
        <div class="nav-item" onclick="showPage('momentsPage')" data-umami-event="Nav Discover">
            <div class="nav-icon">🔍</div>
            <div class="nav-text">发现</div>
        </div>
        <div class="nav-item" onclick="showPage('interactivePage')" data-umami-event="Nav Interactive">
            <div class="nav-icon">🎮</div>
            <div class="nav-text">互动</div>
        </div>
        <div class="nav-item" onclick="showPage('profilePage')" data-umami-event="Nav Profile">
            <div class="nav-icon">👤</div>
            <div class="nav-text">我</div>
        </div>
    </div>

    <div class="modal" id="generatePostModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">生成论坛帖子</div>
                <div class="modal-close" onclick="closeModal('generatePostModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleGeneratePost(event)">
                    <div class="form-group">
                        <label class="form-label">选择角色</label>
                        <select class="form-input" id="postGenCharacterSelect" onchange="handleCharacterChange()" required>
                            <option value="">请选择...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">关系类型</label>
                        <select class="form-input" id="postGenRelations" onchange="handleRelationChange()" required>
                            <option value="">请选择...</option>
                            <option value="CP">CP</option>
                            <option value="CB">CB</option>
                            <option value="好友">好友</option>
                            <option value="宿敌">宿敌</option>
                            <option value="custom">自定义</option>
                        </select>
                    </div>
                    <div class="form-group" style="display: none;">
                        <label class="form-label">自定义关系</label>
                        <input type="text" class="form-input" id="postGenCustomRelation" placeholder="请描述你们的关系">
                    </div>
                    <div class="form-group">
                        <label class="form-label">话题</label>
                        <input type="text" class="form-input" id="postGenHashtag" placeholder="例如：AB、BA、A & B、AB的日记 等" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">生成数量</label>
                        <input type="number" class="form-input" id="postGenCount" value="1" min="1" max="5" required>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Generate Forum Post">开始生成</button>
                </form>
            </div>
        </div>
    </div>

    <!-- 朋友圈发布方式选择模态框 -->
    <div class="modal" id="momentChoiceModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">发布朋友圈</div>
                <div class="modal-close" onclick="closeModal('momentChoiceModal')">取消</div>
            </div>
            <div class="modal-body">
                <div class="post-choice-container">
                    <div class="choice-option" onclick="selectMomentType('manual')">
                        <div class="choice-icon">✍️</div>
                        <div class="choice-title">自己发朋友圈</div>
                        <div class="choice-description">手动输入朋友圈内容，系统会生成评论</div>
                    </div>
                    <div class="choice-option" onclick="selectMomentType('generate')">
                        <div class="choice-icon">✨</div>
                        <div class="choice-title">生成朋友圈</div>
                        <div class="choice-description">AI根据聊天记录自动生成朋友圈和评论</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 手动发朋友圈模态框 -->
    <div class="modal" id="manualMomentModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">发布朋友圈</div>
                <div class="modal-close" onclick="closeModal('manualMomentModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleManualMoment(event)">
                    <div class="form-group">
                        <label class="form-label">发布人</label>
                        <input type="text" class="form-input" id="manualMomentAuthor" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">朋友圈内容</label>
                        <textarea class="form-input" id="manualMomentContent" placeholder="输入你的朋友圈内容..." rows="4" required></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label">位置（可选）</label>
                        <input type="text" class="form-input" id="manualMomentLocation" placeholder="输入位置信息...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">上传图片（最多9张）</label>
                        <input type="file" id="momentImagesInput" accept="image/*" multiple style="margin-bottom: 10px;" onchange="handleMomentImagesUpload(event)">
                        <div class="moment-images-preview" id="momentImagesPreview"></div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Manual Moment Submit">发布并生成评论</button>
                </form>
            </div>
        </div>
    </div>

    <!-- AI生成朋友圈模态框 -->
    <div class="modal" id="generateMomentModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">生成朋友圈</div>
                <div class="modal-close" onclick="closeModal('generateMomentModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleGenerateMoment(event)">
                    <div class="form-group">
                        <label class="form-label">选择角色</label>
                        <select class="form-input" id="momentGenCharacterSelect" required>
                            <option value="">请选择...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">朋友圈主题</label>
                        <input type="text" class="form-input" id="momentGenTopic" placeholder="例如：日常生活、工作感悟、美食分享等（可选）">
                    </div>
                    <div class="form-group">
                        <label class="form-label">位置（可选）</label>
                        <input type="text" class="form-input" id="momentGenLocation" placeholder="输入位置信息，留空则AI自动生成">
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Generate Moment Submit">生成朋友圈</button>
                </form>
            </div>
        </div>
    </div>

    <!-- 编辑位置模态框 -->
    <div class="modal" id="editLocationModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">修改位置</div>
                <div class="modal-close" onclick="closeModal('editLocationModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleEditLocation(event)">
                    <div class="form-group">
                        <label class="form-label">位置信息</label>
                        <input type="text" class="form-input" id="editLocationInput" placeholder="输入位置信息，留空则不显示位置">
                        <input type="hidden" id="editLocationMomentId">
                    </div>
                    <button type="submit" class="form-submit">保存</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="addContactModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="contactModalTitle">添加角色</div>
                <div class="modal-close" onclick="closeModal('addContactModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="saveContact(event)">
                    <div class="form-group">
                        <label class="form-label">角色名称</label>
                        <input type="text" class="form-input" id="contactName" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">头像（可选）</label>
                        <input type="url" class="form-input" id="contactAvatar" placeholder="可直接粘贴URL或上传本地图片">
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="avatarUploadInput" accept="image/*" style="flex: 1;" onchange="handleContactAvatarUpload(event, window.editingContact)">
                            <span id="avatarUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">人设描述</label>
                        <textarea class="form-textarea" id="contactPersonality" required placeholder="描述AI的性格、背景、说话风格等"></textarea>
                    </div>
                    
                    <!-- 【修改点 2】: 更新联系人设置中的语音ID提示 -->
                    <div class="form-group">
                        <label class="form-label">Minimax 语音ID（可选）</label>
                        <input type="text" class="form-input" id="contactVoiceId" placeholder="可选 - 填写后角色会拥有语音能力">
                        <div class="context-info" style="margin-top: 4px;">
                            在 <a href="https://www.minimaxi.com/voice-clone" target="_blank" rel="noopener noreferrer">Minimax官网</a> 克隆或创建声音！
                        </div>
                    </div>
                    
                    <div class="prompt-section">
                        <div class="prompt-header">
                            <div class="prompt-title">自定义提示词（可选）</div>
                            <div class="prompt-actions">
                                <button type="button" class="prompt-btn" onclick="document.getElementById('promptFile').click()">导入JSON</button>
                                <input type="file" id="promptFile" class="file-input" accept=".json" onchange="importPrompts(event)">
                            </div>
                        </div>
                        <div class="form-group">
                            <textarea class="form-textarea" id="customPrompts" placeholder="输入自定义提示词，或导入JSON文件"></textarea>
                        </div>
                    </div>
                    
                    <button type="submit" class="form-submit">确定</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="createGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">创建群聊</div>
                <div class="modal-close" onclick="closeModal('createGroupModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="createGroup(event)">
                    <div class="form-group">
                        <label class="form-label">群聊名称</label>
                        <input type="text" class="form-input" id="groupName" required>
                    </div>
                    
                    <div class="create-group-section">
                        <label class="form-label">选择群成员</label>
                        <div class="group-member-list" id="groupMemberList"></div>
                    </div>
                    
                    <button type="submit" class="form-submit">创建群聊</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="editProfileModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">编辑个人信息</div>
                <div class="modal-close" onclick="closeModal('editProfileModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="saveProfile(event)">
                    <div class="form-group">
                        <label class="form-label">昵称</label>
                        <input type="text" class="form-input" id="profileNameInput" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">头像（可选）</label>
                        <input type="url" class="form-input" id="profileAvatarInput" placeholder="可直接粘贴URL或上传本地图片">
                         <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="profileUploadInput" accept="image/*" style="flex: 1;" onchange="handleProfileAvatarUpload(event)">
                            <span id="profileUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">我的人设描述</label>
                        <textarea class="form-textarea" id="profilePersonality" placeholder="描述你的性格、背景、说话风格等，让AI更好地与你互动"></textarea>
                    </div>
                    <button type="submit" class="form-submit">保存</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="apiSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">API配置管理</div>
                <div class="modal-close" onclick="closeModal('apiSettingsModal')">取消</div>
            </div>
            <div class="modal-body">
                <!-- 配置选择和管理区域 -->
                <div class="config-management-section">
                    <div class="config-selector-row">
                        <div class="config-selector-group">
                            <label class="form-label">当前配置</label>
                            <select class="form-input" id="configSelector" onchange="handleConfigSwitch(this.value)">
                                <option value="">加载中...</option>
                            </select>
                        </div>
                        <div class="config-actions">
                            <button type="button" class="config-action-btn" onclick="showNewConfigForm()" title="新增配置">➕</button>
                            <button type="button" class="config-action-btn config-delete-btn" onclick="deleteCurrentConfig()" title="删除配置" id="deleteBtn">🗑️</button>
                        </div>
                    </div>
                </div>
                
                <!-- API配置表单 -->
                <form onsubmit="saveApiConfig(event)" id="apiConfigForm">
                    <div class="form-group">
                        <label class="form-label">配置名称</label>
                        <input type="text" class="form-input" id="configName" required placeholder="给这个配置起个名字">
                    </div>
                    
                    <div class="config-section">
                        <div class="config-section-title">API配置</div>
                        <div class="form-group">
                            <label class="form-label">API URL</label>
                            <input type="url" class="form-input" id="apiUrl" required placeholder="例如: https://api.openai.com/v1">
                        </div>
                        <div class="form-group main-api-key-group">
                            <label class="form-label">API Key (主Key)</label>
                            <div class="compact-key-row main-key-row">
                                <input type="password" class="form-input api-key-input compact-key-input" id="apiKey" required oninput="updateMainKeyStats(this); handleApiKeyInput(this, event)" placeholder="输入主API Key">
                                <div class="timeout-group">
                                    <input type="number" class="timeout-input" id="apiTimeout" min="5" max="300" value="60" placeholder="60" title="超时(秒)">
                                    <span class="timeout-unit">s</span>
                                </div>
                                <button type="button" class="key-status-btn main-key-status" data-status="enabled" data-enabled="true" onclick="toggleMainKeyStatus(this)" title="主Key(已启用)">🟢</button>
                                <div class="key-stats-compact">
                                    <div class="key-masked-compact" id="mainKeyMask">未设置</div>
                                    <div class="stats-compact">
                                        <span id="mainKeyCalls">0次</span>/<span id="mainKeySuccess">0%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <button type="button" class="form-submit" onclick="addProviderRow()" style="background-color: #28a745; margin-bottom: 10px; font-size: 14px; padding: 8px 16px;">
                                ➕ 添加API Key
                            </button>
                            <div class="context-info" style="margin-top: -5px; font-size: 12px; color: #666;">
                                可以添加多个API Key，手动选择启用的Key
                            </div>
                        </div>
                        
                        <button type="button" class="form-submit" onclick="enhancedTestApiConnection()" style="margin-bottom: 10px;" data-umami-event="Test API Connection">测试连接</button>
                    </div>
                    
                    <button type="submit" class="form-submit" data-umami-event="Save API Config">保存API配置 <small>(第1步)</small></button>
                    <div class="form-step-hint" id="configSaveHint">
                        ✅ API配置已保存！接下来：<strong>①选择配置 ②选择模型 ③滑到最后点击"完成设置"</strong>
                    </div>
                </form>
                
                <!-- 模型和功能配置 -->
                <form onsubmit="saveAppSettings(event)" id="appSettingsForm" style="margin-top: 20px;">
                    <div class="config-section">
                        <div class="config-section-title">应用设置</div>
                        
                        <div class="context-control">
                            <div class="context-header">
                                <div class="context-title">上下文长度</div>
                                <div class="context-value" id="contextValue">10条</div>
                            </div>
                            <input 
                                type="range" 
                                class="context-slider" 
                                id="contextSlider" 
                                min="1" 
                                max="50" 
                                value="10"
                                oninput="updateContextValue(this.value)"
                            >
                            <div class="context-info">
                                控制AI可见的历史消息数量，较长的上下文有助于保持对话连贯性，但可能会增加API成本。
                            </div>
                        </div>
                        
                        <div class="config-section">
                            <div class="config-section-title">模型选择</div>
                            <div class="form-step-reminder" id="modelSelectionReminder">
                                💡 <strong>操作流程：</strong>①保存上方API配置 → ②选择API配置 → ③选择模型 → ④滑到最后点击"完成设置"
                            </div>
                        
                        <div class="form-group">
                            <label class="form-label">主要模型</label>
                            <div class="model-selection-row">
                                <select class="form-input model-config-select" id="primaryConfigSelect" onchange="loadModelsForConfig('primaryConfigSelect', 'primaryModelSelect')">
                                    <option value="">选择API配置</option>
                                </select>
                                <select class="form-input model-select" id="primaryModelSelect" onchange="saveModelSelection('primary')">
                                    <option value="">请先完成第1步保存API配置</option>
                                </select>
                            </div>
                            <div class="context-info" style="margin-top: 4px;">生成对话、生成帖子等使用的模型。建议选择质量高的模型。</div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">次要模型</label>
                            <div class="model-selection-row">
                                <select class="form-input model-config-select" id="secondaryConfigSelect" onchange="loadModelsForConfig('secondaryConfigSelect', 'secondaryModelSelect')">
                                    <option value="">选择API配置</option>
                                    <option value="sync_with_primary">与主模型保持一致</option>
                                </select>
                                <select class="form-input model-select" id="secondaryModelSelect" onchange="saveModelSelection('secondary')">
                                    <option value="">请先完成第1步保存API配置</option>
                                    <option value="sync_with_primary">与主模型保持一致</option>
                                </select>
                            </div>
                            <div class="context-info" style="margin-top: 4px;">用于总结、填写记忆表格等，建议选择便宜的模型，以节约成本。若不介意成本，可选择与主要模型保持一致。</div>
                        </div>
                        </div>
                    
                    <div class="config-section">
                        <div class="config-section-title">扩展功能</div>
                        <div class="form-group">
                            <label for="minimaxGroupId" class="form-label">Minimax Group ID</label>
                            <input type="text" id="minimaxGroupId" class="form-input" placeholder="输入你的 Minimax Group ID...">
                        </div>
                        <div class="form-group">
                            <label for="minimaxApiKey" class="form-label">Minimax API Key (for TTS)</label>
                            <input type="password" id="minimaxApiKey" class="form-input" placeholder="输入你的 Minimax API Key...">
                            <div class="context-info" style="margin-top: 4px;">
                                用于语音克隆功能。在 <a href="https://www.minimaxi.com/" target="_blank" rel="noopener noreferrer">Minimax官网</a> 获取凭证。
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="unsplashApiKey" class="form-label">Unsplash API Key（可选）</label>
                            <input type="password" id="unsplashApiKey" class="form-input" placeholder="输入你的 Unsplash Access Key...">
                            <div class="context-info" style="margin-top: 4px;">
                                用于为论坛帖子和朋友圈自动配图。在 <a href="https://unsplash.com/developers" target="_blank" rel="noopener noreferrer">Unsplash Developers</a> 获取API Key。
                            </div>
                        </div>
                        </div>
                    </div>

                    <div class="final-step-hint">
                        🎯 <strong>最后一步：</strong>确认已选择配置和模型后，点击下方按钮完成设置！
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Save App Settings">完成设置 <small>(第2步)</small></button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="backgroundModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">设置聊天背景</div>
                <div class="modal-close" onclick="closeModal('backgroundModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="setBackground(event)">
                    <div class="form-group">
                        <label class="form-label">背景图片</label>
                        <input type="url" class="form-input" id="backgroundUrl" placeholder="可直接粘贴URL或上传本地图片">
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="bgUploadInput" accept="image/*" style="flex: 1;" onchange="window.ImageUploadHandlers.handleBgUpload(event)">
                            <span id="bgUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Contact Background Save">确定</button>
                </form>
            </div>
        </div>
    </div>

    <div class="modal" id="addEmojiModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">添加表情包</div>
                <div class="modal-close" onclick="closeModal('addEmojiModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="addEmoji(event)">
                    <div class="form-group">
                        <label class="form-label">表情图片</label>
                        <input type="url" class="form-input" id="emojiUrl" placeholder="可直接粘贴URL或上传本地图片" required>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <input type="file" id="emojiUploadInput" accept="image/*" style="flex: 1;" onchange="window.ImageUploadHandlers.handleEmojiFileUpload(event)">
                            <span id="emojiUploadStatus" style="font-size: 12px; color: #07c160;"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">表情含义（用于AI理解和调用）</label>
                        <input type="text" class="form-input" id="emojiMeaning" required placeholder="例如：开心、大笑、哭泣等">
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Sticker Save">添加</button>
                </form>
            </div>
        </div>
    </div>
    
    <div class="modal" id="redPacketModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">发红包</div>
                <div class="modal-close" onclick="closeModal('redPacketModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="sendRedPacket(event)">
                    <div class="form-group">
                        <label class="form-label">金额</label>
                        <input type="number" class="form-input" id="redPacketAmount" step="0.01" required placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label class="form-label">留言（可选）</label>
                        <input type="text" class="form-input" id="redPacketMessage" placeholder="恭喜发财，大吉大利！">
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Redpacket Send">塞钱进红包</button>
                </form>
            </div>
        </div>
    </div>

    <div id="musicModal" class="music-modal">
        <div class="music-modal-content">
            <span class="close-btn" id="closeMusicModal">&times;</span>
            <h2>🎵 音乐播放器</h2>
            
            <div id="currentSongInfo" style="display: none;">
                <h3>正在播放: <span id="currentSongName"></span></h3>
                <div class="player-controls">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="time-display">
                        <span id="currentTime">0:00</span>
                        <span id="totalTime">0:00</span>
                    </div>
                    <div style="text-align: center; margin-top: 10px;">
                        <button class="form-submit" onclick="togglePlay()">
                            <span id="playPauseBtn">▶️ 播放</span>
                        </button>
                        <button class="form-submit" style="background-color: #888;" onclick="stopMusic()">⏹️ 停止</button>
                    </div>
                </div>
            </div>

            <h3>我的歌单</h3>
            <div class="playlist-container" id="playlistContainer">
                <p style="text-align: center; color: #999;">暂无歌曲</p>
            </div>

            <h3>添加新歌曲</h3>
            <div id="addSongForm">
                <div class="form-group">
                    <label class="form-label">歌曲名称 (可选):</label>
                    <input type="text" class="form-input" id="songName" placeholder="留空则使用文件名">
                </div>
                <div class="form-group">
                    <label class="form-label">选择音乐文件:</label>
                    <input type="file" class="form-input" id="musicFileUpload" accept="audio/*,.mp3,.m4a,.wav,.flac">
                </div>
                <div class="form-group">
                    <label class="form-label">LRC歌词文件 (可选):</label>
                    <input type="file" class="form-input" id="lrcFile" accept=".lrc">
                    <small style="color: #666;">请选择.lrc格式的歌词文件</small>
                </div>
                <button class="form-submit" onclick="saveSong()">保存歌曲</button>
            </div>

            <div style="margin-top: 20px;">
                <label>
                    <input type="checkbox" id="showLyrics" onchange="toggleLyricsDisplay()">
                    显示浮动歌词
                </label>
            </div>
        </div>
    </div>

    <div id="floatingLyrics" class="floating-lyrics" style="display: none;">
        <span id="currentLyric">等待歌词...</span>
    </div>

    <div class="toast" id="toast"></div>
    
    <div class="top-notification" id="topNotification"></div>

    <!-- Update Announcement Modal -->
    <div class="modal" id="updateModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">更新公告</div>
            </div>
            <div class="modal-body" id="updateModalBody">
                <!-- Content will be injected by JS to handle markdown -->
            </div>
            <div class="modal-footer">
                 <button class="form-submit" id="updateModalCloseBtn">我知道了</button>
            </div>
        </div>
    </div>

    <!-- Post Choice Modal -->
    <div class="modal" id="postChoiceModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">创建论坛帖子</div>
                <div class="modal-close" onclick="closeModal('postChoiceModal')">取消</div>
            </div>
            <div class="modal-body">
                <div class="post-choice-container">
                    <div class="choice-option" onclick="selectPostType('manual')">
                        <div class="choice-icon">✍️</div>
                        <div class="choice-title">自己发帖子</div>
                        <div class="choice-description">手动输入帖子内容，系统会生成评论</div>
                    </div>
                    <div class="choice-option" onclick="selectPostType('generate')">
                        <div class="choice-icon">✨</div>
                        <div class="choice-title">生成帖子</div>
                        <div class="choice-description">AI根据聊天记录自动生成帖子和评论</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Manual Post Modal -->
    <div class="modal" id="manualPostModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">发布帖子</div>
                <div class="modal-close" onclick="closeModal('manualPostModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleManualPost(event)">
                    <div class="form-group">
                        <label class="form-label">发帖人</label>
                        <input type="text" class="form-input" id="manualPostAuthor" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">话题标签</label>
                        <input type="text" class="form-input" id="manualPostTag" value="碎碎念" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">帖子内容</label>
                        <textarea class="form-input" id="manualPostContent" placeholder="输入你的帖子内容..." rows="4" required></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label">图片描述</label>
                        <textarea class="form-input" id="manualPostImageDesc" placeholder="描述配图内容（可选）..." rows="2"></textarea>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Manual Forum Post Submit">发布并生成评论</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Memory Modal -->
    <div class="modal" id="addMemoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">添加记忆</div>
                <div class="modal-close" onclick="closeModal('addMemoryModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleAddMemory(event)">
                    <div class="form-group" id="memoryTypeGroup">
                        <label class="form-label">记忆类型</label>
                        <select class="form-input" id="memoryType" onchange="handleMemoryTypeChange()">
                            <option value="global">全局记忆</option>
                            <option value="character">角色记忆</option>
                        </select>
                    </div>
                    <div class="form-group hidden" id="characterSelectGroup">
                        <label class="form-label">选择角色</label>
                        <select class="form-input" id="memoryCharacterSelect">
                            <option value="">选择角色...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">记忆内容</label>
                        <textarea class="form-input" id="memoryContent" placeholder="填写你想让AI记住的内容，一行为一条新记忆" rows="6" required></textarea>
                        <div class="form-hint">每行为一条记忆，系统会自动格式化。</div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Memory Add Confirm">添加记忆</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Edit Memory Modal -->
    <div class="modal" id="editMemoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">编辑记忆</div>
                <div class="modal-close" onclick="closeModal('editMemoryModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleEditMemory(event)">
                    <div class="form-group">
                        <label class="form-label">记忆内容</label>
                        <textarea class="form-input" id="editMemoryContent" placeholder="请使用以下格式：&#10;- 第一条记忆&#10;- 第二条记忆&#10;- 第三条记忆" rows="6" required></textarea>
                        <div class="form-hint">只支持 "- 记忆内容" 格式，一行一条记忆。其他格式会被自动忽略。</div>
                    </div>
                    <button type="submit" class="form-submit">保存修改</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Edit Single Memory Item Modal -->
    <div class="modal" id="editSingleMemoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">编辑记忆项</div>
                <div class="modal-close" onclick="closeModal('editSingleMemoryModal')">取消</div>
            </div>
            <div class="modal-body">
                <form onsubmit="handleEditSingleMemory(event)">
                    <div class="form-group">
                        <label class="form-label">记忆内容</label>
                        <textarea class="form-input" id="editSingleMemoryContent" placeholder="填写你想让AI记住的内容" rows="4" required></textarea>
                        <div class="form-hint">编辑单条记忆的内容。</div>
                    </div>
                    <button type="submit" class="form-submit" data-umami-event="Memory Edit Save">保存修改</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Banner上传模态框 -->
    <div class="modal" id="bannerUploadModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">更换背景图片</div>
                <div class="modal-close" onclick="closeModal('bannerUploadModal')">取消</div>
            </div>
            <div class="modal-body">
                <div class="banner-upload-container">
                    <div class="banner-upload-area" id="bannerUploadArea" onclick="triggerBannerFileInput()">
                        <div class="banner-upload-icon">📷</div>
                        <div class="banner-upload-text">点击选择图片</div>
                        <div class="banner-upload-hint">支持 JPG、PNG 格式，推荐横图</div>
                    </div>
                    <input type="file" id="bannerFileInput" accept="image/jpeg,image/jpg,image/png" style="display: none;" onchange="handleBannerFileSelect(event)">
                </div>
                
                <!-- 预览和裁剪区域 -->
                <div class="banner-preview-container" id="bannerPreviewContainer" style="display: none;">
                    <div class="banner-preview-title">预览效果</div>
                    <div class="banner-preview-wrapper">
                        <canvas id="bannerPreviewCanvas" width="400" height="160"></canvas>
                    </div>
                    <div class="banner-crop-controls">
                        <label>垂直位置调整：</label>
                        <input type="range" id="bannerCropSlider" min="0" max="100" value="50" oninput="updateBannerPreview()">
                    </div>
                    <div class="banner-upload-buttons">
                        <button class="btn-secondary" onclick="resetBannerUpload()">重新选择</button>
                        <button class="btn-primary" onclick="saveBannerImage()" data-umami-event="Banner Upload Save">应用背景</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 七夕节AI空回复重试模态框 -->
    <div class="modal" id="qixiRetryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">🌟 请求失败</div>
                <div class="modal-close" onclick="closeModal('qixiRetryModal')">✕</div>
            </div>
            <div class="modal-body">
                <div class="qixi-retry-content">
                    <div class="qixi-retry-icon">❤️‍🩹</div>
                    <div class="qixi-retry-message">
                        <p><strong>操作失败</strong></p>
                        <p>是否要重新尝试？</p>
                    </div>
                </div>
                <div class="qixi-retry-buttons">
                    <button type="button" class="form-button qixi-retry-btn" onclick="handleQixiRetry()">
                        重新尝试
                    </button>
                    <button type="button" class="form-button qixi-cancel-btn" onclick="closeModal('qixiRetryModal')">
                        取消
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 清空localStorage确认对话框 -->
    <div class="modal" id="clearLocalStorageModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">⚠️ 危险操作确认</div>
                <div class="modal-close" onclick="closeModal('clearLocalStorageModal')">✕</div>
            </div>
            <div class="modal-body">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">🗑️</div>
                    <div style="margin-bottom: 20px;">
                        <p style="font-size: 16px; font-weight: bold; color: #dc3545; margin-bottom: 10px;">
                            你即将清空所有localStorage！
                        </p>
                        <p style="font-size: 14px; color: #666; margin-bottom: 8px;">
                            这可能会导致意外的逻辑触发
                        </p>
                        <p style="font-size: 14px; color: #dc3545; font-weight: 600;">
                            除非你知道你在做什么，否则不要确认！
                        </p>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button data-umami-event="Confirm Clear localStorage" type="button" class="form-button" onclick="executeLocalStorageClear()" 
                                style="flex: 1; background: #dc3545; color: white; border: none; padding: 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                            确认
                        </button>
                        <button type="button" class="form-button" onclick="closeModal('clearLocalStorageModal')" 
                                style="flex: 1; background: #6c757d; color: white; border: none; padding: 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                            取消
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- API模型加载等待提示框 -->
    <div class="modal" id="apiLoadingModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">正在加载模型信息</div>
                <div class="modal-close" onclick="cancelApiLoading()">取消</div>
            </div>
            <div class="modal-body">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⏳</div>
                    <div style="margin-bottom: 20px;">
                        <p style="font-size: 16px; margin-bottom: 10px;">
                            正在获取模型列表...
                        </p>
                        <p style="font-size: 14px; margin-bottom: 6px;">
                            此过程取决于您的网速和存储配置的数量。若等待时间过长，建议更换网络重试。
                        </p>
                        <p style="font-size: 24px; font-weight: bold; color: var(--theme-primary);" id="loadingCountdown">
                            0s
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/marked@4.3.0/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- 🔥 统一数据库管理器 - 替代所有数据库相关模块 -->
    <script>
/**
 * 🔥 统一数据库管理器 - 终极简化版
 * 
 * 设计目标：
 * 1. 单一责任：所有数据库操作的唯一入口
 * 2. 状态同步：自动处理跨页面状态同步
 * 3. 简单可靠：单一初始化方法，自动错误恢复
 * 4. 功能完整：整合所有现有数据库功能
 * 5. 向后兼容：保持现有API接口不变
 * 
 * ⚠️ ARCHITECTURAL DEBT WARNING:
 * This file currently mixes database operations with UI concerns (DOM manipulation,
 * alerts, confirm dialogs, toast notifications). This violates separation of concerns
 * and harms maintainability and testability.
 * 
 * TODO - Future Refactoring Plan:
 * 1. Create DatabaseUIManager class for all UI interactions
 * 2. Keep UnifiedDBManager focused only on pure database operations
 * 3. Move StorageManager, DatabaseManager UI functions to separate UI layer
 * 4. Use event system or callbacks for UI notifications instead of direct coupling
 * 5. Make functions pure and testable by removing side effects
 */

class UnifiedDBManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.version = 14; // 版本升级到14，支持图片分类功能
        this.db = null;
        this.isReady = false;
        this.initPromise = null;
        this.urlCache = new Map(); // 文件URL缓存
        
        // 定义不参与手动导入导出的存储（图片等大数据） - 与原始dataMigrator.js完全一致
        this.excludedFromManualExport = ['emojiImages', 'fileStorage', 'imageUsageMetadata'];
        
        // 文件类型映射
        this.mimeTypes = {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg', 
            'png': 'image/png',
            'gif': 'image/gif',
            'webp': 'image/webp',
            'bmp': 'image/bmp',
            'svg': 'image/svg+xml'
        };

        // 图片使用类型枚举
        this.imageUsageTypes = {
            PERMANENT: 'permanent',     // 持续使用的表情包
            TEMPORARY: 'temporary',     // 临时性图片（朋友圈等）
            RECENT: 'recent',          // 最近使用
            ARCHIVE: 'archive'         // 归档（不常用）
        };

        // 定义完整的数据库模式 - 与原始dataMigrator.js完全一致
        this.stores = {
            songs: { keyPath: 'id', autoIncrement: true },
            contacts: { keyPath: 'id' },
            apiSettings: { keyPath: 'id' },
            emojis: { keyPath: 'id' },
            emojiImages: { keyPath: 'tag' }, // 存储表情图片的base64数据（将逐步迁移到fileStorage）
            backgrounds: { keyPath: 'id' },
            userProfile: { keyPath: 'id' },
            moments: { keyPath: 'id' },
            weiboPosts: { keyPath: 'id', autoIncrement: true },
            hashtagCache: { keyPath: 'id' },
            characterMemories: { keyPath: 'contactId' },
            conversationCounters: { keyPath: 'id' },
            globalMemory: { keyPath: 'id' },
            memoryProcessedIndex: { keyPath: 'contactId' },
            fileStorage: { keyPath: 'fileId' }, // 新增：存储原始文件Blob数据
            fileReferences: { keyPath: 'referenceId' }, // 新增：存储文件引用关系
            themeConfig: { keyPath: 'type' }, // 新增：存储主题配置（颜色、渐变等）
            imageUsageMetadata: { keyPath: 'fileId' } // 新增：图片使用元数据表
        };
        
        console.log('🔥 [UnifiedDB] 统一数据库管理器已创建');
    }

    /**
     * 初始化数据库 - 唯一入口方法
     */
    async init() {
        // 如果已经初始化过，直接返回
        if (this.isReady && this.db) {
            console.log('🔥 [UnifiedDB] 数据库已初始化，直接返回');
            this.syncToGlobal();
            return this.db;
        }

        // 如果正在初始化，等待现有初始化完成
        if (this.initPromise) {
            console.log('🔥 [UnifiedDB] 正在初始化中，等待完成...');
            return await this.initPromise;
        }

        // 开始新的初始化流程
        console.log('🔥 [UnifiedDB] 开始数据库初始化...');
        this.initPromise = this._performInit();
        
        try {
            const result = await this.initPromise;
            this.initPromise = null;
            return result;
        } catch (error) {
            this.initPromise = null;
            throw error;
        }
    }

    /**
     * 执行实际的初始化工作
     */
    async _performInit() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => {
                const error = new Error(`数据库打开失败: ${request.error?.message}`);
                console.error('🔥 [UnifiedDB]', error);
                reject(error);
            };
            
            request.onsuccess = () => {
                this.db = request.result;
                this.isReady = true;
                
                console.log(`🔥 [UnifiedDB] 初始化成功，版本: ${this.db.version}`);
                console.log(`🔥 [UnifiedDB] 可用存储:`, Array.from(this.db.objectStoreNames));
                
                // 同步到全局状态
                this.syncToGlobal();
                
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                console.log('🔥 [UnifiedDB] 数据库需要升级...');
                const db = event.target.result;
                this._createStores(db, event.oldVersion);
            };
        });
    }

    /**
     * 创建所有必要的对象存储 - 完全遵循原始dataMigrator.js逻辑
     */
    _createStores(db, oldVersion) {
        console.log(`🔥 [UnifiedDB] 数据库升级: 版本${oldVersion} -> 版本${this.version}`);
        
        try {
            // 处理废弃存储的删除 - 与原始逻辑完全一致
            if (this.version >= 12) {
                // 版本12及以上移除了bubbleDesignerStickers
                if (db.objectStoreNames.contains('bubbleDesignerStickers')) {
                    db.deleteObjectStore('bubbleDesignerStickers');
                    console.log('🔥 [UnifiedDB] 删除废弃的 bubbleDesignerStickers 存储');
                }
            }
            
            // 创建所有对象存储（如果不存在）
            Object.entries(this.stores).forEach(([storeName, config]) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    try {
                        const store = db.createObjectStore(storeName, config);
                        console.log(`🔥 [UnifiedDB] 创建 ${storeName} 存储成功`);
                        
                        // 为特定存储添加索引
                        if (storeName === 'fileReferences') {
                            // 为文件引用表添加category索引，方便按类型查询
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('fileId', 'fileId', { unique: false });
                            console.log('🔥 [UnifiedDB] 为 fileReferences 添加索引');
                        }
                        
                        if (storeName === 'imageUsageMetadata') {
                            // 为图片使用元数据表添加简化的索引
                            store.createIndex('usageType', 'usageType', { unique: false });
                            store.createIndex('category', 'category', { unique: false });
                            store.createIndex('createdAt', 'createdAt', { unique: false });
                            console.log('🔥 [UnifiedDB] 为 imageUsageMetadata 添加索引');
                        }
                        
                    } catch (storeError) {
                        console.error(`🔥 [UnifiedDB] 创建存储 ${storeName} 失败:`, storeError);
                        throw storeError;
                    }
                }
            });
            
            console.log('🔥 [UnifiedDB] 数据库结构升级完成');
            
        } catch (upgradeError) {
            console.error('🔥 [UnifiedDB] 数据库升级过程中出错:', upgradeError);
            throw upgradeError;
        }
    }

    /**
     * 同步状态到全局对象 - 简化的跨页面通信
     */
    syncToGlobal() {
        if (typeof window !== 'undefined') {
            // 设置全局数据库状态
            window.db = this.db;
            window.isIndexedDBReady = this.isReady;
            // 移除混乱的实例赋值 - 统一使用 window.unifiedDB 作为实例引用
            
            // 🔥 简化的跨页面通知：只使用localStorage事件
            try {
                // 写入状态信息
                const dbStatus = {
                    isReady: true,
                    version: this.db.version,
                    timestamp: Date.now(),
                    page: window.location.pathname
                };
                localStorage.setItem('dbStatus', JSON.stringify(dbStatus));
                
                // 触发跨页面事件
                localStorage.setItem('dbSyncTrigger', Date.now().toString());
                localStorage.removeItem('dbSyncTrigger');
                
                console.log('🔥 [UnifiedDB] 已同步状态到全局并触发跨页面事件');
            } catch (e) {
                console.warn('🔥 [UnifiedDB] localStorage 同步失败:', e);
            }
        }
    }

    /**
     * 等待数据库就绪
     */
    static async waitForReady(timeout = 8000) {
        console.log('🔥 [UnifiedDB] 开始等待数据库就绪...');
        
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            let resolved = false;
            let timeoutId = null;

            // 监听localStorage事件
            const storageListener = (event) => {
                if (event.key === 'dbSyncTrigger' && !resolved) {
                    console.log('🔥 [UnifiedDB] 收到跨页面同步事件');
                    setTimeout(checkReady, 50);
                }
            };

            // 清理函数 - 确保在所有退出路径中都调用
            const cleanup = () => {
                window.removeEventListener('storage', storageListener);
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
            };

            // 成功解析函数
            const resolveWithCleanup = (result) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    resolve(result);
                }
            };

            // 失败拒绝函数
            const rejectWithCleanup = (error) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    reject(error);
                }
            };

            const checkReady = () => {
                if (resolved) return;

                // 检查全局状态
                if (window.isIndexedDBReady && window.db && window.db.version >= 14) {
                    console.log('🔥 [UnifiedDB] 检测到数据库已就绪');
                    resolveWithCleanup(window.db);
                    return;
                }

                // 检查localStorage状态  
                try {
                    const dbStatus = JSON.parse(localStorage.getItem('dbStatus') || '{}');
                    if (dbStatus.isReady && dbStatus.version >= 14) {
                        console.log('🔥 [UnifiedDB] 从localStorage检测到数据库状态，尝试建立连接...');
                        
                        // 尝试为当前页面建立数据库连接
                        if (window.unifiedDB) {
                            window.unifiedDB.init().then(db => {
                                resolveWithCleanup(db);
                            }).catch(err => {
                                console.warn('🔥 [UnifiedDB] 连接建立失败:', err);
                                rejectWithCleanup(err);
                            });
                        }
                        // 移除了不可达的 getInstance 逻辑 - window.unifiedDB 检查已经处理了所有情况
                    }
                } catch (e) {
                    console.warn('🔥 [UnifiedDB] localStorage读取失败:', e);
                }

                // 超时检查
                if (Date.now() - startTime > timeout) {
                    rejectWithCleanup(new Error(`等待数据库就绪超时 (${timeout}ms)`));
                    return;
                }

                // 继续检查
                setTimeout(checkReady, 100);
            };

            // 注册事件监听器
            window.addEventListener('storage', storageListener);
            
            // 设置超时
            timeoutId = setTimeout(() => {
                rejectWithCleanup(new Error(`等待数据库就绪超时 (${timeout}ms)`));
            }, timeout);

            // 立即检查一次
            checkReady();
        });
    }

    /**
     * 获取全局实例 - 正确的单例模式实现
     */
    static getInstance() {
        if (!window.unifiedDB) {
            window.unifiedDB = new UnifiedDBManager();
        }
        return window.unifiedDB;
    }

    /**
     * 检查数据库是否就绪
     */
    static isReady() {
        return window.isIndexedDBReady && window.db && window.db.version >= 14;
    }

    // ============================================
    // 数据库操作方法 - 统一API
    // ============================================

    /**
     * 通用数据库操作封装
     */
    async _dbOperation(storeName, mode, operation, description) {
        if (!this.db) {
            await this.init();
        }

        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], mode);
                const store = transaction.objectStore(storeName);

                transaction.onerror = (event) => {
                    console.error(`🔥 [UnifiedDB] Transaction failed for ${description}:`, event.target.error);
                    reject(event.target.error);
                };

                const result = operation(store);

                if (mode === 'readwrite') {
                    // For write operations, the transaction's completion is the source of truth.
                    let operationResult;
                    const resultPromise = Promise.resolve(result);
                    
                    resultPromise.then(res => {
                        operationResult = res;
                    }).catch(reject); // Propagate errors from the inner promise.

                    transaction.oncomplete = () => {
                        resolve(operationResult);
                    };
                } else { // readonly
                    if (result && typeof result.then === 'function') {
                        result.then(resolve).catch(reject);
                    } else if (result && result.onsuccess !== undefined) {
                        result.onsuccess = () => resolve(result.result);
                        result.onerror = (event) => reject(event.target.error);
                    } else {
                        resolve(result);
                    }
                }
            } catch (error) {
                console.error(`🔥 [UnifiedDB] ${description || '数据库操作'}失败:`, error);
                reject(error);
            }
        });
    }

    /**
     * 获取数据
     */
    async get(storeName, key) {
        return this._dbOperation(storeName, 'readonly', store => store.get(key), `获取数据 ${storeName}:${key}`);
    }

    /**
     * 获取所有数据
     */
    async getAll(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.getAll(), `获取所有数据 ${storeName}`);
    }

    /**
     * 保存数据
     */
    async put(storeName, data) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.put(data);
            // Return a promise that resolves when the put operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `保存数据到 ${storeName}`);
    }

    /**
     * 删除数据
     */
    async delete(storeName, key) {
        return this._dbOperation(storeName, 'readwrite', store => {
            const request = store.delete(key);
            // Return a promise that resolves when the delete operation completes
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }, `删除数据 ${storeName}:${key}`);
    }

    /**
     * 计数数据
     */
    async count(storeName) {
        return this._dbOperation(storeName, 'readonly', store => store.count(), `计数 ${storeName}`);
    }

    /**
     * 导出整个数据库 - 完全遵循原始dataMigrator.js格式
     */
    async exportDatabase(options = {}) {
        try {
            if (!this.db) {
                await this.init();
            }

            const { stores = null, includeMetadata = true } = options;
            const exportData = {};
            
            // 添加元数据
            if (includeMetadata) {
                exportData._metadata = await this.getDatabaseInfo();
            }

            // 确定要导出的存储
            const storesToExport = stores || Array.from(this.db.objectStoreNames);
            
            // 导出每个对象存储的数据
            for (const storeName of storesToExport) {
                if (this.db.objectStoreNames.contains(storeName)) {
                    exportData[storeName] = await this.exportStore(storeName);
                }
            }

            return exportData;
            
        } catch (error) {
            console.error('🔥 [UnifiedDB] 数据库导出失败:', error);
            throw new Error(`导出失败: ${error.message}`);
        }
    }

    /**
     * 导出单个对象存储
     */
    async exportStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                let result = request.result;
                
                // 为保护用户隐私，在导出时移除API密钥
                if (storeName === 'apiSettings') {
                    result = result.map(item => {
                        const sanitized = { ...item };
                        // 清理敏感信息
                        if (sanitized.apiKey) delete sanitized.apiKey;
                        if (sanitized.password) delete sanitized.password;
                        return sanitized;
                    });
                }
                
                resolve(result);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 获取数据库版本信息
     */
    async getDatabaseInfo() {
        if (!this.db) {
            await this.init();
        }
        
        return {
            name: this.db.name,
            version: this.db.version,  // 这里使用实际数据库版本，不是目标版本
            stores: Array.from(this.db.objectStoreNames),
            exportTime: new Date().toISOString()
        };
    }

    /**
     * 导入数据库数据 - 完全遵循原始dataMigrator.js逻辑
     */
    async importDatabase(importData, options = {}) {
        try {
            const { 
                overwrite = false, 
                validateVersion = true,
                stores = null,
                enableMigration = true
            } = options;

            if (!this.db) {
                await this.init();
            }

            // 验证数据格式
            if (!importData || typeof importData !== 'object') {
                throw new Error('导入数据格式无效');
            }

            // 版本检查和迁移处理
            let migratedData = importData;
            if (importData._metadata && importData._metadata.version !== this.version) {
                if (enableMigration && importData._metadata.version < this.version) {
                    console.log(`🔥 [UnifiedDB] 检测到版本 ${importData._metadata.version}，开始迁移到版本 ${this.version}`);
                    migratedData = await this.migrateData(importData);
                } else if (validateVersion) {
                    throw new Error(`数据库版本不匹配。当前版本: ${this.version}, 导入版本: ${importData._metadata.version}`);
                }
            }

            // 确定要导入的存储
            const storesToImport = stores || Object.keys(migratedData).filter(key => key !== '_metadata');
            
            // 清空现有数据（如果选择覆盖）
            if (overwrite) {
                for (const storeName of storesToImport) {
                    if (this.db.objectStoreNames.contains(storeName)) {
                        await this.clearStore(storeName);
                    }
                }
            }

            // 导入数据
            const importResults = {};
            for (const storeName of storesToImport) {
                if (this.db.objectStoreNames.contains(storeName) && migratedData[storeName]) {
                    const result = await this.importStore(storeName, migratedData[storeName], overwrite);
                    importResults[storeName] = result;
                }
            }

            return { success: true, importedStores: storesToImport, results: importResults, migrated: migratedData !== importData };
            
        } catch (error) {
            console.error('🔥 [UnifiedDB] 数据库导入失败:', error);
            throw new Error(`导入失败: ${error.message}`);
        }
    }

    /**
     * 导入单个存储的数据
     */
    async importStore(storeName, data, overwrite = false) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            let addedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;

            // 批量导入数据
            data.forEach(item => {
                const request = overwrite ? store.put(item) : store.add(item);
                
                request.onsuccess = () => {
                    addedCount++;
                };
                
                request.onerror = () => {
                    if (request.error.name === 'ConstraintError') {
                        skippedCount++;
                    } else {
                        errorCount++;
                    }
                };
            });

            transaction.oncomplete = () => {
                resolve({
                    total: data.length,
                    added: addedCount,
                    skipped: skippedCount,
                    errors: errorCount
                });
            };

            transaction.onerror = () => reject(transaction.error);
        });
    }

    /**
     * 清空指定存储的所有数据
     */
    async clearStore(storeName) {
        if (!this.db) {
            await this.init();
        }
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.transaction([storeName], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                
                const store = transaction.objectStore(storeName);
                store.clear();
            } catch (error) {
                console.error(`🔥 [UnifiedDB] 清空存储 ${storeName} 失败:`, error);
                reject(error);
            }
        });
    }

    /**
     * 数据迁移函数 - 完全遵循原始dataMigrator.js逻辑
     */
    async migrateData(importData) {
        const { _metadata } = importData;
        const fromVersion = _metadata ? _metadata.version : 1;
        const toVersion = this.version;
        
        console.log(`🔥 [UnifiedDB] 开始数据迁移：从版本 ${fromVersion} 到版本 ${toVersion}`);
        
        // 创建迁移后的数据副本
        const migratedData = JSON.parse(JSON.stringify(importData));
        
        // 更新元数据版本
        migratedData._metadata.version = toVersion;
        migratedData._metadata.migrationTime = new Date().toISOString();
        migratedData._metadata.originalVersion = fromVersion;
        
        // 根据版本差异进行迁移
        if (fromVersion <= 4 && toVersion >= 5) {
            // 版本4到5的迁移：添加缺失的存储
            this.migrateFrom4To5(migratedData);
        }
        
        if (fromVersion <= 5 && toVersion >= 6) {
            // 版本5到6的迁移（如果有需要的话）
            this.migrateFrom5To6(migratedData);
        }
        
        if (fromVersion <= 6 && toVersion >= 7) {
            // 版本6到7的迁移（如果有需要的话）
            this.migrateFrom6To7(migratedData);
        }
        
        if (fromVersion <= 7 && toVersion >= 8) {
            // 版本7到8的迁移：添加文件存储系统
            this.migrateFrom7To8(migratedData);
        }
        
        if (fromVersion <= 8 && toVersion >= 9) {
            // 版本8到9的迁移：完善文件存储系统
            this.migrateFrom8To9(migratedData);
        }
        
        if (fromVersion <= 9 && toVersion >= 10) {
            // 版本9到10的迁移：添加主题配置系统
            this.migrateFrom9To10(migratedData);
        }
        
        if (fromVersion <= 10 && toVersion >= 11) {
            // 版本10到11的迁移：添加气泡设计器贴图库
            this.migrateFrom10To11(migratedData);
        }
        
        if (fromVersion <= 11 && toVersion >= 12) {
            // 版本11到12的迁移：移除气泡设计器贴图库
            this.migrateFrom11To12(migratedData);
        }
        
        if (fromVersion <= 12 && toVersion >= 13) {
            // 版本12到13的迁移：优化数据结构
            this.migrateFrom12To13(migratedData);
        }
        
        if (fromVersion <= 13 && toVersion >= 14) {
            // 版本13到14的迁移：添加图片分类功能
            await this.migrateFrom13To14(migratedData);
        }
        
        console.log(`🔥 [UnifiedDB] 数据迁移完成：版本 ${fromVersion} -> ${toVersion}`);
        return migratedData;
    }

    // 迁移方法占位符 - 需要时可以实现具体逻辑
    migrateFrom4To5(data) {
        console.log('🔥 [UnifiedDB] 执行 4->5 版本迁移');
        // 添加缺失的存储初始化
        if (!data.characterMemories) data.characterMemories = [];
        if (!data.globalMemory) data.globalMemory = [];
    }

    migrateFrom5To6(data) {
        console.log('🔥 [UnifiedDB] 执行 5->6 版本迁移');
        // 可以添加具体迁移逻辑
    }

    migrateFrom6To7(data) {
        console.log('🔥 [UnifiedDB] 执行 6->7 版本迁移');
        // 可以添加具体迁移逻辑
    }

    migrateFrom7To8(data) {
        console.log('🔥 [UnifiedDB] 执行 7->8 版本迁移');
        // 添加文件存储系统
        if (!data.fileStorage) data.fileStorage = [];
        if (!data.fileReferences) data.fileReferences = [];
    }

    migrateFrom8To9(data) {
        console.log('🔥 [UnifiedDB] 执行 8->9 版本迁移');
        // 完善文件存储系统
    }

    migrateFrom9To10(data) {
        console.log('🔥 [UnifiedDB] 执行 9->10 版本迁移');
        // 添加主题配置系统
        if (!data.themeConfig) data.themeConfig = [];
    }

    migrateFrom10To11(data) {
        console.log('🔥 [UnifiedDB] 执行 10->11 版本迁移');
        // 添加气泡设计器贴图库（已在v12中移除）
    }

    migrateFrom11To12(data) {
        console.log('🔥 [UnifiedDB] 执行 11->12 版本迁移');
        // 移除气泡设计器贴图库
        if (data.bubbleDesignerStickers) {
            delete data.bubbleDesignerStickers;
        }
    }

    migrateFrom12To13(data) {
        console.log('🔥 [UnifiedDB] 执行 12->13 版本迁移');
        // 优化数据结构
    }

    /**
     * 版本13到14的迁移：添加图片使用元数据表
     * @param {Object} data - 数据
     */
    async migrateFrom13To14(data) {
        console.log('🔥 [UnifiedDB] 执行 13->14 版本迁移：添加图片分类功能');
        // imageUsageMetadata 表会在 _createStores 中自动创建
        
        try {
            // 为现有的表情包创建简化的 metadata（不区分 temp/permanent）
            if (data.emojis && Array.isArray(data.emojis)) {
                console.log('🔥 [UnifiedDB] 为现有表情包创建图库元数据');
                for (const emoji of data.emojis) {
                    if (emoji.id && emoji.tag) {
                        // 查找对应的文件记录
                        const fileReferences = data.fileReferences || [];
                        const emojiFile = fileReferences.find(ref => 
                            ref.referenceType === 'emoji' && ref.referenceKey === emoji.tag
                        );
                        
                        if (emojiFile && emojiFile.fileId) {
                            await this.setImageUsageMetadata(emojiFile.fileId, 'general', {
                                category: 'emoji',
                                tags: [emoji.tag],
                                createdAt: emoji.createdAt || new Date().toISOString(),
                                fileName: emoji.tag
                            });
                        }
                    }
                }
            }
            
            // 为现有的朋友圈图片创建简化的 metadata
            if (data.moments && Array.isArray(data.moments)) {
                console.log('🔥 [UnifiedDB] 为现有朋友圈图片创建图库元数据');
                for (const moment of data.moments) {
                    if (moment.imageFileIds && Array.isArray(moment.imageFileIds)) {
                        for (let i = 0; i < moment.imageFileIds.length; i++) {
                            const fileId = moment.imageFileIds[i];
                            await this.setImageUsageMetadata(fileId, 'general', {
                                category: 'moments',
                                tags: ['朋友圈', moment.authorName || '未知'],
                                createdAt: moment.timestamp || new Date().toISOString(),
                                fileName: `moment_${moment.id}_${i + 1}.jpg`
                            });
                        }
                    }
                }
            }
            
            console.log('🔥 [UnifiedDB] 历史图片元数据迁移完成');
        } catch (error) {
            console.error('🔥 [UnifiedDB] 迁移历史图片元数据失败:', error);
            // 迁移失败不影响整体升级
        }
    }

    // ============================================
    // 文件存储功能
    // ============================================

    /**
     * 生成唯一的文件ID
     */
    generateFileId() {
        return 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * 从base64字符串中提取MIME类型
     */
    getMimeTypeFromBase64(base64String) {
        const match = base64String.match(/^data:([^;]+);base64,/);
        return match ? match[1] : 'image/jpeg';
    }

    /**
     * 将base64字符串转换为Blob
     */
    base64ToBlob(base64String) {
        try {
            const mimeType = this.getMimeTypeFromBase64(base64String);
            const base64Data = base64String.split(',')[1];
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('🔥 [UnifiedDB] base64转换Blob失败:', error);
            return null;
        }
    }

    /**
     * 存储文件到数据库
     */
    async storeFile(fileData, metadata = {}) {
        let blob;
        
        if (typeof fileData === 'string' && fileData.startsWith('data:')) {
            // base64字符串
            blob = this.base64ToBlob(fileData);
            if (!blob) {
                throw new Error('无法转换base64数据');
            }
        } else if (fileData instanceof File || fileData instanceof Blob) {
            // File或Blob对象
            blob = fileData;
        } else {
            throw new Error(`不支持的文件数据类型: ${typeof fileData}`);
        }

        const fileId = this.generateFileId();
        const fileRecord = {
            fileId: fileId,
            blob: blob,
            type: blob.type,
            size: blob.size,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileStorage', fileRecord);
        
        console.log('🔥 [UnifiedDB] 文件存储成功，ID:', fileId);
        return {
            fileId: fileId,
            type: blob.type,
            size: blob.size
        };
    }

    /**
     * 获取文件
     */
    async getFile(fileId) {
        const result = await this.get('fileStorage', fileId);
        if (!result) {
            throw new Error(`文件不存在: ${fileId}`);
        }
        return result;
    }

    /**
     * 创建文件的临时URL
     */
    async createFileURL(fileId) {
        try {
            // 检查缓存
            if (this.urlCache.has(fileId)) {
                return this.urlCache.get(fileId);
            }

            const fileRecord = await this.getFile(fileId);
            
            // 更宽松的blob检查 - 兼容IndexedDB序列化的blob
            if (!fileRecord.blob) {
                throw new Error(`文件记录中缺少blob数据: ${fileId}`);
            }
            
            let blob = fileRecord.blob;
            
            // 如果不是标准Blob实例，尝试重新构造
            if (!(blob instanceof Blob)) {
                try {
                    // 检查是否是类似Blob的对象
                    if (blob.size !== undefined && blob.type !== undefined) {
                        // 如果有size和type属性，可能是序列化的Blob，尝试重新构造
                        console.log(`🔥 [UnifiedDB] 检测到非标准Blob对象，尝试重新构造: ${fileId}`);
                        
                        // 如果blob有stream方法，说明它仍然是有效的Blob-like对象
                        if (typeof blob.stream === 'function' || typeof blob.arrayBuffer === 'function') {
                            // 直接使用，可能是浏览器内部的Blob表示
                            console.log(`🔥 [UnifiedDB] 使用类Blob对象创建URL: ${fileId}`);
                        } else {
                            throw new Error('Blob对象缺少必要的方法');
                        }
                    } else {
                        throw new Error('无效的blob数据结构');
                    }
                } catch (reconstructError) {
                    throw new Error(`无法处理blob数据: ${reconstructError.message}`);
                }
            }
            
            const url = URL.createObjectURL(blob);
            
            // 缓存URL
            this.urlCache.set(fileId, url);
            
            return url;
        } catch (error) {
            console.error(`🔥 [UnifiedDB] 创建文件URL失败 (${fileId}):`, error);
            return '';
        }
    }

    /**
     * 清理文件URL缓存
     */
    revokeFileURL(fileId) {
        if (this.urlCache.has(fileId)) {
            const url = this.urlCache.get(fileId);
            URL.revokeObjectURL(url);
            this.urlCache.delete(fileId);
        }
    }

    // === 图片使用元数据管理方法 ===

    /**
     * 创建或更新图片使用元数据
     * @param {string} fileId - 文件ID
     * @param {string} usageType - 使用类型 (permanent/temporary/recent/archive)
     * @param {Object} metadata - 额外元数据
     */
    async setImageUsageMetadata(fileId, usageType, metadata = {}) {
        const usageData = {
            fileId: fileId,
            usageType: usageType,
            createdAt: metadata.createdAt || new Date().toISOString(),
            category: metadata.category || 'general', // emoji, moment, chat, avatar, background
            tags: metadata.tags || [],
            size: metadata.size || 0,
            fileName: metadata.fileName || null
        };

        await this.put('imageUsageMetadata', usageData);
        console.log(`🔥 [UnifiedDB] 设置图片使用元数据: ${fileId} -> ${usageType}`);
        return usageData;
    }


    /**
     * 获取图片使用元数据
     * @param {string} fileId - 文件ID
     */
    async getImageUsageMetadata(fileId) {
        return await this.get('imageUsageMetadata', fileId);
    }

    /**
     * 根据使用类型查询图片
     * @param {string} usageType - 使用类型
     * @param {number} limit - 限制数量
     */
    async getImagesByUsageType(usageType, limit = 100) {
        return await this._dbOperation('imageUsageMetadata', 'readonly', (store) => {
            const index = store.index('usageType');
            const request = index.getAll(usageType);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const results = request.result.slice(0, limit);
                    resolve(results);
                };
                request.onerror = () => reject(request.error);
            });
        }, `查询${usageType}类型图片`);
    }

    /**
     * 清理过期的临时图片
     * @param {string[]} fileIds - 要删除的文件ID数组
     */
    async cleanupSelectedImages(fileIds) {
        if (!Array.isArray(fileIds) || fileIds.length === 0) {
            return { deletedCount: 0, errors: [] };
        }

        try {
            let deletedCount = 0;
            const errors = [];

            for (const fileId of fileIds) {
                try {
                    // 删除文件
                    await this.deleteFile(fileId);
                    // 删除元数据
                    await this.delete('imageUsageMetadata', fileId);
                    // 删除相关引用
                    await this.cleanupFileReferences(fileId);
                    deletedCount++;
                    console.log(`🔥 [UnifiedDB] 已删除图片: ${fileId}`);
                } catch (error) {
                    console.warn(`删除图片失败: ${fileId}`, error);
                    errors.push({ fileId, error: error.message });
                }
            }

            console.log(`🔥 [UnifiedDB] 手动清理图片完成: ${deletedCount}/${fileIds.length}`);
            return { deletedCount, totalRequested: fileIds.length, errors };
        } catch (error) {
            console.error('批量删除图片失败:', error);
            throw error;
        }
    }

    /**
     * 清理指定文件的所有引用
     * @param {string} fileId - 文件ID
     */
    async cleanupFileReferences(fileId) {
        return await this._dbOperation('fileReferences', 'readwrite', (store) => {
            return new Promise((resolve, reject) => {
                try {
                    const index = store.index('fileId');
                    const request = index.openCursor(IDBKeyRange.only(fileId));
                    let deletedCount = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            deletedCount++;
                            cursor.continue();
                        } else {
                            // 所有匹配的记录都已处理完成
                            console.log(`🔥 [UnifiedDB] 清理文件引用: ${fileId} (${deletedCount}个引用)`);
                            resolve(deletedCount);
                        }
                    };

                    request.onerror = (event) => {
                        console.warn('清理文件引用失败:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.warn('清理文件引用失败:', error);
                    reject(error);
                }
            });
        }, `清理文件引用: ${fileId}`);
    }

    /**
     * 获取图片使用统计
     */
    async getImageUsageStats() {
        try {
            const allMetadata = await this.getAll('imageUsageMetadata');
            const stats = {
                total: allMetadata.length,
                byType: {},
                byCategory: {},
                totalSize: 0
            };

            allMetadata.forEach(meta => {
                // 按类型统计
                stats.byType[meta.usageType] = (stats.byType[meta.usageType] || 0) + 1;
                
                // 按分类统计
                stats.byCategory[meta.category] = (stats.byCategory[meta.category] || 0) + 1;
                
                // 总大小
                stats.totalSize += meta.size || 0;
            });

            return stats;
        } catch (error) {
            console.error('获取图片使用统计失败:', error);
            return null;
        }
    }

    /**
     * 删除文件
     */
    async deleteFile(fileId) {
        await this.delete('fileStorage', fileId);
        this.revokeFileURL(fileId);
        console.log(`🔥 [UnifiedDB] 文件删除成功: ${fileId}`);
    }

    /**
     * 创建文件引用关系
     */
    async createFileReference(fileId, referenceType, referenceKey, metadata = {}) {
        const referenceId = `${referenceType}_${referenceKey}`;
        const reference = {
            referenceId: referenceId,
            fileId: fileId,
            category: referenceType,
            referenceKey: referenceKey,
            createdAt: new Date().toISOString(),
            metadata: metadata
        };

        await this.put('fileReferences', reference);
        console.log('🔥 [UnifiedDB] 文件引用存储成功:', reference);
        return reference;
    }

    /**
     * 获取文件引用
     */
    async getFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        return await this.get('fileReferences', referenceId);
    }

    /**
     * 删除文件引用
     */
    async deleteFileReference(referenceType, referenceKey) {
        const referenceId = `${referenceType}_${referenceKey}`;
        await this.delete('fileReferences', referenceId);
        console.log(`🔥 [UnifiedDB] 文件引用删除成功: ${referenceId}`);
    }

    // ============================================
    // 向后兼容的辅助方法和错误处理
    // ============================================

    /**
     * 兼容旧的promisifyRequest方法
     */
    promisifyRequest(request, description = '') {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => {
                console.error(`🔥 [UnifiedDB] ${description}失败:`, request.error);
                reject(request.error);
            };
        });
    }

    /**
     * 兼容旧的ensureDBReady方法
     */
    async ensureDBReady(operation, description = '') {
        if (!this.isReady) {
            await this.init();
        }
        
        try {
            return await operation();
        } catch (error) {
            console.error(`🔥 [UnifiedDB] ${description}失败:`, error);
            throw error;
        }
    }

    /**
     * 重试机制 - 向后兼容
     */
    async retryWithBackoff(operation, context, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                lastError = error;
                console.warn(`🔥 [UnifiedDB] ${context} - 尝试 ${attempt}/${maxRetries} 失败:`, error);
                
                if (attempt < maxRetries) {
                    // 指数退避延迟
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.error(`🔥 [UnifiedDB] ${context} - 所有重试失败`);
                    throw lastError;
                }
            }
        }
        
        throw lastError;
    }
}

// ============================================
// 全局导出和兼容性设置 - 立即执行
// ============================================

/**
 * 显示数据库错误对话框 - 向后兼容
 */
function showDatabaseErrorDialog(error, isRetrying = false) {
    const title = isRetrying ? '数据库重试中...' : '数据库连接失败';
    const message = isRetrying 
        ? `数据库连接异常，正在自动重试...\n\n错误信息: ${error.message}`
        : `数据库连接失败。\n\n错误信息: ${error.message}\n\n建议:\n1. 刷新页面重试\n2. 清除浏览器缓存\n3. 检查浏览器是否支持IndexedDB`;
    
    console.error('🔥 [UnifiedDB] 数据库错误:', error);
    
    // Event-driven error dialog - replace direct alert() with custom event
    window.dispatchEvent(new CustomEvent('database:errorDialog', {
        detail: {
            title: title,
            message: message,
            error: error,
            isRetrying: isRetrying,
            suggestions: isRetrying ? [] : [
                '刷新页面重试',
                '清除浏览器缓存', 
                '检查浏览器是否支持IndexedDB'
            ]
        }
    }));
}

/**
 * 重试执行函数 - 向后兼容
 */
async function executeWithRetry(operation, context = '数据库操作') {
    if (window.unifiedDB && typeof window.unifiedDB.retryWithBackoff === 'function') {
        return await window.unifiedDB.retryWithBackoff(operation, context);
    }
    
    // 简单重试逻辑作为后备
    try {
        return await operation();
    } catch (error) {
        console.error(`🔥 [UnifiedDB] ${context} 失败:`, error);
        throw error;
    }
}

// 🔥 立即导出这些函数到全局作用域，确保其他脚本可以使用
if (typeof window !== 'undefined') {
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
}

// 获取全局单例实例
const unifiedDB = UnifiedDBManager.getInstance();

// 创建命名空间以减少全局污染
const AppDB = {
    // 核心管理器
    UnifiedDBManager: UnifiedDBManager,
    unifiedDB: unifiedDB,
    
    // 工具函数
    executeWithRetry: executeWithRetry,
    showDatabaseErrorDialog: showDatabaseErrorDialog,
    promisifyRequest: (request, description) => unifiedDB.promisifyRequest(request, description),
    ensureDBReady: (operation, description) => unifiedDB.ensureDBReady(operation, description),
    initUnifiedDB: () => unifiedDB.init(),
    
    // 管理器对象（将在下面定义）
    StorageManager: null,
    DatabaseManager: null,
    
    // 导入导出函数（将在下面定义）
    exportDatabase: null,
    exportFileStorage: null,
    importDatabase: null,
    performImport: null,
    
    // 文件处理函数（纯业务逻辑）
    performFileStorageImport: null,
    importPrompts: null,
    
    // UI函数现在由UIManager处理
    // handleFileSelect, handleFileStorageImport, confirmFileExport, cancelFileExport, refreshDatabaseStats
    // triggerFileSelect, triggerFileStorageImport
    
    // 文件存储管理器别名
    FileStorageManager: unifiedDB
};

// 导出到window对象
if (typeof window !== 'undefined') {
    window.AppDB = AppDB;
    
    // 向后兼容：保留关键的直接window导出
    window.UnifiedDBManager = UnifiedDBManager;
    window.unifiedDB = unifiedDB;
    window.promisifyRequest = AppDB.promisifyRequest;
    window.ensureDBReady = AppDB.ensureDBReady;
    window.executeWithRetry = executeWithRetry;
    window.showDatabaseErrorDialog = showDatabaseErrorDialog;
    window.initUnifiedDB = AppDB.initUnifiedDB;
    
    // 🔥 完整的 StorageManager 对象
    AppDB.StorageManager = {
        /**
         * 申请持久化存储（纯业务逻辑，不涉及UI）
         */
        async requestPersistentStorage() {
            try {
                console.log('[StorageManager] 申请持久化存储...');
                
                if (!navigator.storage || !navigator.storage.persist) {
                    const result = { success: false, error: '浏览器不支持持久化存储功能' };
                    window.dispatchEvent(new CustomEvent('storage:persistentUnsupported', { detail: result }));
                    return result;
                }

                // 申请持久化存储
                const granted = await navigator.storage.persist();
                const estimate = await navigator.storage.estimate();
                
                const result = {
                    success: true,
                    granted: granted,
                    estimate: estimate,
                    message: granted ? '持久化存储申请成功' : '持久化存储申请被拒绝'
                };

                // 发出事件通知UI层
                const eventType = granted ? 'storage:persistentGranted' : 'storage:persistentDenied';
                window.dispatchEvent(new CustomEvent(eventType, { detail: result }));
                
                console.log(`[StorageManager] 持久化存储申请${granted ? '成功' : '被拒绝'}`);
                
                // 通知需要刷新统计信息
                window.dispatchEvent(new CustomEvent('storage:statsRefreshNeeded'));
                
                return result;

            } catch (error) {
                console.error('[StorageManager] 申请持久化存储失败:', error);
                const result = { success: false, error: error.message };
                window.dispatchEvent(new CustomEvent('storage:persistentError', { detail: result }));
                return result;
            }
        },

        /**
         * 检查持久化存储状态
         */
        async checkPersistentStorageStatus() {
            try {
                if (!navigator.storage || !navigator.storage.persisted) {
                    return false;
                }
                return await navigator.storage.persisted();
            } catch (error) {
                console.error('[StorageManager] 检查持久化存储状态失败:', error);
                return false;
            }
        },

        /**
         * 获取存储使用情况
         */
        async getStorageUsage() {
            try {
                if (!navigator.storage || !navigator.storage.estimate) {
                    return null;
                }
                return await navigator.storage.estimate();
            } catch (error) {
                console.error('[StorageManager] 获取存储使用情况失败:', error);
                return null;
            }
        },

        /**
         * 检查IndexedDB是否为持久化存储
         */
        async checkPersistentStorage() {
            try {
                if ('storage' in navigator && 'persisted' in navigator.storage) {
                    const isPersistent = await navigator.storage.persisted();
                    const estimate = await navigator.storage.estimate();
                    
                    return {
                        success: true,
                        isPersistent: isPersistent,
                        estimate: estimate
                    };
                } else {
                    return {
                        success: false,
                        error: '浏览器不支持Storage API',
                        isPersistent: false
                    };
                }
            } catch (error) {
                console.error('检查持久化存储状态失败:', error);
                return {
                    success: false,
                    error: error.message,
                    isPersistent: false
                };
            }
        },

        // 删除重复方法 - requestPersistentStorage() 已在上面定义
    };

    // 向后兼容：保留 StorageManager 的直接 window 访问
    window.StorageManager = AppDB.StorageManager;

    // 🔥 完整的 DatabaseManager 对象
    AppDB.DatabaseManager = {
        init: () => unifiedDB.init(),
        
        /**
         * 检查数据库健康状态并提供修复选项
         */
        async checkAndOfferRepair() {
            try {
                console.log('[DatabaseManager] 开始数据库健康检查...');
                
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    console.warn('[DatabaseManager] 数据库未就绪，跳过健康检查');
                    return { success: false, error: '数据库未就绪' };
                }

                // 检查所有预期的存储是否存在
                const expectedStores = [
                    'contacts', 'apiSettings', 'emojis', 'backgrounds', 
                    'userProfile', 'moments', 'weiboPosts', 'hashtagCache',
                    'characterMemories', 'globalMemory', 'conversationCounters', 
                    'memoryProcessedIndex', 'themeConfig'
                ];

                const db = window.unifiedDB.db;
                const missingStores = expectedStores.filter(storeName => 
                    !db.objectStoreNames.contains(storeName)
                );

                if (missingStores.length > 0) {
                    console.warn('[DatabaseManager] 发现缺失的存储:', missingStores);
                    
                    // 发出事件，让UI层决定是否修复
                    const repairResult = await new Promise((resolve) => {
                        const eventData = { missingStores, resolve };
                        window.dispatchEvent(new CustomEvent('database:repairNeeded', { detail: eventData }));
                    });
                    
                    if (repairResult) {
                        return await this.repairDatabase(missingStores);
                    }
                    
                    return { success: false, message: '用户取消修复', missingStores };
                } else {
                    console.log('[DatabaseManager] 数据库结构完整');
                    return { success: true, message: '数据库结构完整' };
                }

                return { success: true, message: '健康检查完成' };

            } catch (error) {
                console.error('[DatabaseManager] 健康检查失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 修复数据库结构
         */
        async repairDatabase(missingStores) {
            try {
                console.log('[DatabaseManager] 开始修复数据库...');
                
                // 关闭现有连接
                if (window.unifiedDB && window.unifiedDB.db) {
                    window.unifiedDB.db.close();
                }

                // 重新初始化数据库以创建缺失的存储
                await window.unifiedDB.init();
                
                // 发出修复成功事件
                window.dispatchEvent(new CustomEvent('database:repairSuccess', {
                    detail: { message: '数据库修复完成' }
                }));

                return { success: true, message: '数据库修复完成' };

            } catch (error) {
                console.error('[DatabaseManager] 数据库修复失败:', error);
                
                // 发出修复失败事件
                window.dispatchEvent(new CustomEvent('database:repairError', {
                    detail: { error: error.message }
                }));

                return { success: false, error: error.message };
            }
        },

        /**
         * 获取数据库统计信息
         */
        async getStats() {
            try {
                if (!window.unifiedDB || !window.unifiedDB.isReady) {
                    return { success: false, error: '数据库未就绪' };
                }

                const db = window.unifiedDB.db;
                const stats = {};

                // 遍历所有对象存储获取记录数
                const storeNames = Array.from(db.objectStoreNames);
                
                for (const storeName of storeNames) {
                    try {
                        const count = await window.unifiedDB.count(storeName);
                        stats[storeName] = count;
                    } catch (error) {
                        console.warn(`[DatabaseManager] 获取存储 ${storeName} 统计失败:`, error);
                        stats[storeName] = 0;
                    }
                }

                return { success: true, stats };

            } catch (error) {
                console.error('[DatabaseManager] 获取统计信息失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 重置应用状态 - 清空内存中的全局变量
         * 在数据库导入后使用，确保应用状态与数据库同步
         */
        resetApplicationState() {
            // 联系人相关
            if (typeof window.contacts !== 'undefined') {
                window.contacts = [];
            }
            if (typeof window.currentContact !== 'undefined') {
                window.currentContact = null;
            }
            
            // 表情相关
            if (typeof window.emojis !== 'undefined') {
                window.emojis = [];
            }
            
            // 背景相关
            if (typeof window.backgrounds !== 'undefined') {
                window.backgrounds = {};
            }
            
            // 用户资料
            if (typeof window.userProfile !== 'undefined') {
                window.userProfile = { name: '我的昵称', avatar: '', personality: '' };
            }
            
            // 动态相关
            if (typeof window.moments !== 'undefined') {
                window.moments = [];
            }
            if (typeof window.weiboPosts !== 'undefined') {
                window.weiboPosts = [];
            }
            
            console.log('[DatabaseManager] 应用状态已重置');
        },

        /**
         * 导出并下载数据库
         */
        async exportAndDownload() {
            try {
                console.log('[DatabaseManager] 开始导出数据库...');
                
                const exportData = await window.unifiedDB.exportDatabase();
                
                // 创建下载链接
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `freeapp_backup_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                return { success: true, message: '数据库导出成功' };

            } catch (error) {
                console.error('[DatabaseManager] 导出数据库失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 从文件导入数据库
         */
        async importFromFile(file, overwrite = false) {
            try {
                console.log('[DatabaseManager] 开始导入数据库...');
                
                const text = await this.readFileAsText(file);
                const importData = JSON.parse(text);
                
                const result = await window.unifiedDB.importDatabase(importData, { overwrite });
                
                return { 
                    success: true, 
                    message: '数据库导入成功',
                    result: result
                };

            } catch (error) {
                console.error('[DatabaseManager] 导入数据库失败:', error);
                return { success: false, error: error.message };
            }
        },

        /**
         * 读取文件内容为文本
         */
        readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('文件读取失败'));
                reader.readAsText(file);
            });
        }
    };

    // 向后兼容：保留 DatabaseManager 的直接 window 访问
    window.DatabaseManager = AppDB.DatabaseManager;

    // 🔥 数据库统计刷新函数（纯业务逻辑，UI分离）
    AppDB.refreshDatabaseStats = async function() {
        try {
            // 发出刷新开始事件
            window.dispatchEvent(new CustomEvent('database:statsRefreshStart'));
            
            const [result, persistentResult] = await Promise.all([
                window.DatabaseManager.getStats(),
                window.StorageManager.checkPersistentStorage()
            ]);
            
            if (result.success) {
                // 发出成功事件，让UI层处理显示
                window.dispatchEvent(new CustomEvent('database:statsRefreshSuccess', {
                    detail: { result, persistentResult }
                }));
                return { success: true, result, persistentResult };
            } else {
                // 发出错误事件
                window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                    detail: { error: result.error }
                }));
                return { success: false, error: result.error };
            }
            
        } catch (error) {
            console.error('刷新数据库统计失败:', error);
            // 发出错误事件
            window.dispatchEvent(new CustomEvent('database:statsRefreshError', {
                detail: { error: error.message }
            }));
            return { success: false, error: error.message };
        }
    };

    // 向后兼容：refreshDatabaseStats 现在通过 UIManager 处理
    // window.refreshDatabaseStats is now assigned in uiManager.js

    // 🔥 数据库导出函数（纯业务逻辑）
    AppDB.exportDatabase = async function() {
        try {
            // 发出导出开始事件
            window.dispatchEvent(new CustomEvent('database:exportStart'));
            
            const result = await window.DatabaseManager.exportAndDownload();
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:exportSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:exportError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('导出出错:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:exportError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // 🔥 文件存储导出函数 - 纯业务逻辑，配置通过事件获取
    AppDB.exportFileStorage = async function() {
        try {
            // 通过事件请求导出配置
            const config = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:exportConfigNeeded', {
                    detail: { resolve }
                }));
            });

            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportStart', {
                detail: { config }
            }));

            const exporter = new FileStorageExporter();
            const result = await exporter.downloadFileStorageAsZip(config);

            if (result.success) {
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:exportSuccess', {
                    detail: { 
                        message: '文件存储导出成功！',
                        result: result
                    }
                }));
            } else {
                throw new Error(result.error || '导出失败');
            }

        } catch (error) {
            console.error('文件存储导出失败:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
        }
    };

    // 🔥 处理文件选择函数 - 纯业务逻辑，UI操作移至UIManager
    AppDB.handleFileSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: '未选择文件' };
        }
        
        console.log('选择的文件:', file.name, file.type, file.size);
        
        try {
            const result = await window.importDatabase(file);
            
            // 发出文件处理完成事件，让UI层处理清空操作
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('导入过程中出错:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('database:importError', {
                detail: {
                    error: error,
                    type: 'import_operation'
                }
            }));
            
            // 即使出错也要清空文件输入
            window.dispatchEvent(new CustomEvent('database:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // 🔥 处理文件存储选择函数 - 纯业务逻辑，UI操作通过事件处理
    AppDB.handleFileStorageSelect = async function(event) {
        const file = event.target.files[0];
        
        if (!file) {
            return { success: false, message: '未选择文件' };
        }
        
        console.log('选择的文件存储文件:', file.name, file.type, file.size);
        
        try {
            // 请求UI提供导入选项
            const options = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('fileStorage:importOptionsNeeded', {
                    detail: { resolve }
                }));
            });
            
            // 调用业务逻辑执行导入
            const result = await window.performFileStorageImport(file, options);
            
            // 发出文件处理完成事件，让UI层处理清空操作
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result }
            }));
            
            return result;
            
        } catch (error) {
            console.error('文件存储导入过程中出错:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:importError', {
                detail: {
                    error: error,
                    type: 'operation'
                }
            }));
            
            // 即使出错也要清空文件输入
            window.dispatchEvent(new CustomEvent('fileStorage:fileProcessed', {
                detail: { inputId: event.target.id, result: { success: false, error: error.message } }
            }));
            
            return { success: false, error: error.message };
        }
    };

    // 🔥 数据库导入函数（纯业务逻辑）
    AppDB.importDatabase = async function(file) {
        if (!file) {
            return { success: false, error: '未提供文件' };
        }
        
        try {
            // 请求UI确认
            const confirmed = await new Promise((resolve) => {
                window.dispatchEvent(new CustomEvent('database:importConfirmationNeeded', { 
                    detail: { file, resolve } 
                }));
            });
            
            if (!confirmed) {
                console.log('用户取消导入');
                return { success: false, message: '用户取消导入' };
            }
            
            // 发出导入开始事件
            window.dispatchEvent(new CustomEvent('database:importStart', { 
                detail: { fileName: file.name } 
            }));
            
            // 🎯 确保performImport函数已就绪
            if (!window.performImport || typeof window.performImport !== 'function') {
                console.log('⏳ [Import] performImport未就绪，等待初始化...');
                await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        console.warn('⚠️ [Import] performImport等待超时，尝试继续');
                        resolve();
                    }, 3000);

                    const checkReady = () => {
                        if (window.performImport && typeof window.performImport === 'function') {
                            clearTimeout(timeout);
                            console.log('✅ [Import] performImport已就绪');
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
            }

            const overwrite = true;
            const result = await window.performImport(file, overwrite);

            // 🔍 宽容的结果检查 - 允许undefined返回，通常刷新后会正常
            if (result === undefined) {
                console.warn('⚠️ [Import] performImport返回undefined，这通常在刷新后会自行修复');
                return {
                    success: false,
                    error: '导入功能暂时不可用，请刷新页面后重试',
                    needsRefresh: true
                };
            }
            
            if (result.success) {
                window.dispatchEvent(new CustomEvent('database:importSuccess', { 
                    detail: result 
                }));
            } else {
                window.dispatchEvent(new CustomEvent('database:importError', { 
                    detail: { error: result.error } 
                }));
            }
            
            return result;
            
        } catch (error) {
            console.error('导入失败:', error);
            const errorResult = { success: false, error: error.message };
            window.dispatchEvent(new CustomEvent('database:importError', { 
                detail: { error: error.message } 
            }));
            return errorResult;
        }
    };

    // 🔥 执行导入函数 - 重构为事件驱动架构
    AppDB.performImport = async function(file, overwrite) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('database:importProgress', {
                detail: { message: '正在导入数据库...', stage: 'starting' }
            }));
            
            if (!window.DatabaseManager) {
                console.error('window.DatabaseManager 不存在！');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('数据库管理器未初始化，请刷新页面后重试'),
                        type: 'initialization_error',
                        critical: true
                    }
                }));
                return;
            }
            
            if (!window.DatabaseManager.importFromFile) {
                console.error('importFromFile 方法不存在！');
                // Event-driven critical error notification
                window.dispatchEvent(new CustomEvent('database:importError', {
                    detail: {
                        error: new Error('导入功能不可用，请检查代码'),
                        type: 'function_missing',
                        critical: true
                    }
                }));
                return;
            }
            
            const result = await window.DatabaseManager.importFromFile(file, overwrite);
            
            if (result.success) {
                // 刷新统计信息
                if (typeof window.refreshDatabaseStats === 'function') {
                    window.refreshDatabaseStats();
                }
                
                // 重置应用状态，确保数据同步
                window.DatabaseManager.resetApplicationState();
                
                // Event-driven success notification with reload intent
                window.dispatchEvent(new CustomEvent('database:importSuccess', {
                    detail: { 
                        message: '数据库导入成功！页面将在3秒后自动刷新...',
                        result: result,
                        autoReload: true,
                        reloadDelay: 3000
                    }
                }));
                
                // 延迟刷新页面以确保用户看到成功消息
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
                
            } else {
                throw new Error(result.error || '导入失败');
            }
            
        } catch (error) {
            console.error('导入失败:', error.message);
            throw error; // 重新抛出以便上层处理
        }
    };

    // 🔥 执行文件存储导入函数 - 纯业务逻辑（UI交互已移至UIManager）
    AppDB.performFileStorageImport = async function(file, options) {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:importProgress', {
                detail: { message: '正在导入文件存储...', stage: 'starting' }
            }));

            const importer = new FileStorageImporter();
            const response = await importer.importFromZipFile(file, options);

            if (response.success) {
                // 映射返回结果格式以保持兼容性
                const result = {
                    imported: response.results.created,
                    skipped: response.results.skipped,
                    failed: response.results.failed,
                    matched: response.results.matched,
                    processed: response.results.processed,
                    totalFiles: response.results.totalFiles
                };

                const detailedMessage = `文件存储导入成功！\n\n导入统计：\n• 成功导入 ${result.imported} 个文件\n• 跳过 ${result.skipped} 个文件\n• 失败 ${result.failed} 个文件`;
                
                // Event-driven success notification
                window.dispatchEvent(new CustomEvent('fileStorage:importSuccess', {
                    detail: { 
                        message: '文件存储导入成功！',
                        detailedMessage: detailedMessage,
                        stats: {
                            imported: result.imported,
                            skipped: result.skipped,
                            failed: result.failed
                        },
                        result: result
                    }
                }));
                
                // 刷新统计信息
                if (typeof window.refreshDatabaseStats === 'function') {
                    setTimeout(() => {
                        window.refreshDatabaseStats();
                    }, 1000);
                }

            } else {
                throw new Error(response.error || '导入失败');
            }

        } catch (error) {
            console.error('文件存储导入失败:', error);
            throw error; // 重新抛出以便上层处理
        }
    };

    // 🔥 确认文件导出函数 - 纯业务逻辑，UI操作移至UIManager
    AppDB.confirmFileExport = async function() {
        try {
            // Event-driven progress notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportProgress', {
                detail: { message: '正在导出文件存储...', stage: 'confirming' }
            }));

            // 发出隐藏选项面板事件
            window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));

            const result = await window.exportFileStorage();
            return result;

        } catch (error) {
            console.error('确认文件导出失败:', error);
            // Event-driven error notification
            window.dispatchEvent(new CustomEvent('fileStorage:exportError', {
                detail: {
                    error: error,
                    type: 'confirmation_error'
                }
            }));
            return { success: false, error: error.message };
        }
    };

    // 🔥 取消文件导出函数 - 纯业务逻辑，UI操作移至UIManager
    AppDB.cancelFileExport = function() {
        // 发出隐藏选项面板事件
        window.dispatchEvent(new CustomEvent('fileStorage:hideExportOptions'));
        
        // Event-driven cancellation notification
        window.dispatchEvent(new CustomEvent('fileStorage:exportCancelled', {
            detail: { message: '用户取消了文件导出' }
        }));
        
        return { success: true, message: '用户取消了文件导出' };
    };

    // 🔥 导入提示词函数 - 重构为事件驱动架构
    AppDB.importPrompts = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                const prompts = JSON.parse(content);
                
                if (Array.isArray(prompts)) {
                    localStorage.setItem('customPrompts', JSON.stringify(prompts));
                    // Event-driven success notification
                    window.dispatchEvent(new CustomEvent('prompts:importSuccess', {
                        detail: { 
                            message: `成功导入 ${prompts.length} 个提示词`,
                            count: prompts.length,
                            prompts: prompts
                        }
                    }));
                } else {
                    throw new Error('文件格式不正确，应为提示词数组');
                }
            } catch (error) {
                console.error('导入提示词失败:', error);
                // Event-driven error notification
                window.dispatchEvent(new CustomEvent('prompts:importError', {
                    detail: {
                        error: error,
                        type: 'format_error'
                    }
                }));
            }
        };
        reader.readAsText(file);
        
        // 清空文件输入
        event.target.value = '';
    };
    
    // 向后兼容：保留所有函数的直接 window 访问
    window.exportDatabase = AppDB.exportDatabase;
    window.exportFileStorage = AppDB.exportFileStorage;
    // Pure database operations that remain in UnifiedDBManager
    window.importDatabase = AppDB.importDatabase;
    window.performImport = AppDB.performImport;
    window.performFileStorageImport = AppDB.performFileStorageImport;
    window.importPrompts = AppDB.importPrompts;
    
    // UI-related functions are now handled by UIManager
    // window.triggerFileSelect, window.triggerFileStorageImport, etc. are assigned in uiManager.js
    
    window.FileStorageManager = unifiedDB; // 直接映射到统一管理器
    
    console.log('🔥 [UnifiedDB] 统一数据库管理器已全局导出，包含所有数据库相关功能');

    // 🎯 通知所有依赖函数已就绪 - 解决单文件构建时序问题
    setTimeout(() => {
        window.dispatchEvent(new CustomEvent('unifieddb:ready', {
            detail: {
                timestamp: Date.now(),
                message: '所有导入导出功能已就绪',
                functions: ['performImport', 'importDatabase', 'exportDatabase', 'performFileStorageImport']
            }
        }));
        console.log('✅ [UnifiedDB] 就绪事件已发送，导入功能可用');
    }, 0);
}

// 🔥 Module export removed for browser compatibility
// ES Module导出 (removed for standard script loading)

/*
================================================================================
📚 EVENT-DRIVEN UI ARCHITECTURE DOCUMENTATION
================================================================================

本文档说明了重构后的事件驱动UI架构。所有UI交互现在通过自定义事件进行，
实现了业务逻辑与UI层的完全分离。

🎯 核心优势：
- ✅ 纯业务逻辑，可单元测试
- ✅ 灵活的UI实现（可用任何框架）  
- ✅ 一致的错误处理模式
- ✅ 更好的用户体验（非阻塞交互）

📋 事件类型汇总：

🗂️ 文件存储相关事件：
- fileStorage:importOptionsNeeded - 需要用户选择导入选项
- fileStorage:importError - 文件存储导入错误
- fileStorage:importProgress - 导入进度通知
- fileStorage:importSuccess - 导入成功
- fileStorage:exportStart - 导出开始
- fileStorage:exportProgress - 导出进度
- fileStorage:exportSuccess - 导出成功  
- fileStorage:exportError - 导出错误
- fileStorage:exportCancelled - 导出取消

🗄️ 数据库相关事件：
- database:importConfirmationNeeded - 需要用户确认导入
- database:importProgress - 导入进度通知
- database:importStart - 导入开始
- database:importSuccess - 导入成功
- database:importError - 导入错误
- database:exportStart - 导出开始
- database:exportSuccess - 导出成功
- database:exportError - 导出错误
- database:repairNeeded - 需要数据库修复
- database:repairSuccess - 修复成功
- database:repairError - 修复失败
- database:errorDialog - 显示错误对话框

💡 提示词相关事件：
- prompts:importSuccess - 提示词导入成功
- prompts:importError - 提示词导入错误

🏪 存储相关事件：
- storage:persistentGranted - 持久化存储已授权
- storage:persistentDenied - 持久化存储被拒绝
- storage:persistentUnsupported - 不支持持久化存储
- storage:persistentError - 持久化存储错误
- storage:statsRefreshNeeded - 需要刷新统计信息

================================================================================
📖 UI层实现示例
================================================================================

以下是推荐的UI层实现模式：

// 🎯 1. 基础错误通知处理
window.addEventListener('fileStorage:importError', (event) => {
    const { error, type } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(error.message, 'error');
    } else {
        // 降级到原生对话框
        alert(error.message);
    }
});

// 🎯 2. 用户确认对话框
window.addEventListener('fileStorage:importOptionsNeeded', (event) => {
    const { resolve, messages } = event.detail;
    
    // 现代UI实现示例
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: '导入选项',
            message: messages.overwrite,
            buttons: [
                { text: '覆盖', style: 'primary', value: true },
                { text: '保留', style: 'secondary', value: false }
            ]
        }).then(overwrite => {
            return showCustomDialog({
                title: '处理缺失文件',
                message: messages.skipMissing,
                buttons: [
                    { text: '跳过', style: 'primary', value: true },
                    { text: '占位符', style: 'secondary', value: false }
                ]
            }).then(skipMissing => {
                resolve({ overwrite, skipMissing });
            });
        });
    } else {
        // 降级到原生对话框
        const overwrite = confirm(messages.overwrite);
        const skipMissing = confirm(messages.skipMissing);
        resolve({ overwrite, skipMissing });
    }
});

// 🎯 3. 进度通知处理
window.addEventListener('database:importProgress', (event) => {
    const { message, stage } = event.detail;
    
    if (typeof showProgressToast === 'function') {
        showProgressToast(message);
    } else if (typeof showToast === 'function') {
        showToast(message);
    }
});

// 🎯 4. 成功通知处理
window.addEventListener('database:importSuccess', (event) => {
    const { message, autoReload, reloadDelay } = event.detail;
    
    if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(message);
    }
    
    // 自动刷新已经在业务逻辑中处理，UI层可以添加额外的视觉反馈
    if (autoReload && typeof showCountdownNotification === 'function') {
        showCountdownNotification('页面将自动刷新', reloadDelay);
    }
});

// 🎯 5. 数据库修复确认对话框
window.addEventListener('database:repairNeeded', (event) => {
    const { missingStores, resolve } = event.detail;
    
    const message = `发现数据库结构问题，缺失以下存储：\n${missingStores.join(', ')}\n\n是否立即修复？`;
    
    if (typeof showCustomDialog === 'function') {
        showCustomDialog({
            title: '数据库修复',
            message: message,
            type: 'warning',
            buttons: [
                { text: '立即修复', style: 'primary', value: true },
                { text: '稍后处理', style: 'secondary', value: false }
            ]
        }).then(resolve);
    } else {
        const shouldRepair = confirm(message);
        resolve(shouldRepair);
    }
});

// 🎯 6. 复杂统计信息展示
window.addEventListener('fileStorage:importSuccess', (event) => {
    const { message, stats, detailedMessage } = event.detail;
    
    if (typeof showDetailedNotification === 'function') {
        showDetailedNotification({
            title: '导入完成',
            message: message,
            details: `成功：${stats.imported}，跳过：${stats.skipped}，失败：${stats.failed}`,
            type: 'success'
        });
    } else if (typeof showToast === 'function') {
        showToast(message, 'success');
    } else {
        alert(detailedMessage);
    }
});

================================================================================
🔧 UI框架集成指南
================================================================================

🎨 Vue.js 集成示例：
// 在Vue组件中
mounted() {
    // 监听数据库事件
    window.addEventListener('database:importError', this.handleImportError);
    window.addEventListener('database:importSuccess', this.handleImportSuccess);
},
methods: {
    handleImportError(event) {
        this.$toast.error(event.detail.error.message);
    },
    handleImportSuccess(event) {
        this.$toast.success(event.detail.message);
        if (event.detail.autoReload) {
            this.showCountdown(event.detail.reloadDelay);
        }
    }
}

⚛️ React 集成示例：
// 在React组件中
useEffect(() => {
    const handleImportError = (event) => {
        toast.error(event.detail.error.message);
    };
    
    window.addEventListener('database:importError', handleImportError);
    return () => window.removeEventListener('database:importError', handleImportError);
}, []);

🍰 Vanilla JS 集成示例：
// 创建统一的事件处理管理器
class UIEventManager {
    constructor() {
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // 错误处理
        ['database:importError', 'fileStorage:importError', 'prompts:importError']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleError.bind(this));
            });
            
        // 成功处理
        ['database:importSuccess', 'fileStorage:importSuccess', 'prompts:importSuccess']
            .forEach(eventType => {
                window.addEventListener(eventType, this.handleSuccess.bind(this));
            });
    }
    
    handleError(event) {
        const { error, type } = event.detail;
        this.showNotification(error.message, 'error');
    }
    
    handleSuccess(event) {
        const { message } = event.detail;
        this.showNotification(message, 'success');
    }
}

// 启用事件管理器
document.addEventListener('DOMContentLoaded', () => {
    new UIEventManager();
});

================================================================================
💯 最佳实践
================================================================================

1. ✅ 降级策略：始终提供原生对话框作为降级方案
2. ✅ 错误分类：使用 detail.type 区分不同类型的错误
3. ✅ 进度反馈：长时间操作提供进度通知
4. ✅ 一致性：所有UI交互使用相同的事件模式
5. ✅ 可访问性：确保事件包含足够的上下文信息
6. ✅ 清理：组件销毁时移除事件监听器
7. ✅ 测试友好：事件可以轻松模拟和测试

通过遵循这些模式，你可以创建一个完全解耦、可测试、可维护的应用架构！

================================================================================
*/
// export default UnifiedDBManager;
// export { unifiedDB };
</script>
    
    <!-- 应用核心模块 -->
    <script>
/**
 * UI管理器 - 统一的UI控制系统
 * 包含视口管理、主题管理、输入处理、浏览器兼容性等功能
 */

// === 视口管理系统 ===
class ViewportManager {
    constructor() {
        this.init();
    }

    init() {
        // 设置CSS自定义属性
        this.updateViewportProperties();

        // 监听视口变化
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                this.handleKeyboardToggle();
            });
        }

        // 监听屏幕方向变化
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                this.updateViewportProperties();
            }, 100);
        });

        // 初始设置
        this.setInitialStyles();
    }

    updateViewportProperties() {
        const root = document.documentElement;
        
        // 获取真实的视口尺寸
        // 键盘弹出时不调整viewport height，避免出现白色区域
        const viewportHeight = window.innerHeight; // 使用固定的window.innerHeight
        const viewportWidth = window.visualViewport ? window.visualViewport.width : window.innerWidth;
        
        // 计算safe area
        const safeAreaTop = this.getSafeAreaTop();
        const safeAreaBottom = this.getSafeAreaBottom();
        const safeAreaLeft = this.getSafeAreaLeft();
        const safeAreaRight = this.getSafeAreaRight();

        // 设置CSS自定义属性
        root.style.setProperty('--viewport-height', `${viewportHeight}px`);
        root.style.setProperty('--viewport-width', `${viewportWidth}px`);
        root.style.setProperty('--safe-area-top', `${safeAreaTop}px`);
        root.style.setProperty('--safe-area-bottom', `${safeAreaBottom}px`);
        root.style.setProperty('--safe-area-left', `${safeAreaLeft}px`);
        root.style.setProperty('--safe-area-right', `${safeAreaRight}px`);

        // 计算header高度
        const headerHeight = 44; // 基础header高度
        const totalHeaderHeight = headerHeight + safeAreaTop;
        root.style.setProperty('--header-height', `${totalHeaderHeight}px`);

        // 计算底部导航栏高度
        const navHeight = 50; // 基础导航栏高度
        const totalNavHeight = navHeight + safeAreaBottom;
        root.style.setProperty('--nav-height', `${totalNavHeight}px`);

        // 计算可用内容区域高度
        const contentHeight = viewportHeight - totalHeaderHeight - totalNavHeight;
        root.style.setProperty('--content-height', `${contentHeight}px`);

        // 聊天页面特殊处理（无导航栏）
        const chatContentHeight = viewportHeight - totalHeaderHeight;
        root.style.setProperty('--chat-content-height', `${chatContentHeight}px`);
    }

    /**
     * 处理键盘弹出/收起时的布局调整
     * 使用transform和scroll来适应键盘，而不是改变容器高度
     * 优化版本：增加防抖和状态检查
     */
    handleKeyboardToggle() {
        if (!window.visualViewport) return;
        
        // 防抖机制，避免频繁触发
        if (this.keyboardToggleTimeout) {
            clearTimeout(this.keyboardToggleTimeout);
        }
        
        this.keyboardToggleTimeout = setTimeout(() => {
            const visualHeight = window.visualViewport.height;
            const windowHeight = window.innerHeight;
            const heightDiff = windowHeight - visualHeight;
            
            // 键盘高度阈值，超过150px认为是键盘弹出（提高阈值避免误判）
            const keyboardThreshold = 150;
            const isKeyboardVisible = heightDiff > keyboardThreshold;
            
            const root = document.documentElement;
            const currentState = root.getAttribute('data-keyboard-visible') === 'true';
            
            // 只有状态真正变化时才执行操作
            if (isKeyboardVisible !== currentState) {
                if (isKeyboardVisible) {
                    // 键盘弹出时，设置一个CSS变量来标识状态
                    root.style.setProperty('--keyboard-height', `${heightDiff}px`);
                    root.setAttribute('data-keyboard-visible', 'true');
                    
                    // 延迟执行滚动，确保键盘完全弹出
                    setTimeout(() => {
                        this.scrollToActiveInput();
                    }, 50);
                } else {
                    // 键盘收起时，清除状态
                    root.style.removeProperty('--keyboard-height');
                    root.removeAttribute('data-keyboard-visible');
                }
            }
            
            this.keyboardToggleTimeout = null;
        }, 100); // 100ms防抖
    }

    /**
     * 将当前聚焦的输入框滚动到可见区域
     * 优化版本：避免过度滚动和重复调用
     */
    scrollToActiveInput() {
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
            // 防抖机制，避免重复调用
            if (this.scrollTimeout) {
                clearTimeout(this.scrollTimeout);
            }
            
            this.scrollTimeout = setTimeout(() => {
                // 检查元素是否已经在可视区域内
                const rect = activeElement.getBoundingClientRect();
                const windowHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                const keyboardHeight = windowHeight - (window.visualViewport ? window.visualViewport.height : windowHeight);
                const availableHeight = windowHeight - keyboardHeight;
                
                // 只有当输入框不在可视区域或被键盘遮挡时才滚动
                const isVisible = rect.top >= 0 && rect.bottom <= availableHeight;
                const isPartiallyHidden = rect.bottom > availableHeight * 0.7; // 如果输入框底部超过可用高度的70%，认为需要调整
                
                if (!isVisible || isPartiallyHidden) {
                    activeElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest', // 改为nearest，避免过度滚动
                        inline: 'nearest'
                    });
                }
                
                this.scrollTimeout = null;
            }, 350); // 稍微延长等待时间，确保键盘动画完成
        }
    }

    getSafeAreaTop() {
        // 使用CSS env()获取safe area，如果不支持则返回默认值
        const testEl = document.createElement('div');
        testEl.style.paddingTop = 'env(safe-area-inset-top)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaTop = parseInt(computedStyle.paddingTop) || 0;
        document.body.removeChild(testEl);
        return safeAreaTop;
    }

    getSafeAreaBottom() {
        const testEl = document.createElement('div');
        testEl.style.paddingBottom = 'env(safe-area-inset-bottom)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaBottom = parseInt(computedStyle.paddingBottom) || 0;
        document.body.removeChild(testEl);
        return safeAreaBottom;
    }

    getSafeAreaLeft() {
        const testEl = document.createElement('div');
        testEl.style.paddingLeft = 'env(safe-area-inset-left)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaLeft = parseInt(computedStyle.paddingLeft) || 0;
        document.body.removeChild(testEl);
        return safeAreaLeft;
    }

    getSafeAreaRight() {
        const testEl = document.createElement('div');
        testEl.style.paddingRight = 'env(safe-area-inset-right)';
        document.body.appendChild(testEl);
        const computedStyle = window.getComputedStyle(testEl);
        const safeAreaRight = parseInt(computedStyle.paddingRight) || 0;
        document.body.removeChild(testEl);
        return safeAreaRight;
    }

    setInitialStyles() {
        // 确保body使用完整视口
        document.body.style.height = '100vh';
        document.body.style.height = 'var(--viewport-height, 100vh)';
    }
}

// === 主题管理系统 ===
class ThemeManager {
    constructor() {
        this.THEME_KEY = 'whale-llt-theme';
        this.themes = {
            system: 'system-theme',
            light: '',
            dark: 'dark-mode'
        };
        this.currentTheme = this.getStoredTheme();
        this.mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    }

    getStoredTheme() {
        return localStorage.getItem(this.THEME_KEY) || 'system';
    }

    setTheme(theme) {
        if (!this.themes.hasOwnProperty(theme)) {
            console.warn('未知主题:', theme);
            return;
        }

        this.currentTheme = theme;
        localStorage.setItem(this.THEME_KEY, theme);
        this.applyTheme();
        this.updateThemeUI();
    }

    applyTheme() {
        const body = document.body;
        
        // 移除所有主题类
        Object.values(this.themes).forEach(className => {
            if (className) body.classList.remove(className);
        });

        // 应用当前主题类
        const themeClass = this.themes[this.currentTheme];
        if (themeClass) {
            body.classList.add(themeClass);
        }
    }

    updateThemeUI() {
        // 更新主题切换按钮的显示状态
        const buttons = document.querySelectorAll('[data-theme]');
        buttons.forEach(btn => {
            if (btn.dataset.theme === this.currentTheme) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        console.log('主题UI已更新，当前主题:', this.currentTheme);
    }

    init() {
        // 立即应用主题，避免闪烁
        this.applyTheme();
        
        // 初始化UI状态
        this.updateThemeUI();
        
        // 监听系统主题变化
        this.mediaQuery.addEventListener('change', () => {
            if (this.currentTheme === 'system') {
                this.applyTheme();
            }
        });

        console.log('主题管理器初始化完成，当前主题:', this.currentTheme);
    }

    getCurrentTheme() {
        return this.currentTheme;
    }
}

// === 数据库相关UI管理系统 ===

class UIManager {
    constructor() {
        this.eventListeners = new Map();
        this.initializeEventListeners();
    }

    /**
     * 初始化事件监听器
     */
    initializeEventListeners() {
        // 监听数据库事件
        window.addEventListener('database:exportStart', () => {
            this.showMessage('正在导出数据库...', 'info');
        });

        window.addEventListener('database:exportSuccess', () => {
            this.showMessage('数据库导出成功！', 'success');
        });

        window.addEventListener('database:exportError', (event) => {
            this.showMessage(`导出失败: ${event.detail.error}`, 'error');
        });

        window.addEventListener('database:importStart', () => {
            this.showMessage('正在导入数据库...', 'info');
        });

        window.addEventListener('database:importSuccess', () => {
            this.showMessage('数据库导入成功！页面将在3秒后自动刷新...', 'success');
            setTimeout(() => window.location.reload(), 3000);
        });

        window.addEventListener('database:importError', (event) => {
            this.showMessage(`导入失败: ${event.detail.error}`, 'error');
        });

        window.addEventListener('database:importConfirmationNeeded', async (event) => {
            const { file, resolve } = event.detail;
            const confirmed = await this.confirmDatabaseImport();
            resolve(confirmed);
        });

        window.addEventListener('database:repairNeeded', async (event) => {
            const { missingStores, resolve } = event.detail;
            const shouldRepair = await this.confirmDatabaseRepair(missingStores);
            resolve(shouldRepair);
        });

        window.addEventListener('database:repairSuccess', (event) => {
            this.showMessage(event.detail.message, 'success');
        });

        window.addEventListener('database:repairError', (event) => {
            this.showMessage(`数据库修复失败: ${event.detail.error}`, 'error');
        });

        // 监听存储管理事件
        window.addEventListener('storage:persistentGranted', (event) => {
            this.showMessage('持久化存储申请成功！数据库将受到更好保护', 'success');
            this.updatePersistentStatusIndicator(event.detail);
        });

        window.addEventListener('storage:persistentDenied', (event) => {
            this.showMessage('持久化存储申请被拒绝，请检查浏览器设置', 'warning');
            this.updatePersistentStatusIndicator(event.detail);
        });

        window.addEventListener('storage:persistentUnsupported', () => {
            this.showMessage('您的浏览器不支持持久化存储功能', 'warning');
        });

        window.addEventListener('storage:persistentError', (event) => {
            this.showMessage(`申请持久化存储失败: ${event.detail.error}`, 'error');
        });

        window.addEventListener('storage:statsRefreshNeeded', async () => {
            // 触发统计信息刷新
            if (typeof window.refreshDatabaseStats === 'function') {
                await window.refreshDatabaseStats();
            }
        });

        // 监听数据库统计刷新事件
        window.addEventListener('database:statsRefreshStart', () => {
            this.updateRefreshButtonState(true);
        });

        window.addEventListener('database:statsRefreshSuccess', (event) => {
            const { result, persistentResult } = event.detail;
            this.updatePersistentStatusIndicator(persistentResult);
            this.updateDatabaseStats(result, persistentResult);
            this.updateRefreshButtonState(false);
        });

        window.addEventListener('database:statsRefreshError', (event) => {
            const { error } = event.detail;
            const statsContent = document.getElementById('databaseStatsContent');
            if (statsContent) {
                statsContent.innerHTML = `<div class="error">获取统计信息失败: ${error}</div>`;
            }
            this.updateRefreshButtonState(false);
        });

        // 监听文件处理完成事件，清空文件输入
        window.addEventListener('database:fileProcessed', (event) => {
            const { inputId } = event.detail;
            if (inputId) {
                this.clearFileInput(inputId);
            }
        });

        // 监听文件存储导出选项面板操作事件
        window.addEventListener('fileStorage:hideExportOptions', () => {
            this.hideFileExportOptions();
        });

        // 监听文件存储导入选项请求事件
        window.addEventListener('fileStorage:importOptionsNeeded', async (event) => {
            const { resolve, messages } = event.detail;
            const options = await this.getFileStorageImportOptions(messages);
            resolve(options);
        });

        // 监听文件存储文件处理完成事件，清空文件输入
        window.addEventListener('fileStorage:fileProcessed', (event) => {
            const { inputId } = event.detail;
            if (inputId) {
                this.clearFileInput(inputId);
            }
        });

        // 监听文件存储导出配置请求事件
        window.addEventListener('fileStorage:exportConfigNeeded', (event) => {
            const { resolve } = event.detail;
            const config = this.getFileExportConfig();
            resolve(config);
        });
    }

    /**
     * 显示消息给用户
     */
    showMessage(message, type = 'info') {
        if (typeof showToast === 'function') {
            showToast(message, type);
        } else {
            // 降级到原生 alert
            alert(message);
        }
    }

    /**
     * 显示确认对话框
     */
    async showConfirmDialog(message, title = '确认') {
        return confirm(message);
    }

    /**
     * 显示数据库导入确认流程
     */
    async confirmDatabaseImport() {
        const firstConfirmMessage = '导入数据库将完全覆盖现有数据！\n\n这将删除：\n• 所有聊天记录和联系人\n• 用户资料和设置\n• 朋友圈动态和论坛帖子\n• 音乐库和表情包\n\n确定要继续吗？';
        
        if (!await this.showConfirmDialog(firstConfirmMessage)) {
            return false;
        }
        
        const secondConfirmMessage = '这是最后确认！\n\n导入操作不可撤销，所有现有数据将被永久删除。\n\n您真的确定要继续吗？';
        
        return await this.showConfirmDialog(secondConfirmMessage);
    }

    /**
     * 显示数据库修复确认
     */
    async confirmDatabaseRepair(missingStores) {
        const message = `检测到数据库结构不完整，缺失以下存储:\n${missingStores.join(', ')}\n\n是否尝试修复？`;
        return await this.showConfirmDialog(message, '数据库修复');
    }

    /**
     * 显示文件存储导入选项
     */
    async getFileStorageImportOptions(messages = null) {
        const overwriteMessage = messages?.overwrite || 
            '文件存储导入选项：\n\n点击"确定"覆盖现有文件\n点击"取消"保留现有文件（仅导入新文件）\n\n注意：覆盖模式将删除所有现有的头像、背景、表情等文件！';
        const overwrite = await this.showConfirmDialog(overwriteMessage);
        
        const missingMessage = messages?.skipMissing || 
            '对于缺失的文件引用：\n\n点击"确定"跳过缺失的文件\n点击"取消"尝试创建占位符\n\n建议选择"确定"跳过缺失文件';
        const skipMissing = await this.showConfirmDialog(missingMessage);
        
        return { overwrite, skipMissing };
    }

    /**
     * 获取文件导出配置
     */
    getFileExportConfig() {
        return {
            includeAvatars: this.getCheckboxValue('exportAvatars', true),
            includeBackgrounds: this.getCheckboxValue('exportBackgrounds', true),
            includeEmojis: this.getCheckboxValue('exportEmojis', true),
            includeMomentImages: this.getCheckboxValue('exportMomentImages', true),
            includeWeiboImages: this.getCheckboxValue('exportWeiboImages', true),
            includeUserBanner: this.getCheckboxValue('exportUserBanner', true)
        };
    }

    /**
     * 获取复选框值的辅助方法
     */
    getCheckboxValue(id, defaultValue = false) {
        const element = document.getElementById(id);
        return element ? element.checked : defaultValue;
    }

    /**
     * 触发文件选择
     */
    triggerFileSelect(inputId = 'importFileInput') {
        const fileInput = document.getElementById(inputId);
        if (fileInput) {
            fileInput.click();
        } else {
            this.showMessage(`未找到文件输入元素：${inputId}`, 'error');
        }
    }

    /**
     * 显示/隐藏模态框
     */
    showModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }
    }

    hideModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.add('hidden');
            document.body.style.overflow = '';
        }
    }

    /**
     * 显示持久化存储信息模态框
     */
    showPersistentStorageInfo() {
        this.showModal('persistentStorageInfoModal');
    }

    /**
     * 隐藏持久化存储信息模态框
     */
    hidePersistentStorageInfo() {
        this.hideModal('persistentStorageInfoModal');
    }

    /**
     * 更新持久化状态指示器
     */
    updatePersistentStatusIndicator(persistentResult) {
        const persistentIndicator = document.getElementById('persistentStatusIndicator');
        if (!persistentIndicator) return;

        let status = 'unknown';
        let content = '❓状态未知';
        
        if (persistentResult.success) {
            if (persistentResult.isPersistent) {
                status = 'persistent';
                content = '🎉🟢数据已持久存储';
            } else {
                status = 'not-persistent';
                content = '❤️‍🩹🟡数据未持久存储';
            }
        }
        
        persistentIndicator.dataset.status = status;
        persistentIndicator.innerHTML = content;
    }

    /**
     * 更新数据库统计显示
     */
    updateDatabaseStats(result, persistentResult) {
        const statsContent = document.getElementById('databaseStatsContent');
        if (!statsContent) return;

        if (result.success) {
            const stats = result.stats;
            let statsHtml = '';
            
            const storeLabels = {
                'contacts': '联系人/群聊',
                'songs': '音乐文件', 
                'apiSettings': 'API设置',
                'emojis': '表情包',
                'emojiImages': '表情图片',
                'backgrounds': '聊天背景',
                'userProfile': '用户资料',
                'moments': '朋友圈',
                'weiboPosts': '论坛帖子',
                'hashtagCache': '话题缓存',
                'characterMemories': '角色记忆',
                'globalMemory': '全局记忆',
                'conversationCounters': '对话计数器',
                'memoryProcessedIndex': '记忆处理索引',
                'fileStorage': '文件存储',
                'fileReferences': '文件引用',
                'themeConfig': '主题配置'
            };
            
            for (const [storeName, count] of Object.entries(stats)) {
                const displayName = storeLabels[storeName] || storeName;
                statsHtml += `<div class="stat-item">
                    <span class="stat-name">${displayName}</span>
                    <span class="stat-count">${count} 条记录</span>
                </div>`;
            }
            
            // 添加持久化存储状态信息
            if (persistentResult && persistentResult.success && persistentResult.estimate) {
                const estimate = persistentResult.estimate;
                const usedMB = estimate.usage ? (estimate.usage / 1024 / 1024).toFixed(2) : '未知';
                const quotaMB = estimate.quota ? (estimate.quota / 1024 / 1024).toFixed(2) : '未知';
                
                statsHtml += `
                <div class="storage-info">
                    <div class="stat-item">
                        <span class="stat-name">存储使用量</span>
                        <span class="stat-count">${usedMB} MB</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-name">存储配额</span>
                        <span class="stat-count">${quotaMB} MB</span>
                    </div>
                </div>`;
            }
            
            statsContent.innerHTML = statsHtml;
            
        } else {
            statsContent.innerHTML = `<div class="error">获取统计信息失败: ${result.error}</div>`;
        }
    }

    /**
     * 更新刷新按钮状态
     */
    updateRefreshButtonState(isLoading, buttonSelector = '.refresh-stats-btn') {
        const refreshBtn = document.querySelector(buttonSelector);
        if (refreshBtn) {
            refreshBtn.textContent = isLoading ? '刷新中...' : '刷新统计';
            refreshBtn.disabled = isLoading;
        }
    }

    /**
     * 显示/隐藏文件导出选项面板
     */
    showFileExportOptions() {
        const optionsPanel = document.getElementById('fileExportOptions');
        if (optionsPanel) {
            optionsPanel.style.display = 'block';
        }
    }

    hideFileExportOptions() {
        const optionsPanel = document.getElementById('fileExportOptions');
        if (optionsPanel) {
            optionsPanel.style.display = 'none';
        }
    }

    /**
     * 验证文件类型
     */
    validateFileType(file, expectedExtensions = ['.zip']) {
        const fileName = file.name.toLowerCase();
        const isValid = expectedExtensions.some(ext => fileName.endsWith(ext));
        
        if (!isValid) {
            const expectedTypes = expectedExtensions.join(', ');
            this.showMessage(`请选择 ${expectedTypes} 格式的文件`, 'error');
        }
        
        return isValid;
    }

    /**
     * 清空文件输入
     */
    clearFileInput(inputId) {
        const input = document.getElementById(inputId);
        if (input) {
            input.value = '';
        }
    }

    /**
     * 触发文件选择 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    triggerFileSelect(inputId = 'importFileInput') {
        const fileInput = document.getElementById(inputId);
        if (fileInput) {
            fileInput.click();
        } else {
            this.showMessage(`未找到文件输入元素：${inputId}`, 'error');
        }
    }

    /**
     * 触发文件存储导入 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    triggerFileStorageImport(inputId = 'fileStorageImportInput') {
        const fileInput = document.getElementById(inputId);
        if (fileInput) {
            fileInput.click();
        } else {
            this.showMessage(`未找到文件存储导入输入元素：${inputId}`, 'error');
        }
    }

    /**
     * 刷新数据库统计信息 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    async refreshDatabaseStats() {
        // This will trigger the events that the UIManager is listening to.
        await window.AppDB.refreshDatabaseStats();
    }

    /**
     * 处理文件选择 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    async handleFileSelect(event) {
        // Call the business logic function which will dispatch events for UI updates.
        await window.AppDB.handleFileSelect(event);
    }

    /**
     * 确认文件导出 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    async confirmFileExport() {
        await window.AppDB.confirmFileExport();
    }

    /**
     * 取消文件导出 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    cancelFileExport() {
        window.AppDB.cancelFileExport();
    }

    /**
     * 处理文件存储选择 - 从UnifiedDBManager.js移动过来的UI逻辑
     */
    async handleFileStorageSelect(event) {
        // Call the business logic function which will dispatch events for UI updates.
        await window.AppDB.handleFileStorageSelect(event);
    }
}

// === 输入处理和浏览器兼容性系统 ===

// 浏览器兼容性检测
function checkBrowserCompatibility() {
    // 检测浏览器是否支持 :has() 选择器
    let supportsHas = false;
    
    try {
        // 尝试创建一个使用 :has() 的CSS规则来测试支持性
        const testRule = document.createElement('style');
        testRule.textContent = 'body:has(div) { color: inherit; }';
        document.head.appendChild(testRule);
        
        // 检查规则是否被正确解析
        supportsHas = testRule.sheet && testRule.sheet.cssRules.length > 0;
        
        // 清理测试元素
        document.head.removeChild(testRule);
    } catch (e) {
        // 如果出现错误，说明不支持
        supportsHas = false;
    }
    
    // 如果不支持 :has()，为body添加标识类以启用JavaScript备用方案
    if (!supportsHas) {
        document.body.classList.add('no-has-support');
        console.log('检测到浏览器不支持 :has() 选择器，已启用JavaScript备用方案');
    } else {
        console.log('浏览器支持 :has() 选择器');
    }
    
    // 将支持状态存储为全局变量，供其他函数使用
    window.browserSupportsHas = supportsHas;
}

// 安全聚焦工具函数
function safeFocus(element, options = {}) {
    if (!element || typeof element.focus !== 'function') return;
    
    const {
        preventScroll = false,
        delay = 0,
        smooth = true
    } = options;
    
    // 防抖机制：如果element已经是activeElement，避免重复操作
    if (document.activeElement === element) return;
    
    const focusAction = () => {
        try {
            // 如果元素不在可视区域，先聚焦但阻止滚动
            element.focus({ preventScroll: true });
            
            // 如果需要滚动到可视区域，使用viewportManager的方法
            if (!preventScroll && window.UIManager && window.UIManager.viewportManager) {
                // 延迟一下，让focus事件先完成
                setTimeout(() => {
                    window.UIManager.viewportManager.scrollToActiveInput();
                }, 50);
            }
        } catch (error) {
            console.warn('Focus operation failed:', error);
        }
    };
    
    if (delay > 0) {
        setTimeout(focusAction, delay);
    } else {
        focusAction();
    }
}

// 屏蔽长按选择和上下文菜单系统
function initializeLongPressBlocking() {
    // 屏蔽上下文菜单（右键菜单和长按菜单）
    document.addEventListener('contextmenu', function(e) {
        // 允许输入框的上下文菜单
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
    }, { passive: false });

    // 屏蔽选择开始事件
    document.addEventListener('selectstart', function(e) {
        // 允许输入框的选择
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
    }, { passive: false });

    // 屏蔽拖拽开始事件（某些情况下长按会触发）
    document.addEventListener('dragstart', function(e) {
        // 允许输入框内容的拖拽
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
    }, { passive: false });

    // iOS Safari 特殊处理：屏蔽长按高亮
    let longPressTimer = null;
    let touchStartTime = 0;
    let touchTarget = null;
    
    document.addEventListener('touchstart', function(e) {
        // 输入框允许正常行为
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
            return;
        }
        
        touchTarget = e.target;
        touchStartTime = Date.now();
        longPressTimer = setTimeout(() => {
            // 只有当前活跃元素不是输入框时才blur
            if (document.activeElement && 
                document.activeElement.tagName !== 'INPUT' && 
                document.activeElement.tagName !== 'TEXTAREA' && 
                document.activeElement.contentEditable !== 'true') {
                document.activeElement.blur();
            }
            // 只清除非输入框的选择
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                
                if (element && 
                    element.tagName !== 'INPUT' && 
                    element.tagName !== 'TEXTAREA' && 
                    element.contentEditable !== 'true' &&
                    !element.closest('input, textarea, [contenteditable="true"]')) {
                    selection.removeAllRanges();
                }
            }
        }, 500); // 500ms 后算作长按
    }, { passive: true });

    document.addEventListener('touchend', function(e) {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        touchTarget = null;
    }, { passive: true });

    document.addEventListener('touchmove', function(e) {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, { passive: true });

    // 额外保护：清除任何意外的选择（但不干扰正在交互的输入框）
    setInterval(() => {
        // 如果当前有输入框聚焦，跳过清理
        if (document.activeElement && (
            document.activeElement.tagName === 'INPUT' || 
            document.activeElement.tagName === 'TEXTAREA' || 
            document.activeElement.contentEditable === 'true')) {
            return;
        }
        
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const container = range.commonAncestorContainer;
            const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
            
            // 如果选择的不是输入框内容，就清除选择
            if (element && 
                element.tagName !== 'INPUT' && 
                element.tagName !== 'TEXTAREA' && 
                element.contentEditable !== 'true' &&
                !element.closest('input, textarea, [contenteditable="true"]')) {
                selection.removeAllRanges();
            }
        }
    }, 200); // 降低频率，减少对性能的影响
}

// 主题切换函数（全局函数）
function switchTheme(theme) {
    window.UIManager.themeManager.setTheme(theme);
    
    // 提供用户反馈
    const themeNames = {
        system: '跟随系统',
        light: '亮色模式', 
        dark: '暗黑模式'
    };
    
    // 可以在这里添加toast提示，但现在先不添加以免干扰用户
    console.log(`已切换到${themeNames[theme]}主题`);
}

// 获取当前主题（全局函数）
function getCurrentTheme() {
    return window.UIManager.themeManager.getCurrentTheme();
}

// 创建全局UI管理器实例
const uiManager = new UIManager();

// 导出到window对象以便其他模块使用
if (typeof window !== 'undefined') {
    // 创建统一的UI管理器命名空间
    window.UIManager = {
        // 管理器实例
        viewportManager: new ViewportManager(),
        themeManager: new ThemeManager(),
        
        // 工具函数
        safeFocus,
        switchTheme,
        getCurrentTheme,
        checkBrowserCompatibility,
        initializeLongPressBlocking
    };
    
    // 数据库相关UI管理器实例
    window.uiManager = uiManager;
    
    // 为了向后兼容，保留一些关键的全局引用
    window.viewportManager = window.UIManager.viewportManager;
    window.themeManager = window.UIManager.themeManager;
    window.switchTheme = switchTheme;
    window.getCurrentTheme = getCurrentTheme;
    
    // 数据库UI功能的全局引用（向后兼容）
    window.refreshDatabaseStats = () => uiManager.refreshDatabaseStats();
    window.handleFileSelect = (event) => uiManager.handleFileSelect(event);
    window.confirmFileExport = () => uiManager.confirmFileExport();
    window.cancelFileExport = () => uiManager.cancelFileExport();
    window.handleFileStorageImport = (event) => uiManager.handleFileStorageSelect(event);
    
    // 文件触发函数
    window.triggerFileSelect = () => uiManager.triggerFileSelect();
    window.triggerFileStorageImport = () => uiManager.triggerFileStorageImport();
    
    // 自动初始化
    window.UIManager.themeManager.init();
    window.UIManager.checkBrowserCompatibility();
    
    // 在页面加载完成后初始化长按屏蔽
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.UIManager.initializeLongPressBlocking);
    } else {
        window.UIManager.initializeLongPressBlocking();
    }
    
    console.log('🎨 [UIManager] ViewportManager已恢复，负责处理移动端视口管理和键盘弹出适配');
    console.log('🎨 [UIManager] UI管理器已创建，负责处理所有用户界面交互');
}

// ES Module导出（如果支持）
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { UIManager, uiManager };
}
</script>
    <script>
class APIService {
    constructor() {
        this.maxRetries = 3;
        this.baseDelay = 1000;
    }

    /**
     * 从AI返回的文本中提取完整的JSON对象。
     * 自动清理markdown代码块标记和其他干扰文本。
     * @param {string} text - AI返回的原始文本。
     * @returns {string} 提取出的纯JSON字符串。
     */
    extractJSON(text) {
        if (!text || typeof text !== 'string') {
            throw new Error('无效的文本内容');
        }

        // 1. 优先提取 markdown 代码块中的 JSON
        const codeBlockMatch = text.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/i);
        if (codeBlockMatch) {
            return codeBlockMatch[1].trim();
        }

        // 2. 尝试从首个{到最后一个}截取
        const firstBrace = text.indexOf('{');
        const lastBrace = text.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            const possibleJson = text.substring(firstBrace, lastBrace + 1);
            // 验证这是否是有效的JSON
            try {
                JSON.parse(possibleJson);
                return possibleJson;
            } catch (_) {
                // 如果解析失败，继续尝试兜底方案
            }
        }
        
        // 3. 兜底返回原始文本，让调用者处理
        return text.trim();
    }

    /**
     * 通用的OpenAI兼容API调用函数。
     * @param {string} apiUrl - API地址。
     * @param {string} apiKey - API密钥。
     * @param {string} model - 模型名称。
     * @param {Array} messages - 消息数组。
     * @param {Object} options - 额外选项 (如 temperature, top_p 等)。
     * @param {number} timeout - 超时时间(毫秒)，默认60秒。
     * @returns {Promise<Object>} 返回API响应的JSON对象。
     */
    async callOpenAIAPI(apiUrl, apiKey, model, messages, options = {}, timeout = 60000) {
        console.log(`[API调用] callOpenAIAPI被调用:`, {
            apiUrl: apiUrl.substring(0, 30) + '...',
            apiKey: apiKey ? apiKey.substring(0, 10) + '...' : 'null',
            model,
            messagesCount: messages.length
        });

        // 自动设置 deepseek 模型的 max_tokens 为 8100
        if (model && model.toLowerCase().includes('deepseek')) {
            options = { ...options, max_tokens: 8100 };
            console.log(`[API调用] 检测到 deepseek 模型，自动设置 max_tokens 为 8100`);
        }

        const payload = { model, messages, ...options, stream: false };

        let success = false;
        let shouldRecord = true;
        let resultData = null;

        try {
            for (let i = 0; i < this.maxRetries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);

                    const response = await fetch(apiUrl + '/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`,
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        if (response.status === 504) {
                            const errorBody = await response.text();
                            console.error('ERROR: API网关超时 (504) - 完整返回:', errorBody);
                            throw new Error('请求超时(504): 模型响应时间过长，请稍后重试');
                        }
                        const errorBody = await response.text().catch(() => `[无法解析的错误响应]`);
                        console.error('ERROR: API请求失败 - 完整返回:', errorBody);
                        throw new Error(`API Error (${response.status}): ${errorBody || response.statusText}`);
                    }

                    const responseText = await response.text();
                    console.log('API原始响应:', responseText);

                    try {
                        const data = JSON.parse(responseText);
                        console.log('API解析为JSON成功:', JSON.stringify(data, null, 2));

                        if (data.usage && data.usage.completion_tokens === 0) {
                            console.error('ERROR: API返回空回复 (completion_tokens=0) - 完整返回:', JSON.stringify(data, null, 2));
                            throw new Error('API错误：API响应，但AI空回复了。可能是模型问题、被截断或API提供商问题。请稍后重试。');
                        }

                        success = true;
                        resultData = data;
                        break; // 成功，跳出重试循环
                    } catch (parseError) {
                        console.log('JSON解析失败，作为纯文本处理:', parseError.message);
                        if (!responseText || responseText.trim() === '') {
                            throw new Error('API返回空响应');
                        }
                        // 将原始文本包装成标准OpenAI格式
                        success = true;
                        resultData = {
                            choices: [{
                                message: { content: responseText.trim(), role: 'assistant' },
                                finish_reason: 'stop'
                            }],
                            usage: {
                                completion_tokens: responseText.length,
                                prompt_tokens: 0,
                                total_tokens: responseText.length
                            }
                        };
                        break; // 成功，跳出重试循环
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('请求超时: 模型响应时间过长，请稍后重试');
                    }
                    if (i < this.maxRetries - 1) {
                        const delay = this.baseDelay * Math.pow(2, i);
                        console.log(`第 ${i + 1} 次尝试失败，将在 ${delay}ms 后重试...`);
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        throw error; // 所有重试均失败，抛出最后一次的错误
                    }
                }
            }
        } catch (error) {
            // 记录失败的API调用
            if (shouldRecord && window.apiConfigManager) {
                try {
                    console.log(`[API统计] API调用失败，记录失败统计: ${error.message}`);
                    const configId = window.apiConfigManager.activeConfigId || 'unknown';
                    const config = window.apiConfigManager.activeConfigId
                        ? await window.apiConfigManager.getConfigById(window.apiConfigManager.activeConfigId)
                        : null;
                    if (config) {
                        let keyIndex = -1;
                        if (config.apiKeys && config.apiKeys.length > 0) {
                            keyIndex = config.apiKeys.findIndex(k => k.key === apiKey && k.enabled);
                        }
                        if (keyIndex === -1 && config.key === apiKey) keyIndex = 0;
                        if (keyIndex !== -1) {
                            window.apiConfigManager.recordCall(configId, keyIndex, apiKey, false);
                        }
                    }
                } catch (recordError) {
                    console.warn('记录API调用失败统计失败:', recordError);
                }
            }
            throw error; // 重新抛出原始错误
        }

        // 记录成功的API调用
        if (success && shouldRecord && window.apiConfigManager) {
            try {
                console.log(`[API统计] API调用成功，记录成功统计。`);
                const configId = window.apiConfigManager.activeConfigId || 'unknown';
                const config = window.apiConfigManager.activeConfigId
                    ? await window.apiConfigManager.getConfigById(window.apiConfigManager.activeConfigId)
                    : null;
                if (config) {
                    let keyIndex = -1;
                    if (config.apiKeys && config.apiKeys.length > 0) {
                        keyIndex = config.apiKeys.findIndex(k => k.key === apiKey && k.enabled);
                    }
                    if (keyIndex === -1 && config.key === apiKey) keyIndex = 0;
                    if (keyIndex !== -1) {
                        window.apiConfigManager.recordCall(configId, keyIndex, apiKey, true);
                    }
                }
            } catch (err) {
                console.warn('记录API调用成功统计失败:', err);
            }
        }

        if (success) {
            return resultData;
        }
        
        // 如果循环结束都没有成功，则抛出通用错误
        throw new Error('API调用最终失败');
    }

    /**
     * 测试API连接。
     * @param {string} apiUrl - API地址。
     * @param {string} apiKey - API密钥。
     * @returns {Promise<Object>} 连接测试结果。
     */
    async testConnection(apiUrl, apiKey) {
        try {
            const response = await fetch(apiUrl + '/models', {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36'
                }
            });
            if (!response.ok) {
                const errorBody = await response.text();
                console.error('ERROR: API测试连接失败 - 完整返回:', errorBody);
                throw new Error(`API Error: ${errorBody}`);
            }
            const data = await response.json();
            console.log('API测试连接完整返回:', JSON.stringify(data, null, 2));
            return data;
        } catch (error) {
            throw new Error(`连接失败: ${error.message}`);
        }
    }
}

// UMD 风格导出 + 全局实例
if (typeof module !== 'undefined' && module.exports) {
    module.exports = APIService;
}
if (typeof window !== 'undefined') {
    window.APIService = APIService;
    if (!window.apiService) {
        window.apiService = new APIService();
    }
}
</script>
    <script>
/**
 * Color Utilities
 * 颜色处理相关的实用工具函数
 */

/**
 * 验证十六进制颜色格式是否有效
 * @param {string} color - 十六进制颜色值 (如: #FF0000)
 * @returns {boolean} 是否为有效的十六进制颜色
 */
function isValidHexColor(color) {
    return /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * 将十六进制颜色转换为RGBA格式
 * @param {string} hex - 十六进制颜色值 (如: #FF0000)  
 * @param {number} alpha - 透明度 (0-1)
 * @returns {string} RGBA颜色字符串 (如: rgba(255, 0, 0, 0.5))
 */
function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * 加深颜色 - 通过百分比降低RGB值
 * @param {string} hex - 十六进制颜色值 (如: #FF0000)
 * @param {number} percent - 加深的百分比 (0-1，0.2表示加深20%)
 * @returns {string} 加深后的十六进制颜色值
 */
function darkenColor(hex, percent) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    const newR = Math.round(r * (1 - percent));
    const newG = Math.round(g * (1 - percent));
    const newB = Math.round(b * (1 - percent));
    
    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
}

/**
 * 验证颜色输入框并更新按钮状态
 * @param {HTMLInputElement} input - 颜色输入框元素
 * @param {HTMLButtonElement} button - 关联的按钮元素
 */
function validateColorInput(input, button) {
    const isValid = isValidHexColor(input.value);
    button.disabled = !isValid;
    
    if (isValid) {
        input.classList.remove('invalid');
    } else {
        input.classList.add('invalid');
    }
}

/**
 * 应用单色主题到页面
 * @param {string} color - 主题色的十六进制值
 */
function applyThemeColor(color) {
    // 禁用渐变模式
    document.body.classList.remove('gradient-mode');
    
    // 计算辅助颜色
    const lightColor = hexToRgba(color, 0.1);
    const hoverColor = darkenColor(color, 0.1);
    
    // 计算次要色的交互状态（用于模态框、信息按钮等UI元素）
    const secondaryColor = '#1890ff'; // 固定的次要色
    const secondaryHover = darkenColor(secondaryColor, 0.15);
    const secondaryActive = darkenColor(secondaryColor, 0.25);
    
    // 更新CSS变量
    document.documentElement.style.setProperty('--theme-primary', color);
    document.documentElement.style.setProperty('--theme-primary-light', lightColor);
    document.documentElement.style.setProperty('--theme-primary-hover', hoverColor);
    document.documentElement.style.setProperty('--theme-secondary-hover', secondaryHover);
    document.documentElement.style.setProperty('--theme-secondary-active', secondaryActive);
    document.documentElement.style.setProperty('--use-gradient', '0');
    
    // 更新meta标签中的主题色（影响系统状态栏）
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
        metaThemeColor.setAttribute('content', color);
    }
    
    // 更新manifest相关的meta标签
    const tileMeta = document.querySelector('meta[name="msapplication-TileColor"]');
    if (tileMeta) {
        tileMeta.setAttribute('content', color);
    }
    
    console.log('主题色已应用:', color);
}

/**
 * 应用渐变主题到页面
 * @param {string} primaryColor - 主色的十六进制值
 * @param {string} secondaryColor - 次要色的十六进制值
 * @param {string} direction - 渐变方向 (如: 'to right', 'to bottom')
 */
function applyGradientTheme(primaryColor, secondaryColor, direction) {
    // 启用渐变模式
    document.body.classList.add('gradient-mode');
    
    // 计算辅助颜色
    const lightColor = hexToRgba(primaryColor, 0.1);
    const hoverColor = darkenColor(primaryColor, 0.1);
    
    // 在渐变模式下，使用渐变的次要色作为UI元素的次要色
    const secondaryHover = darkenColor(secondaryColor, 0.15);
    const secondaryActive = darkenColor(secondaryColor, 0.25);
    
    // 更新CSS变量
    document.documentElement.style.setProperty('--theme-primary', primaryColor);
    document.documentElement.style.setProperty('--theme-secondary', secondaryColor);
    document.documentElement.style.setProperty('--theme-primary-light', lightColor);
    document.documentElement.style.setProperty('--theme-primary-hover', hoverColor);
    document.documentElement.style.setProperty('--theme-secondary-hover', secondaryHover);
    document.documentElement.style.setProperty('--theme-secondary-active', secondaryActive);
    document.documentElement.style.setProperty('--theme-gradient-direction', direction);
    document.documentElement.style.setProperty('--theme-gradient', `linear-gradient(${direction}, ${primaryColor}, ${secondaryColor})`);
    document.documentElement.style.setProperty('--use-gradient', '1');
    
    // 更新meta标签中的主题色（使用主色）
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
        metaThemeColor.setAttribute('content', primaryColor);
    }
    
    // 更新manifest相关的meta标签
    const tileMeta = document.querySelector('meta[name="msapplication-TileColor"]');
    if (tileMeta) {
        tileMeta.setAttribute('content', primaryColor);
    }
    
    console.log('渐变主题已应用:', { primaryColor, secondaryColor, direction });
}

// 兼容性：将函数分组暴露到全局window对象
if (typeof window !== 'undefined') {
    window.ColorUtils = {
        isValidHexColor,
        hexToRgba,
        darkenColor,
        validateColorInput,
        applyThemeColor,
        applyGradientTheme
    };
    
    // 向后兼容：保留直接挂载的函数（逐步废弃）
    window.isValidHexColor = isValidHexColor;
    window.hexToRgba = hexToRgba;
    window.darkenColor = darkenColor;
    window.validateColorInput = validateColorInput;
    window.applyThemeColor = applyThemeColor;
    window.applyGradientTheme = applyGradientTheme;
}
</script>
    <script>
/**
 * UI Utilities
 * 通用UI交互相关的实用工具函数
 */

/**
 * 显示Toast消息通知
 * @param {string} message - 要显示的消息内容
 * @param {string} type - 消息类型: 'info', 'success', 'warning', 'error'
 * @param {number} duration - 显示持续时间(毫秒)，默认3秒
 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    if (!toast) {
        console.warn('Toast元素不存在');
        return;
    }
    
    toast.textContent = message;
    
    // 移除之前的类型类
    toast.classList.remove('toast-error', 'toast-success', 'toast-warning', 'toast-info');
    
    // 添加新的类型类
    switch(type) {
        case 'error':
            toast.classList.add('toast-error');
            duration = Math.max(duration, 4000); // 错误消息显示时间稍长
            break;
        case 'success':
            toast.classList.add('toast-success');
            break;
        case 'warning':
            toast.classList.add('toast-warning');
            break;
        default:
            toast.classList.add('toast-info');
            break;
    }
    
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), duration);
}

/**
 * 显示模态框
 * @param {string} modalId - 模态框的DOM元素ID
 */
function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error('模态框不存在:', modalId);
        return;
    }
    modal.style.display = 'block';
    
    // 特定模态框的初始化逻辑
    if (modalId === 'apiSettingsModal') {
        const contextSlider = document.getElementById('contextSlider');
        const contextValue = document.getElementById('contextValue');
        if (contextSlider && contextValue) {
            // 使用新的API获取上下文消息数量，而不是直接访问全局变量
            initializeContextSlider(contextSlider, contextValue);
        }
    }
}

/**
 * 关闭模态框并执行相关清理工作
 * @param {string} modalId - 模态框的DOM元素ID
 */
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error('要关闭的模态框不存在:', modalId);
        return;
    }
    modal.style.display = 'none';
    
    // 特定模态框的清理逻辑
    if (modalId === 'addContactModal') {
        // 重置编辑状态
        if (window.editingContact !== undefined) {
            window.editingContact = null;
        }
        
        // 重置表单
        const elements = {
            'contactModalTitle': '添加AI助手',
            'contactName': '',
            'contactAvatar': '',
            'contactPersonality': '',
            'customPrompts': '',
            'contactVoiceId': ''
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
                    element.value = value;
                } else {
                    element.textContent = value;
                }
            }
        });
    } else if (modalId === 'addEmojiModal') {
        // 清理表情包上传的临时数据
        cleanupEmojiUploadData();
    }
}

/**
 * 清理表情包上传临时数据的辅助函数
 */
function cleanupEmojiUploadData() {
    try {
        // 清理临时文件
        if (window.ImageUploadHandlers && window.ImageUploadHandlers.tempEmojiFile) {
            window.ImageUploadHandlers.tempEmojiFile = null;
        }
        
        // 清理临时URL
        const emojiUrlInput = document.getElementById('emojiUrl');
        if (emojiUrlInput && emojiUrlInput.value.startsWith('temp:')) {
            const tempUrl = emojiUrlInput.value.substring(5);
            URL.revokeObjectURL(tempUrl);
            emojiUrlInput.value = '';
        }
        
        // 清理文件输入
        const fileInput = document.getElementById('emojiUploadInput');
        if (fileInput) {
            fileInput.value = '';
        }
        
        // 清理状态提示
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = '';
            statusElement.style.color = '';
        }
        
        // 清理意思输入框
        const meaningInput = document.getElementById('emojiMeaning');
        if (meaningInput) {
            meaningInput.value = '';
        }
        
        console.log('表情包上传临时数据已清理');
    } catch (error) {
        console.warn('清理表情包临时数据时出错:', error);
    }
}

/**
 * 显示顶部通知消息（短暂显示）
 * @param {string} message - 要显示的通知消息
 */
function showTopNotification(message) {
    const notification = document.getElementById('topNotification');
    if (!notification) {
        console.warn('TopNotification元素不存在');
        return;
    }
    notification.textContent = message;
    notification.classList.add('show');
    setTimeout(() => notification.classList.remove('show'), 1500);
}

/**
 * 显示确认对话框
 * @param {string} title - 对话框标题
 * @param {string} message - 对话框消息内容
 * @param {Function} onConfirm - 确认按钮的回调函数
 */
function showConfirmDialog(title, message, onConfirm) {
    const dialogId = 'customConfirmDialog';
    let dialog = document.getElementById(dialogId);
    if (!dialog) {
        dialog = document.createElement('div');
        dialog.id = dialogId;
        dialog.className = 'modal'; // 复用modal的样式
        dialog.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="confirmDialogTitle"></div>
                    <div class="modal-close" onclick="closeModal('${dialogId}')">取消</div>
                </div>
                <div class="modal-body">
                    <p id="confirmDialogMessage" style="text-align: center; margin-bottom: 20px;"></p>
                    <div style="display: flex; justify-content: space-around; gap: 10px;">
                        <button class="form-submit" style="background-color: #ccc; flex: 1;" onclick="closeModal('${dialogId}')">取消</button>
                        <button class="form-submit delete-button" style="flex: 1;" id="confirmActionButton">确定</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(dialog);
    }

    document.getElementById('confirmDialogTitle').textContent = title;
    document.getElementById('confirmDialogMessage').textContent = message;
    
    const confirmBtn = document.getElementById('confirmActionButton');
    confirmBtn.onclick = () => {
        onConfirm();
        closeModal(dialogId);
    };

    showModal(dialogId);
}

/**
 * 显示上传错误的专用处理函数
 * @param {Error|Object} error - 错误对象，可能包含DetailedError结构
 */
function showUploadError(error) {
    if (error && error.name === 'DetailedError') {
        // 根据错误代码显示不同类型的toast
        switch(error.code) {
            case 'FILE_MISSING':
            case 'PARAM_MISSING':
                showToast(error.message, 'warning');
                break;
            case 'FILE_TOO_LARGE':
            case 'INVALID_FILE_TYPE':
                showToast(error.message, 'error');
                break;
            case 'STORAGE_FULL':
                showToast(error.message, 'error', 5000); // 存储满显示更久
                break;
            case 'DATABASE_ERROR':
                showToast(error.message, 'error');
                break;
            case 'SYSTEM_ERROR':
                showToast(error.message, 'warning');
                break;
            default:
                showToast(error.message, 'error');
                break;
        }
    } else {
        showToast(`上传失败: ${error.message || '未知错误'}`, 'error');
    }
}

/**
 * 处理API错误的专用函数，包含详细的错误记录和重试功能
 * @param {string|Error} prefixOrError - 错误前缀字符串或错误对象
 * @param {Error} error - 错误对象（当第一个参数是前缀时）
 */
function showApiError(prefixOrError, error) {
    let errorMessage;
    let prefix = '';
    
    // 支持单参数和双参数调用
    if (typeof prefixOrError === 'string' && error) {
        // 双参数调用：showApiError('前缀', error)
        prefix = prefixOrError + ': ';
        errorMessage = error.message || '未知错误';
    } else {
        // 单参数调用：showApiError(error)
        errorMessage = prefixOrError.message || '未知错误';
    }
    
    // 记录ERROR级别的日志，包含完整的错误信息
    console.error('ERROR: API调用失败详情:', {
        errorMessage: errorMessage,
        error: error,
        apiResponse: error?.response || error?.apiResponse || error?.data || null,
        timestamp: new Date().toISOString(),
        networkStatus: navigator.onLine ? 'online' : 'offline',
        pageUrl: window.location.href
    });
    
    // 调用特殊的重试模态框处理
    if (typeof window.showQixiRetryModal === 'function') {
        window.showQixiRetryModal(prefixOrError, error, errorMessage, prefix);
    } else {
        // 后备方案：显示普通错误提示
        showToast(prefix + errorMessage, 'error', 4000);
    }
}

/**
 * 初始化上下文滑块的值，使用现代API而非全局变量
 * @param {HTMLElement} contextSlider - 上下文滑块元素
 * @param {HTMLElement} contextValue - 上下文值显示元素
 */
async function initializeContextSlider(contextSlider, contextValue) {
    try {
        // 使用新的API获取当前配置，而不是依赖全局 window.apiSettings
        if (window.apiConfigManager) {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const contextCount = connection.contextMessageCount || 10;
            contextSlider.value = contextCount;
            contextValue.textContent = contextCount + '条';
        } else {
            // 降级处理：如果新API不可用，使用默认值
            console.warn('apiConfigManager 不可用，使用默认上下文消息数量');
            contextSlider.value = 10;
            contextValue.textContent = '10条';
        }
    } catch (error) {
        console.error('初始化上下文滑块失败:', error);
        // 错误情况下使用默认值
        contextSlider.value = 10;
        contextValue.textContent = '10条';
    }
}

// 兼容性：将函数分组暴露到全局window对象
if (typeof window !== 'undefined') {
    window.UIUtils = {
        showToast,
        showModal,
        closeModal,
        showTopNotification,
        showConfirmDialog,
        showUploadError,
        showApiError,
        initializeContextSlider
    };
    
    // 向后兼容：保留直接挂载的函数（逐步废弃）
    window.showToast = showToast;
    window.showModal = showModal;
    window.closeModal = closeModal;
    window.showTopNotification = showTopNotification;
    window.showConfirmDialog = showConfirmDialog;
    window.showUploadError = showUploadError;
    window.showApiError = showApiError;
    window.initializeContextSlider = initializeContextSlider;
}
</script>
    <script>
/**
 * Formatting Utilities
 * 数据格式化相关的实用工具函数
 */

/**
 * HTML字符转义，防止XSS攻击
 * @param {string} text - 需要转义的文本
 * @returns {string} 转义后的安全HTML文本
 */
function escapeHtml(text) {
    if (!text) return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

/**
 * 格式化音乐播放时间 (秒 -> MM:SS格式)
 * @param {number} seconds - 秒数
 * @returns {string} 格式化的时间字符串 (如: "3:45")
 */
function formatMusicTime(seconds) {
    if (!seconds || seconds < 0) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * 格式化时间戳为相对时间显示 (统一版本)
 * @param {string|number|Date} timestamp - 时间戳
 * @param {Object} options - 格式化选项
 * @param {boolean} options.precise - 是否使用精确的"刚刚"判断 (默认true)
 * @returns {string} 格式化的时间字符串
 */
function formatTime(timestamp, options = {}) {
    if (!timestamp) return '';
    
    const { precise = true } = options;
    const now = new Date();
    const postTime = new Date(timestamp);
    const diffInSeconds = (now - postTime) / 1000;
    const diffInMinutes = diffInSeconds / 60;
    const diffInHours = diffInMinutes / 60;

    // 使用日期边界而非24小时计算天数差异
    const startOfNow = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfPostTime = new Date(postTime.getFullYear(), postTime.getMonth(), postTime.getDate());
    const diffInDays = (startOfNow - startOfPostTime) / (1000 * 60 * 60 * 24);

    if (diffInDays < 1) { // 今天
        if (precise && diffInMinutes < 1) return "刚刚";
        if (diffInHours < 1) {
            const minutes = Math.max(1, Math.floor(diffInMinutes));
            return `${minutes}分钟前`;
        }
        return `${Math.floor(diffInHours)}小时前`;
    } else if (diffInDays < 2) { // 昨天
        return "1天前";
    } else { // 2天前及以上
        const isThisYear = now.getFullYear() === postTime.getFullYear();
        const month = (postTime.getMonth() + 1).toString().padStart(2, '0');
        const day = postTime.getDate().toString().padStart(2, '0');
        
        if (isThisYear) {
            const hours = postTime.getHours().toString().padStart(2, '0');
            const minutes = postTime.getMinutes().toString().padStart(2, '0');
            return `${month}-${day} ${hours}:${minutes}`;
        } else {
            return `${postTime.getFullYear()}-${month}-${day}`;
        }
    }
}

/**
 * 格式化时间戳为相对时间显示 (兼容旧版本 - 无"刚刚"判断)
 * @param {string|number|Date} timestamp - 时间戳
 * @returns {string} 格式化的时间字符串
 */
function formatTimeLegacy(timestamp) {
    return formatTime(timestamp, { precise: false });
}

/**
 * 格式化联系人列表时间显示 (针对聊天列表优化)
 * @param {string} dateString - 时间字符串
 * @returns {string} 格式化的时间字符串
 */
function formatContactListTime(dateString) {
    // 处理空值或无效输入
    if (!dateString) return '';
    
    // 如果已经是格式化后的时间，直接返回
    if (typeof dateString === 'string' && (
        dateString === '刚刚' || 
        dateString.includes('分钟前') || 
        dateString.includes('小时前') ||
        dateString.includes('星期') ||
        dateString.includes('昨天') ||
        dateString.includes('前天') ||
        (dateString.includes(':') && !dateString.includes('T')) || // 排除ISO格式
        (dateString.includes('月') && dateString.includes('日'))
    )) {
        return dateString;
    }
    
    // 尝试解析日期
    let d;
    try {
        d = new Date(dateString);
        // 检查日期是否有效
        if (isNaN(d.getTime())) {
            console.warn('Invalid date string:', dateString);
            return '';
        }
    } catch (e) {
        console.warn('Error parsing date:', dateString, e);
        return '';
    }
    
    const now = new Date();
    const diff = now - d;
    
    // 如果时间在未来，可能是时区问题，使用当前时间
    if (diff < 0) {
        console.warn('Future timestamp detected, using current time:', dateString);
        d = now;
    }
    
    // 2分钟内显示"刚刚"
    if (diff < 2 * 60 * 1000) {
        return '刚刚';
    }
    
    // 2分钟后到1小时内显示"X分钟前"
    if (diff < 60 * 60 * 1000) {
        const minutes = Math.floor(diff / (60 * 1000));
        return `${minutes}分钟前`;
    }
    
    // 1小时到24小时内显示"X小时前"
    if (diff < 24 * 60 * 60 * 1000) {
        const hours = Math.floor(diff / (60 * 60 * 1000));
        return `${hours}小时前`;
    }

    // 获取今天、昨天、前天的日期（只比较日期部分）
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const messageDate = new Date(d.getFullYear(), d.getMonth(), d.getDate());
    
    // 昨天
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    if (yesterday.getTime() === messageDate.getTime()) {
        return '昨天';
    }
    
    // 前天
    const dayBeforeYesterday = new Date(today);
    dayBeforeYesterday.setDate(dayBeforeYesterday.getDate() - 2);
    if (dayBeforeYesterday.getTime() === messageDate.getTime()) {
        return '前天';
    }
    
    // 一周内显示星期几
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);
    if (d >= weekAgo) {
        const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        return weekdays[d.getDay()];
    }
    
    // 今年内显示月日
    if (d.getFullYear() === now.getFullYear()) {
        return `${d.getMonth() + 1}月${d.getDate()}日`;
    }
    
    // 其他显示年月日
    return `${d.getFullYear()}年${d.getMonth() + 1}月${d.getDate()}日`;
}

/**
 * 格式化聊天时间戳 (针对聊天消息优化)
 * @param {string} dateString - 时间字符串
 * @returns {string} 格式化的时间字符串
 */
function formatChatTimestamp(dateString) {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return '';

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today.getTime() - 86400000);
    
    const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    const beijingTime = new Date(date.getTime());
    const hours = beijingTime.getHours().toString().padStart(2, '0');
    const minutes = beijingTime.getMinutes().toString().padStart(2, '0');
    const timeStr = `${hours}:${minutes}`;

    if (messageDate.getTime() === today.getTime()) {
        return timeStr;
    }
    if (messageDate.getTime() === yesterday.getTime()) {
        return `昨天 ${timeStr}`;
    }
    if (now.getFullYear() === date.getFullYear()) {
        const month = (date.getMonth() + 1);
        const day = date.getDate();
        return `${month}月${day}日 ${timeStr}`;
    } else {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1);
        const day = date.getDate();
        return `${year}年${month}月${day}日 ${timeStr}`;
    }
}

/**
 * 生成唯一ID
 * @returns {string} 唯一的ID字符串 (时间戳 + 随机字符串)
 */
function generateId() {
    return Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);
}

/**
 * 将文件读取为Data URL格式
 * @param {File} file - 要读取的文件对象
 * @returns {Promise<string>} Promise，解析为Data URL字符串
 */
function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = () => reject(new Error('文件读取失败'));
        reader.readAsDataURL(file);
    });
}

/**
 * 将Canvas转换为Blob对象
 * @param {HTMLCanvasElement} canvas - Canvas元素
 * @returns {Promise<Blob>} Promise，解析为Blob对象
 */
function canvasToBlob(canvas) {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Canvas转换失败'));
            }
        }, 'image/jpeg', 0.9);
    });
}

/**
 * 移除文本中的思维链标签
 * @param {string} text - 包含思维链的文本
 * @returns {string} 清理后的文本
 */
function removeThinkingChain(text) {
    // 删除 <think> ... </think> 标签及其内容
    return text.replace(/<think\s*>[\s\S]*?<\/think\s*>/gi, '').trim();
}

/**
 * 安全创建IndexedDB事务
 * @param {IDBDatabase} db - 数据库对象
 * @param {string|Array} storeNames - 存储名称
 * @param {string} mode - 事务模式 ('readonly' | 'readwrite')
 * @returns {IDBTransaction} 事务对象
 */
function safeCreateTransaction(db, storeNames, mode = 'readonly') {
    if (!db) {
        throw new Error('数据库连接不可用');
    }
    
    // 检查所有存储是否存在
    const missingStores = Array.isArray(storeNames) 
        ? storeNames.filter(storeName => !db.objectStoreNames.contains(storeName))
        : !db.objectStoreNames.contains(storeNames) ? [storeNames] : [];
    
    if (missingStores.length > 0) {
        throw new Error(`存储不存在: ${missingStores.join(', ')}`);
    }
    
    return db.transaction(storeNames, mode);
}

/**
 * Promise化IndexedDB请求
 * @param {IDBRequest} request - IndexedDB请求对象
 * @param {string} operation - 操作描述（用于错误日志）
 * @returns {Promise} Promise对象
 */
function promisifyRequest(request, operation = '数据库操作') {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => {
            console.error(`${operation}失败:`, request.error);
            reject(request.error);
        };
    });
}

/**
 * Promise化IndexedDB事务
 * @param {IDBTransaction} transaction - 事务对象
 * @param {string} operation - 操作描述（用于错误日志）
 * @returns {Promise} Promise对象
 */
function promisifyTransaction(transaction, operation = '数据库事务') {
    return new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => {
            console.error(`${operation}失败:`, transaction.error);
            reject(transaction.error);
        };
        transaction.onabort = () => {
            console.error(`${operation}被中止:`, transaction.error);
            reject(transaction.error || new Error('事务被中止'));
        };
    });
}

// 兼容性：将函数分组暴露到全局window对象
if (typeof window !== 'undefined') {
    window.FormatUtils = {
        escapeHtml,
        formatMusicTime,
        formatTime,
        formatTimeLegacy,
        formatContactListTime,
        formatChatTimestamp,
        generateId,
        readFileAsDataURL,
        canvasToBlob,
        removeThinkingChain
    };
    
    window.DBUtils = {
        safeCreateTransaction,
        promisifyRequest,
        promisifyTransaction
    };
    
    // 向后兼容：保留直接挂载的函数（逐步废弃）
    window.escapeHtml = escapeHtml;
    window.formatMusicTime = formatMusicTime;
    window.formatTime = formatTime;
    window.formatTimeLegacy = formatTimeLegacy;
    window.formatContactListTime = formatContactListTime;
    window.formatChatTimestamp = formatChatTimestamp;
    window.generateId = generateId;
    window.readFileAsDataURL = readFileAsDataURL;
    window.canvasToBlob = canvasToBlob;
    window.removeThinkingChain = removeThinkingChain;
    window.safeCreateTransaction = safeCreateTransaction;
    window.promisifyRequest = promisifyRequest;
    window.promisifyTransaction = promisifyTransaction;
}
</script>
    <script>
﻿// === 核心应用脚本 ===

// 🛡️ 全局错误处理器 - 处理第三方库和浏览器兼容性问题
window.addEventListener('error', function(event) {
    // 过滤掉已知的无害错误
    if (event.message && event.message.includes('document.currentScript')) {
        console.warn('🔧 捕获到 currentScript 兼容性错误，已安全忽略:', event.message);
        event.preventDefault(); // 阻止错误冒泡到控制台
        return true;
    }
    
    // 记录其他真正的错误供调试
    if (event.error && !event.message.includes('Script error')) {
        console.error('🐛 全局错误:', {
            message: event.message,
            filename: event.filename,
            line: event.lineno,
            column: event.colno,
            error: event.error
        });
    }
});

// 🛡️ Promise 未捕获错误处理器（统一处理）
window.addEventListener('unhandledrejection', function(event) {
    // 对于某些第三方库的 Promise 错误，我们也安全忽略
    if (event.reason && event.reason.toString().includes('currentScript')) {
        console.warn('🔧 捕获到未处理的 Promise 错误 (currentScript)，已安全忽略:', event.reason);
        event.preventDefault();
        return;
    }

    console.error('未处理的Promise拒绝:', {
        reason: event.reason,
        promise: event.promise,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
    });
    
    // 记录到全局错误日志
    if (!window.errorLog) window.errorLog = [];
    window.errorLog.push({
        type: 'unhandledrejection',
        reason: event.reason?.toString() || 'Unknown',
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
    });
    
    // 检查是否是API相关的错误，如果是则显示重试对话框
    const errorMessage = event.reason?.message || event.reason?.toString() || '';
    const isAPIError = errorMessage.includes('API请求失败') || 
                      errorMessage.includes('API Error') || 
                      errorMessage.includes('429') ||
                      errorMessage.includes('500') ||
                      errorMessage.includes('503') ||
                      errorMessage.includes('502') ||
                      errorMessage.includes('空回') ||
                      errorMessage.includes('AI回复内容为空') ||
                      errorMessage.includes('AI未返回有效内容');
    
    if (isAPIError && typeof showApiError === 'function') {
        showApiError(event.reason || new Error(errorMessage));
    }
    
    // 防止控制台显示未处理的错误（已记录）
    event.preventDefault();
});

// 已将以下功能迁移到专门的utils文件：
// - 主题管理 → uiManager.js
// - 文件上传处理 → imageStorageAPI.js  
// - 数据库管理 → dataMigrator.js
// - 日志系统 → systemUtilities.js
// - 颜色工具函数 → colorUtils.js
// - UI交互工具函数 → uiUtils.js
// - 格式化工具函数 → formatUtils.js

// 工具函数现在通过全局对象访问：
// - window.ColorUtils.* (颜色工具函数)
// - window.UIUtils.* (UI交互工具函数) 
// - window.FormatUtils.* (格式化工具函数)
// - window.DBUtils.* (数据库工具函数)
// 
// 同时为向后兼容，所有函数也直接挂载在window对象上

// 主题管理已迁移到 utils/uiManager.js

// 长按屏蔽系统已迁移到 utils/uiManager.js


// escapeHtml function moved to utils/formatUtils.js

/**
 * 统一的评论格式化函数 - 转换为标准数据模型
 * 新代码应使用此函数确保数据格式统一
 * @param {Object} comment - 原始评论对象（可能包含旧字段名）
 * @returns {Object} - 标准格式的评论对象
 */
function formatCommentForDataModel(comment) {
    return {
        commenter_name: comment.author || comment.commenter_name || '匿名',
        comment_content: comment.content || comment.comment_content || '',
        like: comment.like !== undefined ? comment.like : false,
        timestamp: comment.time || comment.timestamp || new Date().toISOString()
    };
}

/**
 * 解析语音消息格式，支持新的[V]格式和兼容旧的[语音]:格式
 * @param {string} messageContent - 原始消息内容
 * @returns {Object} - { content: string, isVoice: boolean }
 */
function parseVoiceMessage(messageContent) {
    if (!messageContent) {
        return { content: messageContent, isVoice: false };
    }
    
    const NEW_VOICE_PREFIX = '[V]';
    const OLD_VOICE_PREFIX = '[语音]:';
    
    // 检查新格式：[V]内容
    if (messageContent.startsWith(NEW_VOICE_PREFIX)) {
        const content = messageContent.substring(NEW_VOICE_PREFIX.length);
        return { content: content, isVoice: true };
    }
    
    // 检查旧格式：[语音]:内容
    if (messageContent.startsWith(OLD_VOICE_PREFIX)) {
        const content = messageContent.substring(OLD_VOICE_PREFIX.length).trim();
        return { content: content, isVoice: true };
    }
    
    // 普通文字消息
    return { content: messageContent, isVoice: false };
}

/**
 * 为语音消息设置UI，包括添加语音图标和点击事件
 * @param {HTMLElement} msgDiv - 消息div元素
 * @param {Object} message - 消息对象，包含content、isVoice等属性
 * @param {Object} currentContact - 当前联系人对象
 */
function setupVoiceMessageUI(msgDiv, message, currentContact) {
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    if (!message.isVoice || !currentContact.voiceId || !minimaxGroupId || !minimaxApiKey) {
        return;
    }
    
    // 兼容自定义气泡和默认气泡
    const bubble = msgDiv.querySelector('.message-bubble') || 
                  msgDiv.querySelector('.custom-bubble-container') || 
                  msgDiv.querySelector('.chat-bubble');
    if (!bubble) {
        return;
    }
    
    const messageUniqueId = `${currentContact.id}-${message.time}`;
    
    // 给气泡添加语音消息标识
    bubble.classList.add('voice-message');
    bubble.dataset.voiceMessageId = `voice-${messageUniqueId}`;
    
    // 在消息内容前添加语音符号
    const textContentDiv = bubble.querySelector('.message-content') || bubble;
    if (textContentDiv && !textContentDiv.querySelector('.voice-icon')) {
        const voiceIcon = document.createElement('span');
        voiceIcon.className = 'voice-icon';
        voiceIcon.innerHTML = createVoiceIcon();
        
        // 确定插入点并插入语音符号
        let insertionPoint = textContentDiv.firstChild;
        if (textContentDiv === bubble) {
            const firstTextNode = Array.from(textContentDiv.childNodes).find(node => 
                node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ''
            );
            if (firstTextNode) {
                insertionPoint = firstTextNode;
            }
        }
        textContentDiv.insertBefore(voiceIcon, insertionPoint);
        
        // 添加点击事件监听器
        bubble.addEventListener('click', () => {
            playVoiceMessage(bubble, message.content, message.senderId || currentContact.id);
        });
    }
}

// --- 全局状态 ---
let contacts = [];
// 确保暴露到全局对象
window.contacts = contacts;
let currentContact = null;
window.currentContact = currentContact;
let editingContact = null;
window.editingContact = editingContact;

// 🔥 数据库初始化已统一到 UnifiedDBManager，旧的竞态控制变量已移除

// API配置设置（不包含minimax语音配置）
// 注意：model相关信息现在从全局模型配置获取
let apiSettings = {
    url: '',
    key: '',
    contextMessageCount: 10,
    timeout: 60
    // minimax配置已移至localStorage独立管理
    // model和secondaryModel已迁移到独立的全局模型配置
};

// --- 用户配置获取函数 ---
async function getUserProfile() {
    // 返回全局的 userProfile 对象
    return userProfile || {
        name: '我的昵称',
        avatar: null,
        personality: ''
    };
}
// 确保暴露到全局对象
window.apiSettings = apiSettings;
let emojis = [];
let backgrounds = {};
let userProfile = {
    name: '我的昵称',
    avatar: '',
    personality: '' 
};

// 将 userProfile 绑定到全局作用域
window.userProfile = userProfile;
let moments = [];
let weiboPosts = [];

const RELATION_PRESETS = {
    'CP': 'CP（两者互为情侣）',
    'CB': 'CB（友情、亲情等非恋爱的亲密关系）', 
    '好友': '好友',
    '宿敌': '宿敌（两者互为能持续永恒的较量，长期的敌人，天生的对手，命中注定的竞争者）'
};

let hashtagCache = {};

let audio = null;
// IndexedDB 实例统一使用 window.db，不再使用局部变量

// 全局错误处理已统一到文件开头的 unhandledrejection 监听器中

// === 图片处理辅助函数 ===

/**
 * 获取头像HTML（支持新的文件存储格式和旧的base64格式）
 * @param {Object} entity - 实体对象（联系人或用户）
 * @param {string} entityType - 实体类型 ('contact' 或 'user')
 * @param {string} className - CSS类名（可选）
 * @returns {Promise<string>} 返回HTML字符串
 */
async function getAvatarHTML(entity, entityType = 'contact', className = '') {
    if (!entity) return '';
    
    try {
        // 如果有新的文件引用，使用ImageDisplayHelper
        if (entity.avatarFileId && window.ImageDisplayHelper) {
            return await window.ImageDisplayHelper.createAvatarHTML(entity, entityType, className);
        }
        
        // 回退到旧的base64格式
        const classAttr = className ? ` class="${className}"` : '';
        if (entity.avatar && entity.avatar.startsWith('data:')) {
            return `<img src="${entity.avatar}"${classAttr}>`;
        } else {
            // 使用首字符作为默认头像
            const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? '我' : '?');
            return `<span${classAttr}>${firstChar}</span>`;
        }
    } catch (error) {
        console.warn(`获取${entityType}头像HTML失败:`, error);
        // 安全回退
        const classAttr = className ? ` class="${className}"` : '';
        const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? '我' : '?');
        return entity.avatar ? `<img src="${entity.avatar}"${classAttr}>` : `<span${classAttr}>${firstChar}</span>`;
    }
}

/**
 * 同步获取头像HTML（用于不能使用async的地方）
 * 注意：这个函数不支持新的文件存储格式，只用于紧急情况下的回退
 */
function getAvatarHTMLSync(entity, entityType = 'contact', className = '') {
    if (!entity) return '';
    
    const classAttr = className ? ` class="${className}"` : '';
    if (entity.avatar && entity.avatar.startsWith('data:')) {
        return `<img src="${entity.avatar}"${classAttr}>`;
    } else {
        const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? '我' : '?');
        return `<span${classAttr}>${firstChar}</span>`;
    }
}

/**
 * 获取背景图片URL
 * @param {Object} background - 背景对象
 * @returns {Promise<string>} 返回图片URL
 */
async function getBackgroundImageURL(background) {
    if (!background) return '';
    
    try {
        // 如果有新的文件引用，使用ImageDisplayHelper
        if (background.fileId && window.ImageDisplayHelper) {
            return await window.ImageDisplayHelper.getBackgroundURL(background);
        }
        
        // 回退到旧格式
        return background.data || background.url || '';
    } catch (error) {
        console.warn('获取背景图片失败:', error);
        return background.data || background.url || '';
    }
}

/**
 * 获取表情包URL
 * @param {Object} emoji - 表情包对象
 * @returns {Promise<string>} 返回图片URL
 */
async function getEmojiImageURL(emoji) {
    if (!emoji) return '';
    
    try {
        // 如果有新的文件引用，使用ImageDisplayHelper
        if (emoji.fileId && window.ImageDisplayHelper) {
            return await window.ImageDisplayHelper.getEmojiURL(emoji);
        }
        
        // 回退到旧格式
        return emoji.data || emoji.url || '';
    } catch (error) {
        console.warn('获取表情包失败:', error);
        return emoji.data || emoji.url || '';
    }
} 
let playlist = [];
let currentSongIndex = -1;
let isPlaying = false;
let lyricTimer = null;
let currentObjectUrl = null;

// --- 标志位与分页加载状态 ---
let isEmojiGridRendered = false;
let isMomentsRendered = false;
let isMomentsDataModified = false; // 朋友圈数据是否被修改，需要重新渲染
let isMusicPlayerInitialized = false;
let isIndexedDBReady = false; 
// ⚠️ 注意：数据库操作统一使用 window.db 和 window.isIndexedDBReady，不要使用局部变量 
const MESSAGES_PER_PAGE = 15;
let currentlyDisplayedMessageCount = 0;
let isLoadingMoreMessages = false;

// 论坛帖子分页相关变量
const POSTS_PER_PAGE = 10;
let currentlyDisplayedPostCount = 0;
let isLoadingMorePosts = false;

// 虚拟滚动相关变量
const VIRTUAL_WINDOW_SIZE = 8; // 虚拟滚动窗口大小
const ESTIMATED_POST_HEIGHT = 300; // 估算的帖子高度（像素）
let allPosts = []; // 扁平化的所有帖子列表
let virtualScrollTop = 0;
let currentStartIndex = 0;
let currentEndIndex = 0;

// 多选模式状态
let isMultiSelectMode = false;
let selectedMessages = new Set();

// 语音播放相关全局变量
let voiceAudio = new Audio(); // 用于播放语音消息的全局Audio对象
let currentPlayingElement = null; // 跟踪当前播放的语音元素


console.log('ServiceWorker disabled in single-file mode');

// --- 初始化进度显示函数 ---

/**
 * 显示初始化进度提示
 * @param {string} message - 显示消息
 * @param {string} type - 消息类型 (system/api/worker/url/import/database/error)
 */
function showInitializationProgress(message, type = 'info') {
    // 查找或创建进度容器
    let progressContainer = document.getElementById('init-progress-container');
    if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'init-progress-container';
        progressContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;
        
        const progressBox = document.createElement('div');
        progressBox.id = 'init-progress-box';
        progressBox.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `;
        
        progressBox.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                <div class="spinner" style="
                    width: 24px; height: 24px; margin-right: 12px;
                    border: 3px solid #f3f3f3; border-top: 3px solid #007bff;
                    border-radius: 50%; animation: spin 1s linear infinite;
                "></div>
                <h3 style="margin: 0; color: #333;">Whale-LLT 正在启动</h3>
            </div>
            <p id="init-progress-message" style="margin: 0; color: #666; line-height: 1.5;"></p>
            <div id="init-progress-steps" style="margin-top: 15px; font-size: 12px; color: #999; text-align: left;"></div>
        `;
        
        progressContainer.appendChild(progressBox);
        document.body.appendChild(progressContainer);
        
        // 添加CSS动画
        if (!document.getElementById('init-progress-styles')) {
            const style = document.createElement('style');
            style.id = 'init-progress-styles';
            style.textContent = `
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    const messageEl = document.getElementById('init-progress-message');
    const stepsEl = document.getElementById('init-progress-steps');
    
    if (messageEl) {
        messageEl.textContent = message;
        messageEl.style.color = type === 'error' ? '#dc3545' : '#666';
    }
    
    // 记录步骤
    if (type !== 'error' && stepsEl) {
        const timestamp = new Date().toLocaleTimeString();
        const stepEl = document.createElement('div');
        stepEl.textContent = `${timestamp} - ${message}`;
        stepEl.style.cssText = 'margin: 2px 0; opacity: 0.7;';
        stepsEl.appendChild(stepEl);
        
        // 只保留最近5个步骤
        while (stepsEl.children.length > 5) {
            stepsEl.removeChild(stepsEl.firstChild);
        }
    }
    
    console.log(`[初始化进度] ${message}`);
}

/**
 * 隐藏初始化进度提示
 */
function hideInitializationProgress() {
    const progressContainer = document.getElementById('init-progress-container');
    if (progressContainer) {
        progressContainer.style.opacity = '0';
        progressContainer.style.transition = 'opacity 0.3s ease-out';
        
        setTimeout(() => {
            if (progressContainer.parentNode) {
                progressContainer.parentNode.removeChild(progressContainer);
            }
        }, 300);
    }
    
    // 清理样式
    const styles = document.getElementById('init-progress-styles');
    if (styles && styles.parentNode) {
        styles.parentNode.removeChild(styles);
    }
}

// --- 初始化 ---
async function init() {
    try {
        console.log('[DEBUG] 开始应用初始化...');
        
        // [DEBUG-MOMENTS-ROLES-START] 使用统一的数据库初始化，修复完成后可选择保留
        await executeWithRetry(async () => {
            console.log('[DEBUG] 调用统一的数据库初始化函数');
            
            // 使用统一的数据库初始化函数，防止竞态条件
            const db = await initializeDatabaseOnce();
            
            // 二次确认初始化结果
            if (!db || !window.isIndexedDBReady) {
                throw new Error('统一数据库初始化后连接仍未建立');
            }
            
            // 验证关键表是否存在
            const requiredStores = ['contacts', 'moments', 'apiSettings'];
            const missingStores = requiredStores.filter(store => !window.db.objectStoreNames.contains(store));
            if (missingStores.length > 0) {
                throw new Error(`数据库初始化不完整，缺少存储: ${missingStores.join(', ')}`);
            }
            
            console.log('[DEBUG] 统一数据库初始化成功');
            console.log('[DEBUG] 数据库版本:', window.db.version);
            console.log('[DEBUG] 可用存储:', Array.from(window.db.objectStoreNames));
            
        }, '应用初始化 - 统一数据库连接');
        // [DEBUG-MOMENTS-ROLES-END]
        
        // 从IndexedDB加载数据
        await loadDataFromDB();
        console.log('应用数据加载完成');
        
        // 初始化图片关键词生成器
        if (window.imageKeywordGenerator && window.apiService) {
            window.imageKeywordGenerator.init(apiSettings, window.apiService);
            console.log('图片关键词生成器初始化完成');
        }
        
        // 七夕节特殊处理 - 检查是否为8月29日且第一次打开
        await window.SystemUtils.checkSpecialEvents();
        
    } catch (error) {
        console.error('应用初始化失败:', error);
        
        // 分析错误类型并提供针对性解决方案
        let errorType = 'unknown';
        if (error.message.includes('数据库') || error.message.includes('IndexedDB') || error.message.includes('objectStoreNames')) {
            errorType = 'database';
        } else if (error.message.includes('网络') || error.message.includes('fetch')) {
            errorType = 'network';
        }
        
        // 记录详细错误信息用于调试
        window.lastInitError = {
            timestamp: new Date().toISOString(),
            error: error.message,
            stack: error.stack,
            userAgent: navigator.userAgent,
            url: window.location.href,
            type: errorType,
            dbState: {
                hasWindow: !!window.db,
                isReady: !!window.isIndexedDBReady,
                dbVersion: window.db?.version
            }
        };
        
        showDatabaseErrorDialog(error, false);
        throw error;
    }

    await renderContactList();
    // 立即更新一次时间显示，确保首次进入页面显示正确的时间
    updateContactListTimes();
    await updateUserProfileUI();
    updateContextIndicator();
    
    // 绑定基础事件
    const chatInput = document.getElementById('chatInput');
    chatInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
    });
    
    setTimeout(() => {
        const hint = document.getElementById('featureHint');
        if (hint) {
            hint.style.display = 'block';
            setTimeout(() => {
                hint.style.display = 'none';
            }, 5000);
        }
    }, 1000);

    // 为全局voiceAudio对象绑定事件
    voiceAudio.onended = () => {
        if (currentPlayingElement) {
            currentPlayingElement.classList.remove('playing');
            const voiceIcon = currentPlayingElement.querySelector('.voice-icon');
            if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
            currentPlayingElement = null;
        }
    };
    voiceAudio.onerror = () => {
        showToast('音频文件加载失败');
        if (currentPlayingElement) {
             currentPlayingElement.classList.remove('playing', 'loading');
             const voiceIcon = currentPlayingElement.querySelector('.voice-icon');
             if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
             currentPlayingElement = null;
        }
    };


    // Check for update announcements
    const unreadAnnouncements = await announcementManager.getUnread();
    if (unreadAnnouncements.length > 0) {
        const modalBody = document.getElementById('updateModalBody');
        const modalFooter = document.querySelector('#updateModal .modal-footer');
        
        const combinedContent = unreadAnnouncements.reverse()
            .map(ann => ann.content)
            .join('<hr style="margin: 20px 0; border: 0; border-top: 1px solid #eee;">');
        
        modalBody.innerHTML = marked.parse(combinedContent);
        showModal('updateModal');

        // Logic to show button when scrolled to bottom
        modalBody.onscroll = () => {
            // Check if the user has scrolled to the bottom
            // Adding a 5px tolerance
            if (modalBody.scrollHeight - modalBody.scrollTop - modalBody.clientHeight < 5) {
                modalFooter.classList.add('visible');
            }
        };

        // Also check if the content is not long enough to scroll
        // Use a timeout to allow the DOM to render first
        setTimeout(() => {
            if (modalBody.scrollHeight <= modalBody.clientHeight) {
                modalFooter.classList.add('visible');
            }
        }, 100);


        document.getElementById('updateModalCloseBtn').onclick = () => {
            closeModal('updateModal');
            const idsToMark = unreadAnnouncements.map(ann => ann.id);
            announcementManager.markAsSeen(idsToMark);
        };
    }
}



// --- IndexedDB 核心函数 ---

// 表情数据结构优化函数（版本4、5用户升级到7时自动执行）
async function performEmojiOptimization() {
    try {
        console.log('开始执行表情数据结构优化...');
        
        if (!window.isIndexedDBReady) {
            console.error('数据库未准备就绪，无法执行优化');
            return;
        }
        
        // 获取当前数据
        const transaction = window.db.transaction(['contacts', 'emojis', 'emojiImages'], 'readonly');
        const contactsStore = transaction.objectStore('contacts');
        const emojisStore = transaction.objectStore('emojis');
        const emojiImagesStore = transaction.objectStore('emojiImages');
        
        const contacts = await promisifyRequest(contactsStore.getAll()) || [];
        const emojis = await promisifyRequest(emojisStore.getAll()) || [];
        const existingEmojiImages = await promisifyRequest(emojiImagesStore.getAll()) || [];
        
        if (contacts.length === 0 || emojis.length === 0) {
            console.log('没有数据需要优化，跳过');
            return;
        }
        
        let processedCount = 0;
        const base64UrlPattern = /data:image\/[^;]+;base64,[A-Za-z0-9+\/=]+/g;
        const newEmojiImages = [];
        const updatedEmojis = [...emojis];
        const updatedContacts = [];
        
        // 遍历所有联系人的消息
        for (const contact of contacts) {
            const updatedContact = { ...contact };
            let contactUpdated = false;
            
            if (contact.messages && Array.isArray(contact.messages)) {
                updatedContact.messages = [];
                
                for (const message of contact.messages) {
                    const updatedMessage = { ...message };
                    
                    if (message.content && typeof message.content === 'string') {
                        const matches = message.content.match(base64UrlPattern);
                        if (matches) {
                            for (const base64Url of matches) {
                                // 查找对应的表情
                                const emoji = updatedEmojis.find(e => e.url === base64Url);
                                if (emoji && emoji.meaning) {
                                    // 检查是否已存在相同的表情图片
                                    const existingImage = existingEmojiImages.find(img => img.tag === emoji.meaning) ||
                                                        newEmojiImages.find(img => img.tag === emoji.meaning);
                                    
                                    if (!existingImage) {
                                        newEmojiImages.push({
                                            tag: emoji.meaning,
                                            data: base64Url
                                        });
                                    }
                                    
                                    // 更新表情数据结构
                                    if (!emoji.tag) {
                                        emoji.tag = emoji.meaning;
                                    }
                                    if (emoji.url) {
                                        delete emoji.url;
                                    }
                                    
                                    // 替换消息中的格式
                                    updatedMessage.content = updatedMessage.content.replace(
                                        base64Url,
                                        `[emoji:${emoji.meaning}]`
                                    );
                                    
                                    processedCount++;
                                    contactUpdated = true;
                                }
                            }
                        }
                    }
                    
                    updatedContact.messages.push(updatedMessage);
                }
            }
            
            if (contactUpdated) {
                updatedContacts.push(updatedContact);
            }
        }
        
        // 保存优化后的数据
        if (processedCount > 0) {
            const writeTransaction = window.db.transaction(['contacts', 'emojis', 'emojiImages'], 'readwrite');
            
            // 更新表情图片数据
            if (newEmojiImages.length > 0) {
                const emojiImagesStore = writeTransaction.objectStore('emojiImages');
                for (const emojiImage of newEmojiImages) {
                    await promisifyRequest(emojiImagesStore.put(emojiImage));
                }
            }
            
            // 更新表情元数据
            const emojisStore = writeTransaction.objectStore('emojis');
            for (const emoji of updatedEmojis) {
                if (emoji.tag) { // 只更新有tag的表情
                    await promisifyRequest(emojisStore.put(emoji));
                }
            }
            
            // 更新联系人消息
            const contactsStore = writeTransaction.objectStore('contacts');
            for (const contact of updatedContacts) {
                await promisifyRequest(contactsStore.put(contact));
            }
            
            console.log(`表情数据结构优化完成！`);
            console.log(`- 处理了 ${processedCount} 个表情引用`);
            console.log(`- 创建了 ${newEmojiImages.length} 个新的表情图片记录`);
            console.log(`- 更新了 ${updatedContacts.length} 个联系人的消息`);
            
            // 显示提示
            if (typeof showToast === 'function') {
                showToast(`表情数据优化完成！处理了 ${processedCount} 个表情`, 'success');
            }
            
            // 重新加载数据以确保界面同步
            await loadDataFromDB();
        } else {
            console.log('没有需要优化的表情数据');
        }
        
    } catch (error) {
        console.error('表情数据优化失败:', error);
        if (typeof showToast === 'function') {
            showToast('表情数据优化失败: ' + error.message, 'error');
        }
    }
}

async function loadDataFromDB() {
    return await ensureDBReady(async () => {
        console.log('[FIXED] 开始从数据库加载数据，使用 window.db...');
        
        const storeNames = [
        'contacts', 
        'apiSettings', 
        'emojis', 
        'backgrounds', 
        'userProfile', 
        'moments', 
        'weiboPosts', 
        'hashtagCache'
        ];

        // 先检查存不存在 emojiImages
        if (window.db.objectStoreNames.contains('emojiImages')) {
            storeNames.push('emojiImages');
        } else {
            console.warn('数据库版本未包含 emojiImages 存储，建议更新页面以升级数据库。');
        }
        
        const transaction = window.db.transaction(storeNames, 'readonly');
        
        const contactsStore = transaction.objectStore('contacts');
        const apiSettingsStore = transaction.objectStore('apiSettings');
        const emojisStore = transaction.objectStore('emojis');
        const backgroundsStore = transaction.objectStore('backgrounds');
        const userProfileStore = transaction.objectStore('userProfile');
        const momentsStore = transaction.objectStore('moments');
        const weiboPostsStore = transaction.objectStore('weiboPosts');
        
        // 加载联系人数据
        contacts = (await promisifyRequest(contactsStore.getAll(), '加载联系人数据')) || [];
        console.log(`[DEBUG] 从数据库加载了 ${contacts.length} 个联系人`);
        
        // 更新全局引用
        window.contacts = contacts;
        
        // [DEBUG-MOMENTS-ROLES-START] 调试信息，修复完成后删除
        if (contacts.length > 0) {
            const privateContacts = contacts.filter(c => c.type === 'private');
            console.log('[DEBUG] contacts数据加载详情:', {
                totalContacts: contacts.length,
                privateContacts: privateContacts.length,
                contactsList: contacts.map(c => ({ name: c.name, id: c.id, type: c.type })),
                windowContactsSet: !!window.contacts,
                windowContactsLength: window.contacts ? window.contacts.length : 0
            });
        } else {
            console.warn('[DEBUG] 数据库中没有找到任何联系人数据');
        }
        // [DEBUG-MOMENTS-ROLES-END]
        
        // 迁移旧数据格式或添加默认值
        contacts.forEach(contact => {
            if (contact.type === undefined) contact.type = 'private';
            // 为旧联系人数据添加 voiceId 默认值
            if (contact.voiceId === undefined) contact.voiceId = '';
            window.memoryTableManager.initContactMemoryTable(contact);
            if (contact.messages) {
                contact.messages.forEach(msg => {
                    if (msg.role === 'user' && msg.senderId === undefined) msg.senderId = 'user';
                    else if (msg.role === 'assistant' && msg.senderId === undefined) msg.senderId = contact.id;
                });
            }
        });

        // 加载API设置（只包含连接信息）
        const savedApiSettings = (await promisifyRequest(apiSettingsStore.get('settings'), '加载API设置')) || {};
        apiSettings = {
            ...apiSettings,
            url: savedApiSettings.url || '',
            key: savedApiSettings.key || '',
            contextMessageCount: savedApiSettings.contextMessageCount || 10,
            timeout: savedApiSettings.timeout || 60
        };

        // 为旧API设置数据添加 elevenLabsApiKey 默认值
        if (apiSettings.elevenLabsApiKey === undefined) apiSettings.elevenLabsApiKey = '';

        // 更新全局引用
        window.apiSettings = apiSettings;
        console.log('API设置加载完成');

        // 加载表情数据
        emojis = (await promisifyRequest(emojisStore.getAll(), '加载表情数据')) || [];
        console.log(`加载了 ${emojis.length} 个表情`);
        
        // 加载背景数据
        backgrounds = (await promisifyRequest(backgroundsStore.get('backgroundsMap'), '加载背景数据')) || {};
        console.log(`加载了 ${Object.keys(backgrounds).length} 个背景`);
        
        // 加载用户资料
        const savedUserProfile = (await promisifyRequest(userProfileStore.get('profile'), '加载用户资料')) || {};
        userProfile = { ...userProfile, ...savedUserProfile };
        if (userProfile.personality === undefined) {
            userProfile.personality = '';
        }
        console.log('用户资料加载完成');
        
        // 加载朋友圈数据
        moments = (await promisifyRequest(momentsStore.getAll(), '加载朋友圈数据')) || [];
        console.log(`加载了 ${moments.length} 个朋友圈`);
        
        // 加载微博数据
        weiboPosts = (await promisifyRequest(weiboPostsStore.getAll(), '加载微博数据')) || [];
        console.log(`加载了 ${weiboPosts.length} 个微博帖子`);

        // 加载hashtag缓存
        const hashtagCacheStore = transaction.objectStore('hashtagCache');
        const savedHashtagCache = (await promisifyRequest(hashtagCacheStore.get('cache'), '加载标签缓存')) || {};
        hashtagCache = savedHashtagCache;
        console.log('标签缓存加载完成');

        // 重新初始化角色记忆管理器的数据（现在数据库已准备好）
        if (window.characterMemoryManager) {
            try {
                await window.characterMemoryManager.loadConversationCounters();
                await window.characterMemoryManager.getGlobalMemory();
                console.log('角色记忆管理器初始化完成');
            } catch (memoryError) {
                console.error('角色记忆管理器初始化失败:', memoryError);
            }
        }
        
        // 初始化完成后进行数据一致性检查
        if (weiboPosts && weiboPosts.length > 0) {
            const repaired = await checkAndRepairDataConsistency();
            if (repaired) {
                console.log('初始化时修复了数据不一致性');
            }
        }
        
        // 数据库健康检查和修复提示
        if (window.DatabaseManager && window.DatabaseManager.checkAndOfferRepair) {
            window.DatabaseManager.checkAndOfferRepair();
        }

        console.log('数据库事务数据加载完成');

    }, '数据库加载操作');

    // 在事务结束后加载全局模型配置
    try {
        const modelConfig = await window.apiConfigManager.getGlobalModelConfig();
        window.modelSettings = {
            apiConfigId: modelConfig.apiConfigId || '',
            primaryModel: modelConfig.primaryModel || '',
            secondaryModel: modelConfig.secondaryModel || ''
        };
        console.log('全局模型配置加载完成:', window.modelSettings);
    } catch (error) {
        console.warn('加载全局模型配置失败:', error);
        window.modelSettings = {
            apiConfigId: '',
            primaryModel: '',
            secondaryModel: ''
        };
    }

    console.log('所有数据加载完成');
    showToast('数据加载完成', 'success');
}

async function saveDataToDB() {
    return await ensureDBReady(async () => {
        console.log('[FIXED] 开始保存数据到数据库，使用 window.db...');
        
        // 检查是否存在新的emojiImages存储
        const storeNames = ['contacts', 'apiSettings', 'emojis', 'backgrounds', 'userProfile', 'moments', 'hashtagCache'];
        if (window.db.objectStoreNames.contains('emojiImages')) {
            storeNames.push('emojiImages');
        }
        
        const transaction = window.db.transaction(storeNames, 'readwrite');
        
        const contactsStore = transaction.objectStore('contacts');
        const apiSettingsStore = transaction.objectStore('apiSettings');
        const emojisStore = transaction.objectStore('emojis');
        const backgroundsStore = transaction.objectStore('backgrounds');
        const userProfileStore = transaction.objectStore('userProfile');
        const momentsStore = transaction.objectStore('moments');
        
        // 清空contacts，然后重新添加，确保数据最新
        await promisifyRequest(contactsStore.clear(), '清空联系人数据');
        console.log(`开始保存 ${contacts.length} 个联系人...`);
        for (const contact of contacts) {
            await promisifyRequest(contactsStore.put(contact), `保存联系人 ${contact.name || contact.id}`);
        }
        console.log('联系人数据保存完成');

        // 保存API设置
        await promisifyRequest(apiSettingsStore.put({ id: 'settings', ...apiSettings }), '保存API设置');
        console.log('API设置保存完成');
        
        // 保存表情数据
        await promisifyRequest(emojisStore.clear(), '清空表情数据');
        console.log(`开始保存 ${emojis.length} 个表情...`);
        for (const emoji of emojis) {
            await promisifyRequest(emojisStore.put(emoji), `保存表情 ${emoji.id}`);
        }
        console.log('表情数据保存完成');

        // 保存背景和用户资料
        await promisifyRequest(backgroundsStore.put({ id: 'backgroundsMap', ...backgrounds }), '保存背景数据');
        await promisifyRequest(userProfileStore.put({ id: 'profile', ...userProfile }), '保存用户资料');
        console.log('背景和用户资料保存完成');
        
        // 保存朋友圈数据
        await promisifyRequest(momentsStore.clear(), '清空朋友圈数据');
        console.log(`开始保存 ${moments.length} 个朋友圈...`);
        for (const moment of moments) {
            await promisifyRequest(momentsStore.put(moment), `保存朋友圈 ${moment.id}`);
        }
        console.log('朋友圈数据保存完成');

        // 保存hashtag缓存
        const hashtagCacheStore = transaction.objectStore('hashtagCache');
        await promisifyRequest(hashtagCacheStore.put({ id: 'cache', ...hashtagCache }), '保存标签缓存');
        console.log('标签缓存保存完成');

        // 等待所有操作完成
        await promisifyTransaction(transaction, '数据保存事务');
        console.log('所有数据保存完成');        
    }, '数据库保存操作');
}


/**
 * 🔥 简化的数据库初始化函数 - 使用统一数据库管理器
 * 替代了复杂的 initializeDatabaseOnce 逻辑
 */
async function initializeDatabaseOnce() {
    console.log('🔥 [简化初始化] 使用统一数据库管理器初始化...');
    
    try {
        // 使用统一数据库管理器进行初始化
        const db = await window.unifiedDB.init();
        
        console.log('🔥 [简化初始化] 数据库初始化成功，版本:', db.version);
        console.log('🔥 [简化初始化] 可用存储:', Array.from(db.objectStoreNames));
        
        // 初始化API配置管理器
        if (window.apiConfigManager) {
            try {
                await window.apiConfigManager.init();
                console.log('🔥 [简化初始化] API配置管理器初始化完成');
            } catch (error) {
                console.error('🔥 [简化初始化] API配置管理器初始化失败:', error);
            }
        }
        
        return db;
        
    } catch (error) {
        console.error('🔥 [简化初始化] 数据库初始化失败:', error);
        throw error;
    }
}


// --- 论坛功能 ---

// formatTime function moved to utils/formatUtils.js

// --- 页面导航 ---
const pageIds = ['contactListPage', 'weiboPage', 'momentsPage', 'profilePage', 'chatPage', 'dataManagementPage', 'debugLogPage', 'memoryManagementPage', 'userProfilePage', 'appearanceManagementPage', 'apiConfigManagementPage', 'interactivePage'];

function showPage(pageIdToShow) {
    // 异步包装函数，用于处理包含异步操作的页面显示
    showPageAsync(pageIdToShow).catch(error => {
        console.error('页面显示错误:', error);
    });
}

async function showPageAsync(pageIdToShow) {
    // 记录当前活跃页面，用于导航历史
    const currentActivePage = pageNavManager.getCurrentActivePage();
    if (currentActivePage && currentActivePage !== pageIdToShow) {
        pageNavManager.navigateTo(currentActivePage, pageIdToShow);
    }

    // Hide all main pages and the chat page
    pageIds.forEach(pageId => {
        const page = document.getElementById(pageId);
        if (page) {
            page.classList.remove('active');
        }
    });

    // Show the requested page
    const pageToShow = document.getElementById(pageIdToShow);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }

    // Update the active state of the bottom navigation buttons
    const navItems = document.querySelectorAll('.bottom-nav .nav-item');
    const navMapping = ['contactListPage', 'weiboPage', 'momentsPage', 'profilePage'];
    navItems.forEach((item, index) => {
        // This relies on the order in the HTML, which is correct.
        if (navMapping[index] === pageIdToShow) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });

    // 兼容性适配：显式控制底部导航栏的显示/隐藏
    // 为不支持 :has() 选择器的浏览器提供JavaScript备用方案
    const bottomNav = document.querySelector('.bottom-nav');
    if (bottomNav) {
        if (pageIdToShow === 'chatPage') {
            // 聊天页面时隐藏导航栏
            bottomNav.style.display = 'none';
            document.body.classList.add('chat-active');
        } else {
            // 其他页面时显示导航栏
            bottomNav.style.display = 'flex';
            document.body.classList.remove('chat-active');
        }
    }

    // --- Lazy Loading/Rendering ---
    // Render Weibo posts when the page is shown
    if (pageIdToShow === 'weiboPage') {
        renderAllWeiboPosts();
    } else {
        // 离开论坛页面时清理虚拟滚动监听器
        const weiboPage = document.getElementById('weiboPage');
        if (weiboPage) {
            weiboPage.onscroll = null;
        }
    }
    // Render Moments only on the first time it's opened OR if data has been modified
    if (pageIdToShow === 'momentsPage' && (!isMomentsRendered || isMomentsDataModified)) {
        await renderMomentsList();
        isMomentsRendered = true;
        isMomentsDataModified = false; // 重置修改标志
    }
    
    // Load API Config Management page content
    if (pageIdToShow === 'apiConfigManagementPage') {
        await loadApiConfigManagementPage();
    }
    
    // 更新朋友圈锁定指示器显示状态
    if (window.momentsLockManager) {
        window.momentsLockManager.updateLockIndicator();
    }

    if (pageIdToShow === 'dataManagementPage') {
        refreshDatabaseStats();
    }
    
    // 切换到联系人列表时手动刷新时间显示
    if (pageIdToShow === 'contactListPage') {
        updateContactListTimes();
    }
    
    // 切换到个人信息页面时更新版本号显示
    if (pageIdToShow === 'profilePage') {
        updateProfileVersion();
    }

    // 定期清理导航历史
    pageNavManager.cleanupHistory();
}

/**
 * 更新个人信息页面的版本号显示
 */
function updateProfileVersion() {
    try {
        // 确保 EnvironmentConfig 已加载
        if (typeof EnvironmentConfig === 'undefined') {
            console.warn('EnvironmentConfig not loaded, using fallback version');
            return;
        }
        
        const versionElement = document.getElementById('profileVersionText');
        if (versionElement) {
            const version = EnvironmentConfig.getVersion();
            versionElement.textContent = version; // 不加 v 前缀，直接显示 commit hash
        }
    } catch (error) {
        console.warn('Failed to update profile version:', error);
    }
}

function showGeneratePostModal() {
    const select = document.getElementById('postGenCharacterSelect');
    select.innerHTML = '<option value="">请选择...</option>'; // Reset
    contacts.forEach(contact => {
        if (contact.type === 'private') {
            const option = document.createElement('option');
            option.value = contact.id;
            option.textContent = contact.name;
            select.appendChild(option);
        }
    });
    
    // 重置关系选择
    const relationSelect = document.getElementById('postGenRelations');
    relationSelect.value = '';
    handleRelationChange();
    
    // postUnsplashKey元素已从HTML中移除，不再恢复Unsplash API Key
    
    showModal('generatePostModal');
}

// 新增：处理关系选择变化
function handleRelationChange() {
    const relationSelect = document.getElementById('postGenRelations');
    const customRelationInput = document.getElementById('postGenCustomRelation');
    
    if (relationSelect.value === 'custom') {
        customRelationInput.parentElement.style.display = 'block'; // 显示父级 .form-group
        customRelationInput.required = true;
    } else {
        customRelationInput.parentElement.style.display = 'none'; // 隐藏父级 .form-group
        customRelationInput.required = false;
        customRelationInput.value = '';
    }
}

// 新增：处理角色选择变化，加载hashtag缓存
function handleCharacterChange() {
    const contactId = document.getElementById('postGenCharacterSelect').value;
    const hashtagInput = document.getElementById('postGenHashtag');
    
    if (contactId && hashtagCache[contactId]) {
        hashtagInput.value = hashtagCache[contactId];
    } else {
        const contact = contacts.find(c => c.id === contactId);
        if (contact) {
            // 默认hashtag为 #A & B#
            hashtagInput.value = `${contact.name} & ${userProfile.name}`;
        }
    }
}

async function handleGeneratePost(event) {
    event.preventDefault();
    const contactId = document.getElementById('postGenCharacterSelect').value;
    const relationSelect = document.getElementById('postGenRelations');
    const customRelationInput = document.getElementById('postGenCustomRelation');
    const hashtagInput = document.getElementById('postGenHashtag');
    const count = document.getElementById('postGenCount').value;
    // postUnsplashKey元素已从HTML中移除，从localStorage直接获取
    const unsplashKey = localStorage.getItem('forumUnsplashApiKey') || '';

    if (!contactId) {
        showToast('请选择角色');
        return;
    }

    let relations;
    let relationDescription;
    
    if (relationSelect.value === 'custom') {
        if (!customRelationInput.value.trim()) {
            showToast('请填写自定义关系');
            return;
        }
        relations = customRelationInput.value.trim();
        relationDescription = relations; // 自定义关系直接使用用户输入
    } else {
        if (!relationSelect.value) {
            showToast('请选择关系类型');
            return;
        }
        relations = relationSelect.value;
        relationDescription = RELATION_PRESETS[relations];
    }

    const hashtag = hashtagInput.value.trim();
    if (!hashtag) {
        showToast('请填写话题标签');
        return;
    }

    // 缓存hashtag
    hashtagCache[contactId] = hashtag;
    await saveDataToDB();
    
    // Unsplash API Key已从localStorage获取，无需重复保存

    closeModal('generatePostModal');
    await generateWeiboPosts(contactId, relations, relationDescription, hashtag, count, unsplashKey);
}

async function saveWeiboPost(postData) {
    if (!window.isIndexedDBReady) {
        console.error('IndexedDB not ready, cannot save post.');
        showToast('数据库错误，无法保存帖子');
        return;
    }
    try {
        const transaction = window.db.transaction(['weiboPosts'], 'readwrite');
        const store = transaction.objectStore('weiboPosts');
        await promisifyRequest(store.add(postData));
        await promisifyTransaction(transaction);
    } catch (error) {
        console.error('Failed to save Weibo post to DB:', error);
        showToast('保存帖子失败');
    }
}

async function generateWeiboPosts(contactId, relations, relationDescription, hashtag, count = 1, unsplashKey = null) {
    
    const contact = contacts.find(c => c.id === contactId);
    
    if (!contact) {
        console.error('未找到联系人，contactId:', contactId, '所有联系人:', contacts);
        showToast('未找到指定的聊天对象');
        return;
    }
    
    
    // 检查API配置和模型配置
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        console.error('API配置不完整:', error.message);
        showToast('请先在设置中配置API和模型');
        return;
    }

    if (!apiCallInfo.url || !apiCallInfo.key || !apiCallInfo.model) {
        console.error('API配置不完整:', apiCallInfo);
        showToast('请先在设置中配置API和模型');
        return;
    }
    
    const container = document.getElementById('weiboContainer');
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'loading-text';
    loadingIndicator.textContent = '正在生成论坛内容...';
    container.prepend(loadingIndicator);

    console.log('正在构建系统提示词...');
    const systemPrompt = await window.promptBuilder.buildWeiboPrompt(
        contactId, 
        relations, 
        relationDescription,
        hashtag,
        count, 
        contact, 
        userProfile, 
        contacts,
        emojis
    );

    try {
        const payload = {
            model: apiCallInfo.model,
            messages: [{ role: 'user', content: systemPrompt }],
            response_format: { type: "json_object" },
            temperature: 0.7
        };

        const apiUrl = `${apiCallInfo.url}/chat/completions`;
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiCallInfo.key}`
            },
            body: JSON.stringify(payload)
        });

        console.log('收到API响应:', {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok,
            headers: Object.fromEntries(response.headers.entries())
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('API请求失败，错误详情:', {
                status: response.status,
                statusText: response.statusText,
                errorText: errorText
            });
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        console.log('API完整返回:', JSON.stringify(data, null, 2));
        
        let rawText = data.choices[0].message.content;
        
        if (!rawText) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error("AI未返回有效内容");
        }
        
        // 使用统一的JSON提取函数清理markdown语法
        let jsonText;
        try {
            jsonText = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawText);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }

        // 解析JSON
        let weiboData;
        try {
            weiboData = JSON.parse(jsonText);
        } catch (parseError) {
            console.error('ERROR: JSON解析失败 - API完整返回:', rawText);
            console.error('ERROR: JSON解析失败 - 尝试解析的文本:', jsonText);
            console.error('ERROR: JSON解析失败 - 错误详情:', parseError);
            throw new Error(`JSON解析失败: ${parseError.message}`);
        }

        // --- 时间戳注入 ---
        // 注入时间戳
        const now = Date.now();
        // 主楼时间设为2-5分钟前
        const postCreatedAt = new Date(now - (Math.random() * 3 + 2) * 60 * 1000);
        let lastCommentTime = postCreatedAt.getTime();
        

        if (weiboData.posts && Array.isArray(weiboData.posts)) {
            weiboData.posts.forEach((post, index) => {
                post.timestamp = postCreatedAt.toISOString(); // 给主楼加时间戳
                
                if (post.comments && Array.isArray(post.comments)) {
                    post.comments.forEach((comment, commentIndex) => {
                        // 回复时间在主楼和现在之间，且比上一条晚一点
                        const newCommentTimestamp = lastCommentTime + (Math.random() * 2 * 60 * 1000); // 0-2分钟后
                        lastCommentTime = newCommentTimestamp;
                        comment.timestamp = new Date(Math.min(newCommentTimestamp, now)).toISOString(); // 不超过当前时间
                    });
                }
            });
        } else {
            console.error('weiboData.posts不是数组或不存在:', weiboData);
        }
        // --- 时间戳注入结束 ---
        
        // --- 图片生成逻辑 ---
        if (unsplashKey && weiboData.posts && Array.isArray(weiboData.posts)) {
            try {
                for (const post of weiboData.posts) {
                    if (post.image_description && post.image_description.trim()) {
                        try {
                            const imageUrl = await fetchMatchingImageForPublish(post.image_description, unsplashKey);
                            if (imageUrl) {
                                // 将图片描述替换为实际图片HTML
                                post.actual_image_url = imageUrl;
                                // 保留原始描述用于备份
                                post.original_image_description = post.image_description;
                                post.image_description = `<img src="${imageUrl}" alt="${post.image_description}" style="width: 100%; max-width: 300px; border-radius: 8px;">`;
                            }
                        } catch (imageError) {
                            console.warn(`为帖子生成图片失败: ${imageError.message}`);
                            // 图片生成失败时保持原始文字描述
                        }
                    }
                }
            } catch (error) {
                console.warn('批量图片生成过程中出现错误:', error);
            }
        }
        // --- 图片生成结束 ---
        
        const newPost = {
            id: Date.now(),
            contactId: contactId,
            relations: relations,
            relationDescription: relationDescription,
            hashtag: hashtag,
            data: weiboData,
            createdAt: postCreatedAt.toISOString()
        };

        console.log('准备保存新帖子:', {
            id: newPost.id,
            contactId: newPost.contactId,
            relations: newPost.relations,
            hashtag: newPost.hashtag,
            createdAt: newPost.createdAt,
            dataStructure: {
                hasWeiboPosts: !!newPost.data.posts,
                postsCount: newPost.data.posts ? newPost.data.posts.length : 0
            }
        });

        console.log('保存帖子到数据库...');
        await saveWeiboPost(newPost);
        console.log('帖子保存成功，添加到内存数组...');
        weiboPosts.push(newPost); // Update in-memory array
        console.log('当前内存中的帖子数量:', weiboPosts.length);
        
        console.log('重新渲染所有帖子...');
        renderAllWeiboPosts();
        console.log('=== 论坛帖子生成完成 ===');
        showToast('帖子已刷新！');

    } catch (error) {
        console.error('=== 生成论坛失败 ===');
        console.error('错误类型:', error.name);
        console.error('错误消息:', error.message);
        console.error('完整错误对象:', error);
        showApiError(error);
    } finally {
        loadingIndicator.remove();
    }
}


// 扁平化帖子数据，每个帖子包含原始信息和位置信息
function flattenPosts() {
    if (!weiboPosts || weiboPosts.length === 0) {
        allPosts = [];
        return;
    }

    const sortedPosts = weiboPosts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    allPosts = [];
    
    sortedPosts.forEach(storedPost => {
        if (storedPost.data?.posts) {
            storedPost.data.posts.forEach((post, postIndex) => {
                allPosts.push({
                    storedPost,
                    post,
                    postIndex,
                    height: ESTIMATED_POST_HEIGHT,
                    rendered: false
                });
            });
        }
    });
}

// 计算虚拟滚动的渲染范围
function calculateRenderRange(scrollTop) {
    const containerHeight = document.getElementById('weiboContainer').clientHeight;
    
    // 使用实际高度计算可见区域
    let currentHeight = 0;
    let visibleStartIndex = 0;
    let visibleEndIndex = allPosts.length;
    
    // 找到可见区域开始的索引
    for (let i = 0; i < allPosts.length; i++) {
        const postHeight = allPosts[i].height || ESTIMATED_POST_HEIGHT;
        if (currentHeight + postHeight > scrollTop) {
            visibleStartIndex = i;
            break;
        }
        currentHeight += postHeight;
    }
    
    // 找到可见区域结束的索引
    const viewportBottom = scrollTop + containerHeight;
    let heightFromStart = currentHeight; // 从可见开始位置的累积高度
    
    for (let i = visibleStartIndex; i < allPosts.length; i++) {
        const postHeight = allPosts[i].height || ESTIMATED_POST_HEIGHT;
        heightFromStart += postHeight;
        if (heightFromStart > viewportBottom) {
            visibleEndIndex = i + 1; // 包含当前项目
            break;
        }
    }
    
    // 上下各预留4条帖子，提供适中的缓冲区
    const startIndex = Math.max(0, visibleStartIndex - 4);
    const endIndex = Math.min(allPosts.length, visibleEndIndex + 4);
    
    // 确保至少渲染一些帖子
    if (endIndex <= startIndex) {
        return { 
            startIndex: Math.max(0, Math.min(visibleStartIndex, allPosts.length - VIRTUAL_WINDOW_SIZE)), 
            endIndex: Math.min(allPosts.length, Math.max(visibleStartIndex + VIRTUAL_WINDOW_SIZE, VIRTUAL_WINDOW_SIZE))
        };
    }
    
    return { startIndex, endIndex };
}

// 数据一致性检查和修复函数
async function checkAndRepairDataConsistency() {
    if (!window.isIndexedDBReady || !window.db) {
        return false;
    }
    
    try {
        // 从数据库重新加载所有帖子
        const transaction = window.db.transaction(['weiboPosts'], 'readonly');
        const store = transaction.objectStore('weiboPosts');
        const allDbPosts = await promisifyRequest(store.getAll());
        
        // 检查内存中的帖子是否与数据库一致
        const memoryPostIds = new Set(weiboPosts.map(p => p.id));
        const dbPostIds = new Set(allDbPosts.map(p => p.id));
        
        // 找出不一致的数据
        const missingInMemory = allDbPosts.filter(p => !memoryPostIds.has(p.id));
        const extraInMemory = weiboPosts.filter(p => !dbPostIds.has(p.id));
        
        if (missingInMemory.length > 0 || extraInMemory.length > 0) {
            console.warn(`数据不一致: 内存缺少 ${missingInMemory.length} 个帖子，内存多余 ${extraInMemory.length} 个帖子`);
            
            // 使用数据库数据作为准确来源
            weiboPosts = allDbPosts;
            console.log('已从数据库恢复数据一致性');
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('数据一致性检查失败:', error);
        return false;
    }
}

function renderAllWeiboPosts(isInitialLoad = true) {
    const container = document.getElementById('weiboContainer');
    
    if (!weiboPosts || weiboPosts.length === 0) {
        container.innerHTML = '<div class="loading-text">还没有任何帖子，点击右上角"+"来生成吧！</div>';
        allPosts = [];
        return;
    }

    // 扁平化帖子数据
    flattenPosts();
    
    // 如果帖子数量较少，直接渲染全部而不使用虚拟滚动
    if (allPosts.length <= 15) {
        renderAllPostsDirectly();
        return;
    }
    
    if (isInitialLoad) {
        currentStartIndex = 0;
        // 初始时渲染稍多一些内容，避免空白但不会太多
        const initialRenderCount = Math.min(allPosts.length, Math.max(VIRTUAL_WINDOW_SIZE, 12));
        currentEndIndex = initialRenderCount;
        renderVirtualPosts();
    }

    // 设置虚拟滚动监听器
    setupVirtualScrollListener();
}

// 直接渲染所有帖子（用于帖子数量较少的情况）
function renderAllPostsDirectly() {
    const container = document.getElementById('weiboContainer');
    container.innerHTML = '';
    
    // 清理虚拟滚动监听器
    const scrollContainer = document.getElementById('weiboContainer');
    if (scrollContainer) {
        scrollContainer.onscroll = null;
    }
    
    // 渲染所有帖子
    allPosts.forEach((postData, index) => {
        const postElement = renderSingleVirtualPost(postData, index);
        if (postElement) {
            container.appendChild(postElement);
        }
    });
}

// 虚拟滚动渲染函数
function renderVirtualPosts() {
    const container = document.getElementById('weiboContainer');
    
    // 创建虚拟容器，用于保持总高度
    container.innerHTML = '';
    
    // 计算顶部占位符高度（使用实际高度）
    let topSpacerHeight = 0;
    for (let i = 0; i < currentStartIndex; i++) {
        topSpacerHeight += allPosts[i] ? (allPosts[i].height || ESTIMATED_POST_HEIGHT) : ESTIMATED_POST_HEIGHT;
    }
    
    // 添加顶部占位符
    const topSpacer = document.createElement('div');
    topSpacer.style.height = `${topSpacerHeight}px`;
    topSpacer.className = 'virtual-spacer-top';
    container.appendChild(topSpacer);
    
    // 渲染当前窗口内的帖子
    const renderedPosts = [];
    for (let i = currentStartIndex; i < currentEndIndex; i++) {
        if (i >= allPosts.length) break;
        const postElement = renderSingleVirtualPost(allPosts[i], i);
        if (postElement) {
            renderedPosts.push(postElement);
            // 关键修复：将帖子元素添加到容器中！
            container.appendChild(postElement);
        }
    }
    
    // 计算底部占位符高度（使用实际高度）
    let bottomSpacerHeight = 0;
    for (let i = currentEndIndex; i < allPosts.length; i++) {
        bottomSpacerHeight += allPosts[i] ? (allPosts[i].height || ESTIMATED_POST_HEIGHT) : ESTIMATED_POST_HEIGHT;
    }
    
    // 添加底部占位符
    const bottomSpacer = document.createElement('div');
    bottomSpacer.style.height = `${Math.max(0, bottomSpacerHeight)}px`;
    bottomSpacer.className = 'virtual-spacer-bottom';
    container.appendChild(bottomSpacer);
    
    const containerWidth = container.offsetWidth;
    
    // 强制重排以修复布局问题
    container.offsetHeight; // 触发重排
    
    // 测量实际高度并更新估算值（延迟执行避免布局抖动）
    setTimeout(() => {
        updatePostHeights(renderedPosts);
    }, 50);
}

// 渲染单个虚拟帖子
function renderSingleVirtualPost(postData, index) {
    const container = document.getElementById('weiboContainer');
    const { storedPost, post, postIndex } = postData;
    
    const contact = contacts.find(c => c.id === storedPost.contactId);
    if (storedPost.contactId && !contact) return null;
    
    const postAuthorContact = post.author_type === 'User' ? userProfile : contact;
    const postAuthorNickname = post.author_type === 'User' ? userProfile.name : (contact ? contact.name : '未知用户');
    const postAuthorAvatar = postAuthorContact ? postAuthorContact.avatar : '';
    const otherPartyName = post.author_type === 'User' ? (contact ? contact.name : '') : userProfile.name;

    const postElement = document.createElement('div');
    postElement.className = 'post';
    // 使用与常规渲染一致的ID格式：weibo-post-{storedPostId}-{postIndex}
    const postHtmlId = `weibo-post-${storedPost.id}-${postIndex}`;
    postElement.id = postHtmlId;
    postElement.setAttribute('data-index', index);

    // 使用固定的随机数，避免每次渲染都重新生成
    const savedRandomRetweet = postData.randomRetweet || (postData.randomRetweet = Math.floor(Math.random() * 500));
    const savedRandomLike = postData.randomLike || (postData.randomLike = Math.floor(Math.random() * 5000));

    postElement.innerHTML = `
        <div class="post-header">
            <div class="avatar">
                ${postAuthorAvatar ? `<img src="${postAuthorAvatar}" alt="${postAuthorNickname[0]}">` : postAuthorNickname[0]}
            </div>
            <div class="post-info">
                <div class="user-name">
                    ${postAuthorNickname}
                    <span class="vip-badge">${post.author_type === 'User' ? '会员' : '蓝星'}</span>
                </div>
                <div class="post-time">${formatTime(post.timestamp)}</div>
                <div class="post-source">来自 ${storedPost.relations} 研究所</div>
            </div>
            <div class="post-menu" onclick="toggleWeiboMenu(event, '${storedPost.id}', ${postIndex})">
                ...
                <div class="post-menu-dropdown" id="weibo-menu-${storedPost.id}-${postIndex}">
                    <div class="menu-item" onclick="regeneratePostImage('${storedPost.id}', ${postIndex})">重新生成图片</div>
                    <div class="menu-item" onclick="removePostImage('${storedPost.id}', ${postIndex})">删除图片恢复文字</div>
                    <div class="menu-item" onclick="regeneratePostComments('${storedPost.id}', ${postIndex})">重新生成评论</div>
                    <div class="menu-item" onclick="deleteWeiboPost('${storedPost.id}', ${postIndex})">删除</div>
                </div>
            </div>
        </div>
        <div class="post-content">
            <a href="#" class="hashtag">#${storedPost.hashtag || storedPost.data.relation_tag}#</a>
            ${post.post_content}
            ${otherPartyName ? `<a href="#" class="mention">@${otherPartyName}</a>` : ''}
        </div>
        <div class="post-image-desc">
            ${post.image_description}
        </div>
        <div class="post-actions">
            <a href="#" class="action-btn-weibo">
                <span class="action-icon">🔄</span>
                <span>${savedRandomRetweet}</span>
            </a>
            <a href="#" class="action-btn-weibo" onclick="showReplyBox('${postHtmlId}').catch(console.error)">
                <span class="action-icon">💬</span>
                <span>${post.comments ? post.comments.length : 0}</span>
            </a>
            <a href="#" class="action-btn-weibo">
                <span class="action-icon">👍</span>
                <span>${savedRandomLike}</span>
            </a>
        </div>
        <div class="comments-section"></div>
    `;

    container.appendChild(postElement);
    
    // 调试：检查帖子宽度
    setTimeout(() => {
        const postWidth = postElement.offsetWidth;
        if (postWidth < 500) { // 如果宽度异常小
        }
    }, 10);
    
    // 渲染评论
    const commentsSection = postElement.querySelector('.comments-section');
    
    // 添加评论区点击事件（与常规渲染保持一致）
    commentsSection.onclick = () => showReplyBox(postHtmlId).catch(console.error);
    
    if (post.comments && post.comments.length > 0) {
        post.comments.forEach(comment => {
            const commenterType = comment.commenter_type ? ` (${comment.commenter_type})` : '';
            
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment';
            
            // 向后兼容（Helper function）
            // 新代码应使用统一字段：commenter_name, comment_content, timestamp
            commentDiv.innerHTML = `
                <span class="comment-user">${comment.commenter_name}${commenterType}:</span>
                <span class="comment-content">${comment.comment_content}</span>
                <span class="comment-time">${formatTime(comment.timestamp)}</span>
            `;

            commentDiv.addEventListener('click', (event) => {
                event.stopPropagation();
                replyToComment(comment.commenter_name || comment.author, postHtmlId).catch(console.error);
            });
            
            commentsSection.appendChild(commentDiv);
        });
    }
    
    return postElement;
}

// 测量并更新帖子的实际高度
function updatePostHeights(renderedPosts) {
    if (!renderedPosts || renderedPosts.length === 0) return;
    
    let totalMeasuredHeight = 0;
    let measuredCount = 0;
    
    renderedPosts.forEach(postElement => {
        if (postElement && postElement.offsetHeight > 0) {
            const index = parseInt(postElement.getAttribute('data-index'));
            const actualHeight = postElement.offsetHeight + 8; // 包括margin-bottom
            
            if (allPosts[index]) {
                allPosts[index].height = actualHeight;
                totalMeasuredHeight += actualHeight;
                measuredCount++;
            }
        }
    });
    
    // 更新全局估算高度
    if (measuredCount > 0) {
        const newEstimatedHeight = Math.round(totalMeasuredHeight / measuredCount);
        if (Math.abs(newEstimatedHeight - ESTIMATED_POST_HEIGHT) > 50) {
            // 只有当差异较大时才更新全局估算值
        }
    }
}

// 虚拟滚动监听器
function setupVirtualScrollListener() {
    // 修复：使用实际的滚动容器 weiboContainer 而不是 weiboPage
    const scrollContainer = document.getElementById('weiboContainer');
    if (!scrollContainer) {
        console.error('找不到滚动容器 weiboContainer');
        return;
    }

    // 移除旧的监听器
    scrollContainer.onscroll = null;
    
    
    let ticking = false;
    let lastScrollTime = 0;
    
    scrollContainer.onscroll = () => {
        const now = performance.now();
        if (now - lastScrollTime < 16) return; // 限制到60fps
        lastScrollTime = now;
        
        if (!ticking) {
            requestAnimationFrame(() => {
                handleVirtualScroll();
                ticking = false;
            });
            ticking = true;
        }
    };
}

function handleVirtualScroll() {
    const scrollContainer = document.getElementById('weiboContainer');
    const scrollTop = scrollContainer.scrollTop;
    
    
    // 计算新的渲染范围
    const { startIndex, endIndex } = calculateRenderRange(scrollTop);
    
    // 检查是否需要更新渲染范围（减少阈值以提供更好的响应）
    const threshold = 1; // 索引变化阈值
    const startIndexChanged = Math.abs(startIndex - currentStartIndex) >= threshold;
    const endIndexChanged = Math.abs(endIndex - currentEndIndex) >= threshold;
    
    if (startIndexChanged || endIndexChanged) {
        currentStartIndex = startIndex;
        currentEndIndex = endIndex;
        
        renderVirtualPosts();
    }
}

// 加载更多帖子数据的函数
async function loadMorePostData() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;
    
    // 这里可以实现加载更多帖子数据的逻辑
    // 目前只是简单的延时，实际应用中可以调用API获取更多帖子
    setTimeout(() => {
        isLoadingMorePosts = false;
    }, 1000);
}

function renderSingleWeiboPost(storedPost) {
    const container = document.getElementById('weiboContainer');
    const contact = contacts.find(c => c.id === storedPost.contactId);
    
    // 对于用户自己发的帖子，contactId为null，contact为undefined，这是正常的
    // 只有当contactId不为null但找不到对应联系人时才跳过渲染
    if (storedPost.contactId && !contact) return; // Don't render if contact should exist but is deleted

    const data = storedPost.data;

    if (!data || !data.posts || !Array.isArray(data.posts)) {
        return;
    }

    data.posts.forEach((post, index) => {
        const postAuthorContact = post.author_type === 'User' ? userProfile : contact;
        const postAuthorNickname = post.author_type === 'User' ? userProfile.name : (contact ? contact.name : '未知用户');
        const postAuthorAvatar = postAuthorContact ? postAuthorContact.avatar : '';
        // 修复otherPartyName逻辑，对于用户自己发的帖子，otherPartyName可以是空或者话题标签
        const otherPartyName = post.author_type === 'User' ? (contact ? contact.name : '') : userProfile.name;

        const postElement = document.createElement('div');
        postElement.className = 'post';
        const postHtmlId = `weibo-post-${storedPost.id}-${index}`;
        postElement.id = postHtmlId;

        // Set the main structure of the post
        postElement.innerHTML = `
            <div class="post-header">
                <div class="avatar">
                    ${postAuthorAvatar ? `<img src="${postAuthorAvatar}" alt="${postAuthorNickname[0]}">` : postAuthorNickname[0]}
                </div>
                <div class="post-info">
                    <div class="user-name">
                        ${postAuthorNickname}
                        <span class="vip-badge">${post.author_type === 'User' ? '会员' : '蓝星'}</span>
                    </div>
                    <div class="post-time">${formatTime(post.timestamp)}</div>
                    <div class="post-source">来自 ${storedPost.relations} 研究所</div>
                </div>
                <div class="post-menu" onclick="toggleWeiboMenu(event, '${storedPost.id}', ${index})">
                    ...
                    <div class="post-menu-dropdown" id="weibo-menu-${storedPost.id}-${index}">
                        <div class="menu-item" onclick="regeneratePostImage('${storedPost.id}', ${index})">重新生成图片</div>
                        <div class="menu-item" onclick="removePostImage('${storedPost.id}', ${index})">删除图片恢复文字</div>
                        <div class="menu-item" onclick="regeneratePostComments('${storedPost.id}', ${index})">重新生成评论</div>
                        <div class="menu-item" onclick="deleteWeiboPost('${storedPost.id}', ${index})">删除</div>
                    </div>
                </div>
            </div>
            <div class="post-content">
                <a href="#" class="hashtag">#${storedPost.hashtag || data.relation_tag}#</a>
                ${post.post_content}
                ${otherPartyName ? `<a href="#" class="mention">@${otherPartyName}</a>` : ''}
            </div>
            <div class="post-image-desc">
                ${post.image_description}
            </div>
            <div class="post-actions">
                <a href="#" class="action-btn-weibo">
                    <span class="action-icon">🔄</span>
                    <span>${Math.floor(Math.random() * 500)}</span>
                </a>
                <a href="#" class="action-btn-weibo" onclick="showReplyBox('${postHtmlId}').catch(console.error)">
                    <span class="action-icon">💬</span>
                    <span>${post.comments ? post.comments.length : 0}</span>
                </a>
                <a href="#" class="action-btn-weibo">
                    <span class="action-icon">👍</span>
                    <span>${Math.floor(Math.random() * 5000)}</span>
                </a>
            </div>
            <div class="comments-section"></div>
        `;

        // Programmatically create and append comments
        const commentsSection = postElement.querySelector('.comments-section');
        if (commentsSection) {
            commentsSection.onclick = () => showReplyBox(postHtmlId).catch(console.error);

            if (post.comments && Array.isArray(post.comments)) {
                post.comments.forEach(comment => {
                    const commenterType = comment.commenter_type ? ` (${comment.commenter_type})` : '';
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'comment';
                    
                    // 兼容性渲染：支持新旧字段名
                    // 新代码应使用统一字段：commenter_name, comment_content, timestamp
                    commentDiv.innerHTML = `
                        <span class="comment-user">${comment.commenter_name || comment.author}${commenterType}:</span>
                        <span class="comment-content">${comment.comment_content || comment.content}</span>
                        <span class="comment-time">${formatTime(comment.timestamp || comment.time)}</span>
                    `;

                    commentDiv.addEventListener('click', (event) => {
                        event.stopPropagation();
                        replyToComment(comment.commenter_name || comment.author, postHtmlId).catch(console.error);
                    });

                    commentsSection.appendChild(commentDiv);
                });
            }
        }
        
        container.appendChild(postElement);
    });
}

async function replyToComment(commenterName, postHtmlId) {
    // First, ensure the reply box is visible for the post.
    await showReplyBox(postHtmlId);

    // Now, find the reply box and its textarea.
    const postElement = document.getElementById(postHtmlId);
    if (!postElement) return;

    const replyInput = postElement.querySelector('.reply-input');
    if (!replyInput) return;

    // Pre-fill the textarea with the @-mention.
    const currentText = replyInput.value;
    const mention = `@${commenterName} `;
    
    // Avoid adding duplicate mentions if the user clicks multiple times.
    if (!currentText.includes(mention)) {
        replyInput.value = mention + currentText;
    }
    
    // Focus the input and place the cursor at the end.
    replyInput.focus();
    replyInput.setSelectionRange(replyInput.value.length, replyInput.value.length);
}

async function showReplyBox(postHtmlId) {
    const postElement = document.getElementById(postHtmlId);
    if (!postElement) {
        console.warn(`找不到帖子元素: ${postHtmlId}`);
        return;
    }
    
    // 在显示回复框前检查数据一致性
    const storedPostId = parseInt(postHtmlId.split('-')[2], 10);
    const storedPost = weiboPosts.find(p => p.id === storedPostId);
    if (!storedPost) {
        console.warn(`数据不一致，帖子ID ${storedPostId} 不存在，尝试修复...`);
        const repaired = await checkAndRepairDataConsistency();
        if (repaired) {
            // 数据修复后重新渲染页面
            renderAllWeiboPosts();
            showToast('数据已同步，请重新点击回复');
            return;
        }
    }

    let replyBox = postElement.querySelector('.reply-box');
    if (replyBox) {
        replyBox.querySelector('textarea').focus();
        return;
    }

    const commentsSection = postElement.querySelector('.comments-section');
    
    replyBox = document.createElement('div');
    replyBox.className = 'reply-box';
    replyBox.innerHTML = `
        <textarea class="reply-input" placeholder="输入你的回复..."></textarea>
        <button class="reply-button">回复</button>
    `;
    
    commentsSection.appendChild(replyBox);
    const replyInput = replyBox.querySelector('.reply-input');
    const replyButton = replyBox.querySelector('.reply-button');

    replyInput.focus();
    
    // 确保回复框不被底部导航栏遮挡
    setTimeout(() => {
        replyBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }, 100);

    replyButton.onclick = async () => {
        const replyContent = replyInput.value.trim();
        if (!replyContent) {
            showToast('回复内容不能为空');
            return;
        }

        // --- Find the target post ---
        const storedPostId = parseInt(postHtmlId.split('-')[2], 10);
        const postIndex = parseInt(postHtmlId.split('-')[3], 10);
        let storedPost = weiboPosts.find(p => p.id === storedPostId);
        
        // 容错机制：如果找不到帖子，尝试从数据库重新加载
        if (!storedPost) {
            console.warn(`找不到帖子ID ${storedPostId}，尝试从数据库重新加载...`);
            
            // 首先尝试按不同类型查找
            let foundByString = weiboPosts.find(p => p.id.toString() === storedPostId.toString());
            if (foundByString) {
                storedPost = foundByString;
            } else {
                // 尝试从数据库重新加载
                try {
                    if (window.isIndexedDBReady && window.db) {
                        const transaction = window.db.transaction(['weiboPosts'], 'readonly');
                        const store = transaction.objectStore('weiboPosts');
                        
                        // 尝试数字ID和字符串ID
                        let dbPost = await promisifyRequest(store.get(storedPostId));
                        if (!dbPost) {
                            dbPost = await promisifyRequest(store.get(storedPostId.toString()));
                        }
                        
                        if (dbPost) {
                            // 将从数据库找到的帖子重新添加到内存数组
                            weiboPosts.push(dbPost);
                            storedPost = dbPost;
                            console.log(`成功从数据库恢复帖子ID ${storedPostId}`);
                        } else {
                            // 数据库中也没有，检查是否是异常ID（如0、1等）
                            if (storedPostId < 1000000000000) {
                                showToast('检测到数据异常，正在重新同步...');
                                const repaired = await checkAndRepairDataConsistency();
                                if (repaired) {
                                    renderAllWeiboPosts();
                                    return;
                                }
                            }
                            
                            // 数据库中也没有，可能帖子已被删除，刷新页面
                            showToast('帖子可能已被删除，正在刷新页面...');
                            renderAllWeiboPosts();
                            return;
                        }
                    } else {
                        showToast('数据库未就绪，请刷新页面重试');
                        return;
                    }
                } catch (error) {
                    console.error('从数据库恢复帖子失败:', error);
                    showToast('数据加载失败，请刷新页面重试');
                    return;
                }
            }
        }
        
        // 检查帖子索引是否有效
        if (!storedPost.data?.posts || !storedPost.data.posts[postIndex]) {
            console.error(`帖子索引无效: storedPostId=${storedPostId}, postIndex=${postIndex}`);
            showToast('帖子数据异常，正在刷新页面...');
            renderAllWeiboPosts();
            return;
        }
        
        const postData = storedPost.data.posts[postIndex];

        // --- Create User Comment ---
        const userComment = {
            commenter_name: userProfile.name,
            commenter_type: 'User',
            comment_content: replyContent,
            timestamp: new Date().toISOString()
        };

        // --- Disable UI ---
        replyInput.disabled = true;
        replyButton.disabled = true;
        replyButton.textContent = '请稍后...';

        // --- Add user's comment to the list immediately for better UX ---
        if (!postData.comments) {
            postData.comments = [];
        }
        postData.comments.push(userComment);
        renderAllWeiboPosts(); // Re-render to show the user's comment
        await showReplyBox(postHtmlId); // Keep the reply box open

        // 检查并更新全局记忆（用户回复内容）
        if (window.characterMemoryManager) {
            const forumContent = `用户回复论坛：\n原帖：${postData.post_content}\n用户回复：${replyContent}`;
            window.characterMemoryManager.checkAndUpdateGlobalMemory(forumContent);
        }

        try {
            const mentionRegex = /@(\S+)/;
            const match = replyContent.match(mentionRegex);
            let mentionedContact = null;

            if (match) {
                const mentionedName = match[1].trim();
                mentionedContact = contacts.find(c => c.name === mentionedName && c.type === 'private');
            }

            if (match) {
                const mentionedName = match[1].trim();
                const mentionedPersonContact = mentionedContact || {
                    name: mentionedName,
                    personality: `一个被@的网友，名字叫${mentionedName}`
                };
                
                const aiReplyContent = await getMentionedAIReply(postData, userComment, mentionedPersonContact);
                const aiComment = {
                    commenter_name: mentionedName,
                    commenter_type: 'Mentioned',
                    comment_content: aiReplyContent,
                    timestamp: new Date().toISOString()
                };
                postData.comments.push(aiComment);
                await updateWeiboPost(storedPost);
                showToast('AI已回复！');
                renderAllWeiboPosts();
                return;
            }

            if (postData.author_type !== 'User') {
                const postAuthorContact = contacts.find(c => c.id === storedPost.contactId);
                if (!postAuthorContact) throw new Error('Post author not found');
                
                const aiReplyContent = await getAIReply(postData, replyContent, storedPost.contactId);
                const aiComment = {
                    commenter_name: postAuthorContact.name,
                    commenter_type: '楼主',
                    comment_content: aiReplyContent,
                    timestamp: new Date().toISOString()
                };
                postData.comments.push(aiComment);
                await updateWeiboPost(storedPost);
                showToast('AI已回复！');
                renderAllWeiboPosts();
                return;
            }

            await updateWeiboPost(storedPost);
            showToast('已回复');
            renderAllWeiboPosts();

        } catch (error) {
            showApiError(error);
            console.error('AI回复生成失败:', error);
            // On failure, remove the user's comment that was added optimistically
            postData.comments.pop();
            renderAllWeiboPosts();
        }
    };
}

async function getMentionedAIReply(postData, mentioningComment, mentionedContact) {
    const apiCallInfo = await getApiCallInfo();
    if (!apiCallInfo.url || !apiCallInfo.key || !apiCallInfo.model) {
        throw new Error('API或模型未配置');
    }

    const systemPrompt = window.promptBuilder.buildMentionReplyPrompt(postData, mentioningComment, mentionedContact, contacts, userProfile);
    
    const data = await window.apiService.callOpenAIAPI(
        apiCallInfo.url,
        apiCallInfo.key,
        apiCallInfo.model,
        [{ role: 'user', content: systemPrompt }],
        { temperature: 0.75 }, // Slightly higher temp for more creative/natural replies
        (apiCallInfo.timeout || 60) * 1000
    );

    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
        console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
        throw new Error('AI未返回有效回复');
    }
    
    return data.choices[0].message.content;
}

async function getAIReply(postData, userReply, contactId) {
    const apiCallInfo = await getApiCallInfo();
    if (!apiCallInfo.url || !apiCallInfo.key || !apiCallInfo.model) {
        throw new Error('API或模型未配置');
    }

    const systemPrompt = window.promptBuilder.buildReplyPrompt(postData, userReply, contactId, contacts, userProfile);
    const data = await window.apiService.callOpenAIAPI(
        apiCallInfo.url,
        apiCallInfo.key,
        apiCallInfo.model,
        [{ role: 'user', content: systemPrompt }],
        { temperature: 0.7 },
        (apiCallInfo.timeout || 60) * 1000
    );

    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
        console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
        throw new Error('AI未返回有效回复');
    }
    
    return data.choices[0].message.content;
}




function toggleWeiboMenu(event, storedPostId, postIndex) {
    event.stopPropagation();
    const menu = document.getElementById(`weibo-menu-${storedPostId}-${postIndex}`);
    
    // Close all other menus
    document.querySelectorAll('.post-menu-dropdown').forEach(m => {
        if (m.id !== menu.id) {
            m.style.display = 'none';
        }
    });

    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

// Close dropdown when clicking anywhere else
window.addEventListener('click', (event) => {
    if (!event.target.matches('.post-menu')) {
        document.querySelectorAll('.post-menu-dropdown').forEach(m => {
            m.style.display = 'none';
        });
    }
});


// 重新生成帖子图片
async function regeneratePostImage(storedPostId, postIndex) {
    const numericStoredPostId = parseInt(storedPostId, 10);
    const storedPost = weiboPosts.find(p => p.id === numericStoredPostId);
    
    if (!storedPost || !storedPost.data.posts[postIndex]) {
        showToast('找不到指定的帖子');
        return;
    }
    
    const post = storedPost.data.posts[postIndex];
    
    // 检查是否有原始图片描述
    const imageDescription = post.original_image_description || post.image_description;
    
    if (!imageDescription || imageDescription.trim() === '暂无图片描述') {
        showToast('该帖子没有图片描述，无法生成图片');
        return;
    }
    
    const unsplashKey = localStorage.getItem('forumUnsplashApiKey');
    if (!unsplashKey) {
        showToast('请先在设置中配置Unsplash API Key');
        return;
    }
    
    try {
        showToast('正在重新生成图片...');
        
        const imageUrl = await fetchMatchingImageForPublish(imageDescription, unsplashKey);
        if (imageUrl) {
            // 更新帖子数据
            post.actual_image_url = imageUrl;
            post.original_image_description = imageDescription;
            post.image_description = `<img src="${imageUrl}" alt="${imageDescription}" style="width: 100%; max-width: 300px; border-radius: 8px;">`;
            
            // 更新数据库
            await updateWeiboPostInDB(storedPost);
            
            // 重新渲染
            renderAllWeiboPosts();
            
            showToast('图片已重新生成！');
        } else {
            showToast('图片生成失败，请稍后重试');
        }
    } catch (error) {
        console.error('重新生成图片失败:', error);
        showToast('图片生成失败: ' + error.message);
    }
}


// 删除帖子图片恢复文字显示
async function removePostImage(storedPostId, postIndex) {
    const numericStoredPostId = parseInt(storedPostId, 10);
    const storedPost = weiboPosts.find(p => p.id === numericStoredPostId);
    
    if (!storedPost || !storedPost.data.posts[postIndex]) {
        showToast('找不到指定的帖子');
        return;
    }
    
    const post = storedPost.data.posts[postIndex];
    
    // 检查是否有图片可以删除
    if (!post.actual_image_url && !post.image_description.includes('<img')) {
        showToast('该帖子没有Unsplash图片，无需删除');
        return;
    }
    
    try {
        // 恢复原始文字描述
        if (post.original_image_description) {
            post.image_description = post.original_image_description;
        } else {
            // 如果没有原始描述，从img标签中提取alt文本
            const imgMatch = post.image_description.match(/alt="([^"]*)"/);
            if (imgMatch) {
                post.image_description = imgMatch[1];
            } else {
                post.image_description = '图片描述';
            }
        }
        
        // 清除图片相关字段
        delete post.actual_image_url;
        delete post.original_image_description;
        
        // 更新数据库
        await updateWeiboPostInDB(storedPost);
        
        // 重新渲染
        renderAllWeiboPosts();
        
        showToast('已删除图片，恢复文字显示');
    } catch (error) {
        console.error('删除帖子图片失败:', error);
        showToast('删除图片失败: ' + error.message);
    }
}

// 重新生成帖子评论
async function regeneratePostComments(storedPostId, postIndex) {
    const numericStoredPostId = parseInt(storedPostId, 10);
    const storedPost = weiboPosts.find(p => p.id === numericStoredPostId);
    
    if (!storedPost || !storedPost.data.posts[postIndex]) {
        showToast('找不到指定的帖子');
        return;
    }
    
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('请先配置API和模型设置');
        return;
    }
    
    const post = storedPost.data.posts[postIndex];
    
    try {
        showToast('正在重新生成评论...');
        
        // 构建重新生成评论的提示词
        const newComments = await generateAICommentsWithCurrentTime(post.post_content);
        
        // 更新帖子评论
        post.comments = newComments;
        
        // 更新数据库
        await updateWeiboPostInDB(storedPost);
        
        // 重新渲染
        renderAllWeiboPosts();
        
        showToast('评论已重新生成！');
    } catch (error) {
        console.error('重新生成评论失败:', error);
        showApiError(error);
    }
}

async function deleteWeiboPost(storedPostId, postIndex) {
    // Convert storedPostId to the correct type if necessary, assuming it's a number from the template
    const numericStoredPostId = parseInt(storedPostId, 10);

    // Find the specific post group in the in-memory weiboPosts array
    const postGroupIndex = weiboPosts.findIndex(p => p.id === numericStoredPostId);
    
    if (postGroupIndex > -1) {
        // The specific post to be deleted
        const postGroup = weiboPosts[postGroupIndex];
        
        // Remove the specific post from the 'posts' array within the group
        if (postGroup.data && postGroup.data.posts && postGroup.data.posts.length > postIndex) {
            postGroup.data.posts.splice(postIndex, 1);
        }

        // If this was the last post in the group, remove the entire group
        if (postGroup.data.posts.length === 0) {
            weiboPosts.splice(postGroupIndex, 1);
            // Also delete the entire entry from IndexedDB
            if (window.isIndexedDBReady) {
                try {
                    const transaction = window.db.transaction(['weiboPosts'], 'readwrite');
                    const store = transaction.objectStore('weiboPosts');
                    await promisifyRequest(store.delete(numericStoredPostId));
                    await promisifyTransaction(transaction);
                } catch (error) {
                    console.error('Failed to delete Weibo post group from DB:', error);
                    showToast('从数据库删除帖子失败');
                    // Optional: Add back the data to memory to maintain consistency
                    return;
                }
            }
        } else {
            // Otherwise, just update the modified group in IndexedDB
            await updateWeiboPost(postGroup);
        }
    }

    // Re-render the UI
    renderAllWeiboPosts();
    showToast('帖子已删除');
}

async function updateWeiboPost(postToUpdate) {
    if (!window.isIndexedDBReady) {
        console.error('IndexedDB not ready, cannot update post.');
        showToast('数据库错误，无法更新帖子');
        return;
    }
    try {
        const transaction = window.db.transaction(['weiboPosts'], 'readwrite');
        const store = transaction.objectStore('weiboPosts');
        await promisifyRequest(store.put(postToUpdate));
        await promisifyTransaction(transaction);
    } catch (error) {
        console.error('Failed to update Weibo post in DB:', error);
        showToast('更新帖子失败');
    }
}

// 别名函数，用于保持一致性
async function updateWeiboPostInDB(postToUpdate) {
    return await updateWeiboPost(postToUpdate);
}

// --- 朋友圈功能 ---

// 存储上传的图片数据
let momentUploadedImages = [];

// 朋友圈发布方式选择
function showPublishMomentModal() {
    // 检查朋友圈操作是否被锁定
    if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
        return;
    }
    
    // 显示朋友圈发布方式选择模态框
    showModal('momentChoiceModal');
}

function selectMomentType(type) {
    closeModal('momentChoiceModal');
    
    if (type === 'manual') {
        showManualMomentModal();
    } else if (type === 'generate') {
        showGenerateMomentModal();
    }
}

async function showManualMomentModal() {
    showModal('manualMomentModal');
    
    // 获取用户信息
    const userProfile = await getUserProfile();
    
    // 设置发布人为当前用户
    document.getElementById('manualMomentAuthor').value = userProfile.name || '我';
    
    // 清空之前的内容、位置和图片
    document.getElementById('manualMomentContent').value = '';
    document.getElementById('manualMomentLocation').value = '';
    momentUploadedImages = [];
    document.getElementById('momentImagesPreview').innerHTML = '';
}

function showGenerateMomentModal() {
    // [DEBUG-MOMENTS-ROLES-START] 调试信息，修复完成后删除
    console.log('[DEBUG] showGenerateMomentModal 被调用');
    console.log('[DEBUG] 打开生成朋友圈模态框时的全局状态:', {
        windowContacts: !!window.contacts,
        contactsLength: window.contacts ? window.contacts.length : 0,
        isIndexedDBReady: !!window.isIndexedDBReady,
        dbConnected: !!window.db,
        dbVersion: window.db ? window.db.version : 'no-db',
        timestamp: new Date().toISOString()
    });
    
    if (window.contacts && window.contacts.length > 0) {
        const privateContacts = window.contacts.filter(c => c.type === 'private');
        console.log('[DEBUG] 私聊角色详情:', {
            totalContacts: window.contacts.length,
            privateContactsCount: privateContacts.length,
            privateContactsNames: privateContacts.map(c => ({ name: c.name, id: c.id, type: c.type }))
        });
    }
    // [DEBUG-MOMENTS-ROLES-END]
    
    showModal('generateMomentModal');
    
    // 清空表单
    document.getElementById('momentGenTopic').value = '';
    // momentUnsplashKey元素已从HTML中移除，移除相关代码避免null指针异常
    
    // 加载角色列表
    loadMomentCharacterOptions();
}

// 加载角色选项 - 增强版本，处理数据未就绪情况
async function loadMomentCharacterOptions() {
    const select = document.getElementById('momentGenCharacterSelect');
    select.innerHTML = '<option value="">加载中...</option>';
    
    // [DEBUG-MOMENTS-ROLES-START] 调试信息，修复完成后删除
    console.log('[DEBUG] loadMomentCharacterOptions 开始执行');
    console.log('[DEBUG] 当前状态:', {
        windowContacts: !!window.contacts,
        contactsLength: window.contacts ? window.contacts.length : 0,
        isIndexedDBReady: !!window.isIndexedDBReady,
        dbConnected: !!window.db,
        dbReadyState: window.db ? window.db.readyState : 'no-db'
    });
    // [DEBUG-MOMENTS-ROLES-END]
    
    try {
        // 确保数据已经加载完成 - 最多等待10秒
        let attempts = 0;
        const maxAttempts = 20; // 10秒 (20 * 500ms)
        
        while ((!window.contacts || window.contacts.length === 0) && attempts < maxAttempts) {
            console.log(`[DEBUG] 角色数据未准备好，等待加载... (尝试 ${attempts + 1}/${maxAttempts})`);
            
            // 如果数据库还没就绪，等待数据库初始化
            if (!window.isIndexedDBReady || !window.db) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                continue;
            }
            
            // 如果数据库就绪但contacts为空，尝试主动加载
            if ((!window.contacts || window.contacts.length === 0) && attempts === 5) {
                console.log('[DEBUG] 主动触发数据重新加载');
                try {
                    await loadDataFromDB();
                } catch (loadError) {
                    console.error('[DEBUG] 主动加载数据失败:', loadError);
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            attempts++;
        }
        
        // 更新选择框
        select.innerHTML = '<option value="">请选择...</option>';
        
        // [DEBUG-MOMENTS-ROLES-START] 调试信息，修复完成后删除
        console.log('[DEBUG] 等待完成后的状态:', {
            windowContacts: !!window.contacts,
            contactsLength: window.contacts ? window.contacts.length : 0,
            attempts: attempts,
            timedOut: attempts >= maxAttempts
        });
        // [DEBUG-MOMENTS-ROLES-END]
        
        // 只添加联系人选项（AI角色），不包括"我"
        if (window.contacts && window.contacts.length > 0) {
            let addedCount = 0;
            window.contacts.forEach(contact => {
                if (contact.type === 'private') { // 只显示私聊角色
                    const option = document.createElement('option');
                    option.value = contact.id;
                    option.textContent = contact.name;
                    select.appendChild(option);
                    addedCount++;
                    
                    // [DEBUG-MOMENTS-ROLES-START] 调试信息，修复完成后删除
                    console.log(`[DEBUG] 添加角色: ${contact.name} (ID: ${contact.id})`);
                    // [DEBUG-MOMENTS-ROLES-END]
                }
            });
            
            // [DEBUG-MOMENTS-ROLES-START] 调试信息，修复完成后删除
            console.log(`[DEBUG] 成功添加 ${addedCount} 个角色到选择列表`);
            // [DEBUG-MOMENTS-ROLES-END]
            
            if (addedCount === 0) {
                select.innerHTML = '<option value="">未找到AI角色，请先添加角色</option>';
                console.warn('[DEBUG] 没有找到任何私聊类型的角色');
            }
        } else {
            select.innerHTML = '<option value="">未找到AI角色，请先添加角色</option>';
            console.warn('[DEBUG] window.contacts 为空或不存在');
        }
        
    } catch (error) {
        console.error('[DEBUG] 加载角色选项失败:', error);
        select.innerHTML = '<option value="">加载失败，请重试</option>';
        
        // 如果是严重错误，尝试显示用户友好的错误信息
        if (typeof showToast === 'function') {
            showToast('角色列表加载失败，请刷新页面重试', 'error');
        }
    }
}

// 处理生成朋友圈表单提交
async function handleGenerateMoment(event) {
    event.preventDefault();
    
    const contactId = document.getElementById('momentGenCharacterSelect').value;
    const topic = document.getElementById('momentGenTopic').value.trim();
    const location = document.getElementById('momentGenLocation').value.trim();
    // momentUnsplashKey元素已从HTML中移除，从localStorage直接获取
    const unsplashKey = localStorage.getItem('unsplashApiKey') || '';
    
    if (!contactId) {
        showToast('请选择角色');
        return;
    }

    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('请先设置API和模型');
        return;
    }
    
    // Unsplash API Key已从localStorage获取，无需重复保存
    
    try {
        // 找到角色信息
        const character = window.contacts?.find(c => c.id === contactId);
        if (!character) {
            showToast('未找到选中的角色');
            return;
        }
        
        showToast('正在生成朋友圈内容和评论...');
        
        // 获取用户信息
        const userProfile = await getUserProfile();
        
        // 一次性生成朋友圈内容、图片关键词和评论，传入位置信息
        const momentData = await generateMomentAndComments(character, userProfile, topic, location);
        
        let imageUrl = null;
        
        // 如果提供了Unsplash API Key 且 AI返回了关键词，尝试获取配图
        if (unsplashKey && momentData.imageKeyword) {
            showToast('正在获取配图...');
            try {
                // 使用AI返回的关键词进行搜索
                imageUrl = await getUnsplashImage(momentData.imageKeyword, unsplashKey);
            } catch (imageError) {
                console.warn('获取Unsplash图片失败:', imageError);
                // 即使图片获取失败也继续发布朋友圈
            }
        }
        
        // 创建朋友圈对象
        const moment = {
            id: Date.now().toString(),
            authorName: character.name,
            authorAvatar: character.avatar,
            content: momentData.content,
            location: momentData.location || location, // 优先使用AI生成的位置，如果没有则使用用户输入的位置
            image: imageUrl, // Unsplash图片URL
            imageCount: imageUrl ? 1 : 0,
            isUnsplashImage: imageUrl ? true : false, // 标记为Unsplash图片
            time: new Date().toISOString(),
            likes: 0,
            comments: momentData.comments
        };
        
        // 保存朋友圈
        moments.unshift(moment);
        await saveDataToDB();
        await renderMomentsList();
        
        closeModal('generateMomentModal');
        showToast('朋友圈发布成功！');
        
    } catch (error) {
        console.error('生成朋友圈失败:', error);
        showApiError(error);
    }
}

// 获取Unsplash图片
async function getUnsplashImage(searchQuery, apiKey) {
    // 现在此函数直接调用新的 fetchMatchingImageForPublish
    return await fetchMatchingImageForPublish(searchQuery, apiKey);
}

// 一次性生成朋友圈内容和评论
async function generateMomentAndComments(character, userProfile, topic = '', location = '') {
    try {
        
        // 检查必要的依赖
        if (!window.promptBuilder) {
            throw new Error('PromptBuilder未初始化');
        }
        
        if (!window.apiService) {
            throw new Error('APIService未初始化');
        }
        
        // 使用新的全局API调用信息接口获取完整连接和模型信息
        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            throw new Error('API设置未完成');
        }

        // 使用PromptBuilder构建prompt（传入 apiCallInfo 以包含模型信息）
        const systemPrompt = await window.promptBuilder.buildMomentAndCommentsPrompt(
            character,
            userProfile,
            apiCallInfo,
            window.contacts,
            topic,
            location
        );

        // 使用云端API服务 (使用 apiCallInfo 中的连接/模型信息)
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            {
                temperature: 0.9,
                max_tokens: 10000,
                response_format: { type: "json_object" },
            },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        
        const rawContent = data.choices[0]?.message?.content;
        console.log('API返回的原始内容:', rawContent);
        
        if (!rawContent) {
            console.error('ERROR: API返回空内容 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error('API返回空内容');
        }
        
        // 使用统一的JSON提取函数清理markdown语法
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawContent);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawContent);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }
        
        // 解析JSON结果
        let momentData;
        try {
            momentData = JSON.parse(cleanedJson);
        } catch (parseError) {
            console.error('ERROR: 解析JSON失败 - API完整返回:', rawContent);
            console.error('ERROR: 解析JSON失败 - 错误详情:', parseError);
            throw new Error('AI返回的数据格式不正确，无法解析为JSON。');
        }
        
        // 确保返回格式正确
        if (!momentData.content) {
            throw new Error('生成的朋友圈内容为空');
        }
        
        if (!Array.isArray(momentData.comments)) {
            momentData.comments = [];
        }

        // 获取图片关键词，可能为 null
        const imageKeyword = momentData.imageKeyword || null;
        
        // 使用统一helper函数转换评论格式
        const formattedComments = momentData.comments.map(formatCommentForDataModel);
        
        const result = {
            content: momentData.content,
            imageKeyword: imageKeyword, // 添加新的字段
            comments: formattedComments
        };
        
        return result;
        
    } catch (error) {
        console.error('生成朋友圈和评论失败:', error);
        throw error; // 直接抛出错误，不返回默认内容
    }
}

// === 图片AI识别相关功能 ===

// 分析上传的图片内容
async function analyzeImageContent(imageBase64, prompt = '请描述这张图片的内容') {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        throw new Error('请先设置API和模型');
    }

    try {
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: prompt
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: imageBase64
                        }
                    }
                ]
            }],
            { max_tokens: 5000, temperature: 0.7 },
            (apiCallInfo.timeout || 60) * 1000
        );

        return data.choices[0]?.message?.content || '无法识别图片内容';

    } catch (error) {
        console.error('图片分析失败:', error);
        return '图片分析功能暂时不可用';
    }
}

// 根据图片内容生成朋友圈文案
async function generateMomentTextFromImage(imageBase64, character) {
    const analysisPrompt = `你是${character.name}，性格特点：${character.personality}。
请看这张图片，然后以${character.name}的身份发布一条朋友圈动态。

要求：
1. 基于图片内容来写朋友圈
2. 符合${character.name}的性格特点和说话风格
3. 内容要自然真实，就像真的朋友圈一样
4. 长度控制在30-100字之间
5. 可以适当使用emoji表情
6. 不要说"这张图片"之类的话，要像是自己拍的照片一样

直接返回朋友圈内容，不要有其他说明文字。`;

    return await analyzeImageContent(imageBase64, analysisPrompt);
}

// 检查图片内容是否合适
async function checkImageContent(imageBase64) {
    const checkPrompt = `请检查这张图片是否包含以下不当内容：
1. 暴力血腥内容
2. 色情内容  
3. 政治敏感内容
4. 其他不适合在社交媒体分享的内容

如果图片内容合适，请回复"合适"；如果不合适，请简短说明原因。`;

    const result = await analyzeImageContent(imageBase64, checkPrompt);
    return {
        isAppropriate: result.includes('合适'),
        reason: result.includes('合适') ? '' : result
    };
}

// 为特定角色生成朋友圈内容
async function generateMomentForCharacter(character, topic = '') {
    const topicPrompt = topic ? `围绕"${topic}"这个主题，` : '';
    
    const prompt = `你是${character.name}，性格特点：${character.personality}。
请${topicPrompt}发布一条符合你性格的朋友圈动态。

要求：
1. 内容要符合${character.name}的性格特点
2. 语言风格要自然，就像真的朋友圈一样
3. 长度控制在50-150字之间
4. 可以包含生活感悟、日常分享、心情表达等
5. 不要使用过于正式的语言
6. 可以适当使用emoji表情

直接返回朋友圈内容，不要有其他说明文字。`;

    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        throw new Error('请先设置API和模型');
    }

    const data = await window.apiService.callOpenAIAPI(
        apiCallInfo.url,
        apiCallInfo.key,
        apiCallInfo.model,
        [{ role: 'user', content: prompt }],
        { max_tokens: 5000, temperature: 0.8 },
        (apiCallInfo.timeout || 60) * 1000
    );

    return data.choices[0]?.message?.content || '今天心情不错~';
}

// 处理图片上传
async function handleMomentImagesUpload(event) {
    const files = Array.from(event.target.files);
    if (files.length + momentUploadedImages.length > 9) {
        showToast('最多只能上传9张图片');
        return;
    }
    
    for (const file of files) {
        if (file.type.startsWith('image/')) {
            try {
                // 直接存储File对象，用于后续保存到文件系统
                momentUploadedImages.push({
                    file: file,
                    previewUrl: await fileToBase64(file) // 用于预览
                });
            } catch (error) {
                console.error('图片上传失败:', error);
                showToast(`图片上传失败: ${error.message || '未知错误'}`, 'error');
            }
        }
    }
    
    renderMomentImagesPreview();
    event.target.value = ''; // 清空input
}

// 渲染图片预览
function renderMomentImagesPreview() {
    const preview = document.getElementById('momentImagesPreview');
    preview.innerHTML = '';
    
    momentUploadedImages.forEach((imageItem, index) => {
        const item = document.createElement('div');
        item.className = 'moment-image-item';
        item.innerHTML = `
            <img src="${imageItem.previewUrl}" alt="预览图">
            <div class="moment-image-remove" onclick="removeMomentUploadImage(${index})">×</div>
        `;
        preview.appendChild(item);
    });
}

// 删除图片
function removeMomentUploadImage(index) {
    momentUploadedImages.splice(index, 1);
    renderMomentImagesPreview();
}

// 文件转Base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// 手动发布朋友圈
async function handleManualMoment(event) {
    event.preventDefault();
    
    const authorName = document.getElementById('manualMomentAuthor').value;
    const content = document.getElementById('manualMomentContent').value.trim();
    const location = document.getElementById('manualMomentLocation').value.trim();
    
    if (!content) {
        showToast('请填写朋友圈内容');
        return;
    }
    
    closeModal('manualMomentModal');
    
    // 发布手动朋友圈
    await publishManualMoment(authorName, content, momentUploadedImages, location);
}

async function publishManualMoment(authorName, content, imageItems, location = '') {
    // 使用当前时间作为发布时间，就像论坛一样
    const momentCreatedAt = new Date();
    const momentId = Date.now().toString();
    
    try {
        // 存储图片到文件系统
        let imageFileIds = [];
        let imageCount = 0;
        
        if (imageItems && imageItems.length > 0) {
            showToast('正在保存图片...');
            
            // 确保ImageStorageAPI已初始化
            if (window.ImageStorageAPI) {
                await window.ImageStorageAPI.init();
                
                // 提取File对象
                const imageFiles = imageItems.map(item => item.file);
                
                // 存储多张图片
                imageFileIds = await window.ImageStorageAPI.storeMomentImages(imageFiles, momentId);
                imageCount = imageFiles.length;
                
            } else {
                console.warn('ImageStorageAPI未初始化，跳过图片存储');
            }
        }
        
        // 创建朋友圈对象
        const moment = {
            id: momentId,
            authorName: authorName,
            authorAvatar: userProfile.avatar || '',
            content: content,
            location: location, // 添加位置字段
            imageFileIds: imageFileIds, // 存储fileId数组
            imageCount: imageCount, // 存储图片数量，用于后续获取
            time: momentCreatedAt.toISOString(),
            likes: 0,
            comments: [] // 先创建空评论
        };

        // 保存并立即显示朋友圈
        moments.unshift(moment);
        await saveDataToDB();
        await renderMomentsList();
        showToast('朋友圈发布成功，正在生成评论...');

        // 异步生成评论
        setTimeout(async () => {
            try {
                // 为用户上传的图片生成评论时，需要考虑vision支持
                let commentsWithTime;
                if (imageItems && imageItems.length > 0) {
                    // 获取当前模型并检测vision支持
                    const currentModel = await getCurrentModel();
                    const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModel) || false;
                    if (supportsVision) {
                        // 支持vision的模型，准备图片数据进行多模态分析
                        commentsWithTime = await generateAICommentsWithVision(content, moment.id, imageItems);
                    } else {
                        // 不支持vision的模型，只基于文字内容生成评论（包含位置信息）
                        commentsWithTime = await generateAICommentsWithCurrentTime(content, { location });
                    }
                } else {
                    // 没有图片，使用当前时间生成评论（包含位置信息）
                    commentsWithTime = await generateAICommentsWithCurrentTime(content, { location });
                }
                // 更新朋友圈的评论
                const momentIndex = moments.findIndex(m => m.id === moment.id);
                if (momentIndex !== -1) {
                    moments[momentIndex].comments = commentsWithTime;
                    await saveDataToDB();
                    // 性能优化：只更新评论部分，而不是重新渲染整个列表
                    await updateMomentElement(moment.id, 'comments');
                }
            } catch (error) {
                console.error('评论生成失败:', error);
            }
        }, 1000);
        
        // 清空表单和图片
        document.getElementById('manualMomentContent').value = '';
        momentUploadedImages = [];
        
    } catch (error) {
        console.error('发布朋友圈失败:', error);
        showToast('发布失败: ' + error.message);
    }
}

/**
 * @description 根据聊天记录和角色信息生成朋友圈内容
 * @changes **MODIFIED**: Changed API request to be compatible with OpenAI format.
 */
async function generateMomentContent() {
    // 检查朋友圈操作是否被锁定
    if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
        return;
    }
    
    if (!currentContact) {
        showToast('请先选择一个联系人');
        return;
    }

    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('请先设置API和模型');
        return;
    }

    const generateBtn = document.querySelector('.generate-moment-btn');
    generateBtn.disabled = true;
    generateBtn.textContent = '生成中...';

    try {
        const systemPrompt = window.promptBuilder.buildMomentContentPrompt(currentContact, userProfile, apiCallInfo, contacts);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { temperature: 0.8 },
            (apiCallInfo.timeout || 60) * 1000
        );

        const momentContent = data.choices[0].message.content || '';

        let imageData = null;
        // unsplashApiKey元素已从HTML中移除，从localStorage直接获取
        const unsplashKey = localStorage.getItem('unsplashApiKey') || '';
        if (unsplashKey) {
            imageData = await fetchMatchingImageForPublish(momentContent, unsplashKey);
        }

        // 使用当前时间生成评论（就像论坛一样）
        const comments = await generateAICommentsWithCurrentTime(momentContent, { imageData });

        // 生成朋友圈ID
        const momentId = Date.now().toString();

        const moment = {
            id: momentId,
            authorName: currentContact.name,
            authorAvatar: currentContact.avatar,
            content: momentContent,
            image: imageData ? imageData.url : null, // 保存Unsplash URL
            imageDescription: imageData ? imageData.description : null, // 保存图片描述
            imageAltDescription: imageData ? imageData.altDescription : null, // 保存Unsplash提供的描述
            imageCount: imageData ? 1 : 0, // 简单的计数，不再处理文件存储
            isUnsplashImage: imageData ? true : false, // 标记为Unsplash图片
            time: new Date().toISOString(),
            likes: 0,
            comments: comments
        };

        moments.unshift(moment);
        await saveDataToDB();
        await renderMomentsList();
        closeModal('generateMomentModal');
        showToast('朋友圈发布成功');

    } catch (error) {
        console.error('生成朋友圈失败:', error);
        showApiError(error);
    } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = '生成朋友圈';
    }
}


/**
 * @description 根据内容生成图片搜索关键词，并调用 Unsplash API 获取图片
 * @changes 现在使用AI生成更精准的搜索关键词
 */
async function fetchMatchingImageForPublish(content, apiKey) {
    try {
        // 使用AI生成更精准的搜索关键词
        const searchQuery = await generateImageSearchKeyword(content);
        console.log(`[fetchMatchingImageForPublish] 原始内容: "${content}"`);
        console.log(`[fetchMatchingImageForPublish] 搜索关键词: "${searchQuery}"`);
        
        // 检查关键词是否为英文（简单检查）
        const isEnglish = /^[a-zA-Z0-9\s\-.,!?]+$/.test(searchQuery.trim());
        if (!isEnglish) {
            console.warn(`[fetchMatchingImageForPublish] 关键词似乎不是英文，可能AI生成失败: "${searchQuery}"`);
        }
        
        // 调用Unsplash API搜索图片
        const apiUrl = `https://api.unsplash.com/search/photos?query=${encodeURIComponent(searchQuery)}&per_page=3&orientation=landscape`;
        console.log(`[fetchMatchingImageForPublish] API URL: ${apiUrl}`);
        
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `Client-ID ${apiKey}`
            }
        });
        
        console.log(`[fetchMatchingImageForPublish] Response status: ${response.status} ${response.statusText}`);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`[fetchMatchingImageForPublish] API错误详情: ${errorText}`);
            throw new Error(`Unsplash API请求失败: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log(`[fetchMatchingImageForPublish] 搜索结果: 使用关键词"${searchQuery}"找到${data.results?.length || 0}张图片`);
        
        if (data.results && data.results.length > 0) {
            console.log(`[fetchMatchingImageForPublish] 返回图片URL: ${data.results[0].urls.regular}`);
            // 返回图片URL和描述信息
            return {
                url: data.results[0].urls.regular,
                description: searchQuery, // 搜索关键词作为描述
                altDescription: data.results[0].alt_description || searchQuery // Unsplash提供的描述
            };
        } else {
            console.warn(`[fetchMatchingImageForPublish] 未找到匹配图片`);
            return null;
        }
    } catch (error) {
        console.error('[fetchMatchingImageForPublish] 获取配图失败:', error);
        return null;
    }
}

/**
 * @description 调用 API 生成图片搜索关键词
 * @changes **MODIFIED**: Changed API request to be compatible with OpenAI format.
 */
async function generateImageSearchQuery(content) {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        console.error('获取API配置失败:', error);
        return null;
    }
    try {
        const systemPrompt = window.promptBuilder.buildImageSearchPrompt(content);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { temperature: 0.5 },
            (apiCallInfo.timeout || 60) * 1000
        );
        return data.choices[0].message.content || null;
    } catch (error) {
        console.error('AI关键词生成失败:', error);
        return null;
    }
}


function extractImageKeywords(content) {
    const emotionMap = { '开心': 'happy sunshine joy', '难过': 'sad rain melancholy', '兴奋': 'excited celebration party', '平静': 'peaceful calm nature', '浪漫': 'romantic sunset flowers', '怀念': 'nostalgic vintage memories' };
    const sceneMap = { '咖啡': 'coffee cafe cozy', '旅行': 'travel landscape adventure', '美食': 'food delicious cooking', '工作': 'office workspace productivity', '运动': 'sports fitness outdoor', '读书': 'books reading library', '音乐': 'music instruments concert', '电影': 'cinema movie theater', '购物': 'shopping fashion style', '聚会': 'party friends celebration' };
    let keywords = [];
    for (const [chinese, english] of Object.entries(emotionMap)) { if (content.includes(chinese)) { keywords.push(english); break; } }
    for (const [chinese, english] of Object.entries(sceneMap)) { if (content.includes(chinese)) { keywords.push(english); break; } }
    if (keywords.length === 0) keywords.push('lifestyle daily life aesthetic');
    return keywords.join(' ');
}

/**
 * @description 调用 API 生成朋友圈评论
 * @changes **MODIFIED**: Changed API request to be compatible with OpenAI format.
 */
async function generateAIComments(momentContent, location = '') {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        const systemPrompt = await window.promptBuilder.buildCommentsPrompt(momentContent, contacts, location);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error("AI未返回有效的JSON格式");
        }

        // 使用统一的JSON提取函数清理markdown语法
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawText);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        return commentsData.comments.map(formatCommentForDataModel);
    } catch (error) {
        console.error('AI评论生成失败:', error);
        return [];
    }
}

// 生成带当前时间戳的评论（像论坛一样）
async function generateAICommentsWithCurrentTime(momentContent, options = {}) {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        // 解构参数，支持location和imageData
        const { location = '', imageData = null } = options;

        // 如果有Unsplash图片描述，将其添加到内容中
        let enhancedContent = momentContent;
        if (imageData && imageData.description) {
            enhancedContent += ` [图片描述: ${imageData.description}]`;
            if (imageData.altDescription && imageData.altDescription !== imageData.description) {
                enhancedContent += ` [详细描述: ${imageData.altDescription}]`;
            }
        }

        // 构建系统提示，同时支持location和enhancedContent
        const systemPrompt = await window.promptBuilder.buildCommentsPrompt(enhancedContent, contacts, location);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error("AI未返回有效的JSON格式");
        }

        // 使用统一的JSON提取函数清理markdown语法
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawText);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        const baseComments = commentsData.comments || [];
        
        // 所有评论都使用当前时间（就像论坛一样）
        return baseComments.map(formatCommentForDataModel);
    } catch (error) {
        console.error('生成带时间戳评论失败:', error);
        return [];
    }
}

// 为支持vision的模型生成带图片分析的评论
async function generateAICommentsWithVision(momentContent, momentId, imageItems) {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        // 获取图片的base64数据用于vision分析
        const imagePromises = imageItems.slice(0, 9) // 限制最多9张图片
            .filter(item => item.file)
            .map(async (imageItem) => {
                const base64Data = await fileToBase64(imageItem.file);
                return {
                    type: "image_url",
                    image_url: {
                        url: `data:${imageItem.file.type};base64,${base64Data}`
                    }
                };
            });
        const imageMessages = await Promise.all(imagePromises);
        
        // 构建多模态消息
        const messages = [{
            role: 'user',
            content: [
                {
                    type: "text", 
                    text: `请基于以下朋友圈内容和图片，生成3-5条朋友评论。内容："${momentContent}"`
                },
                ...imageMessages
            ]
        }];
        
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            messages,
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error("AI未返回有效的JSON格式");
        }

        // 使用统一的JSON提取函数清理markdown语法
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawText);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        const baseComments = commentsData.comments || [];
        
        // 所有评论都使用当前时间（就像论坛一样）
        return baseComments.map(formatCommentForDataModel);
    } catch (error) {
        console.error('生成带vision的评论失败:', error);
        // 失败时回退到普通评论生成
        return await generateAICommentsWithCurrentTime(momentContent);
    }
}

// 将File对象转换为base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
            const result = reader.result;
            const base64 = result.split(',')[1]; // 去掉data:image/...;base64,前缀
            resolve(base64);
        };
        reader.onerror = error => reject(error);
    });
}

// 生成带时间戳的评论（基于朋友圈发布时间）
async function generateAICommentsWithTime(momentContent, momentTime, location = '') {
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        return [];
    }
    try {
        const systemPrompt = await window.promptBuilder.buildCommentsPrompt(momentContent, contacts, location);
        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: systemPrompt }],
            { response_format: { type: "json_object" }, temperature: 0.9 },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawText = data.choices[0].message.content;
        if (!rawText) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error("AI未返回有效的JSON格式");
        }

        // 使用统一的JSON提取函数清理markdown语法
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawText);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        const baseComments = commentsData.comments || [];
        
        // 为每个评论添加时间戳（在朋友圈发布时间之后）
        const momentTimeMs = new Date(momentTime).getTime();
        return baseComments.map((comment, index) => {
            // 评论时间在朋友圈发布后的几分钟到几小时内
            const minDelayMs = (index + 1) * 2 * 60 * 1000; // 每个评论间隔至少2分钟
            const maxDelayMs = (index + 1) * 30 * 60 * 1000; // 最多30分钟后
            const randomDelay = minDelayMs + Math.random() * (maxDelayMs - minDelayMs);
            const commentTime = new Date(momentTimeMs + randomDelay);
            
            const processedComment = formatCommentForDataModel({
                ...comment,
                time: commentTime.toISOString() // 使用计算出的时间
            });
            return processedComment;
        });
    } catch (error) {
        console.error('生成带时间戳评论失败:', error);
        return [];
    }
}


async function publishMoment() {
    const content = document.getElementById('momentPreviewContent').textContent;
    const imageElement = document.getElementById('momentPreviewImage');
    const imageUrl = imageElement.style.display === 'block' ? imageElement.src : null;
    if (!content) {
        showToast('请先生成朋友圈内容');
        return;
    }
    const publishBtn = document.getElementById('publishMomentBtn');
    publishBtn.disabled = true;
    publishBtn.textContent = '发布中...';
    try {
        // 使用当前时间生成评论（就像论坛一样）
        const comments = await generateAICommentsWithCurrentTime(content);
        const moment = { id: Date.now().toString(), authorName: currentContact.name, authorAvatar: currentContact.avatar, content, image: imageUrl, time: new Date().toISOString(), likes: 0, comments };
        moments.unshift(moment);
        await saveDataToDB(); // 使用IndexedDB保存
        await renderMomentsList();
        closeModal('generateMomentModal');
        showToast('朋友圈发布成功');
    } catch (error) {
        console.error('发布朋友圈失败:', error);
        showToast('发布失败: ' + error.message);
    } finally {
        publishBtn.disabled = false;
        publishBtn.textContent = '发布';
    }
}

async function renderMomentsList() {
    const momentsEmpty = document.getElementById('momentsEmpty');
    const momentsList = document.getElementById('momentsList');
    if (moments.length === 0) { 
        momentsEmpty.style.display = 'block';
        momentsList.style.display = 'none';
    } else {
        momentsEmpty.style.display = 'none';
        momentsList.style.display = 'block';
        momentsList.innerHTML = '';
        
        // 按时间排序，从新到旧（最新的在前面）
        const sortedMoments = [...moments].sort((a, b) => {
            return new Date(b.time) - new Date(a.time);
        });

        // 性能优化：在循环开始前获取模型信息，避免在循环中重复调用
        const currentModelForVision = await getCurrentModel();
        const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModelForVision) || false;

        for (const moment of sortedMoments) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';
            
            // 处理作者头像 - 支持新的文件系统格式
            let avatarContent = '';
            const author = window.contacts ? window.contacts.find(c => c.name === moment.authorName) : null;
            
            try {
                if (author) {
                    // 使用getAvatarHTML获取联系人头像
                    const avatarHTML = await getAvatarHTML(author, 'contact', '');
                    if (avatarHTML.includes('<img')) {
                        const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                        if (srcMatch) {
                            avatarContent = `<img src="${srcMatch[1]}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                        }
                    }
                } else if (moment.authorName === userProfile.name) {
                    // 如果是当前用户的动态，使用getAvatarHTML获取用户头像
                    const avatarHTML = await getAvatarHTML(userProfile, 'user', '');
                    if (avatarHTML.includes('<img')) {
                        const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                        if (srcMatch) {
                            avatarContent = `<img src="${srcMatch[1]}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                        }
                    }
                }
                
                // 如果没有头像或头像获取失败，使用文字头像
                if (!avatarContent) {
                    avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
                }
            } catch (error) {
                console.warn('获取朋友圈头像失败，使用回退逻辑:', error);
                // 回退到旧的逻辑
                if (author && author.avatar) {
                    avatarContent = `<img src="${author.avatar}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                } else if (moment.authorName === userProfile.name && userProfile.avatar) {
                    avatarContent = `<img src="${userProfile.avatar}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                } else {
                    avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
                }
            }
            
            // 处理图片内容 - 优先处理Unsplash图片，然后是用户上传的图片
            let imageContent = '';

            // 优先处理Unsplash图片（直接使用URL，不需要vision指示器因为已有描述）
            if (moment.isUnsplashImage && moment.image) {
                imageContent = `<div class="moment-images-grid grid-1">
                                  <div class="moment-image-container">
                                      <img src="${moment.image}" class="moment-grid-image" onclick="viewImage('${moment.image}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" alt="Unsplash图片">
                                      <div class="moment-image-error" style="display: none;">
                                          <div class="image-error-icon">📷</div>
                                          <div class="image-error-text">图片加载失败</div>
                                      </div>
                                  </div>
                                </div>`;
            }
            // 用户上传的图片（从文件系统加载，需要vision指示器）
            else if (moment.imageFileIds && moment.imageCount > 0 && window.ImageStorageAPI) {
                const visionIndicator = supportsVision ? '<div class="vision-support-indicator">✓</div>' : '';
                try {
                    await window.ImageStorageAPI.init();
                    const imageUrls = await window.ImageStorageAPI.getMomentImagesURLs(moment.id, moment.imageCount);
                    if (imageUrls.length > 0) {
                        const gridClass = `grid-${imageUrls.length}`;
                        imageContent = `<div class="moment-images-grid ${gridClass}">`;
                        imageUrls.forEach((imageSrc, imageIndex) => {
                            imageContent += `<div class="moment-image-container">
                                               <img src="${imageSrc}" class="moment-grid-image" onclick="viewImage('${imageSrc}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" alt="图片${imageIndex + 1}">
                                               ${visionIndicator}
                                               <div class="moment-image-error" style="display: none;">
                                                   <div class="image-error-icon">📷</div>
                                                   <div class="image-error-text">图片加载失败</div>
                                               </div>
                                             </div>`;
                        });
                        imageContent += '</div>';
                    }
                } catch (error) {
                    console.error('加载朋友圈图片失败:', error);
                }
            }
            // 兼容旧数据结构（可能是历史数据，根据是否为Unsplash图片决定是否显示vision指示器）
            else if (moment.image || moment.images) {
                const images = moment.images || (moment.image ? [moment.image] : []);
                if (images.length > 0) {
                    // 只有非Unsplash图片才显示vision指示器
                    const visionIndicator = (!moment.isUnsplashImage && supportsVision) ? '<div class="vision-support-indicator">✓</div>' : '';
                    const gridClass = `grid-${images.length}`;
                    imageContent = `<div class="moment-images-grid ${gridClass}">`;
                    images.forEach((imageSrc, imageIndex) => {
                        imageContent += `<div class="moment-image-container">
                                           <img src="${imageSrc}" class="moment-grid-image" onclick="viewImage('${imageSrc}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" alt="图片${imageIndex + 1}">
                                           ${visionIndicator}
                                           <div class="moment-image-error" style="display: none;">
                                               <div class="image-error-icon">📷</div>
                                               <div class="image-error-text">图片加载失败</div>
                                           </div>
                                         </div>`;
                    });
                    imageContent += '</div>';
                }
            }
            
            // 处理评论内容 - 发现页面保持简洁样式
            let commentsContent = '';
            if (moment.comments && moment.comments.length > 0) {
                // 兼容性处理朋友圈评论：支持新旧字段名
                // 新代码应使用统一字段：commenter_name, comment_content, timestamp
                const commentsList = moment.comments
                    .filter(comment => (comment.comment_content || comment.content) && (comment.comment_content || comment.content).trim())
                    .map(comment => {
                        const safeContent = (comment.comment_content || comment.content).replace(/'/g, '&#39;');
                        const authorName = comment.commenter_name || comment.author;
                        return `<div onclick="showMomentReplyToComment('${moment.id}', '${authorName}')" style="font-size: 13px; color: #576b95; margin-bottom: 4px; cursor: pointer; padding: 4px; border-radius: 4px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='transparent'">
                            <span onclick="event.stopPropagation(); handleCommentAuthorClick('${authorName}')" style="cursor: pointer; color: #576b95; font-weight: bold;">${authorName}:</span>
                            <span class="moment-comment">${safeContent}</span>
                        </div>`;
                    }).join('');
                commentsContent = `<div style="margin-top: 10px; padding-top: 10px; border-top: 0.5px solid #eee;">${commentsList}</div>`;
            }
            
            // 处理点赞信息
            const likes = moment.likes || [];
            let likedUsers = [];
            
            // 获取点赞用户列表（包括独立点赞和评论点赞）
            if (likes.length > 0) {
                likedUsers = [...likes];
            }
            
            if (moment.comments && moment.comments.length > 0) {
                // 兼容性处理：点赞评论用户列表
                const commentLikedUsers = moment.comments
                    .filter(comment => comment.like === true)
                    .map(comment => comment.commenter_name || comment.author)
                    .filter(author => !likedUsers.includes(author)); // 避免重复
                
                likedUsers = [...likedUsers, ...commentLikedUsers];
            }
            
            const likesContent = likedUsers.length > 0 ? 
                `<div style="font-size: 13px; color: #576b95; margin-bottom: 4px;">❤️ ${likedUsers.join(', ')}</div>` : '';
            
            // 显示名称 - 如果是当前用户，使用最新的用户名
            const isCurrentUser = moment.authorName === userProfile.name;
            const displayName = isCurrentUser ? userProfile.name : moment.authorName;
            
            // 三点菜单按钮
            const menuButton = `<div class="moment-menu-btn" onclick="event.stopPropagation(); toggleMomentMenu('${moment.id}')" title="更多选项">⋯</div>`;
            
            // 菜单内容
            const menuContent = `
                <div class="moment-menu" id="momentMenu-${moment.id}" style="display: none;">
                    <div class="moment-menu-item" onclick="event.stopPropagation(); editMomentLocation('${moment.id}')">修改位置</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); regenerateMomentImage('${moment.id}')">重新生成图片</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); removeMomentImage('${moment.id}')">删除图片</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); regenerateComments('${moment.id}')">重新生成评论</div>
                    <div class="moment-menu-item" onclick="event.stopPropagation(); deleteMoment('${moment.id}')">删除</div>
                </div>
            `;
            
            // 创建点击头像的事件处理函数
            const avatarClickHandler = `onclick="handleMomentAvatarClick('${moment.authorName.replace(/'/g, "\\'")}')"`;
            
            // 添加折叠菜单
            const actionsMenu = `
                <div class="moment-actions-container">
                    <button class="moment-collapse-btn" onclick="toggleMomentActions('${moment.id}')">❤/💬</button>
                    <div class="moment-actions-menu" id="momentActions-${moment.id}">
                        <button class="moment-action-btn" onclick="likeMoment('${moment.id}')" title="点赞">❤</button>
                        <button class="moment-action-btn" onclick="showMomentComment('${moment.id}')" title="评论">💬</button>
                    </div>
                </div>
            `;
            
            momentDiv.innerHTML = `
                <div class="moment-header" style="display: flex; align-items: flex-start; margin-bottom: 8px;">
                    <div ${avatarClickHandler} style="cursor: pointer; margin-right: 12px; flex-shrink: 0;">${avatarContent}</div>
                    <div style="flex: 1; min-width: 0;">
                        <div class="moment-name" style="font-weight: 600; color: #576b95; font-size: 16px; line-height: 1.2; margin: 0;">${displayName}</div>
                    </div>
                    <div style="margin-left: auto;">
                        ${menuButton}
                        ${menuContent}
                    </div>
                </div>
                <div class="moment-content">${moment.content}</div>
                ${imageContent}
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0px;">
                    <div class="moment-time-location">
                        <span>${formatContactListTime(moment.time)}</span>
                        ${moment.location ? `<span class="moment-location">📍 ${moment.location}</span>` : ''}
                    </div>
                    ${actionsMenu}
                </div>
                ${likesContent}
                ${commentsContent}
                <div class="moment-reply-input-container" id="momentMainReply-${moment.id}">
                    <textarea class="moment-reply-input" placeholder="写评论..."></textarea>
                    <div class="moment-reply-actions">
                        <button class="moment-reply-btn moment-reply-cancel" onclick="hideMomentComment('${moment.id}')">取消</button>
                        <button class="moment-reply-btn moment-reply-submit" onclick="submitMomentComment('${moment.id}')">发送</button>
                    </div>
                </div>
            `;
            momentsList.appendChild(momentDiv);
        }
    }
}

/**
 * 性能优化：更新单个朋友圈元素而非重新渲染整个列表
 * @param {string} momentId - 要更新的朋友圈ID
 * @param {string} updateType - 更新类型：'location', 'content', 'comments', 'likes'
 */
async function updateMomentElement(momentId, updateType = 'location') {
    const moment = moments.find(m => m.id === momentId);
    if (!moment) {
        console.warn(`未找到ID为 ${momentId} 的朋友圈`);
        return;
    }

    // 查找对应的DOM元素
    const momentElement = document.querySelector(`#momentMenu-${momentId}`)?.closest('.moment-item');
    if (!momentElement) {
        console.warn(`未找到朋友圈 ${momentId} 对应的DOM元素`);
        return;
    }

    try {
        switch (updateType) {
            case 'location':
                await updateMomentLocation(momentElement, moment);
                break;
            case 'content':
                await updateMomentContent(momentElement, moment);
                break;
            case 'comments':
                await updateMomentComments(momentElement, moment);
                break;
            case 'likes':
                await updateMomentLikes(momentElement, moment);
                break;
            default:
                console.warn(`未知的更新类型: ${updateType}`);
        }
    } catch (error) {
        console.error(`更新朋友圈元素失败 (${updateType}):`, error);
        // 如果局部更新失败，回退到全量渲染
        await renderMomentsList();
    }

    console.log(`🚀 性能优化完成: ${updateType}更新`);
}

/**
 * 更新朋友圈位置显示
 */
async function updateMomentLocation(momentElement, moment) {
    const timeLocationContainer = momentElement.querySelector('.moment-time-location');
    if (!timeLocationContainer) {
        console.warn('未找到时间位置容器');
        return;
    }

    // 更新时间和位置显示
    timeLocationContainer.innerHTML = `
        <span>${formatContactListTime(moment.time)}</span>
        ${moment.location ? `<span class="moment-location">📍 ${moment.location}</span>` : ''}
    `;

    console.log(`✅ 位置更新完成: ${moment.location || '已清除'}`);
}

/**
 * 更新朋友圈内容显示
 */
async function updateMomentContent(momentElement, moment) {
    const contentElement = momentElement.querySelector('.moment-content');
    if (contentElement) {
        contentElement.textContent = moment.content;
    }

    console.log(`✅ 内容更新完成`);
}

/**
 * 更新朋友圈评论显示
 */
async function updateMomentComments(momentElement, moment) {
    // 查找评论容器 - 使用更通用的选择器
    let commentsContainer = momentElement.querySelector('.moment-comments');
    
    // 如果没有找到.moment-comments，查找包含评论的div（通过样式特征）
    if (!commentsContainer) {
        commentsContainer = momentElement.querySelector('div[style*="margin-top: 10px"][style*="padding-top: 10px"][style*="border-top"]');
    }
    
    // 如果还是没找到，查找最后一个包含评论相关内容的div
    if (!commentsContainer) {
        const allDivs = momentElement.querySelectorAll('div');
        for (let i = allDivs.length - 1; i >= 0; i--) {
            if (allDivs[i].innerHTML.includes('moment-comment') || allDivs[i].querySelector('.moment-comment')) {
                commentsContainer = allDivs[i];
                break;
            }
        }
    }

    // 生成新的评论内容 - 使用与 renderMomentsList 相同的逻辑
    let newCommentsContent = '';
    if (moment.comments && moment.comments.length > 0) {
        // 兼容性处理朋友圈评论：支持新旧字段名
        // 新代码应使用统一字段：commenter_name, comment_content, timestamp
        const commentsList = moment.comments
            .filter(comment => (comment.comment_content || comment.content) && (comment.comment_content || comment.content).trim())
            .map(comment => {
                const safeContent = (comment.comment_content || comment.content).replace(/'/g, '&#39;');
                const authorName = comment.commenter_name || comment.author;
                return `<div onclick="showMomentReplyToComment('${moment.id}', '${authorName}')" style="font-size: 13px; color: #576b95; margin-bottom: 4px; cursor: pointer; padding: 4px; border-radius: 4px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='transparent'">
                            <span onclick="event.stopPropagation(); handleCommentAuthorClick('${authorName}')" style="cursor: pointer; color: #576b95; font-weight: bold;">${authorName}:</span>
                            <span class="moment-comment">${safeContent}</span>
                        </div>`;
            }).join('');
        newCommentsContent = `<div class="moment-comments" style="margin-top: 10px; padding-top: 10px; border-top: 0.5px solid #eee;">${commentsList}</div>`;
    }

    if (commentsContainer) {
        // 如果找到了评论容器，直接替换
        if (newCommentsContent) {
            commentsContainer.outerHTML = newCommentsContent;
        } else {
            // 如果没有评论，移除评论容器
            commentsContainer.remove();
        }
        console.log(`✅ 评论更新完成`);
    } else {
        // 如果没有找到评论容器，但有新评论要显示，则添加到moment内容区域末尾
        if (newCommentsContent) {
            const replyContainer = momentElement.querySelector('.moment-reply-input-container');
            if (replyContainer) {
                replyContainer.insertAdjacentHTML('beforebegin', newCommentsContent);
                console.log(`✅ 评论插入完成`);
            } else {
                // 最后的备用方案：添加到moment-item的末尾
                momentElement.insertAdjacentHTML('beforeend', newCommentsContent);
                console.log(`✅ 评论添加完成（备用方案）`);
            }
        } else {
            console.log(`ℹ️ 无评论需要显示`);
        }
    }
}

/**
 * 更新朋友圈点赞显示
 */
async function updateMomentLikes(momentElement, moment) {
    // 查找点赞容器 - 使用更通用的选择器
    let likesContainer = momentElement.querySelector('.moment-likes');
    
    // 如果没有找到 .moment-likes，查找包含点赞内容的div（通过内容特征）
    if (!likesContainer) {
        const allDivs = momentElement.querySelectorAll('div[style*="font-size: 13px"][style*="color: #576b95"]');
        for (const div of allDivs) {
            if (div.innerHTML.includes('❤️')) {
                likesContainer = div;
                break;
            }
        }
    }

    // 生成新的点赞内容 - 使用与 renderMomentsList 相同的逻辑
    const likes = moment.likes || [];
    let likedUsers = [];
    
    // 获取点赞用户列表（包括独立点赞和评论点赞）
    if (likes.length > 0) {
        likedUsers = [...likes];
    }
    
    if (moment.comments && moment.comments.length > 0) {
        const commentLikedUsers = moment.comments
            .filter(comment => comment.like === true)
            .map(comment => comment.commenter_name  || comment.author)
            .filter(author => !likedUsers.includes(author)); // 避免重复
        
        likedUsers = [...likedUsers, ...commentLikedUsers];
    }
    
    const newLikesContent = likedUsers.length > 0 ? 
        `<div class="moment-likes" style="font-size: 13px; color: #576b95; margin-bottom: 4px;">❤️ ${likedUsers.join(', ')}</div>` : '';

    if (likesContainer) {
        // 如果找到了点赞容器，直接替换
        if (newLikesContent) {
            likesContainer.outerHTML = newLikesContent;
        } else {
            // 如果没有点赞，移除点赞容器
            likesContainer.remove();
        }
        console.log(`✅ 点赞更新完成`);
    } else {
        // 如果没有找到点赞容器，但有新点赞要显示，则添加到合适位置
        if (newLikesContent) {
            // 查找评论容器，在其前面插入点赞
            const commentsContainer = momentElement.querySelector('.moment-comments') || 
                                    momentElement.querySelector('div[style*="margin-top: 10px"][style*="border-top"]');
            
            if (commentsContainer) {
                commentsContainer.insertAdjacentHTML('beforebegin', newLikesContent);
                console.log(`✅ 点赞插入完成（评论前）`);
            } else {
                // 如果没有评论容器，在回复输入框前插入
                const replyContainer = momentElement.querySelector('.moment-reply-input-container');
                if (replyContainer) {
                    replyContainer.insertAdjacentHTML('beforebegin', newLikesContent);
                    console.log(`✅ 点赞插入完成（回复框前）`);
                } else {
                    // 最后的备用方案：添加到moment-item的末尾
                    momentElement.insertAdjacentHTML('beforeend', newLikesContent);
                    console.log(`✅ 点赞添加完成（备用方案）`);
                }
            }
        } else {
            console.log(`ℹ️ 无点赞需要显示`);
        }
    }
}

// 图片查看功能
function viewImage(imageSrc) {
    // 创建全屏图片查看器
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
        background: rgba(0,0,0,0.9); z-index: 10000; 
        display: flex; align-items: center; justify-content: center;
        cursor: pointer;
    `;
    
    const img = document.createElement('img');
    img.src = imageSrc;
    img.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain;';
    
    overlay.appendChild(img);
    overlay.onclick = () => document.body.removeChild(overlay);
    document.body.appendChild(overlay);
}


// 删除朋友圈
async function deleteMoment(momentId) {
    showConfirmDialog('删除确认', '确定要删除这条朋友圈吗？', async () => {
        try {
            // 从数组中删除
            const momentIndex = moments.findIndex(m => m.id === momentId);
            if (momentIndex !== -1) {
                moments.splice(momentIndex, 1);
                await saveDataToDB();
                isMomentsDataModified = true; // 标记数据已修改
                await renderMomentsList();
                showToast('朋友圈已删除');
            } else {
                showToast('未找到要删除的朋友圈');
            }
        } catch (error) {
            console.error('删除朋友圈失败:', error);
            isMomentsDataModified = true; // 即使失败也标记，确保下次切换页面时刷新
            showToast('删除失败: ' + error.message);
        }
    });
}

// --- 音乐播放器 (懒加载) ---
function lazyInitMusicPlayer() {
    // 确保只初始化一次
    if (isMusicPlayerInitialized) return;
    isMusicPlayerInitialized = true;

    initMusicPlayer();
}

async function initMusicPlayer() {
    try {
        // DB已经由init()打开，这里不需要再次打开
        await loadPlaylistFromDB();
    } catch (error) {
        console.error("Failed to initialize music player:", error);
        showToast("无法加载音乐库");
    }

    document.getElementById('closeMusicModal').addEventListener('click', closeMusicModal);
    document.getElementById('progressBar').addEventListener('click', seekMusic);
    window.addEventListener('click', (event) => { if (event.target === document.getElementById('musicModal')) closeMusicModal(); });
    
    audio = new Audio();
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('ended', onSongEnded);
    audio.addEventListener('loadedmetadata', onMetadataLoaded);
}

async function loadPlaylistFromDB() {
    return new Promise((resolve, reject) => {
        if (!window.isIndexedDBReady) { // 确保DB已准备好
            reject('IndexedDB not ready');
            return;
        }
        const transaction = window.db.transaction(['songs'], 'readonly');
        const store = transaction.objectStore('songs');
        const request = store.getAll();

        request.onsuccess = () => {
            playlist = request.result.map(song => ({
                id: song.id,
                name: song.name,
                lyrics: song.lyrics,
            }));
            renderPlaylist();
            resolve();
        };

        request.onerror = (event) => {
            console.error('Failed to load playlist from DB:', event.target.error);
            reject('Failed to load playlist');
        };
    });
}

async function saveSong() {
    const nameInput = document.getElementById('songName');
    const musicFileInput = document.getElementById('musicFileUpload');
    const lrcFileInput = document.getElementById('lrcFile');

    const musicFile = musicFileInput.files[0];
    const lrcFile = lrcFileInput.files[0];

    if (!musicFile) {
        showToast('请选择一个音乐文件');
        return;
    }

    const songName = nameInput.value.trim() || musicFile.name.replace(/\.[^/.]+$/, "");

    let lyrics = [];
    if (lrcFile) {
        try {
            const lrcText = await lrcFile.text();
            lyrics = parseLRC(lrcText);
        } catch (e) {
            showToast('歌词文件读取失败，将不带歌词保存。');
        }
    }
    
    const songRecord = {
        name: songName,
        music: musicFile, 
        lyrics: lyrics
    };

    if (!window.isIndexedDBReady) {
        showToast('数据库未准备好，无法保存歌曲。');
        return;
    }

    const transaction = window.db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');
    const request = store.add(songRecord);

    request.onsuccess = async () => {
        showToast(`歌曲 "${songName}" 已成功保存到本地`);
        clearAddForm();
        await loadPlaylistFromDB(); 
    };

    request.onerror = (event) => {
        console.error('Failed to save song to DB:', event.target.error);
        showToast('保存歌曲失败');
    };
}

async function playSong(index) {
    if (index < 0 || index >= playlist.length) return;
    
    const songInfo = playlist[index];
    currentSongIndex = index;

    if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
        currentObjectUrl = null;
    }

    if (!window.isIndexedDBReady) {
        showToast('数据库未准备好，无法播放歌曲。');
        return;
    }

    const transaction = window.db.transaction(['songs'], 'readonly');
    const store = transaction.objectStore('songs');
    const request = store.get(songInfo.id);

    request.onsuccess = (event) => {
        const songRecord = event.target.result;
        if (songRecord && songRecord.music) {
            currentObjectUrl = URL.createObjectURL(songRecord.music);
            audio.src = currentObjectUrl;
            audio.play().then(() => {
                isPlaying = true;
                updatePlayButton();
                document.getElementById('currentSongInfo').style.display = 'block';
                document.getElementById('currentSongName').textContent = songRecord.name;
                currentLyrics = songRecord.lyrics || [];
                currentLyricIndex = -1;
                if (currentLyrics.length > 0) startLyricSync();
                else document.getElementById('currentLyric').textContent = '暂无歌词';
                renderPlaylist();
            }).catch(error => showToast('播放失败: ' + error.message));
        } else {
            showToast('无法从数据库中找到歌曲文件');
        }
    };

    request.onerror = (event) => {
        console.error("Error fetching song from DB:", event.target.error);
        showToast('播放歌曲时出错');
    };
}

async function deleteSong(index) {
    showConfirmDialog('删除确认', '确定要永久删除这首歌吗？', async () => {
        const songInfo = playlist[index];
        
        if (!window.isIndexedDBReady) {
            showToast('数据库未准备好，无法删除歌曲。');
            return;
        }

        const transaction = window.db.transaction(['songs'], 'readwrite');
        const store = transaction.objectStore('songs');
        const request = store.delete(songInfo.id);

        request.onsuccess = async () => {
            showToast(`歌曲 "${songInfo.name}" 已删除`);
            if (index === currentSongIndex) {
                stopMusic();
                currentSongIndex = -1;
                document.getElementById('currentSongInfo').style.display = 'none';
            }
            await loadPlaylistFromDB();
        };

        request.onerror = (event) => {
            console.error('Failed to delete song from DB:', event.target.error);
            showToast('删除歌曲失败');
        };
    });
}

function showMusicModal() {
    lazyInitMusicPlayer(); // 第一次点击时才初始化
    document.getElementById('musicModal').style.display = 'block';
    renderPlaylist();
}

function closeMusicModal() {
    document.getElementById('musicModal').style.display = 'none';
}

function renderPlaylist() {
    const container = document.getElementById('playlistContainer');
    if (!playlist || playlist.length === 0) { 
        container.innerHTML = '<p style="text-align: center; color: #999;">暂无歌曲，请从下方上传</p>'; 
        return; 
    }
    container.innerHTML = '';
    playlist.forEach((song, index) => {
        const songDiv = document.createElement('div');
        songDiv.className = 'song-item';
        if (index === currentSongIndex) songDiv.classList.add('active');
        songDiv.innerHTML = `<span onclick="playSong(${index})" style="flex: 1;">${song.name}</span><span class="delete-song" onclick="deleteSong(${index})">×</span>`;
        container.appendChild(songDiv);
    });
}

function parseLRC(lrcContent) {
    const lines = lrcContent.split(/\r?\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?\]/g;
    lines.forEach(line => {
        if (!line.trim()) return;
        let match;
        let lastIndex = 0;
        const times = [];
        while ((match = timeRegex.exec(line)) !== null) {
            const totalSeconds = parseInt(match[1]) * 60 + parseInt(match[2]) + (match[3] ? parseInt(match[3].padEnd(3, '0')) / 1000 : 0);
            times.push(totalSeconds);
            lastIndex = match.index + match[0].length;
        }
        if (times.length > 0) {
            const text = line.substring(lastIndex).trim();
            if (text) times.forEach(time => lyrics.push({ time, text }));
        }
    });
    lyrics.sort((a, b) => a.time - b.time);
    return lyrics;
}

function startLyricSync() {
    stopLyricSync();
    lyricTimer = setInterval(() => { if (!audio.paused && currentLyrics.length > 0) updateLyrics(); }, 100);
}

function stopLyricSync() {
    if (lyricTimer) clearInterval(lyricTimer);
    lyricTimer = null;
}

function updateLyrics() {
    const currentTime = audio.currentTime;
    let newIndex = -1;
    for (let i = currentLyrics.length - 1; i >= 0; i--) {
        if (currentTime >= currentLyrics[i].time) { newIndex = i; break; }
    }
    if (newIndex !== currentLyricIndex && newIndex >= 0) {
        currentLyricIndex = newIndex;
        const lyricText = currentLyrics[newIndex].text;
        document.getElementById('currentLyric').textContent = lyricText;
        sendLyricToAI(lyricText);
    }
}

function sendLyricToAI(lyricText) {
    if (currentSongIndex > -1) {
         window.currentMusicInfo = { songName: playlist[currentSongIndex]?.name || '', lyric: lyricText, isPlaying };
    }
}

function togglePlay() {
    if (audio.src) {
        if (audio.paused) { audio.play(); isPlaying = true; startLyricSync(); }
        else { audio.pause(); isPlaying = false; stopLyricSync(); }
        updatePlayButton();
    }
}

function stopMusic() {
    audio.pause();
    audio.currentTime = 0;
    isPlaying = false;
    currentLyricIndex = -1;
    stopLyricSync();
    updatePlayButton();
    document.getElementById('currentLyric').textContent = '等待歌词...';
    window.currentMusicInfo = null;
    if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
        currentObjectUrl = null;
    }
}

function updatePlayButton() {
    document.getElementById('playPauseBtn').textContent = isPlaying ? '⏸️ 暂停' : '▶️ 播放';
}

function updateProgress() {
    if (audio.duration) {
        document.getElementById('progressFill').style.width = (audio.currentTime / audio.duration) * 100 + '%';
        document.getElementById('currentTime').textContent = formatMusicTime(audio.currentTime);
    }
}

function onMetadataLoaded() {
    document.getElementById('totalTime').textContent = formatMusicTime(audio.duration);
}

function onSongEnded() {
    isPlaying = false;
    updatePlayButton();
    stopLyricSync();
    window.currentMusicInfo = null;
}

function seekMusic(event) {
    if (audio.duration) {
        const rect = event.currentTarget.getBoundingClientRect();
        audio.currentTime = ((event.clientX - rect.left) / rect.width) * audio.duration;
    }
}

function toggleLyricsDisplay() {
    document.getElementById('floatingLyrics').style.display = document.getElementById('showLyrics').checked ? 'block' : 'none';
}

function clearAddForm() {
    document.getElementById('songName').value = '';
    document.getElementById('musicFileUpload').value = '';
    document.getElementById('lrcFile').value = '';
}

// formatMusicTime and formatTime functions moved to utils/formatUtils.js

// --- UI 更新 & 交互 ---
function updateContextIndicator() {
    const indicator = document.getElementById('contextIndicator');
    if (indicator) indicator.innerHTML = `上下文: ${apiSettings.contextMessageCount}条`;
}

function updateContextValue(value) {
    document.getElementById('contextValue').textContent = value + '条';
}


// 专门用于显示上传错误的函数
// showUploadError function moved to utils/uiUtils.js

// 处理API错误的专用函数，七夕节特殊功能：所有API失败都显示重试确认对话框
// showApiError function moved to utils/uiUtils.js

// === localStorage清空功能 ===
function showClearLocalStorageConfirmation() {
    showModal('clearLocalStorageModal');
    console.log('显示localStorage清空确认对话框');
}

function executeLocalStorageClear() {
    try {
        // 记录清空前的localStorage项目数量
        const itemCount = localStorage.length;
        console.log(`准备清空localStorage，当前有${itemCount}个项目`);
        
        // 获取所有localStorage键名（用于日志记录）
        const allKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            allKeys.push(localStorage.key(i));
        }
        
        console.log('localStorage清空前的所有键名:', allKeys);
        
        // 执行清空操作
        localStorage.clear();
        
        // 关闭对话框
        closeModal('clearLocalStorageModal');
        
        // 显示成功提示
        showToast(`✅ localStorage已清空！已删除${itemCount}个项目`, 3000);
        
        // 记录操作到控制台
        console.log('✅ localStorage清空操作完成', {
            timestamp: new Date().toISOString(),
            clearedItemsCount: itemCount,
            clearedKeys: allKeys,
            currentItemsCount: localStorage.length
        });
        
        // 可选：延迟刷新页面让用户看到结果
        setTimeout(() => {
            if (confirm('localStorage已清空。是否要刷新页面以确保所有组件正确重置？')) {
                window.location.reload();
            }
        }, 2000);
        
    } catch (error) {
        console.error('清空localStorage时发生错误:', error);
        showToast(`❌ 清空失败: ${error.message}`, 3000);
        closeModal('clearLocalStorageModal');
    }
}

// === 七夕节特殊功能：AI空回复重试 ===
let qixiRetryContext = null; // 存储重试上下文

function showQixiRetryModal(prefixOrError, error, errorMessage, prefix) {
    // 检查模态框元素是否存在
    const modal = document.getElementById('qixiRetryModal');
    if (!modal) {
        // 如果模态框不存在，直接显示确认对话框作为fallback
        const shouldRetry = confirm(`操作失败：${errorMessage}\n\n是否要重新尝试？`);
        if (shouldRetry) {
            // 保存重试上下文
            if (typeof prefixOrError === 'string' && error) {
                qixiRetryContext = { type: 'dual-param', prefix: prefixOrError, error: error, errorMessage, fullPrefix: prefix };
            } else {
                qixiRetryContext = { type: 'single-param', error: prefixOrError, errorMessage, fullPrefix: prefix };
            }
            handleQixiRetry();
        }
        return;
    }
    
    // 保存重试上下文，支持单参数和双参数调用
    if (typeof prefixOrError === 'string' && error) {
        qixiRetryContext = { type: 'dual-param', prefix: prefixOrError, error: error, errorMessage, fullPrefix: prefix };
    } else {
        qixiRetryContext = { type: 'single-param', error: prefixOrError, errorMessage, fullPrefix: prefix };
    }
    
    // 更新模态框中的错误信息显示
    const errorDiv = document.querySelector('#qixiRetryModal .qixi-retry-message');
    if (errorDiv) {
        errorDiv.innerHTML = `
            <p><strong>操作失败</strong></p>
            <p>${errorMessage}</p>
            <p>是否要重新尝试？</p>
        `;
    }
    
    showModal('qixiRetryModal');
}

async function handleQixiRetry() {
    closeModal('qixiRetryModal');
    
    if (!qixiRetryContext) {
        showToast('重试上下文丢失，请重新操作');
        return;
    }
    
    try {
        showToast('🌹 正在重新尝试...');
        
        // 根据当前场景重新执行相应的操作
        if (currentContact) {
            // 重新发送消息
            let apiCallInfo;
            try {
                apiCallInfo = await getApiCallInfo();
            } catch (error) {
                showToast('请先设置API和模型');
                return;
            }
            
            showTypingIndicator();
            
            try {
                let replies;
                if (currentContact.type === 'group') {
                    const result = await callChatAPIWithPriority(currentContact, [], true);
                    replies = result.replies;
                } else {
                    const result = await callChatAPIWithPriority(currentContact, [], true);
                    replies = result.replies;
                }
                
                hideTypingIndicator();
                
                if (!replies || replies.length === 0) {
                    showToast('重试后仍未获得有效回复');
                    return;
                }
                
                // 处理AI回复
                for (let i = 0; i < replies.length; i++) {
                    const response = replies[i];
                    const isLastReply = i === replies.length - 1;
                    
                    await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
                    
                    let rawMessageContent = removeThinkingChain(response.content);
                    const voiceParsed = parseVoiceMessage(rawMessageContent);

                    const aiMessage = { 
                        role: 'assistant', 
                        content: voiceParsed.content,
                        type: response.type, 
                        time: new Date().toISOString(), 
                        senderId: currentContact.id,
                        isVoice: voiceParsed.isVoice
                    };

                    currentContact.messages.push(aiMessage);

                    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                        currentlyDisplayedMessageCount++;
                    }
                    
                    await addSingleMessage(aiMessage, true);
                    
                    if (isLastReply) {
                        currentContact.lastMessage = response.type === 'text' ? response.content.substring(0, 20) + '...' : (response.type === 'emoji' ? '[表情]' : '[红包]');
                        currentContact.lastTime = formatContactListTime(new Date().toISOString());
                        await renderContactList();
                        await saveDataToDB();
                    }
                }
                
                showToast('重试成功');
                
            } catch (retryError) {
                hideTypingIndicator();
                console.error('重试失败:', retryError);
                
                showToast('重试失败: ' + retryError.message);
            }
        } else {
            showToast('没有当前聊天对象，无法重试');
        }
        
    } catch (error) {
        console.error('处理重试时发生错误:', error);
        showToast('重试过程出现错误: ' + error.message);
    } finally {
        // 清理重试上下文
        qixiRetryContext = null;
    }
}

// === 表情图片管理函数 ===
async function renderEmojiContent(emojiContent, isInline = false) {
    // 处理新格式 [emoji:tag]
    if (emojiContent.startsWith('[emoji:') && emojiContent.endsWith(']')) {
        const tag = emojiContent.slice(7, -1);
        const imageData = await getEmojiImage(tag);
        if (imageData) {
            const style = isInline ? 'max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;' : '';
            const className = isInline ? '' : 'class="message-emoji"';
            return `<img src="${imageData}" ${className} style="${style}">`;
        } else {
            // 如果找不到图片，显示标签
            return `[表情:${tag}]`;
        }
    }
    
    // 处理旧格式的base64或URL
    if (emojiContent.startsWith('data:image/') || emojiContent.startsWith('http')) {
        const style = isInline ? 'max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;' : '';
        const className = isInline ? '' : 'class="message-emoji"';
        return `<img src="${emojiContent}" ${className} style="${style}">`;
    }
    
    return emojiContent; // 返回原内容
}

// 删除AI回复中的思维链标签
// removeThinkingChain function moved to utils/formatUtils.js

async function processTextWithInlineEmojis(textContent) {
    const emojiTagRegex = /\[(?:emoji|发送了表情)[:：]([^\]]+)\]/g;
    const standaloneEmojiMatch = textContent.trim().match(/^\[(?:emoji|发送了表情)[:：]([^\]]+)\]$/);
    
    if (standaloneEmojiMatch) {
        // 处理独立表情消息
        const emojiName = standaloneEmojiMatch[1];
        const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
        if (foundEmoji && foundEmoji.tag) {
            return await renderEmojiContent(`[emoji:${foundEmoji.tag}]`);
        } else if (foundEmoji && foundEmoji.url) {
            // 旧格式兼容
            return `<img src="${foundEmoji.url}" class="message-emoji">`;
        } else {
            return `<div class="message-content">${textContent}</div>`;
        }
    } else {
        // 处理包含内联表情的文本
        let processedContent = textContent.replace(/\n/g, '<br>');
        
        // 使用异步替换处理内联表情
        const emojiMatches = [...processedContent.matchAll(emojiTagRegex)];
        for (const match of emojiMatches) {
            const fullMatch = match[0];
            const emojiName = match[1];
            const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
            
            let replacement = fullMatch; // 默认保持原样
            if (foundEmoji && foundEmoji.tag) {
                const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                replacement = emojiHtml;
            } else if (foundEmoji && foundEmoji.url) {
                // 旧格式兼容
                replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
            }
            
            processedContent = processedContent.replace(fullMatch, replacement);
        }
        
        return `<div class="message-content">${processedContent}</div>`;
    }
}
async function saveEmojiImage(tag, base64Data) {
    if (!window.isIndexedDBReady) {
        console.warn('IndexedDB 未准备好，无法保存表情图片。');
        return;
    }
    
    // 如果 emojiImages 存储不存在，提示用户刷新页面
    if (!window.db.objectStoreNames.contains('emojiImages')) {
        console.log('检测到 emojiImages 存储不存在，需要升级数据库');
        if (typeof showToast === 'function') {
            showToast('检测到数据库需要升级，请刷新页面');
        }
        return;
    }
    
    try {
        const transaction = window.db.transaction(['emojiImages'], 'readwrite');
        const store = transaction.objectStore('emojiImages');
        await promisifyRequest(store.put({ tag: tag, data: base64Data }));
    } catch (error) {
        console.error('保存表情图片失败:', error);
        throw error;
    }
}

async function getEmojiImage(tag) {
    if (!window.isIndexedDBReady) {
        console.warn('IndexedDB 未准备好，无法获取表情图片。');
        return null;
    }
    
    try {
        // 首先尝试从新的文件存储系统获取
        if (window.ImageStorageAPI) {
            try {
                await window.ImageStorageAPI.init();
                const url = await window.ImageStorageAPI.getEmojiURL(tag);
                if (url) {
                    return url;
                }
            } catch (error) {
                console.warn('从新文件存储获取表情失败，回退到旧系统:', error);
            }
        }
        
        // 回退到旧的 emojiImages 存储
        if (!window.db.objectStoreNames.contains('emojiImages')) {
            console.log('检测到 emojiImages 存储不存在，需要升级数据库');
            if (typeof showToast === 'function') {
                showToast('检测到数据库需要升级，请刷新页面');
            }
            return null;
        }
        
        const transaction = window.db.transaction(['emojiImages'], 'readonly');
        const store = transaction.objectStore('emojiImages');
        const result = await promisifyRequest(store.get(tag));
        return result ? result.data : null;
        
    } catch (error) {
        console.error('获取表情图片失败:', error);
        return null;
    }
}

async function deleteEmojiImage(tag) {
    if (!window.isIndexedDBReady) {
        console.warn('IndexedDB 未准备好，无法删除表情图片。');
        return;
    }
    
    // 如果 emojiImages 存储不存在，提示用户刷新页面
    if (!window.db.objectStoreNames.contains('emojiImages')) {
        console.log('检测到 emojiImages 存储不存在，需要升级数据库');
        if (typeof showToast === 'function') {
            showToast('检测到数据库需要升级，请刷新页面');
        }
        return;
    }
    
    try {
        const transaction = window.db.transaction(['emojiImages'], 'readwrite');
        const store = transaction.objectStore('emojiImages');
        await promisifyRequest(store.delete(tag));
    } catch (error) {
        console.error('删除表情图片失败:', error);
        throw error;
    }
}


// 数据库优化函数：将现有base64表情转换为标签格式
async function optimizeEmojiDatabase() {
    if (!window.isIndexedDBReady) {
        showToast('数据库未准备好，无法执行优化');
        return;
    }
    
    try {
        showToast('开始优化数据库...');
        let optimizedCount = 0;
        let processedContacts = 0;
        
        // 处理所有联系人的消息
        for (const contact of contacts) {
            let contactModified = false;
            
            for (const message of contact.messages) {
                // 查找包含base64图片的消息
                if (message.content && typeof message.content === 'string') {
                    const base64Regex = /data:image\/[^,\s]+,[A-Za-z0-9+/=]+/g;
                    const matches = message.content.match(base64Regex);
                    
                    if (matches) {
                        let newContent = message.content;
                        
                        for (const base64Url of matches) {
                            // 查找对应的表情
                            const emoji = emojis.find(e => e.url === base64Url || (e.url && e.url === base64Url));
                            if (emoji && emoji.meaning) {
                                // 如果还没有保存过这个表情的图片，保存到emojiImages
                                const existingImage = await getEmojiImage(emoji.meaning);
                                if (!existingImage) {
                                    await saveEmojiImage(emoji.meaning, base64Url);
                                }
                                
                                // 更新表情数据结构
                                if (!emoji.tag) {
                                    emoji.tag = emoji.meaning;
                                }
                                
                                // 替换消息中的base64为标签格式
                                newContent = newContent.replace(base64Url, `[emoji:${emoji.meaning}]`);
                                optimizedCount++;
                                contactModified = true;
                            } else {
                                // 如果找不到对应的表情，可能是独立的base64图片，创建一个临时标签
                                const tempTag = `temp_${Date.now()}`;
                                await saveEmojiImage(tempTag, base64Url);
                                newContent = newContent.replace(base64Url, `[emoji:${tempTag}]`);
                                
                                // 创建一个新的表情记录
                                emojis.push({
                                    id: Date.now().toString(),
                                    tag: tempTag,
                                    meaning: tempTag
                                });
                                optimizedCount++;
                                contactModified = true;
                            }
                        }
                        
                        // 更新消息内容
                        message.content = newContent;
                        
                        // 如果消息类型是emoji，也更新类型
                        if (message.type === 'emoji' && matches.length === 1 && newContent.trim().match(/^\[emoji:[^\]]+\]$/)) {
                            // 这是一个纯表情消息
                            message.content = newContent.trim();
                        }
                    }
                }
            }
            
            if (contactModified) {
                processedContacts++;
            }
        }
        
        // 更新表情数据结构，移除旧的url字段
        for (const emoji of emojis) {
            if (emoji.url && emoji.url.startsWith('data:image/')) {
                // 确保图片已保存到emojiImages
                if (emoji.tag || emoji.meaning) {
                    const tag = emoji.tag || emoji.meaning;
                    const existingImage = await getEmojiImage(tag);
                    if (!existingImage) {
                        await saveEmojiImage(tag, emoji.url);
                    }
                    
                    // 移除url字段
                    delete emoji.url;
                    
                    // 确保有tag字段
                    if (!emoji.tag && emoji.meaning) {
                        emoji.tag = emoji.meaning;
                    }
                }
            }
        }
        
        // 保存优化后的数据
        await saveDataToDB();
        
        showToast(`数据库优化完成！处理了 ${optimizedCount} 个表情，涉及 ${processedContacts} 个联系人`);
        
        // 刷新表情网格
        await renderEmojiGrid();
        
        // 如果当前有打开的聊天，重新渲染消息
        if (currentContact) {
            await renderMessages(true);
        }
        
    } catch (error) {
        console.error('数据库优化失败:', error);
        showToast(`优化失败: ${error.message}`);
    }
}

// showTopNotification function moved to utils/uiUtils.js



// 清理表情包上传临时数据的函数
function cleanupEmojiUploadData() {
    try {
        // 清理临时文件
        if (window.ImageUploadHandlers.tempEmojiFile) {
            window.ImageUploadHandlers.tempEmojiFile = null;
        }
        
        // 清理临时URL
        const emojiUrlInput = document.getElementById('emojiUrl');
        if (emojiUrlInput && emojiUrlInput.value.startsWith('temp:')) {
            const tempUrl = emojiUrlInput.value.substring(5);
            URL.revokeObjectURL(tempUrl);
            emojiUrlInput.value = '';
        }
        
        // 清理文件输入
        const fileInput = document.getElementById('emojiUploadInput');
        if (fileInput) {
            fileInput.value = '';
        }
        
        // 清理状态提示
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = '';
            statusElement.style.color = '';
        }
        
        // 清理意思输入框
        const meaningInput = document.getElementById('emojiMeaning');
        if (meaningInput) {
            meaningInput.value = '';
        }
        
        console.log('表情包上传临时数据已清理');
    } catch (error) {
        console.error('清理表情包上传数据时出错:', error);
    }
}

function showAddContactModal() {
    editingContact = null;
    window.editingContact = null;
    document.getElementById('contactModalTitle').textContent = '添加AI助手';
    
    // 清除所有输入框和状态提示
    document.getElementById('contactName').value = '';
    document.getElementById('contactAvatar').value = '';
    document.getElementById('contactPersonality').value = '';
    document.getElementById('customPrompts').value = '';
    document.getElementById('contactVoiceId').value = '';
    
    // 清除文件输入和状态提示
    const fileInput = document.getElementById('avatarUploadInput');
    const statusElement = document.getElementById('avatarUploadStatus');
    if (fileInput) fileInput.value = '';
    if (statusElement) statusElement.textContent = '';
    
    showModal('addContactModal');
}

function showEditContactModal() {
    if (!currentContact) { showToast('请先选择联系人'); return; }
    editingContact = currentContact;
    window.editingContact = editingContact;
    document.getElementById('contactModalTitle').textContent = '编辑AI助手';
    document.getElementById('contactName').value = currentContact.name;
    
    // 处理头像显示和状态
    const avatarInput = document.getElementById('contactAvatar');
    const fileInput = document.getElementById('avatarUploadInput');
    const statusElement = document.getElementById('avatarUploadStatus');
    
    // 设置隐藏的URL输入框
    if (currentContact.avatarFileId) {
        avatarInput.value = `file:${currentContact.avatarFileId}`;
        // 显示已上传状态
        if (statusElement) {
            statusElement.textContent = '已上传';
            statusElement.style.color = '#07c160';
        }
    } else {
        avatarInput.value = currentContact.avatar || '';
        // 清除状态提示
        if (statusElement) {
            statusElement.textContent = '';
        }
    }
    
    // 清除file input以避免显示上次的文件
    if (fileInput) {
        fileInput.value = '';
    }
    
    document.getElementById('contactPersonality').value = currentContact.personality;
    document.getElementById('customPrompts').value = currentContact.customPrompts || '';
    // 加载当前联系人的语音ID
    document.getElementById('contactVoiceId').value = currentContact.voiceId || '';
    showModal('addContactModal');
}

// API加载等待相关变量
let apiLoadingTimerId = null;
let apiLoadingStartTime = null;
let apiLoadingCancelled = false;

// 显示API加载等待框
function showApiLoadingModal() {
    apiLoadingCancelled = false;
    apiLoadingStartTime = Date.now();
    showModal('apiLoadingModal');
    
    // 开始倒计时
    apiLoadingTimerId = setInterval(() => {
        if (apiLoadingCancelled) {
            clearInterval(apiLoadingTimerId);
            return;
        }
        
        const elapsed = Math.floor((Date.now() - apiLoadingStartTime) / 1000);
        const countdownElement = document.getElementById('loadingCountdown');
        if (countdownElement) {
            countdownElement.textContent = elapsed + 's';
        }
    }, 1000);
}

// 隐藏API加载等待框
function hideApiLoadingModal() {
    if (apiLoadingTimerId) {
        clearInterval(apiLoadingTimerId);
        apiLoadingTimerId = null;
    }
    closeModal('apiLoadingModal');
}

// 取消API加载
function cancelApiLoading() {
    apiLoadingCancelled = true;
    hideApiLoadingModal();
    showToast('已取消模型加载');
}

async function showApiSettingsModal() {
    try {
        console.log('显示API配置管理模态框');
        
        // 显示等待提示框
        showApiLoadingModal();
        
        try {
            // 初始化配置选择器
            await loadConfigSelector();
            
            // 检查是否被取消
            if (apiLoadingCancelled) return;
            
            // 加载当前配置到表单
            await loadCurrentConfigToForm();
            
            // 检查是否被取消
            if (apiLoadingCancelled) return;
            
            // 加载模型选择器的API配置列表
            await loadApiConfigSelectorsForModels();
            
            // 检查是否被取消
            if (apiLoadingCancelled) return;
            
        } finally {
            // 无论成功还是失败都要隐藏等待框
            hideApiLoadingModal();
        }
        
        // 只有在没有被取消时才显示API设置模态框
        if (!apiLoadingCancelled) {
            showModal('apiSettingsModal');
            console.log('API设置模态框已显示');
            
            // 确保API key状态正确显示
            setTimeout(() => {
                updateAllKeyStates();
                // 更新UI提示状态
                updateUIHintStatus();
            }, 200); // 延迟确保DOM已完全渲染
        }
        
    } catch (error) {
        console.error('显示API设置模态框失败:', error);
        hideApiLoadingModal();
        showToast('打开设置失败: ' + error.message);
    }
}

// 确保函数在全局作用域可用
window.showApiSettingsModal = showApiSettingsModal;

// 添加API设置按钮事件监听器（安全的延迟绑定）
document.addEventListener('DOMContentLoaded', function() {
    const apiSettingsIcon = document.getElementById('apiSettingsIcon');
    if (apiSettingsIcon) {
        apiSettingsIcon.addEventListener('click', showApiSettingsModal);
        apiSettingsIcon.setAttribute('data-umami-event', 'API Settings Open');
    }
});

function showBackgroundModal() {
    // 异步包装函数
    showBackgroundModalAsync().catch(error => {
        console.error('显示背景设置界面错误:', error);
    });
}

async function showBackgroundModalAsync() {
    if (!currentContact) { showToast('请先选择联系人'); return; }
    
    // 处理背景URL显示
    let displayUrl = '';
    const backgroundUrl = backgrounds[currentContact.id];
    if (backgroundUrl) {
        if (backgroundUrl.startsWith('file:')) {
            // 如果是新的文件存储格式，显示文件存储标识
            displayUrl = '(已使用文件存储)';
        } else {
            displayUrl = backgroundUrl;
        }
    }
    
    document.getElementById('backgroundUrl').value = displayUrl;
    showModal('backgroundModal');
}

function showAddEmojiModal() {
    showModal('addEmojiModal');
    toggleEmojiPanel(true);
}

function showRedPacketModal() {
    showModal('redPacketModal');
}

function showEditProfileModal() {
    document.getElementById('profileNameInput').value = userProfile.name;
    
    // 处理头像显示和状态
    const avatarInput = document.getElementById('profileAvatarInput');
    const fileInput = document.getElementById('profileUploadInput');
    const statusElement = document.getElementById('profileUploadStatus');
    
    // 设置隐藏的URL输入框
    if (userProfile.avatarFileId) {
        avatarInput.value = `file:${userProfile.avatarFileId}`;
        // 显示已上传状态
        if (statusElement) {
            statusElement.textContent = '已上传';
            statusElement.style.color = '#07c160';
        }
    } else {
        avatarInput.value = userProfile.avatar || '';
        // 清除状态提示
        if (statusElement) {
            statusElement.textContent = '';
        }
    }
    
    // 清除file input以避免显示上次的文件
    if (fileInput) {
        fileInput.value = '';
    }
    
    document.getElementById('profilePersonality').value = userProfile.personality || '';
    showModal('editProfileModal');
}

function showCreateGroupModal() {
    // 异步包装函数
    showCreateGroupModalAsync().catch(error => {
        console.error('显示群聊创建界面错误:', error);
    });
}

async function showCreateGroupModalAsync() {
    const memberList = document.getElementById('groupMemberList');
    memberList.innerHTML = '';
    
    for (const contact of contacts) {
        if (contact.type !== 'group') {
            const item = document.createElement('div');
            item.className = 'group-member-item';
            
            const avatarHTML = await getAvatarHTML(contact, 'contact') || contact.name[0];
            item.innerHTML = `<div class="group-member-avatar">${avatarHTML}</div><div class="group-member-name">${contact.name}</div><div class="group-member-checkbox">✓</div>`;
            item.onclick = () => {
                item.classList.toggle('selected');
                item.querySelector('.group-member-checkbox').classList.toggle('selected');
            };
            memberList.appendChild(item);
        }
    }
    showModal('createGroupModal');
}

// --- 数据保存与处理 ---
async function saveContact(event) {
    event.preventDefault();
    const avatarValue = document.getElementById('contactAvatar').value;

    // 处理临时URL的情况：如果是临时URL但还有临时文件，先转换存储
    if (avatarValue.startsWith('temp:') && window.tempContactAvatarFile) {
        try {
            const statusElement = document.getElementById('avatarUploadStatus');
            if (statusElement) {
                statusElement.textContent = '正在存储头像...';
                statusElement.style.color = '#999';
            }

            // 预生成联系人ID用于存储（与后面创建联系人时的ID保持一致）
            const newContactId = Date.now().toString();
            window.preGeneratedContactId = newContactId;  // 存储以便后续使用

            // 使用ImageStorageAPI存储头像
            await window.ImageStorageAPI.init();
            const fileId = await window.ImageStorageAPI.storeAvatar(window.tempContactAvatarFile, 'contact', newContactId);

            // 清理临时数据
            const tempUrl = avatarValue.substring(5);
            URL.revokeObjectURL(tempUrl);
            window.tempContactAvatarFile = null;

            // 更新URL输入框为fileId格式
            document.getElementById('contactAvatar').value = `file:${fileId}`;

            if (statusElement) {
                statusElement.textContent = '头像存储成功';
                statusElement.style.color = '#07c160';
            }
        } catch (error) {
            console.error('临时头像文件转换失败:', error);
            showToast('头像存储失败，请重试');
            return;
        }
    }

    // 重新获取处理后的头像值
    const finalAvatarValue = document.getElementById('contactAvatar').value;

    // 处理头像数据：如果是新的fileId格式，分别保存到avatar和avatarFileId字段
    const contactData = {
        name: document.getElementById('contactName').value,
        personality: document.getElementById('contactPersonality').value,
        customPrompts: document.getElementById('customPrompts').value,
        // 保存语音ID
        voiceId: document.getElementById('contactVoiceId').value.trim()
    };

    // 处理头像字段
    if (finalAvatarValue.startsWith('file:')) {
        // 新的fileSystem格式
        contactData.avatarFileId = finalAvatarValue.substring(5); // 移除 "file:" 前缀
        // 保留原avatar字段为空或删除，确保向后兼容
        contactData.avatar = '';
    } else if (finalAvatarValue.startsWith('temp:')) {
        showToast('头像尚未正确存储，请重新上传');
        return;
    } else {
        // 传统的URL或base64格式
        contactData.avatar = finalAvatarValue;
        // 清除可能存在的avatarFileId
        contactData.avatarFileId = null;
    }
    if (editingContact) {
        Object.assign(editingContact, contactData);
        showToast('修改成功');
    } else {
        // 使用预生成的ID（如果有头像上传），否则生成新ID
        const contactId = window.preGeneratedContactId || Date.now().toString();
        window.preGeneratedContactId = null; // 清理

        const contact = {
            id: contactId,
            ...contactData,
            messages: [],
            lastMessage: '点击开始聊天',
            lastTime: formatContactListTime(new Date().toISOString()),
            type: 'private',
            memoryTableContent: defaultMemoryTable,
            // 互动界面相关字段
            interactiveBackgroundFileId: '',
            touchZones: [],
            theme: 'theme-pink-white',
            ttsEnabled: false,
            diaryEntries: {},
            interactiveChatHistory: []
        };
        contacts.unshift(contact);
        showToast('添加成功');
    }
    await saveDataToDB(); // 使用IndexedDB保存
    await renderContactList();
    if (editingContact && currentContact && editingContact.id === currentContact.id) {
        await renderMessages(false);
    }
    closeModal('addContactModal');
    
    // 清理自定义状态提示
    const statusElement = document.getElementById('avatarUploadStatus');
    if (statusElement) statusElement.textContent = '';
    
    event.target.reset();
}

async function createGroup(event) {
    event.preventDefault();
    const groupName = document.getElementById('groupName').value;
    if (!groupName) { showToast('请输入群聊名称'); return; }
    const selectedItems = document.querySelectorAll('.group-member-item.selected');
    if (selectedItems.length < 2) { showToast('请至少选择两个成员'); return; }
    const memberIds = [];
    selectedItems.forEach(item => {
        const name = item.querySelector('.group-member-name').textContent;
        const contact = contacts.find(c => c.name === name && c.type === 'private');
        if (contact) memberIds.push(contact.id);
    });
    const group = { id: 'group_' + Date.now().toString(), name: groupName, members: memberIds, messages: [], lastMessage: '群聊已创建', lastTime: formatContactListTime(new Date().toISOString()), type: 'group', memoryTableContent: defaultMemoryTable };
    contacts.unshift(group);
    await saveDataToDB(); // 使用IndexedDB保存
    await renderContactList();
    closeModal('createGroupModal');
    showToast('群聊创建成功');
}

function importPrompts(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            document.getElementById('customPrompts').value = JSON.stringify(JSON.parse(e.target.result), null, 2);
            showToast('导入成功');
        } catch (error) {
            showToast('导入失败：文件格式错误');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

async function saveProfile(event) {
    event.preventDefault();
    const avatarValue = document.getElementById('profileAvatarInput').value;
    
    userProfile.name = document.getElementById('profileNameInput').value;
    userProfile.personality = document.getElementById('profilePersonality').value;
    
    // 处理头像字段
    if (avatarValue.startsWith('file:')) {
        // 新的fileSystem格式
        userProfile.avatarFileId = avatarValue.substring(5); // 移除 "file:" 前缀
        // 保留原avatar字段为空，确保向后兼容
        userProfile.avatar = '';
    } else {
        // 传统的URL或base64格式
        userProfile.avatar = avatarValue;
        // 清除可能存在的avatarFileId
        userProfile.avatarFileId = null;
    }
    
    await saveDataToDB(); // 使用IndexedDB保存
    await updateUserProfileUI();
    
    // 清理自定义状态提示
    const statusElement = document.getElementById('profileUploadStatus');
    if (statusElement) statusElement.textContent = '';
    
    closeModal('editProfileModal');
    showToast('保存成功');
}

async function updateUserProfileUI() {
    const userAvatar = document.getElementById('userAvatar');
    const userName = document.getElementById('userName');
    userName.textContent = userProfile.name;
    
    // 使用getAvatarHTML支持文件存储
    const avatarHTML = await getAvatarHTML(userProfile, 'user');
    userAvatar.innerHTML = avatarHTML || (userProfile.name[0] || '我');
}

async function renderContactList() {
    const contactList = document.getElementById('contactList');
    contactList.innerHTML = '';
    
    for (const contact of contacts) {
        const item = document.createElement('div');
        item.className = 'contact-item';
        item.setAttribute('data-contact-id', contact.id);
        
        if (contact.type === 'group') {
            const groupAvatarContent = await getGroupAvatarContent(contact);
            item.innerHTML = `<div class="group-avatar"><div class="group-avatar-inner">${groupAvatarContent}</div></div><div class="contact-info"><div class="contact-name">${contact.name}</div><div class="contact-message">${contact.lastMessage}</div></div><div class="contact-time">${contact.lastTime}</div>`;
        } else {
            // 使用异步版本支持文件存储
            const avatarHTML = await getAvatarHTML(contact, 'contact');
            item.innerHTML = `<div class="contact-avatar">${avatarHTML || contact.name[0]}</div><div class="contact-info"><div class="contact-name">${contact.name}</div><div class="contact-message">${contact.lastMessage}</div></div><div class="contact-time">${contact.lastTime}</div>`;
        }
        item.onclick = () => openChat(contact);

        // 添加长按事件监听器来删除联系人/群聊
        let pressTimer;
        item.addEventListener('touchstart', () => {
            pressTimer = setTimeout(() => {
                showConfirmDialog('删除确认', `确定要删除 "${contact.name}" 吗？此操作不可撤销。`, () => {
                    deleteContact(contact.id);
                });
            }, 700); // 长按700毫秒触发
        });
        item.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
        });
        item.addEventListener('touchmove', () => {
            clearTimeout(pressTimer);
        });
        // 对于非触摸设备，也可以添加右键菜单
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showConfirmDialog('删除确认', `确定要删除 "${contact.name}" 吗？此操作不可撤销。`, () => {
                deleteContact(contact.id);
            });
        });

        contactList.appendChild(item);
    }
}

/**
 * 更新联系人列表的时间显示
 * 每分钟调用一次，重新计算相对时间
 * 使用直接DOM更新，避免重新渲染整个列表
 */
function updateContactListTimes() {
    // 检查是否在联系人列表页面
    const contactListPage = document.getElementById('contactListPage');
    if (!contactListPage || !contactListPage.classList.contains('active')) {
        return; // 如果不在联系人列表页面，直接返回
    }
    
    let updateCount = 0;
    
    // 更新每个联系人的时间显示
    contacts.forEach(contact => {
        if (contact.messages && contact.messages.length > 0) {
            const lastMsg = contact.messages[contact.messages.length - 1];
            const newTime = formatContactListTime(lastMsg.time);
            
            // 只有时间显示真的改变了才更新DOM
            if (contact.lastTime !== newTime) {
                contact.lastTime = newTime;
                
                // 找到对应的DOM元素并直接更新时间显示
                const contactItem = document.querySelector(`[data-contact-id="${contact.id}"]`);
                if (contactItem) {
                    const timeElement = contactItem.querySelector('.contact-time');
                    if (timeElement) {
                        timeElement.textContent = newTime;
                        updateCount++;
                    }
                }
            }
        }
    });
    
}

/**
 * 启动联系人时间定时更新器
 */
function startContactTimeUpdater() {
    // 每分钟更新一次时间显示
    setInterval(updateContactListTimes, 60000); // 60秒 = 1分钟
}

async function getGroupAvatarContent(group) {
    const memberAvatars = group.members.slice(0, 4).map(id => contacts.find(c => c.id === id)).filter(Boolean);
    let avatarContent = '';
    
    for (let i = 0; i < 4; i++) {
        if (i < memberAvatars.length) {
            const member = memberAvatars[i];
            const avatarHTML = await getAvatarHTML(member, 'contact');
            avatarContent += `<div class="group-avatar-item">${avatarHTML || member.name[0]}</div>`;
        } else {
            avatarContent += `<div class="group-avatar-item"></div>`;
        }
    }
    return avatarContent;
}

// --- 聊天核心逻辑 ---
async function openChat(contact) {
    // 确保从数据库获取最新的联系人数据，解决voiceId同步问题
    try {
        const dbContact = await ensureDBReady(async () => {
            const transaction = window.db.transaction(['contacts'], 'readonly');
            const store = transaction.objectStore('contacts');

            return await promisifyRequest(store.get(contact.id), '获取联系人数据');
        }, '获取联系人数据');
        
        // 同步voiceId和其他字段到内存对象
        if (dbContact) {
            const fieldsToSync = ['voiceId', 'personality', 'customPrompts'];
            let syncedFields = [];
            
            for (const field of fieldsToSync) {
                if (dbContact[field] !== contact[field]) {
                    contact[field] = dbContact[field];
                    syncedFields.push(field);
                }
            }
            
        }
    } catch (error) {
        console.error('[openChat] 数据库同步失败，使用内存数据:', error);
    }
    
    currentContact = contact;
    window.currentContact = contact;
    window.memoryTableManager.setCurrentContact(contact);
    document.getElementById('chatTitle').textContent = contact.name;
    showPage('chatPage');
    
    // 重置消息加载状态
    currentlyDisplayedMessageCount = 0; 
    
    // 检查并加载最新的气泡样式（每次进入聊天都检查）
    await loadCustomBubbleStyle();
    
    await renderMessages(true); // 初始加载
    
    updateContextIndicator();
    const chatMessagesEl = document.getElementById('chatMessages');
    // 处理背景图片 - 支持新的文件存储系统
    if (backgrounds[contact.id]) {
        const backgroundUrl = backgrounds[contact.id];
        if (backgroundUrl.startsWith('file:')) {
            // 新的文件存储格式: file:fileId
            const fileId = backgroundUrl.substring(5); // 移除 'file:' 前缀
            if (window.ImageStorageAPI) {
                try {
                    await window.ImageStorageAPI.init();
                    const url = await window.ImageStorageAPI.getBackgroundURL(contact.id);
                    chatMessagesEl.style.backgroundImage = `url(${url})`;
                } catch (error) {
                    console.warn('获取背景图片失败:', error);
                    chatMessagesEl.style.backgroundImage = 'none';
                }
            } else {
                chatMessagesEl.style.backgroundImage = 'none';
            }
        } else {
            // 旧格式 - 直接使用URL
            chatMessagesEl.style.backgroundImage = `url(${backgroundUrl})`;
        }
    } else {
        chatMessagesEl.style.backgroundImage = 'none';
    }
    
    // 移除旧的监听器
    chatMessagesEl.onscroll = null; 
    // 添加新的滚动监听器
    chatMessagesEl.onscroll = () => {
        if (chatMessagesEl.scrollTop === 0 && !isLoadingMoreMessages && currentContact.messages.length > currentlyDisplayedMessageCount) {
            loadMoreMessages();
        }
    };

    toggleMemoryPanel(true);
}

function closeChatPage() {
    showPage('contactListPage');
    
    // 清理工作
    const chatMessagesEl = document.getElementById('chatMessages');
    chatMessagesEl.onscroll = null; // 移除监听器
    currentContact = null;
    window.currentContact = null;
    toggleEmojiPanel(true);
    closeContactSettingsPage();
    toggleMemoryPanel(true);
}

async function renderMessages(isInitialLoad = false, hasNewMessage = false) {
    if (!currentContact) return;
    const chatMessages = document.getElementById('chatMessages');
    const allMessages = currentContact.messages;
    
    // 避免在循环中重复访问localStorage
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    // 定义不使用气泡样式的消息类型
    const BUBBLE_EXCLUDED_TYPES = ['emoji', 'red_packet', 'image'];

    // 性能优化：在循环开始前获取模型信息，避免在循环中重复调用
    const currentModel = await getCurrentModel();
    const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModel) || false;

    if (isInitialLoad) {
        currentlyDisplayedMessageCount = Math.min(allMessages.length, MESSAGES_PER_PAGE);
    }
    const messagesToRender = allMessages.slice(allMessages.length - currentlyDisplayedMessageCount);

    const oldScrollHeight = chatMessages.scrollHeight;
    
    chatMessages.innerHTML = '';

    if (allMessages.length > currentlyDisplayedMessageCount) {
        const loadMoreDiv = document.createElement('div');
        loadMoreDiv.className = 'load-more-messages';
        loadMoreDiv.textContent = '加载更早的消息...';
        loadMoreDiv.onclick = loadMoreMessages;
        chatMessages.appendChild(loadMoreDiv);
    }
    
    if (currentContact.type === 'group') {
        const hint = document.createElement('div');
        hint.className = 'group-info-hint';
        hint.textContent = `群聊成员: ${getGroupMembersText()}`;
        chatMessages.appendChild(hint);
    }

    let lastTimestamp = null;
    for (const [index, msg] of messagesToRender.entries()) {
        const originalIndex = allMessages.length - currentlyDisplayedMessageCount + index;
        const currentMsgTime = new Date(msg.time);

        if (!lastTimestamp || currentMsgTime - lastTimestamp > 5 * 60 * 1000) {
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = formatChatTimestamp(msg.time);
            chatMessages.appendChild(timestampDiv);
            lastTimestamp = currentMsgTime;
        }

        const msgDiv = document.createElement('div');
        if (msg.role === 'system') continue;
        
        const isLastMessage = index === messagesToRender.length - 1;
        const isNewMsg = hasNewMessage && isLastMessage;
        msgDiv.className = `message ${msg.role === 'user' ? 'sent' : 'received'}${isNewMsg ? ' new-message' : ''}`;
        msgDiv.dataset.messageIndex = originalIndex;

        let contentHtml = '';
        if (msg.type === 'emoji') {
            contentHtml = await renderEmojiContent(msg.content);
        } else if (msg.type === 'red_packet') {
            const packet = JSON.parse(msg.content);
            contentHtml = `<div class="message-content red-packet" onclick="showToast('红包金额: ${packet.amount}')"><div class="red-packet-body"><svg class="red-packet-icon" viewBox="0 0 1024 1024"><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32zM731.2 565.2H603.9c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8zM419.8 565.2H292.5c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8z" fill="#FEFEFE"></path><path d="M872.4 240H151.6c-17.7 0-32 14.3-32 32v64h784v-64c0-17.7-14.3-32-32-32z" fill="#FCD4B3"></path><path d="M512 432c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88z m0 152c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64-64z" fill="#FCD4B3"></path><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32z m-32 552H215.6V368h624.8v488z" fill="#F37666"></path><path d="M512 128c-112.5 0-204 91.5-204 204s91.5 204 204 204 204-91.5 204-204-91.5-204-204-204z m0 384c-99.4 0-180-80.6-180-180s80.6-180 180-180 180 80.6 180 180-80.6 180-180 180z" fill="#F37666"></path><path d="M512 456c-35.3 0-64 28.7-64 64s28.7 64 64 64 64 28.7 64 64-28.7-64-64-64z m16.4 76.4c-2.3 2.3-5.4 3.6-8.5 3.6h-15.8c-3.1 0-6.2-1.3-8.5-3.6s-3.6-5.4-3.6-8.5v-27.8c0-6.6 5.4-12 12-12h16c6.6 0 12 5.4 12 12v27.8c0.1 3.1-1.2 6.2-3.5 8.5z" fill="#F37666"></path></svg><div class="red-packet-text"><div>${packet.message || '恭喜发财，大吉大利！'}</div><div>领取红包</div></div></div><div class="red-packet-footer">AI红包</div></div>`;
        } else if (msg.type === 'image') {
            contentHtml = await renderImageContent(msg, supportsVision);
        } else {
            contentHtml = await processTextWithInlineEmojis(msg.content);
        }


        let avatarContent = '';
        if (msg.role === 'user') {
            avatarContent = await getAvatarHTML(userProfile, 'user') || (userProfile.name[0] || '我');
        } else {
            const sender = contacts.find(c => c.id === msg.senderId);
            if (sender) {
                avatarContent = await getAvatarHTML(sender, 'contact') || sender.name[0];
            } else {
                avatarContent = '?';
            }
        }

        // 检查是否有自定义气泡样式（根据消息角色选择不同样式）
        let bubbleHtml = '';
        const currentBubbleStyle = msg.role === 'user' ? 
            (window.customBubbleStyleSelf || window.customBubbleStyle) : 
            (window.customBubbleStyleKare || window.customBubbleStyle);
            
        if (currentBubbleStyle && currentBubbleStyle.html && !BUBBLE_EXCLUDED_TYPES.includes(msg.type)) {
            // 使用自定义气泡样式 - 获取原始内容，不包装 message-content
            console.log(`应用${msg.role === 'user' ? '我的' : '对方的'}自定义气泡样式`);
            
            let rawContent = '';
            if (msg.type === 'emoji') {
                rawContent = await renderEmojiContent(msg.content);
            } else if (msg.type === 'red_packet') {
                // 红包保持原有格式
                rawContent = contentHtml;
            } else {
                // 处理文本，但不包装 message-content
                rawContent = msg.content.replace(/\n/g, '<br>');
                
                // 处理内联表情
                const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
                const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
                for (const match of emojiMatches) {
                    const fullMatch = match[0];
                    const emojiName = match[1];
                    const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                    
                    if (foundEmoji && foundEmoji.tag) {
                        const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                        rawContent = rawContent.replace(fullMatch, emojiHtml);
                    } else if (foundEmoji && foundEmoji.url) {
                        const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                        rawContent = rawContent.replace(fullMatch, replacement);
                    }
                }
            }
            
            bubbleHtml = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', rawContent);
            
            // 处理HTML中的file:格式图片
            bubbleHtml = await processFileUrlsInHtml(bubbleHtml);
            
            // 清理 HTML 中的转义换行符，避免显示 \n
            bubbleHtml = bubbleHtml.replace(/\\n/g, '');
            // console.log('生成的自定义气泡 HTML:', bubbleHtml);
        } else {
            // 使用默认气泡样式
            console.log('使用默认气泡样式，自定义样式状态:', {
                hasCustomStyle: !!window.customBubbleStyle,
                hasHtml: !!window.customBubbleStyle?.html
            });
            bubbleHtml = `<div class="message-bubble">${contentHtml}</div>`;
        }

        if (currentContact.type === 'group' && msg.role !== 'user') {
            const sender = contacts.find(c => c.id === msg.senderId);
            const senderName = sender ? sender.name : '未知';
            if (currentBubbleStyle && currentBubbleStyle.html && !BUBBLE_EXCLUDED_TYPES.includes(msg.type)) {
                // 对于群聊消息，在自定义气泡前添加发送者信息
                const groupHeader = `<div class="group-message-header"><div class="group-message-name">${senderName}</div></div>`;
                
                // 获取原始内容（与上面相同的逻辑）
                let rawContent = '';
                if (msg.type === 'emoji') {
                    rawContent = await renderEmojiContent(msg.content);
                } else if (msg.type === 'red_packet') {
                    rawContent = contentHtml;
                } else {
                    rawContent = msg.content.replace(/\n/g, '<br>');
                    const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
                    const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
                    for (const match of emojiMatches) {
                        const fullMatch = match[0];
                        const emojiName = match[1];
                        const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                        
                        if (foundEmoji && foundEmoji.tag) {
                            const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                            rawContent = rawContent.replace(fullMatch, emojiHtml);
                        } else if (foundEmoji && foundEmoji.url) {
                            const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                            rawContent = rawContent.replace(fullMatch, replacement);
                        }
                    }
                }
                
                let customBubbleWithHeader = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', groupHeader + rawContent);
                
                // 处理HTML中的file:格式图片
                customBubbleWithHeader = await processFileUrlsInHtml(customBubbleWithHeader);
                
                // 清理 HTML 中的转义换行符，避免显示 \n
                customBubbleWithHeader = customBubbleWithHeader.replace(/\\n/g, '');
                msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${customBubbleWithHeader}`;
            } else {
                msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div><div class="message-bubble"><div class="group-message-header"><div class="group-message-name">${senderName}</div></div>${contentHtml}</div>`;
            }
        } else {
            msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${bubbleHtml}`;
        }
        
        // 调试：输出最终的 HTML 结构
        // if (currentBubbleStyle && currentBubbleStyle.html) {
        //     console.log('最终消息 HTML 结构:', msgDiv.innerHTML);
        // }
        
        // 使用预先读取的值
        if (msg.isVoice && currentContact.voiceId && minimaxGroupId && minimaxApiKey) {
            // 兼容自定义气泡和默认气泡
            const bubble = msgDiv.querySelector('.message-bubble') || 
                          msgDiv.querySelector('.custom-bubble-container') || 
                          msgDiv.querySelector('.chat-bubble');
            if (bubble) {
                const messageUniqueId = `${currentContact.id}-${msg.time}`; // 使用时间戳保证唯一性
                
                // 给气泡添加语音消息标识
                bubble.classList.add('voice-message');
                bubble.dataset.voiceMessageId = `voice-${messageUniqueId}`;
                
                // 在消息内容前添加语音符号
                // 优先查找.message-content，如果没有则直接在气泡内添加
                const textContentDiv = bubble.querySelector('.message-content') || bubble;
                if (textContentDiv && !textContentDiv.querySelector('.voice-icon')) {
                    const voiceIcon = document.createElement('span');
                    voiceIcon.className = 'voice-icon';
                    voiceIcon.innerHTML = createVoiceIcon(); // SVG音频波形图标
                    
                    // 将语音符号插入到文本内容的最前面
                    if (textContentDiv === bubble) {
                        // 如果是直接在气泡内，需要在文本节点前插入
                        const firstTextNode = Array.from(textContentDiv.childNodes).find(node => 
                            node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ''
                        );
                        if (firstTextNode) {
                            textContentDiv.insertBefore(voiceIcon, firstTextNode);
                        } else {
                            textContentDiv.insertBefore(voiceIcon, textContentDiv.firstChild);
                        }
                    } else {
                        textContentDiv.insertBefore(voiceIcon, textContentDiv.firstChild);
                    }
                }
                
                // 给整个气泡添加点击事件来播放语音
                bubble.style.cursor = 'pointer';
                
                // 移除任何已存在的语音播放事件监听器
                const existingHandler = bubble._voiceClickHandler;
                if (existingHandler) {
                    bubble.removeEventListener('click', existingHandler);
                }
                
                // 创建新的事件处理器
                const voiceClickHandler = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('语音气泡被点击，开始播放:', { text: msg.content, voiceId: currentContact.voiceId });
                    playVoiceMessage(bubble, msg.content, currentContact.voiceId);
                };
                
                // 保存处理器引用并添加事件监听器
                bubble._voiceClickHandler = voiceClickHandler;
                bubble.addEventListener('click', voiceClickHandler);
            }
        }


        if (isMultiSelectMode) {
            msgDiv.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleMessageSelection(originalIndex);
            });
            if (selectedMessages.has(originalIndex)) {
                msgDiv.classList.add('message-selected');
            }
        } else {
            addMessageActionListeners(msgDiv, originalIndex);
        }
        
        chatMessages.appendChild(msgDiv);
    }

    if (isInitialLoad) {
        // 只有在初始化加载且没有新消息时才滚动到底部
        // 这样可以避免每次重新渲染都滚动到顶部的问题
        if (!hasNewMessage) {
            setTimeout(() => {
                chatMessages.scrollTo({
                    top: chatMessages.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
        }
    } else {
        // 非初始化加载时保持当前滚动位置
        const newScrollHeight = chatMessages.scrollHeight;
        chatMessages.scrollTop = chatMessages.scrollTop + (newScrollHeight - oldScrollHeight);
    }
}


async function loadMoreMessages() {
    if (isLoadingMoreMessages) return;
    isLoadingMoreMessages = true;

    const chatMessages = document.getElementById('chatMessages');
    const loadMoreButton = chatMessages.querySelector('.load-more-messages');
    if (loadMoreButton) {
        loadMoreButton.textContent = '正在加载...';
    }

    setTimeout(async () => {
        const allMessages = currentContact.messages;
        const newCount = Math.min(allMessages.length, currentlyDisplayedMessageCount + MESSAGES_PER_PAGE);
        
        if (newCount > currentlyDisplayedMessageCount) {
            currentlyDisplayedMessageCount = newCount;
            await renderMessages(false); // 重新渲染，非初始加载
        }
        
        isLoadingMoreMessages = false;
    }, 500);
}

function getGroupMembersText() {
    if (!currentContact || currentContact.type !== 'group') return '';
    return currentContact.members.map(id => contacts.find(c => c.id === id)?.name || '未知').join('、');
}

async function sendUserMessage() {
    if (!currentContact) return;
    const input = document.getElementById('chatInput');
    const content = input.value.trim();
    if (!content) return;
    const userMessage = { role: 'user', content, type: 'text', time: new Date().toISOString(), senderId: 'user' };
    currentContact.messages.push(userMessage);
    
    // 如果消息总数超过了当前显示的条数，增加显示条数以包含新消息
    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
        currentlyDisplayedMessageCount++;
    }

    currentContact.lastMessage = content;
    currentContact.lastTime = formatContactListTime(new Date().toISOString());
    input.value = '';
    input.style.height = 'auto';
    await addSingleMessage(userMessage, true); // 单独添加用户消息，使用动画
    await renderContactList();
    await saveDataToDB(); // 使用IndexedDB保存
    window.UIManager.safeFocus(input);
}

async function sendMessage() {
    if (!currentContact) return;
    const input = document.getElementById('chatInput');
    const content = input.value.trim();
    if (content) await sendUserMessage();
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('请先设置API和模型');
        return;
    }
    if (currentContact.messages.length === 0 && !content) return;
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.disabled = true;
    try {
        if (currentContact.type === 'group') {
            await sendGroupMessage();
        } else {
            showTypingIndicator();
            const { replies } = await callChatAPIWithPriority(currentContact, [], true);
            hideTypingIndicator();
            
            // 异步更新记忆表格（使用API队列，不阻塞用户操作）
            if (window.updateMemoryTableWithSecondaryModel) {
                window.updateMemoryTableWithSecondaryModel(currentContact, true);
            }
            if (!replies || replies.length === 0) { showTopNotification('AI没有返回有效回复'); return; }
            
            // 批量处理AI回复，避免每条消息都重新渲染
            for (let i = 0; i < replies.length; i++) {
                const response = replies[i];
                const isLastReply = i === replies.length - 1;
                
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
                
                let rawMessageContent = removeThinkingChain(response.content);
                const voiceParsed = parseVoiceMessage(rawMessageContent);

                const aiMessage = { 
                    role: 'assistant', 
                    content: voiceParsed.content,
                    type: response.type, 
                    time: new Date().toISOString(), 
                    senderId: currentContact.id,
                    isVoice: voiceParsed.isVoice
                };

                currentContact.messages.push(aiMessage);
                if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                    currentlyDisplayedMessageCount++;
                }
                
                // 单独添加这条新消息，而不是重新渲染整个界面
                await addSingleMessage(aiMessage, true); // true表示这是AI回复的新消息
                
                // 只在最后一条消息时更新联系人列表和保存数据
                if (isLastReply) {
                    currentContact.lastMessage = response.type === 'text' ? response.content.substring(0, 20) + '...' : (response.type === 'emoji' ? '[表情]' : '[红包]');
                    currentContact.lastTime = formatContactListTime(new Date().toISOString());
                    await renderContactList();
                    await saveDataToDB();
                }
            }
            // 检查是否需要更新记忆（新逻辑：用户发送2条消息就触发）
            
            if (window.characterMemoryManager && window.contacts && Array.isArray(window.contacts)) {
                try {
                    await window.characterMemoryManager.checkAndUpdateMemory(currentContact.id, currentContact);
                } catch (error) {
                    console.error('检查更新记忆失败:', error);
                }
            } else {
            }
        }
    } catch (error) {
        console.error('发送消息错误:', error);
        console.error('错误详情:', {
            name: error.name,
            message: error.message,
            timestamp: new Date().toISOString(),
            url: window.location.href
        });
        // API错误已在callAPI内部处理，这里只需要清理UI状态
        hideTypingIndicator();
    } finally {
        sendBtn.disabled = false;
    }
}

// === 聊天图片发送功能 ===

/**
 * 触发图片上传选择
 */
function triggerImageUpload() {
    const chatImageInput = document.getElementById('chatImageInput');
    if (chatImageInput) {
        chatImageInput.click();
    }
}

/**
 * 处理聊天图片上传
 * @param {Event} event - 文件选择事件
 */
async function handleChatImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        // 检查文件类型
        if (!file.type.startsWith('image/')) {
            showToast('请选择图片文件', 'error');
            return;
        }

        // 检查文件大小 (10MB)
        const maxSize = 10 * 1024 * 1024;
        if (file.size > maxSize) {
            showToast('图片大小不能超过10MB', 'error');
            return;
        }

        // 显示上传进度
        showToast('正在上传图片...', 'info');

        // 生成唯一的图片ID - 使用crypto.randomUUID()提高健壮性
        const imageId = `chat_img_${crypto.randomUUID()}`;

        // 存储图片到文件系统 - 使用UnifiedDBManager
        const result = await window.unifiedDB.storeFile(file, {
            type: 'chat_image',
            imageId: imageId
        });

        // 创建文件引用
        await window.unifiedDB.createFileReference(
            result.fileId,
            'chat_image',
            imageId,
            {
                storedAt: new Date().toISOString(),
                fileName: file.name,
                fileSize: file.size
            }
        );

        // 设置图片使用元数据 - 使用统一的general分类
        await window.unifiedDB.setImageUsageMetadata(result.fileId, 'general', {
            category: 'chat',
            tags: ['聊天图片', getCurrentContactId()],
            size: file.size,
            fileName: file.name,
            createdAt: new Date().toISOString()
        });

        // 发送图片消息
        await sendImageMessage(imageId, result.fileId, file.name);

        // 检测当前模型是否支持图像，显示相应提示
        const currentModel = await getCurrentModel();
        const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModel) || false;
        if (supportsVision) {
            showToast(`🖼️ ${currentModel} 支持图像分析，AI可以看到图片内容`, 'success');
        } else {
            showToast(`📝 ${currentModel} 不支持图像分析，AI将看到文字描述`, 'warning');
        }

    } catch (error) {
        console.error('上传图片失败:', error);
        showToast('图片上传失败: ' + (error.message || '未知错误'), 'error');
    } finally {
        // 清空文件选择
        event.target.value = '';
    }
}

/**
 * 显示图片处理错误的提示
 * @param {string} fileName - 文件名
 * @param {string} errorMessage - 错误信息
 */
function showImageProcessingError(fileName, errorMessage) {
    showToast(`图片处理失败: ${fileName} - ${errorMessage}`, 'error');
}

// 将函数暴露到全局，供PromptBuilder使用
window.showImageProcessingError = showImageProcessingError;

/**
 * 生成图片消息的显示内容
 * @param {string} fileName - 文件名
 * @returns {string} - 格式化的图片消息内容
 */
function formatImageMessageContent(fileName) {
    return `[图片: ${fileName}]`;
}

/**
 * 发送图片消息
 * @param {string} imageId - 图片ID
 * @param {string} fileId - 文件ID
 * @param {string} fileName - 文件名
 */
async function sendImageMessage(imageId, fileId, fileName) {
    const currentContact = getCurrentContact();
    if (!currentContact) {
        throw new Error('未选择联系人');
    }

    // 生成一致的图片消息内容
    const messageContent = formatImageMessageContent(fileName);

    // 创建图片消息对象 - 使用crypto.randomUUID()生成更健壮的ID
    const imageMessage = {
        id: `msg_${crypto.randomUUID()}`,
        type: 'image',
        content: messageContent,
        imageId: imageId,
        fileId: fileId,
        fileName: fileName,
        time: new Date().toISOString(), // 使用 time 字段而不是 timestamp
        role: 'user' // 使用 role 字段而不是 sender
    };

    // 添加到聊天记录
    if (!currentContact.messages) {
        currentContact.messages = [];
    }
    currentContact.messages.push(imageMessage);

    // 更新联系人的最后消息信息 - 使用相同的内容确保一致性
    currentContact.lastMessage = messageContent;
    currentContact.lastTime = formatContactListTime(imageMessage.time);

    // 保存到数据库
    await saveDataToDB();

    // 刷新聊天显示
    await renderMessages(false, true); // 标记为新消息

    // 刷新联系人列表
    await renderContactList();

    console.log('图片消息发送成功:', imageMessage);
}

/**
 * 获取当前联系人ID
 */
function getCurrentContactId() {
    const currentContact = getCurrentContact();
    return currentContact ? currentContact.id : 'unknown';
}

/**
 * 获取当前联系人
 */
function getCurrentContact() {
    return window.currentContact || null;
}

/**
 * 渲染图片消息内容
 * @param {Object} msg - 图片消息对象
 */
async function renderImageContent(msg, supportsVision = false) {
    try {
        // 获取图片URL
        let imageUrl = '';
        
        if (msg.fileId) {
            // 新的文件系统格式 - 从文件ID获取URL
            const reference = await window.unifiedDB.getFileReference('chat_image', msg.imageId);
            if (reference && reference.fileId) {
                imageUrl = await window.unifiedDB.createFileURL(reference.fileId);
            }
        }

        if (!imageUrl) {
            // 回退：显示占位符
            return `
                <div class="message-content chat-image-placeholder">
                    <div class="image-placeholder">
                        <span>📷</span>
                        <div>图片加载失败</div>
                    </div>
                </div>
            `;
        }

    // 使用传入的 supportsVision 参数，避免重复调用 getCurrentModel
    const visionIndicator = supportsVision ? '<div class="vision-support-indicator">✓</div>' : '';

        // 生成图片HTML
        return `
            <div class="message-content chat-image">
                <div class="image-container">
                    <img src="${imageUrl}" 
                         alt="${msg.fileName || '聊天图片'}" 
                         class="chat-image-content"
                         onclick="showImagePreview('${imageUrl}', '${msg.fileName || '聊天图片'}')"
                         onerror="const errDiv = document.createElement('div'); errDiv.className = 'image-error'; errDiv.textContent = '📷 图片加载失败'; this.parentElement.replaceWith(errDiv);"
                         loading="lazy">
                    ${visionIndicator}
                </div>
            </div>
        `;

    } catch (error) {
        console.error('渲染图片消息失败:', error);
        return `
            <div class="message-content chat-image-error">
                <span>📷</span>
                <div>图片显示出错</div>
            </div>
        `;
    }
}

async function sendGroupMessage() {
    if (!currentContact || currentContact.type !== 'group') return;
    
    showTypingIndicator();
    try {
        // 一次性调用API获取所有群成员的回复
        const { replies } = await callChatAPIWithPriority(currentContact, [], true);
        hideTypingIndicator();
        
        if (!replies || replies.length === 0) {
            showTopNotification('群聊AI没有返回有效回复');
            return;
        }
        
        // 解析JSON格式的群聊回复
        let groupMessages = [];
        try {
            // 假设第一个reply包含所有群成员的回复
            const firstReply = replies[0];
            let responseText = removeThinkingChain(firstReply.content);
            
            // 尝试解析JSON格式的回复（支持纯JSON、Markdown代码块等格式）
            if (responseText.includes('{') && responseText.includes('}')) {
                try {
                    // 使用统一的JSON提取函数清理markdown语法
                    const cleanedJson = window.apiService.extractJSON(responseText);
                    const parsedResponse = JSON.parse(cleanedJson);
                    
                    if (parsedResponse.messages && Array.isArray(parsedResponse.messages)) {
                        groupMessages = parsedResponse.messages;
                    }
                } catch (jsonError) {
                    console.error('群聊JSON提取失败:', jsonError);
                    
                    // 继续使用原有逻辑作为备用
                    const jsonStart = responseText.indexOf('{');
                    const jsonEnd = responseText.lastIndexOf('}') + 1;
                    const jsonText = responseText.substring(jsonStart, jsonEnd);
                    
                    const parsedResponse = JSON.parse(jsonText);
                    if (parsedResponse.messages && Array.isArray(parsedResponse.messages)) {
                        groupMessages = parsedResponse.messages;
                    }
                }
            }
        } catch (error) {
            console.error('解析群聊JSON回复失败:', error);
            console.error('错误详情:', {
                error: error.message,
                firstReply: replies[0],
                repliesLength: replies.length
            });
            // 显示具体的错误信息而不是泛泛的"无法解析API回复"
            showTopNotification(`无法解析API回复: ${error.message}`);
            return;
        }
        
        if (groupMessages.length === 0) {
            showTopNotification('未能解析出有效的群聊回复');
            return;
        }
        
        // 逐个显示群成员的发言
        for (let i = 0; i < groupMessages.length; i++) {
            const message = groupMessages[i];
            
            // 查找对应的群成员
            const member = contacts.find(c => c.name === message.speaker && currentContact.members.includes(c.id));
            if (!member) {
                console.warn(`未找到群成员: ${message.speaker}`);
                continue;
            }
            
            await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
            
            const voiceParsed = parseVoiceMessage(message.content);
            
            const aiMessage = {
                role: 'assistant',
                content: voiceParsed.content,
                type: 'text',
                time: new Date().toISOString(),
                senderId: member.id,
                isVoice: voiceParsed.isVoice
            };
            
            currentContact.messages.push(aiMessage);
            if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                currentlyDisplayedMessageCount++;
            }
            
            // 单独添加群成员消息
            await addSingleMessage(aiMessage, true);
            
            // 异步更新该成员的记忆
            if (window.characterMemoryManager) {
                setTimeout(async () => {
                    try {
                        await window.characterMemoryManager.checkAndUpdateMemory(member.id, currentContact);
                    } catch (error) {
                        console.error(`群聊成员记忆更新失败 - ${member.name}:`, error);
                    }
                }, 1000);
            }
        }
        
        // 更新群聊最后消息和时间
        if (groupMessages.length > 0) {
            const lastMessage = groupMessages[groupMessages.length - 1];
            currentContact.lastMessage = `${lastMessage.speaker}: ${lastMessage.content.substring(0, 15)}...`;
            currentContact.lastTime = formatContactListTime(new Date().toISOString());
            await renderContactList();
            await saveDataToDB();
        }
        
    } catch (error) {
        console.error('群聊消息发送错误:', error);
        console.error('群聊错误详情:', {
            groupInfo: {
                id: currentContact.id,
                name: currentContact.name,
                membersCount: currentContact.members ? currentContact.members.length : 0
            },
            errorName: error.name,
            errorMessage: error.message,
            timestamp: new Date().toISOString()
        });
        hideTypingIndicator();
        showTopNotification(`群聊回复失败: ${error.message}`);
    }
}

async function showTypingIndicator(contact = null) {
    const chatMessages = document.getElementById('chatMessages');
    let indicator = document.getElementById('typingIndicator');
    if (indicator) indicator.remove();
    indicator = document.createElement('div');
    indicator.className = 'message received';
    indicator.id = 'typingIndicator';
    chatMessages.appendChild(indicator);
    const displayContact = contact || currentContact;
    
    let avatarContent = '';
    if (displayContact) {
        avatarContent = await getAvatarHTML(displayContact, 'contact') || displayContact.name[0];
    }
    
    indicator.innerHTML = `<div class="message-avatar">${avatarContent}</div><div class="message-bubble"><div class="typing-indicator"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div></div>`;
    // 延时滚动，让打字指示器的动画先开始
    setTimeout(() => {
        chatMessages.scrollTo({
            top: chatMessages.scrollHeight,
            behavior: 'smooth'
        });
    }, 100); // 稍微延长延时，让动画更明显
}

function hideTypingIndicator() {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) indicator.remove();
}

/**
 * 单独添加一条新消息，而不是重新渲染整个聊天界面
 */
async function addSingleMessage(message, isNewMessage = false) {
    const chatMessages = document.getElementById('chatMessages');
    
    // 创建消息元素
    const msgDiv = document.createElement('div');
    if (message.role === 'system') return;
    
    msgDiv.className = `message ${message.role === 'user' ? 'sent' : 'received'}${isNewMessage ? ' new-message' : ''}`;
    // 设置正确的消息索引
    const messageIndex = currentContact.messages.findIndex(m => m === message);
    msgDiv.dataset.messageIndex = messageIndex >= 0 ? messageIndex : currentContact.messages.length - 1;

    let contentHtml = '';
    if (message.type === 'emoji') {
        contentHtml = await renderEmojiContent(message.content);
    } else if (message.type === 'red_packet') {
        const packet = JSON.parse(message.content);
        contentHtml = `<div class="message-content red-packet" onclick="showToast('红包金额: ${packet.amount}')"><div class="red-packet-body"><svg class="red-packet-icon" viewBox="0 0 1024 1024"><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32zM731.2 565.2H603.9c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8zM419.8 565.2H292.5c-4.4 0-8 3.6-8 8v128.3c0 4.4 3.6 8 8 8h127.3c4.4 0 8-3.6 8-8V573.2c0-4.4-3.6-8-8-8z" fill="#FEFEFE"></path><path d="M872.4 240H151.6c-17.7 0-32 14.3-32 32v64h784v-64c0-17.7-14.3-32-32-32z" fill="#FCD4B3"></path><path d="M512 432c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88z m0 152c-35.3 0-64-28.7-64-64s28.7-64 64-64 64 28.7 64 64-28.7 64-64-64z" fill="#FCD4B3"></path><path d="M840.4 304H183.6c-17.7 0-32 14.3-32 32v552c0 17.7 14.3 32 32 32h656.8c17.7 0 32-14.3 32-32V336c0-17.7-14.3-32-32-32z m-32 552H215.6V368h624.8v488z" fill="#F37666"></path><path d="M512 128c-112.5 0-204 91.5-204 204s91.5 204 204 204 204-91.5 204-204-91.5-204-204-204z m0 384c-99.4 0-180-80.6-180-180s80.6-180 180-180 180 80.6 180 180-80.6 180-180 180z" fill="#F37666"></path><path d="M512 456c-35.3 0-64 28.7-64 64s28.7 64 64 64 64 28.7 64 64-28.7-64-64-64z m16.4 76.4c-2.3 2.3-5.4 3.6-8.5 3.6h-15.8c-3.1 0-6.2-1.3-8.5-3.6s-3.6-5.4-3.6-8.5v-27.8c0-6.6 5.4-12 12-12h16c6.6 0 12 5.4 12 12v27.8c0.1 3.1-1.2 6.2-3.5 8.5z" fill="#F37666"></path></svg><div class="red-packet-text"><div>${packet.message || '恭喜发财，大吉大利！'}</div><div>领取红包</div></div></div><div class="red-packet-footer">AI红包</div></div>`;
    } else {
        contentHtml = await processTextWithInlineEmojis(message.content);
    }

    let avatarContent = '';
    if (message.role === 'assistant') {
        if (currentContact.type === 'group') {
            // 修复：从contacts数组中查找成员，而不是从members数组（members只存储ID）
            const member = contacts.find(c => c.id === message.senderId);
            avatarContent = member ? (await getAvatarHTML(member, 'contact') || member.name[0]) : '🤖';
        } else {
            avatarContent = await getAvatarHTML(currentContact, 'contact') || currentContact.name[0];
        }
    } else {
        avatarContent = await getAvatarHTML(userProfile, 'user') || userProfile?.name?.[0] || '我';
    }

    // 应用自定义气泡样式（与renderMessages中的逻辑保持一致）
    const currentBubbleStyle = message.role === 'user' ? 
        (window.customBubbleStyleSelf || window.customBubbleStyle) : 
        (window.customBubbleStyleKare || window.customBubbleStyle);
        
    let bubbleHtml = '';
    if (currentBubbleStyle && currentBubbleStyle.html && message.type !== 'emoji' && message.type !== 'red_packet') {
        // 使用自定义气泡样式 - 获取原始内容，不包装 message-content
        console.log(`应用${message.role === 'user' ? '我的' : '对方的'}自定义气泡样式`);
        
        let rawContent = '';
        if (message.type === 'emoji') {
            rawContent = await renderEmojiContent(message.content);
        } else if (message.type === 'red_packet') {
            // 红包保持原有格式
            rawContent = contentHtml;
        } else {
            // 处理文本，但不包装 message-content
            rawContent = message.content.replace(/\n/g, '<br>');
            
            // 处理内联表情
            const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
            const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
            for (const match of emojiMatches) {
                const fullMatch = match[0];
                const emojiName = match[1];
                const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                
                if (foundEmoji && foundEmoji.tag) {
                    const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                    rawContent = rawContent.replace(fullMatch, emojiHtml);
                } else if (foundEmoji && foundEmoji.url) {
                    const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                    rawContent = rawContent.replace(fullMatch, replacement);
                }
            }
        }
        
        bubbleHtml = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', rawContent);
        
        // 处理HTML中的file:格式图片
        bubbleHtml = await processFileUrlsInHtml(bubbleHtml);
        
        // 清理 HTML 中的转义换行符，避免显示 \n
        bubbleHtml = bubbleHtml.replace(/\\n/g, '');
        // console.log('生成的自定义气泡 HTML:', bubbleHtml);
    } else {
        // 使用默认气泡样式
        console.log('使用默认气泡样式，自定义样式状态:', {
            hasCustomStyle: !!window.customBubbleStyle,
            hasHtml: !!window.customBubbleStyle?.html
        });
        bubbleHtml = `<div class="message-bubble">${contentHtml}</div>`;
    }

    if (currentContact.type === 'group' && message.role === 'assistant') {
        // 修复：从contacts数组中查找成员
        const member = contacts.find(c => c.id === message.senderId);
        const memberName = member ? member.name : '未知成员';
        
        if (currentBubbleStyle && currentBubbleStyle.html && message.type !== 'emoji' && message.type !== 'red_packet') {
            // 对于群聊消息，在自定义气泡前添加发送者信息
            const groupHeader = `<div class="group-message-header"><div class="group-message-name">${memberName}</div></div>`;
            
            // 获取原始内容（与上面相同的逻辑）
            let rawContent = '';
            if (message.type === 'emoji') {
                rawContent = await renderEmojiContent(message.content);
            } else if (message.type === 'red_packet') {
                rawContent = contentHtml;
            } else {
                rawContent = message.content.replace(/\n/g, '<br>');
                const emojiTagRegex = /\[emoji:([^\]]+)\]/g;
                const emojiMatches = [...rawContent.matchAll(emojiTagRegex)];
                for (const match of emojiMatches) {
                    const fullMatch = match[0];
                    const emojiName = match[1];
                    const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                    
                    if (foundEmoji && foundEmoji.tag) {
                        const emojiHtml = await renderEmojiContent(`[emoji:${foundEmoji.tag}]`, true);
                        rawContent = rawContent.replace(fullMatch, emojiHtml);
                    } else if (foundEmoji && foundEmoji.url) {
                        const replacement = `<img src="${foundEmoji.url}" style="max-width: 100px; max-height: 100px; border-radius: 8px; vertical-align: middle; margin: 2px;">`;
                        rawContent = rawContent.replace(fullMatch, replacement);
                    }
                }
            }
            
            let customBubbleWithHeader = currentBubbleStyle.html.replace('{{BUBBLE_TEXT}}', groupHeader + rawContent);
            
            // 处理HTML中的file:格式图片
            customBubbleWithHeader = await processFileUrlsInHtml(customBubbleWithHeader);
            
            // 清理 HTML 中的转义换行符，避免显示 \n
            customBubbleWithHeader = customBubbleWithHeader.replace(/\\n/g, '');
            msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${customBubbleWithHeader}`;
        } else {
            msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div><div class="message-bubble"><div class="group-message-header"><div class="group-message-name">${memberName}</div></div>${contentHtml}</div>`;
        }
    } else {
        msgDiv.innerHTML = `<div class="message-avatar">${avatarContent}</div>${bubbleHtml}`;
    }

    // 添加长按事件监听器 - 修复新消息无法长按弹出菜单的问题
    if (!isMultiSelectMode) {
        const originalIndex = parseInt(msgDiv.dataset.messageIndex);
        addMessageActionListeners(msgDiv, originalIndex);
    }

    // 添加到聊天界面
    chatMessages.appendChild(msgDiv);

    // 处理语音消息UI
    setupVoiceMessageUI(msgDiv, message, currentContact);

    // 只有新消息才滚动到底部，避免每次添加消息都重新滚动
    if (isNewMessage) {
        setTimeout(() => {
            chatMessages.scrollTo({
                top: chatMessages.scrollHeight,
                behavior: 'smooth'
            });
        }, 150); // 新消息延时150ms，让滑入动画更明显
    }
}

/**
 * 检测消息数组中是否包含图像消息
 * @param {array} messages - 消息数组
 * @returns {boolean} 是否包含图像消息
 */
function _hasImageMessages(messages) {
    return messages.some(msg => 
        Array.isArray(msg.content) && 
        msg.content.some(part => part.type === 'image_url')
    );
}

/**
 * 通过我们的 Netlify Function 代理来调用 API。
 * @param {object} contact The contact object.
 * @param {array} turnContext Additional messages for group chat context.
 * @returns {object} The API response containing replies and the new memory table.
 */
async function callAPI(contact, turnContext = []) {
    try {
        // 获取完整API调用信息（包含模型）
        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            throw new Error('请先设置API和模型');
        }

        // 1. 检测当前模型是否支持图像
        const currentModelForVision = await getCurrentModel();
        const supportsVision = window.modelCapabilityDetector?.supportsVision(currentModelForVision) || false;
        console.log(`[callAPI] 当前模型 ${currentModelForVision} 图像支持: ${supportsVision}`);

        // 2. 构建系统提示词
        const systemPrompt = await window.promptBuilder.buildChatPrompt(
            contact,
            userProfile,
            currentContact,
            apiCallInfo,
            emojis,
            window,
            turnContext
        );

        // 3. 构建消息数组（现在支持图像）
        const messages = [{ role: 'system', content: systemPrompt }];
        const messageHistory = await window.promptBuilder.buildMessageHistory(
            currentContact,
            apiCallInfo,
            userProfile,
            contacts,
            contact,
            emojis,
            turnContext,
            supportsVision // 传递图像支持标志
        );

        messages.push(...messageHistory);

        // 4. 如果模型不支持图像但消息中包含图像，记录警告
        if (!supportsVision && _hasImageMessages(messageHistory)) {
            console.warn('[callAPI] 当前模型不支持图像分析，图片消息已转为文本描述');
        }

        // 5. 调用API
        console.log(`[多key调试] callAPI被调用，当前使用的API Key: ${apiCallInfo.key ? apiCallInfo.key.substring(0, 10) + '...' : 'null'}`);

        const data = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            messages,
            {},
            (apiCallInfo.timeout || 60) * 1000
        );
        

        // 4. 处理响应
        if (!data) {
            throw new Error('API返回数据为空');
        }

        let fullResponseText;
        if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
            // 标准OpenAI格式
            fullResponseText = data.choices[0].message.content;
        } else if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0]) {
            // Gemini API 格式
            fullResponseText = data.candidates[0].content.parts[0].text;
        } else if (data.content) {
            // 可能的替代格式
            fullResponseText = data.content;
        } else if (data.message) {
            // 另一种可能的格式
            fullResponseText = data.message;
        } else {
            // 检查是否是因为没有生成内容
            if (data.choices && data.choices[0] && data.choices[0].finish_reason === 'content_filter') {
                throw new Error('AI模型没有生成回复，可能是内容被过滤，请检查输入或稍后重试');
            }
            console.error('API响应格式不支持:', data);
            throw new Error('API响应格式不支持，无法提取回复内容');
        }

        // 检查内容是否有效
        if (!fullResponseText || fullResponseText.trim() === '') {
            throw new Error('AI回复内容为空，请稍后重试');
        }
        
        
        let chatRepliesText = fullResponseText;

        // 群聊模式：如果是群聊，直接返回完整内容，不进行分割
        let replies;
        if (currentContact && currentContact.type === 'group') {
            replies = [chatRepliesText.trim()];
        } else {
            // 处理回复分割（仅用于私聊）
            // 首先检查是否有 ||| 分隔符
            if (chatRepliesText.includes('|||')) {
                replies = chatRepliesText.split('|||').map(r => r.trim()).filter(r => r);
            } 
            // 如果没有 |||，检查是否有 || 分隔符
            else if (chatRepliesText.includes('||')) {
                replies = chatRepliesText.split('||').map(r => r.trim()).filter(r => r);
            }
            // 如果都没有，按换行符分割
            else {
                replies = chatRepliesText.split('\n').map(r => r.trim()).filter(r => r);
            }
        }
        const processedReplies = [];
        
        // 处理特殊消息类型（表情、红包等）
        const emojiNameRegex = /^\[(?:emoji|发送了表情)[:：]([^\]]+)\]$/;
        const redPacketRegex = /^\[red_packet:({.*})\]$/;

        for (const reply of replies) {
            const emojiMatch = reply.match(emojiNameRegex);
            const redPacketMatch = reply.match(redPacketRegex);

            if (emojiMatch) {
                const emojiName = emojiMatch[1];
                const foundEmoji = emojis.find(e => e.tag === emojiName || e.meaning === emojiName);
                if (foundEmoji) {
                    const content = foundEmoji.tag ? `[emoji:${foundEmoji.tag}]` : foundEmoji.url;
                    processedReplies.push({ type: 'emoji', content: content });
                } else {
                    processedReplies.push({ type: 'text', content: reply });
                }
            } else if (redPacketMatch) {
                try {
                    const packetData = JSON.parse(redPacketMatch[1]);
                    if (typeof packetData.amount === 'number' && typeof packetData.message === 'string') {
                         processedReplies.push({ type: 'red_packet', content: JSON.stringify(packetData) });
                    } else {
                         processedReplies.push({ type: 'text', content: reply });
                    }
                } catch (e) {
                    processedReplies.push({ type: 'text', content: reply });
                }
            } else {
                processedReplies.push({ type: 'text', content: reply });
            }
        }
        
        
        return { replies: processedReplies };

    } catch (error) {
        // 尝试获取更可靠的apiCallInfo用于日志，而不是直接使用过时的window.apiSettings
        let apiCallInfoForLog = { url: 'not set', hasKey: false, model: 'not set' };
        try {
            const info = await getApiCallInfo();
            apiCallInfoForLog = {
                url: info?.url ? (info.url.substring(0, 50) + '...') : 'not set',
                hasKey: !!info?.key,
                model: info?.model || 'not set'
            };
        } catch (e) {
            // 如果获取失败，尝试从兼容对象读取，保持旧日志结构
            apiCallInfoForLog = {
                url: (window.apiSettings && window.apiSettings.url) ? (window.apiSettings.url.substring(0,50) + '...') : 'not set',
                hasKey: !!(window.apiSettings && window.apiSettings.key),
                model: (window.modelSettings && window.modelSettings.primaryModel) ? window.modelSettings.primaryModel : 'not set'
            };
        }

        // 获取当前模型的可读名称作为补充信息
        let currentModelName = 'not set';
        try {
            currentModelName = await getCurrentModel() || currentModelName;
        } catch (e) {
            console.warn('Failed to get current model name for error logging:', e);
        }

        console.error('callAPI错误详情:', {
            errorName: error.name,
            errorMessage: error.message,
            errorStack: error.stack,
            contact: contact ? {
                id: contact.id,
                name: contact.name,
                type: contact.type
            } : null,
            turnContextLength: turnContext ? turnContext.length : 0,
            apiSettings: apiCallInfoForLog,
            currentModel: currentModelName,
            timestamp: new Date().toISOString(),
            networkStatus: navigator.onLine ? 'online' : 'offline'
        });

        // 不再抛出错误，让showApiError处理重试逻辑
        showApiError(error);
        return null; // 返回null表示API调用失败
    }
}


async function testApiConnection() {
    // 声明变量，使其在try-catch块外可访问
    let enabledKey = '';
    let keyElement = null; // 存储对应的DOM元素
    
    try {
        const url = document.getElementById('apiUrl')?.value?.trim();
        
        if (!url) {
            showToast('请填写API URL');
            return;
        }
        
        // 检查主key是否有值
        const mainKey = document.getElementById('apiKey')?.value?.trim();
        if (mainKey) {
            enabledKey = mainKey; // 默认使用主key
            keyElement = document.getElementById('apiKey');
        }
        
        // 检查是否有额外key被启用
        const enabledButtons = document.querySelectorAll('.key-enable-btn[data-enabled="true"]');
        if (enabledButtons.length > 0) {
            const enabledButton = enabledButtons[0];
            const row = enabledButton.closest('.api-provider-row');
            const keyInput = row?.querySelector('.api-key-input');
            if (keyInput && keyInput.value.trim()) {
                enabledKey = keyInput.value.trim();
                keyElement = keyInput;
            }
        }
        
        if (!enabledKey) {
            showToast('请填写至少一个API Key');
            return;
        }
        
        console.log('测试连接使用的key前8位:', enabledKey.substring(0, 8) + '...');

        // 测试连接
        console.log(`[测试连接] window.apiService存在: ${!!window.apiService}`);
        console.log(`[测试连接] window.apiService.testConnection类型: ${typeof window.apiService?.testConnection}`);
        
        if (!window.apiService) {
            // 尝试重新初始化APIService
            if (typeof APIService !== 'undefined') {
                console.log('[测试连接] 重新初始化APIService');
                window.apiService = new APIService();
            } else {
                throw new Error('APIService类未定义，请检查api.js是否正确加载');
            }
        }
        
        if (typeof window.apiService.testConnection !== 'function') {
            console.error('window.apiService对象:', window.apiService);
            console.error('可用方法:', Object.getOwnPropertyNames(window.apiService));
            throw new Error('testConnection方法不存在');
        }
        
        const data = await window.apiService.testConnection(url, enabledKey);
        const models = data.data ? data.data.map(m => m.id).sort() : [];

        // 连接成功，但不重写模型选择框
        if (models.length === 0) {
            showToast('连接成功，但未找到可用模型');
        } else {
            showToast(`连接成功，找到 ${models.length} 个可用模型`);
        }
        
        // 只缓存模型列表，不更新UI
        if (models && models.length > 0 && window.apiConfigManager) {
            const activeConfig = await window.apiConfigManager.getActiveConfig();
            if (activeConfig) {
                window.apiConfigManager.availableModels.set(activeConfig.id, models);
                console.log(`[测试连接] 已缓存 ${models.length} 个模型到配置 ${activeConfig.id}`);
            }
        }

    } catch (error) {
        console.error('测试连接失败:', error);
        
        // 标记测试失败的key为失败状态，并传递具体错误信息
        if (keyElement) {
            console.log('标记key为失败状态:', keyElement.id || 'secondary key');
            markKeyAsFailed(keyElement, '连接失败: ' + error.message);
        } else {
            console.error('无法标记key为失败状态: keyElement为null');
            showToast('连接失败: ' + error.message);
        }
    }
}

function handlePrimaryModelChange() {
    const primaryModel = document.getElementById('primaryModelSelect').value;
    const secondarySelect = document.getElementById('secondaryModelSelect');
    
    // 立即更新全局模型设置
        if (window.modelSettings) {
            window.modelSettings.primaryModel = primaryModel;
        console.log('主模型已更新为:', primaryModel);
    }
    
    // 如果次要模型设置为"同步"，则在数据层面更新它
    if (window.modelSettings && window.modelSettings.secondaryModel === 'sync_with_primary') {
        // 不需要直接修改UI，保存时会处理
    }
}

async function saveApiConfig(event) {
    event.preventDefault();
    
    try {
        if (!window.apiConfigManager) {
            throw new Error('配置管理器未初始化');
        }
        
        // 获取表单数据
        const getElementValue = (id, defaultValue = '') => {
            const element = document.getElementById(id);
            return element ? element.value.trim() : defaultValue;
        };
        
        const configName = getElementValue('configName');
        const apiUrl = getElementValue('apiUrl');
        const apiKey = getElementValue('apiKey');
        const timeout = parseInt(getElementValue('apiTimeout')) || 60;
        
        // 验证必填字段
        if (!configName) {
            showToast('请输入配置名称');
            return;
        }
        
        if (!apiUrl || !apiKey) {
            showToast('请输入API URL和API Key');
            return;
        }
        
        // 构建完整的API Keys数组（包括主key和所有副key）
        const allApiKeys = [];
        
        // 首先添加主key（始终在index 0）
        const mainKeyStatus = document.querySelector('.main-key-status');
        const mainKeyEnabled = mainKeyStatus ? (mainKeyStatus.dataset.enabled === 'true' && mainKeyStatus.dataset.status === 'enabled') : true;
        
        allApiKeys.push({
            key: apiKey,
            name: '主Key',
            enabled: mainKeyEnabled,
            index: 0
        });
        
        // 然后添加所有副key
        const providerRows = document.querySelectorAll('.api-provider-row');
        providerRows.forEach((row, index) => {
            const keyInput = row.querySelector('.api-key-input');
            const enableButton = row.querySelector('.key-enable-btn');
            if (keyInput && keyInput.value.trim()) {
                allApiKeys.push({
                    key: keyInput.value.trim(),
                    name: `Key ${index + 1}`,
                    enabled: enableButton ? (enableButton.dataset.enabled === 'true' && enableButton.dataset.status === 'enabled') : false,
                    index: index + 1
                });
            }
        });
        
        // 获取模型选择
        const primaryModel = getElementValue('primaryModelSelect');
        const secondaryModel = getElementValue('secondaryModelSelect');
        
        // 获取上下文消息数量
        const contextMessageCount = parseInt(getElementValue('contextSlider')) || 10;
        
        // 检查是否为新配置（通过按钮状态或其他标识判断）
        const isNewConfig = window.currentConfigState === 'new';
        const configSelector = document.getElementById('configSelector');
        const currentConfigId = isNewConfig ? null : configSelector?.value || null;
        
        // 构建配置数据 - 保持原有key结构，只更新启用状态
        const configData = {
            configId: currentConfigId,
            configName,
            url: apiUrl,
            key: apiKey, // 保持主key不变
            model: primaryModel,
            secondaryModel: secondaryModel,
            contextMessageCount,
            timeout,
            apiKeys: allApiKeys // 使用完整的apiKeys结构
        };
        
        console.log('[API配置保存] 准备保存的配置数据:', {
            key: apiKey.substring(0, 10) + '...',
            apiKeysCount: allApiKeys.length,
            enabledKeys: allApiKeys.filter(k => k.enabled).map(k => ({
                index: k.index, 
                keyPrefix: k.key.substring(0, 10) + '...'
            }))
        });
        
        // 保存配置
        const savedConfig = await window.apiConfigManager.saveConfig(configData);
        
        // 如果是新配置，切换到新配置
        if (!currentConfigId || currentConfigId === '') {
            await window.apiConfigManager.switchToConfig(savedConfig.id);
        }
        
        // 重新加载配置选择器
        await loadConfigSelector();
        
        // 设置选中的配置
        if (configSelector) {
            configSelector.value = savedConfig.id;
        }
        
        // 重置新配置状态
        window.currentConfigState = null;
        
        showToast('API配置保存成功');
        
        // 显示成功提示并隐藏流程提醒
        showConfigSaveSuccess();
        
        // 立即更新全局API设置
        await ensureApiConfigIsUpdated();
        
    } catch (error) {
        console.error('保存API配置失败:', error);
        showToast('保存API配置失败: ' + error.message);
    }
}

async function saveAppSettings(event) {
    event.preventDefault();
    
    // 验证用户流程完整性
    if (!validateUserFlow()) {
        return;
    }
    
    try {
        // 获取表单数据
        const getElementValue = (id, defaultValue = '') => {
            const element = document.getElementById(id);
            return element ? element.value.trim() : defaultValue;
        };
        
        const primaryConfig = getElementValue('primaryConfigSelect');
        const primaryModel = getElementValue('primaryModelSelect');
        const secondaryConfig = getElementValue('secondaryConfigSelect', 'sync_with_primary');
        const secondaryModel = getElementValue('secondaryModelSelect', 'sync_with_primary');
        const contextMessageCount = parseInt(getElementValue('contextSlider')) || 10;
        const minimaxGroupId = getElementValue('minimaxGroupId');
        const minimaxApiKey = getElementValue('minimaxApiKey');
        const unsplashKey = getElementValue('unsplashApiKey');
        
        // 保存应用设置到localStorage（这些不属于API配置）
        localStorage.setItem('primaryModelConfig', primaryConfig);
        localStorage.setItem('primaryModel', primaryModel);
        localStorage.setItem('secondaryModelConfig', secondaryConfig);
        localStorage.setItem('secondaryModel', secondaryModel);
        localStorage.setItem('contextMessageCount', contextMessageCount.toString());
        localStorage.setItem('minimaxGroupId', minimaxGroupId);
        localStorage.setItem('minimaxApiKey', minimaxApiKey);
        
        // 保存 Unsplash API Key
        if (unsplashKey) {
            localStorage.setItem('forumUnsplashApiKey', unsplashKey);
            localStorage.setItem('unsplashApiKey', unsplashKey);
        } else {
            localStorage.removeItem('forumUnsplashApiKey');
            localStorage.removeItem('unsplashApiKey');
        }
        
        // 重新初始化图片关键词生成器
        if (window.imageKeywordGenerator && window.apiService) {
            window.imageKeywordGenerator.init(window.apiSettings, window.apiService);
            console.log('图片关键词生成器已更新配置');
        }
        
        updateContextIndicator();
        showToast('应用设置保存成功');
        
        // 显示流程完成消息
        showFlowCompletionMessage();
        
    } catch (error) {
        console.error('保存应用设置失败:', error);
        showToast('保存应用设置失败: ' + error.message);
    }
}

async function loadApiConfigSelectorsForModels() {
    try {
        if (!window.apiConfigManager) return;
        
        const configs = await window.apiConfigManager.getAllConfigs();
        
        // 为主要模型和次要模型的配置选择器添加选项
        const primaryConfigSelect = document.getElementById('primaryConfigSelect');
        const secondaryConfigSelect = document.getElementById('secondaryConfigSelect');
        
        if (primaryConfigSelect) {
            primaryConfigSelect.innerHTML = '<option value="">选择API配置</option>';
            configs.forEach(config => {
                const option = document.createElement('option');
                option.value = config.id;
                option.textContent = config.configName;
                primaryConfigSelect.appendChild(option);
            });
        }
        
        if (secondaryConfigSelect) {
            secondaryConfigSelect.innerHTML = '<option value="">选择API配置</option><option value="sync_with_primary">与主模型保持一致</option>';
            configs.forEach(config => {
                const option = document.createElement('option');
                option.value = config.id;
                option.textContent = config.configName;
                secondaryConfigSelect.appendChild(option);
            });
        }
        
        // 加载保存的选择
        const savedPrimaryConfig = localStorage.getItem('primaryModelConfig');
        const savedPrimaryModel = localStorage.getItem('primaryModel');
        const savedSecondaryConfig = localStorage.getItem('secondaryModelConfig');
        const savedSecondaryModel = localStorage.getItem('secondaryModel');
        
        if (savedPrimaryConfig && primaryConfigSelect) {
            primaryConfigSelect.value = savedPrimaryConfig;
            await loadModelsForConfig('primaryConfigSelect', 'primaryModelSelect');
            if (savedPrimaryModel) {
                const primaryModelSelect = document.getElementById('primaryModelSelect');
                if (primaryModelSelect) {
                    primaryModelSelect.value = savedPrimaryModel;
                }
            }
        }
        
        if (savedSecondaryConfig && secondaryConfigSelect) {
            secondaryConfigSelect.value = savedSecondaryConfig;
            if (savedSecondaryConfig !== 'sync_with_primary') {
                await loadModelsForConfig('secondaryConfigSelect', 'secondaryModelSelect');
                if (savedSecondaryModel) {
                    const secondaryModelSelect = document.getElementById('secondaryModelSelect');
                    if (secondaryModelSelect) {
                        secondaryModelSelect.value = savedSecondaryModel;
                    }
                }
            }
        }
        
    } catch (error) {
        console.error('加载API配置选择器失败:', error);
    }
}

// 检查API Key是否重复
function checkKeyDuplicate(keyValue, excludeInput = null) {
    // 获取主key
    const mainKeyInput = document.getElementById('apiKey');
    if (mainKeyInput !== excludeInput && mainKeyInput.value.trim() === keyValue) {
        return true;
    }
    
    // 获取所有副key
    const secondaryKeyInputs = document.querySelectorAll('.api-provider-row .api-key-input');
    for (const input of secondaryKeyInputs) {
        if (input !== excludeInput && input.value.trim() === keyValue) {
            return true;
        }
    }
    
    return false;
}

// 处理API Key输入，检查重复
function handleApiKeyInput(input, event) {
    const keyValue = input.value.trim();
    
    if (keyValue && checkKeyDuplicate(keyValue, input)) {
        // 如果有重复，显示警告
        input.style.borderColor = '#dc3545';
        showToast('API Key不能重复！', 'warning');
        
        // 可选：清除重复的值
        // input.value = '';
    } else {
        // 没有重复，恢复正常边框
        input.style.borderColor = '';
    }
}

// 检查所有API Key是否有重复
function checkAllApiKeysForDuplicates() {
    const allKeyInputs = document.querySelectorAll('.api-key-input');
    const keyMap = new Map(); // 存储key值和对应的输入框
    
    // 重置所有边框
    allKeyInputs.forEach(input => {
        input.style.borderColor = '';
    });
    
    // 检查重复
    let hasDuplicates = false;
    allKeyInputs.forEach(input => {
        const keyValue = input.value.trim();
        if (!keyValue) return;
        
        if (keyMap.has(keyValue)) {
            // 发现重复
            hasDuplicates = true;
            input.style.borderColor = '#dc3545';
            keyMap.get(keyValue).style.borderColor = '#dc3545';
        } else {
            keyMap.set(keyValue, input);
        }
    });
    
    if (hasDuplicates) {
        showToast('检测到重复的API Keys，请检查！', 'warning');
    }
}

function addProviderRow() {
    try {
        console.log('添加新的API Key行');
        
        // 找到API配置表单中的基本设置部分
        const configSection = document.querySelector('.config-section');
        if (!configSection) {
            console.error('未找到配置部分容器');
            showToast('无法添加新行：未找到配置容器');
            return;
        }
        
        // 计算这是第几个Key（从1开始，0是主Key）
        const existingRows = document.querySelectorAll('.api-provider-row').length;
        const keyIndex = existingRows + 1;
        
        // 创建新的API Key行
        const newKeyRow = document.createElement('div');
        newKeyRow.className = 'form-group api-provider-row';
        newKeyRow.innerHTML = `
            <div class="key-header">
                <label class="form-label">API Key ${keyIndex}</label>
                <button type="button" class="remove-provider-btn" onclick="removeProviderRow(this, event)" title="移除此Key">×</button>
            </div>
            <div class="compact-key-row additional-key-row">
                <input type="password" class="form-input api-key-input compact-key-input" placeholder="输入API Key" oninput="updateKeyStats(this); handleApiKeyInput(this, event)">
                <button type="button" class="key-enable-btn" onclick="toggleKeyEnable(this)" data-enabled="false" data-status="disabled" title="点击启用此Key">⚪</button>
                <div class="key-stats-compact">
                    <div class="key-masked-compact">未设置</div>
                    <div class="stats-compact">
                        <span class="calls-count">0次</span>/<span class="success-rate">0%</span>
                    </div>
                </div>
            </div>
        `;
        
        // 找到现有API Key输入框的父容器，在其后插入新行
        const apiKeyGroup = document.querySelector('#apiKey').closest('.form-group');
        if (apiKeyGroup && apiKeyGroup.parentNode) {
            apiKeyGroup.parentNode.insertBefore(newKeyRow, apiKeyGroup.nextSibling);
            console.log('成功添加新的API Key行');
        } else {
            console.error('未找到API Key输入框容器');
            showToast('无法添加新行：未找到API Key容器');
        }
        
    } catch (error) {
        console.error('添加API Key行失败:', error);
        showToast('添加新行失败: ' + error.message);
    }
}

function removeProviderRow(button, event) {
    try {
        // 阻止事件冒泡
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        
        const row = button.closest('.api-provider-row');
        if (row) {
            row.remove();
            console.log('移除API Key行成功');
            showToast('已移除API Key行');
        }
    } catch (error) {
        console.error('移除API Key行失败:', error);
        showToast('移除行失败: ' + error.message);
    }
}

// 标记API Key为失败状态
async function markKeyAsFailed(keyElement, errorMessage = null) {
    try {
        if (!keyElement) {
            console.error('markKeyAsFailed: keyElement为null');
            return;
        }
        
        console.log('markKeyAsFailed: 开始处理key', keyElement.id || 'secondary key');
        
        // 判断是主key还是额外key
        if (keyElement.id === 'apiKey') {
            // 主key - 使用主key状态按钮
            const mainKeyStatusBtn = document.querySelector('.main-key-status');
            if (mainKeyStatusBtn) {
                console.log('markKeyAsFailed: 找到主key状态按钮，设置为失败状态');
                mainKeyStatusBtn.dataset.status = 'failed';
                mainKeyStatusBtn.dataset.enabled = 'false';
                mainKeyStatusBtn.style.backgroundColor = 'white'; // 白色背景
                mainKeyStatusBtn.textContent = '🔴'; // 红色圆圈
                // 更新全局设置
                if (window.apiConfigManager) {
                    await window.apiConfigManager.setKeyEnabled('', false); // 清除启用的key
                }
            } else {
                console.error('markKeyAsFailed: 未找到主key状态按钮(.main-key-status)');
            }
        } else {
            // 额外key - 找到对应的状态按钮
            const row = keyElement.closest('.api-provider-row');
            if (row) {
                const statusBtn = row.querySelector('.key-enable-btn');
                if (statusBtn) {
                    console.log('markKeyAsFailed: 找到副key状态按钮，设置为失败状态');
                    statusBtn.dataset.status = 'failed';
                    statusBtn.dataset.enabled = 'false';
                    statusBtn.style.backgroundColor = 'white'; // 白色背景
                    statusBtn.textContent = '🔴'; // 红色圆圈
                    // 如果这个key是启用状态，需要更新配置
                    const keyValue = keyElement.value.trim();
                    if (keyValue && window.apiConfigManager) {
                        try {
                            // 获取当前配置
                            const currentConfig = await window.apiConfigManager.getActiveConfig();
                            if (currentConfig) {
                                const currentEnabled = window.apiConfigManager.getEnabledKey(currentConfig);
                                if (currentEnabled === keyValue) {
                                    // 如果被标记失败的是当前启用的key，清除启用状态
                                    if (keyElement.id === 'apiKey') {
                                        // 主key，不需要特殊处理
                                    } else {
                                        // 副key，禁用它
                                        statusBtn.dataset.enabled = 'false';
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn('更新配置状态失败:', error);
                        }
                    }
                } else {
                    console.error('markKeyAsFailed: 在row中未找到.key-enable-btn按钮');
                }
            } else {
                console.error('markKeyAsFailed: 未找到key的父行(.api-provider-row)');
            }
        }
        
        // 显示具体的错误信息，而不是通用的失败消息
        if (errorMessage) {
            showToast(errorMessage);
        }
        
    } catch (error) {
        console.error('标记Key失败状态出错:', error);
    }
}

async function toggleKeyEnable(button) {
    try {
        const currentStatus = button.dataset.status || 'disabled';
        const row = button.closest('.api-provider-row');
        const keyInput = row.querySelector('.api-key-input');
        const keyValue = keyInput ? keyInput.value.trim() : '';
        
        if (!keyValue) {
            showToast('请先填写API Key');
            return;
        }
        
        // 状态切换逻辑：disabled -> enabled -> disabled -> failed -> enabled
        let newStatus, newIcon, newTitle, newColor;
        
        console.log(`[多key调试] toggleKeyEnable被调用: 当前状态=${currentStatus}, key前缀=${keyValue.substring(0, 10)}...`);
        
        switch (currentStatus) {
            case 'disabled':
                // 禁用 -> 启用
                newStatus = 'enabled';
                newIcon = '🟢';
                newTitle = '已启用 (点击禁用)';
                newColor = '#28a745';
                
                // 禁用所有其他key
                await disableAllOtherKeys();
                
                // 启用这个key
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('已启用此API Key');
                break;
                
            case 'enabled':
                // 启用 -> 禁用
                newStatus = 'disabled';
                newIcon = '⚪';
                newTitle = '已禁用 (点击启用)';
                newColor = '#6c757d';
                button.dataset.enabled = 'false';
                
                // 回退到主key
                await enableMainKey();
                showToast('已禁用此API Key');
                break;
                
            case 'failed':
                // 失败 -> 启用
                newStatus = 'enabled';
                newIcon = '🟢';
                newTitle = '已启用 (点击禁用)';
                newColor = '#28a745';
                
                // 禁用所有其他key
                await disableAllOtherKeys();
                
                // 启用这个key
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('已重新启用此API Key');
                break;
        }
        
        // 更新按钮状态
        button.dataset.status = newStatus;
        button.innerHTML = newIcon;
        button.title = newTitle;
        button.style.backgroundColor = newColor;
        
        // 更新对应行的样式
        if (newStatus === 'enabled') {
            row.classList.add('enabled');
        } else {
            row.classList.remove('enabled');
        }
        
        // 统一更新所有key的状态
        setTimeout(() => {
            updateAllKeyStates();
        }, 100);
        
    } catch (error) {
        console.error('切换Key状态失败:', error);
        showToast('操作失败: ' + error.message);
    }
}

async function toggleMainKeyStatus(button) {
    try {
        const currentStatus = button.dataset.status || 'enabled';
        const keyInput = document.getElementById('apiKey');
        const keyValue = keyInput ? keyInput.value.trim() : '';
        
        if (!keyValue) {
            showToast('请先填写主API Key');
            return;
        }
        
        let newStatus, newIcon, newTitle, newColor;
        
        switch (currentStatus) {
            case 'enabled':
                // 启用 -> 禁用（用户点击只能禁用，不能直接标记为失败）
                newStatus = 'disabled';
                newIcon = '⚪';
                newTitle = '主Key未启用 (点击启用)';
                newColor = '#6c757d';
                button.dataset.enabled = 'false';
                showToast('已禁用主API Key');
                break;
                
            case 'failed':
                // 失败 -> 启用
                newStatus = 'enabled';
                newIcon = '🟢';
                newTitle = '主Key已启用 (点击禁用)';
                newColor = '#28a745';
                
                // 禁用所有副key
                await disableAllOtherKeys();
                
                // 启用主key
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('已重新启用主API Key');
                break;
                
            case 'disabled':
                // 禁用 -> 启用（当副key被启用时主key会变为禁用状态）
                newStatus = 'enabled';
                newIcon = '🟢';
                newTitle = '主Key已启用 (点击禁用)';
                newColor = '#28a745';
                
                // 禁用所有副key
                await disableAllOtherKeys();
                
                // 启用主key
                button.dataset.enabled = 'true';
                await updateGlobalApiKey(keyValue);
                showToast('已启用主API Key');
                break;
        }
        
        // 更新按钮状态
        button.dataset.status = newStatus;
        button.innerHTML = newIcon;
        button.title = newTitle;
        // 主key按钮不设置背景色，保持透明
        
        // 更新主key行的样式
        const mainKeyRow = document.querySelector('.main-key-row');
        if (mainKeyRow) {
            if (newStatus === 'enabled') {
                mainKeyRow.classList.add('enabled');
            } else {
                mainKeyRow.classList.remove('enabled');
            }
        }
        
        // 统一更新所有key的状态
        setTimeout(() => {
            updateAllKeyStates();
        }, 100);
        
    } catch (error) {
        console.error('切换主Key状态失败:', error);
        showToast('操作失败: ' + error.message);
    }
}

// 辅助函数：启用第一个可用的副key
async function enableFirstAvailableSecondaryKey() {
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    for (const btn of allSecondaryButtons) {
        const row = btn.closest('.api-provider-row');
        const keyInput = row.querySelector('.api-key-input');
        const keyValue = keyInput ? keyInput.value.trim() : '';
        
        if (keyValue && btn.dataset.status !== 'failed') {
            // 启用这个key
            btn.dataset.status = 'enabled';
            btn.dataset.enabled = 'true';
            btn.innerHTML = '🟢';
            btn.style.backgroundColor = '#28a745';
            btn.title = '已启用 (点击禁用)';
            
            await updateGlobalApiKey(keyValue);
            console.log('已自动启用副key:', keyValue.substring(0, 10) + '...');
            return;
        }
    }
    
    // 如果没有可用的副key，提示用户
    showToast('没有可用的备用Key');
}

// 辅助函数：禁用所有其他key
async function disableAllOtherKeys() {
    // 禁用所有副key
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    allSecondaryButtons.forEach(btn => {
        btn.dataset.enabled = 'false';
        btn.dataset.status = btn.dataset.status === 'failed' ? 'failed' : 'disabled';
        btn.innerHTML = btn.dataset.status === 'failed' ? '🔴' : '⚪';
        btn.style.backgroundColor = btn.dataset.status === 'failed' ? 'white' : '#6c757d';
        btn.title = btn.dataset.status === 'failed' ? '标记失败 (点击重新启用)' : '点击启用此Key';
    });
    
    // 仅在副key被启用时，才将主key设为视觉上的禁用状态
    const mainKeyStatus = document.querySelector('.main-key-status');
    if (mainKeyStatus) {
        mainKeyStatus.dataset.enabled = 'false';
        mainKeyStatus.dataset.status = mainKeyStatus.dataset.status === 'failed' ? 'failed' : 'disabled';
        mainKeyStatus.innerHTML = mainKeyStatus.dataset.status === 'failed' ? '🔴' : '⚪';
        mainKeyStatus.style.backgroundColor = mainKeyStatus.dataset.status === 'failed' ? 'white' : '#6c757d';
        mainKeyStatus.title = mainKeyStatus.dataset.status === 'failed' ? '主Key标记失败 (点击重新启用)' : '主Key (点击启用)';
    }
}

// 辅助函数：启用主key
async function enableMainKey() {
    const mainKeyStatus = document.querySelector('.main-key-status');
    const mainKeyInput = document.getElementById('apiKey');
    const mainKeyRow = document.querySelector('.main-key-row');
    
    if (mainKeyStatus && mainKeyInput && mainKeyRow) {
        const keyValue = mainKeyInput.value.trim();
        if (keyValue) {
            // 禁用所有副key
            await disableAllSecondaryKeys();
            
            mainKeyStatus.dataset.enabled = 'true';
            mainKeyStatus.dataset.status = 'enabled';
            mainKeyStatus.innerHTML = '🟢';
            mainKeyStatus.title = '主Key已启用 (点击设为失败)';
            mainKeyRow.classList.add('enabled');
            
            await updateGlobalApiKey(keyValue);
        }
    }
}

// 新增：仅禁用副key的函数
async function disableAllSecondaryKeys() {
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    allSecondaryButtons.forEach(btn => {
        btn.dataset.enabled = 'false';
        btn.dataset.status = btn.dataset.status === 'failed' ? 'failed' : 'disabled';
        btn.innerHTML = btn.dataset.status === 'failed' ? '🔴' : '⚪';
        btn.style.backgroundColor = btn.dataset.status === 'failed' ? 'white' : '#6c757d';
        btn.title = btn.dataset.status === 'failed' ? '标记失败 (点击重新启用)' : '点击启用此Key';
    });
}

// 新增：统一更新所有key的视觉状态
function updateAllKeyStates() {
    // 检查哪个key当前是启用的
    const mainKeyStatus = document.querySelector('.main-key-status');
    const mainKeyRow = document.querySelector('.main-key-row');
    const allSecondaryButtons = document.querySelectorAll('.key-enable-btn');
    const allSecondaryRows = document.querySelectorAll('.api-provider-row');
    
    let hasEnabledSecondaryKey = false;
    
    // 首先重置所有副key行的样式
    allSecondaryRows.forEach(row => {
        row.classList.remove('enabled');
    });
    
    // 检查是否有副key被启用，并设置对应行的样式
    allSecondaryButtons.forEach(btn => {
        const row = btn.closest('.api-provider-row');
        if (btn.dataset.enabled === 'true' && btn.dataset.status === 'enabled') {
            hasEnabledSecondaryKey = true;
            if (row) {
                row.classList.add('enabled');
            }
        }
    });
    
    // 处理主key的状态和样式
    if (mainKeyStatus && mainKeyRow) {
        const mainKeyInput = document.getElementById('apiKey');
        const keyValue = mainKeyInput ? mainKeyInput.value.trim() : '';
        
        // 如果没有副key被启用，且主key不是失败状态，则主key应该是启用的
        if (!hasEnabledSecondaryKey && keyValue && mainKeyStatus.dataset.status !== 'failed') {
            mainKeyStatus.dataset.enabled = 'true';
            mainKeyStatus.dataset.status = 'enabled';
            mainKeyStatus.innerHTML = '🟢';
            mainKeyStatus.title = '主Key已启用 (点击设为失败)';
            mainKeyRow.classList.add('enabled');
        } else {
            // 主key未启用，移除启用样式
            mainKeyRow.classList.remove('enabled');
        }
    }
}


// 辅助函数：更新全局API Key
async function updateGlobalApiKey(keyValue) {
    if (keyValue && window.apiSettings) {
        const oldKey = window.apiSettings.key;
        window.apiSettings.key = keyValue;
        console.log(`[多key调试] 已更新全局API Key: ${oldKey ? oldKey.substring(0, 8) + '...' : 'empty'} -> ${keyValue.substring(0, 8) + '...'}`);
        
        try {
            if (window.apiConfigManager && window.apiConfigManager.activeConfigId) {
                const config = await window.apiConfigManager.getConfigById(window.apiConfigManager.activeConfigId);
                if (config && config.apiKeys) {
                    const keyIndex = config.apiKeys.findIndex(k => k.key === keyValue);
                    if (keyIndex !== -1) {
                        await window.apiConfigManager.setKeyEnabled(window.apiConfigManager.activeConfigId, keyIndex, true);
                    }
                }
            }
        } catch (error) {
            console.warn('更新配置管理器状态失败:', error);
        }
    }
}

async function updateConfigKeyInDB(newKey) {
    try {
        if (!window.apiConfigManager || !window.apiConfigManager.activeConfigId) {
            console.error('无法更新配置：配置管理器未初始化或无激活配置');
            return;
        }
        
        // 获取当前激活的配置
        const configId = window.apiConfigManager.activeConfigId;
        const config = await window.apiConfigManager.getConfigById(configId);
        
        if (!config) {
            console.error('无法获取当前配置');
            return;
        }
        
        // 更新配置中的主key字段
        config.key = newKey;
        config.updatedAt = Date.now();
        
        // 如果有apiKeys数组，也要更新对应key的启用状态
        if (config.apiKeys && Array.isArray(config.apiKeys)) {
            // 将所有key设为未启用
            config.apiKeys.forEach(keyObj => {
                keyObj.enabled = false;
            });
            
            // 找到新启用的key并设为启用状态
            const enabledKeyObj = config.apiKeys.find(keyObj => keyObj.key === newKey);
            if (enabledKeyObj) {
                enabledKeyObj.enabled = true;
            }
        }
        
        // 保存配置到IndexedDB
        await window.apiConfigManager.saveConfig(config);
        
        console.log('已更新IndexedDB中的配置key:', newKey.substring(0, 8) + '...');
        
    } catch (error) {
        console.error('更新IndexedDB配置失败:', error);
        showToast('更新配置失败: ' + error.message);
    }
}

function updateKeyStats(input) {
    try {
        let keyValue = input.value;
        
        // 确保keyValue是字符串
        if (typeof keyValue === 'object') {
            keyValue = keyValue.key || keyValue.toString();
        }
        
        keyValue = keyValue ? keyValue.trim() : '';
        
        const row = input.closest('.api-provider-row');
        const maskedDisplay = row.querySelector('.key-masked-compact');
        const callsCount = row.querySelector('.calls-count');
        const successRate = row.querySelector('.success-rate');
        
        if (!keyValue) {
            if (maskedDisplay) maskedDisplay.textContent = '未设置';
            if (callsCount) callsCount.textContent = '0次';
            if (successRate) successRate.textContent = '0%';
            return;
        }
        
        // 显示掩码Key
        if (window.apiConfigManager) {
            if (maskedDisplay) {
                maskedDisplay.textContent = window.apiConfigManager.maskKey(keyValue);
            }
            
            // 获取统计信息
            const configId = window.apiConfigManager.activeConfigId || 'unknown';
            const keyIndex = Array.from(document.querySelectorAll('.api-provider-row')).indexOf(row) + 1;
            const stats = window.apiConfigManager.getKeyStats(configId, keyIndex, keyValue);
            
            if (callsCount) callsCount.textContent = `${stats.recentCalls}次`;
            if (successRate) successRate.textContent = `${stats.successRate}%`;
        }
        
    } catch (error) {
        console.error('更新Key统计失败:', error);
    }
}

function updateMainKeyStats(input) {
    try {
        const keyValue = input.value.trim();
        const maskedDisplay = document.getElementById('mainKeyMask');
        const callsCount = document.getElementById('mainKeyCalls');
        const successRate = document.getElementById('mainKeySuccess');
        
        if (!maskedDisplay || !callsCount || !successRate) return;
        
        if (!keyValue) {
            maskedDisplay.textContent = '未设置';
            callsCount.textContent = '0次';
            successRate.textContent = '0%';
            return;
        }
        
        // 显示掩码Key
        if (window.apiConfigManager) {
            maskedDisplay.textContent = window.apiConfigManager.maskKey(keyValue);
            
            // 获取统计信息（主key的索引是0）
            const configId = window.apiConfigManager.activeConfigId || 'unknown';
            const stats = window.apiConfigManager.getKeyStats(configId, 0, keyValue);
            
            callsCount.textContent = `${stats.recentCalls}次`;
            successRate.textContent = `${stats.successRate}%`;
        }
        
    } catch (error) {
        console.error('更新主Key统计失败:', error);
    }
}

async function loadModelsForConfig(configSelectId, modelSelectId) {
    try {
        const configSelect = document.getElementById(configSelectId);
        const modelSelect = document.getElementById(modelSelectId);
        
        if (!configSelect || !modelSelect) return;
        
        const configId = configSelect.value;
        
        // 清空模型选择器
        modelSelect.innerHTML = '';
        
        if (!configId) {
            modelSelect.innerHTML = '<option value="">请先选择API配置</option>';
            return;
        }
        
        if (configId === 'sync_with_primary') {
            modelSelect.innerHTML = '<option value="sync_with_primary">与主模型保持一致</option>';
            return;
        }
        
        // 获取指定配置的模型列表
        if (!window.apiConfigManager) {
            modelSelect.innerHTML = '<option value="">配置管理器未初始化</option>';
            return;
        }
        
        const config = await window.apiConfigManager.getConfigById(configId);
        if (!config) {
            modelSelect.innerHTML = '<option value="">配置不存在</option>';
            return;
        }
        
        // 创建临时的API连接来获取模型列表
        modelSelect.innerHTML = '<option value="">加载中...</option>';
        
        const tempApiService = {
            baseURL: config.url,
            apiKey: config.key,
            timeout: config.timeout
        };
        
        try {
            const response = await fetch(`${config.url}/models`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${config.key}`,
                    'Content-Type': 'application/json'
                },
                timeout: config.timeout * 1000
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            const models = data.data || [];
            
            modelSelect.innerHTML = '';
            
            if (models.length === 0) {
                modelSelect.innerHTML = '<option value="">无可用模型</option>';
                return;
            }
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.id;
                modelSelect.appendChild(option);
            });
            
            // 保存配置选择
            const type = configSelectId.includes('primary') ? 'primary' : 'secondary';
            if (type === 'primary') {
                localStorage.setItem('primaryModelConfig', configId);
                console.log(`[模型配置] 已保存主要配置选择: ${configId}`);
            } else {
                localStorage.setItem('secondaryModelConfig', configId);
                console.log(`[模型配置] 已保存次要配置选择: ${configId}`);
            }
            
        } catch (error) {
            console.error('获取模型列表失败:', error);
            modelSelect.innerHTML = '<option value="">获取模型失败</option>';
        }
        
    } catch (error) {
        console.error('loadModelsForConfig 失败:', error);
    }
}

/**
 * 保存模型选择到localStorage
 * @param {string} type - 'primary' 或 'secondary'
 */
/**
 * 获取当前使用的模型名称（主要模型）
 */
async function getCurrentModel() {
    try {
        if (window.modelSettings && window.modelSettings.primaryModel) {
            return window.modelSettings.primaryModel;
        }

        const modelConfig = await window.apiConfigManager.getGlobalModelConfig();
        return modelConfig.primaryModel || '';
    } catch (error) {
        console.error('获取当前模型失败:', error);
        return '';
    }
}

/**
 * 获取当前使用的次要模型名称
 */
async function getCurrentSecondaryModel() {
    try {
        if (window.modelSettings && window.modelSettings.secondaryModel) {
            return window.modelSettings.secondaryModel;
        }

        const modelConfig = await window.apiConfigManager.getGlobalModelConfig();
        return modelConfig.secondaryModel || '';
    } catch (error) {
        console.error('获取当前次要模型失败:', error);
        return '';
    }
}

/**
 * 获取完整的API调用信息（包含连接信息和模型信息）
 */
async function getApiCallInfo() {
    try {
        const connection = await window.apiConfigManager.getCurrentApiConnection();
        return {
            url: connection.url,
            key: connection.key,
            model: connection.primaryModel,
            secondaryModel: connection.secondaryModel,
            timeout: connection.timeout,
            contextMessageCount: connection.contextMessageCount
        };
    } catch (error) {
        console.error('获取API调用信息失败:', error);
        throw error;
    }
}

async function saveModelSelection(type) {
    try {
        const configSelectId = type === 'primary' ? 'primaryConfigSelect' : 'secondaryConfigSelect';
        const modelSelectId = type === 'primary' ? 'primaryModelSelect' : 'secondaryModelSelect';

        const configSelect = document.getElementById(configSelectId);
        const modelSelect = document.getElementById(modelSelectId);

        if (configSelect && modelSelect) {
            const configId = configSelect.value;
            const modelId = modelSelect.value;

            // 获取当前的全局模型配置
            const currentModelConfig = await window.apiConfigManager.getGlobalModelConfig();

            if (type === 'primary') {
                // 保存到全局模型配置
                await window.apiConfigManager.saveGlobalModelConfig({
                    apiConfigId: configId,
                    primaryModel: modelId,
                    secondaryModel: currentModelConfig.secondaryModel || '' // 保持次要模型不变
                });
                console.log(`[模型选择] 已保存主要模型: 配置=${configId}, 模型=${modelId}`);
            } else {
                // 保存到全局模型配置
                await window.apiConfigManager.saveGlobalModelConfig({
                    apiConfigId: currentModelConfig.apiConfigId || configId, // 使用当前API配置ID
                    primaryModel: currentModelConfig.primaryModel || '', // 保持主要模型不变
                    secondaryModel: modelId
                });
                console.log(`[模型选择] 已保存次要模型: 配置=${configId}, 模型=${modelId}`);
            }

            // TODO: 兼容性代码块 - 需要逐步迁移
            // 这个代码块是为了在重构期间保持向后兼容性而添加的。
            // 它更新全局 window.apiSettings 以确保依赖旧API的代码正常工作。
            //
            // 迁移计划：
            // 1. 首先迁移 utils/ 目录下的文件，使用 getApiCallInfo() 替代直接访问 window.apiSettings
            // 2. 然后迁移 script.js 中的其他函数
            // 3. 最后移除这个兼容性代码块
            //
            // 相关依赖位置：
            // - utils/characterMemory.js (7处引用)
            // - utils/memoryTable.js (5处引用)
            // - utils/uiUtils.js (3处引用)
            // - utils/apiConfigManager.js (3处引用)
            // - script.js (11处引用)
            if (type === 'primary' && window.apiSettings) {
                // 获取完整的API连接信息
                const connection = await window.apiConfigManager.getCurrentApiConnection();
                Object.assign(window.apiSettings, {
                    url: connection.url,
                    key: connection.key,
                    timeout: connection.timeout,
                    contextMessageCount: connection.contextMessageCount
                });
                // 模型信息现在存储在window.modelSettings中
                console.log('全局API设置已更新 - 这是临时兼容性代码，将来会被移除');
            }
        }
    } catch (error) {
        console.error('保存模型选择失败:', error);
    }
}

async function getApiConnectionForModel(modelType) {
    try {
        if (modelType === 'primary') {
            const configId = localStorage.getItem('primaryModelConfig');
            const modelId = localStorage.getItem('primaryModel');
            
            if (!configId || !modelId) {
                throw new Error('主要模型配置未设置');
            }
            
            const config = await window.apiConfigManager.getConfigById(configId);
            if (!config) {
                throw new Error('API配置不存在');
            }
            
            return {
                baseURL: config.url,
                apiKey: config.key,
                timeout: config.timeout,
                model: modelId,
                configId: configId
            };
            
        } else if (modelType === 'secondary') {
            const configId = localStorage.getItem('secondaryModelConfig');
            const modelId = localStorage.getItem('secondaryModel');
            
            if (!configId || configId === 'sync_with_primary' || !modelId || modelId === 'sync_with_primary') {
                // 使用主要模型的配置
                return await getApiConnectionForModel('primary');
            }
            
            const config = await window.apiConfigManager.getConfigById(configId);
            if (!config) {
                throw new Error('次要模型API配置不存在');
            }
            
            return {
                baseURL: config.url,
                apiKey: config.key,
                timeout: config.timeout,
                model: modelId,
                configId: configId
            };
        }
        
        throw new Error('未知的模型类型');
        
    } catch (error) {
        console.error('获取API连接信息失败:', error);
        throw error;
    }
}

// API配置管理页面函数
async function loadApiConfigManagementPage() {
    try {
        if (!window.apiConfigManager) return;
        
        const configs = await window.apiConfigManager.getAllConfigs();
        const configList = document.getElementById('apiConfigList');
        
        if (!configList) return;
        
        if (configs.length === 0) {
            configList.innerHTML = `
                <div class="config-list-empty">
                    <div class="empty-icon">⚙️</div>
                    <div class="empty-text">暂无API配置</div>
                    <button class="empty-action-btn" onclick="showNewApiConfigForm()">添加第一个配置</button>
                </div>
            `;
        } else {
            configList.innerHTML = configs.map(config => `
                <div class="config-item" onclick="editApiConfigInPage('${config.id}')">
                    <div class="config-item-header">
                        <div class="config-item-name">${config.configName}</div>
                        <div class="config-item-actions">
                            <button class="config-item-btn config-item-edit" onclick="event.stopPropagation(); editApiConfigInPage('${config.id}')" title="编辑">✏️</button>
                            <button class="config-item-btn config-item-delete" onclick="event.stopPropagation(); deleteApiConfigInPage('${config.id}')" title="删除">🗑️</button>
                        </div>
                    </div>
                    <div class="config-item-url">${config.url}</div>
                    <div class="config-item-status active">已配置</div>
                </div>
            `).join('');
        }
        
    } catch (error) {
        console.error('加载API配置列表失败:', error);
    }
}

function showNewApiConfigForm() {
    // 清空表单
    document.getElementById('pageConfigName').value = '新配置 ' + Date.now().toString().slice(-6);
    document.getElementById('pageApiUrl').value = '';
    document.getElementById('pageApiKey').value = '';
    document.getElementById('pageApiTimeout').value = '60';
    
    // 设置表单标题和状态
    document.getElementById('configFormTitle').textContent = '新增API配置';
    window.currentEditingConfigId = null;
    
    // 显示表单
    document.getElementById('apiConfigForm').style.display = 'block';
}

function closeApiConfigForm() {
    document.getElementById('apiConfigForm').style.display = 'none';
    window.currentEditingConfigId = null;
}

async function editApiConfigInPage(configId) {
    try {
        const config = await window.apiConfigManager.getConfigById(configId);
        if (!config) return;
        
        // 填充表单
        document.getElementById('pageConfigName').value = config.configName || '';
        document.getElementById('pageApiUrl').value = config.url || '';
        document.getElementById('pageApiKey').value = config.key || '';
        document.getElementById('pageApiTimeout').value = config.timeout || 60;
        
        // 设置表单标题和状态
        document.getElementById('configFormTitle').textContent = '编辑API配置';
        window.currentEditingConfigId = configId;
        
        // 显示表单
        document.getElementById('apiConfigForm').style.display = 'block';
        
    } catch (error) {
        console.error('加载配置失败:', error);
        showToast('加载配置失败: ' + error.message);
    }
}

async function deleteApiConfigInPage(configId) {
    try {
        if (!confirm('确定要删除这个API配置吗？')) return;
        
        await window.apiConfigManager.deleteConfig(configId);
        showToast('配置删除成功');
        
        // 重新加载列表
        await loadApiConfigManagementPage();
        
    } catch (error) {
        console.error('删除配置失败:', error);
        showToast('删除配置失败: ' + error.message);
    }
}

async function saveApiConfigInPage(event) {
    event.preventDefault();
    
    try {
        const configData = {
            configId: window.currentEditingConfigId,
            configName: document.getElementById('pageConfigName').value.trim(),
            url: document.getElementById('pageApiUrl').value.trim(),
            key: document.getElementById('pageApiKey').value.trim(),
            timeout: parseInt(document.getElementById('pageApiTimeout').value) || 60
        };
        
        if (!configData.configName || !configData.url || !configData.key) {
            showToast('请填写完整的配置信息');
            return;
        }
        
        await window.apiConfigManager.saveConfig(configData);
        showToast(window.currentEditingConfigId ? '配置更新成功' : '配置保存成功');
        
        // 关闭表单并重新加载列表
        closeApiConfigForm();
        await loadApiConfigManagementPage();
        
        // 自动关闭API配置管理页面，返回到我的界面
        setTimeout(() => {
            showPage('profilePage');
        }, 1000); // 延迟1秒让用户看到成功提示
        
    } catch (error) {
        console.error('保存配置失败:', error);
        showToast('保存配置失败: ' + error.message);
    }
}

async function testApiConnectionInPage(event) {
    try {
        const url = document.getElementById('pageApiUrl').value.trim();
        const key = document.getElementById('pageApiKey').value.trim();
        const timeout = parseInt(document.getElementById('pageApiTimeout').value) || 60;
        
        if (!url || !key) {
            showToast('请先填写API URL和API Key');
            return;
        }
        
        const button = event.target;
        button.disabled = true;
        button.textContent = '测试中...';
        
        const response = await fetch(`${url}/models`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
            },
            timeout: timeout * 1000
        });
        
        if (response.ok) {
            const data = await response.json();
            showToast(`连接成功！找到 ${data.data?.length || 0} 个模型`);
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
    } catch (error) {
        console.error('测试连接失败:', error);
        showToast('连接测试失败: ' + error.message);
    } finally {
        const button = event.target;
        button.disabled = false;
        button.textContent = '测试连接';
    }
}

async function setBackground(event) {
    event.preventDefault();
    if (!currentContact) return;
    const url = document.getElementById('backgroundUrl').value;
    if (url) backgrounds[currentContact.id] = url;
    else delete backgrounds[currentContact.id];
    await saveDataToDB(); // 使用IndexedDB保存
    openChat(currentContact);
    closeModal('backgroundModal');
    showToast('背景设置成功');
}

async function addEmoji(event) {
    event.preventDefault();
    const meaning = document.getElementById('emojiMeaning').value.trim();
    if (emojis.some(e => e.tag === meaning)) {
        showToast('该表情标签已存在，请使用其他标签。');
        return;
    }
    
    const imageUrl = document.getElementById('emojiUrl').value;
    
    // 处理临时URL的情况：如果是临时URL但还有临时文件，先转换存储
    if (imageUrl.startsWith('temp:') && window.ImageUploadHandlers.tempEmojiFile) {
        try {
            const statusElement = document.getElementById('emojiUploadStatus');
            await window.ImageUploadHandlers.storeEmojiWithMeaning(window.ImageUploadHandlers.tempEmojiFile, meaning, statusElement);
            
            // 清理临时数据
            const tempUrl = imageUrl.substring(5);
            URL.revokeObjectURL(tempUrl);
            window.ImageUploadHandlers.tempEmojiFile = null;
            
            // 获取新的fileId URL
            const newImageUrl = document.getElementById('emojiUrl').value;
            
            if (!newImageUrl.startsWith('file:')) {
                showToast('文件存储失败，请重试');
                return;
            }
        } catch (error) {
            console.error('临时文件转换失败:', error);
            showToast('文件存储失败，请重试');
            return;
        }
    }
    
    const finalImageUrl = document.getElementById('emojiUrl').value;
    
    // 处理不同格式的图片
    let imageData = finalImageUrl;
    if (finalImageUrl.startsWith('file:')) {
        // 新的fileSystem格式 - 表情包已经在上传时保存到文件系统
        // 只需要保存emoji记录即可，不需要额外处理
        imageData = finalImageUrl; // 保留file:fileId格式用于引用
    } else if (finalImageUrl.startsWith('data:image/')) {
        // 传统的base64格式（向后兼容，但新版本应该不会用到）
        await saveEmojiImage(meaning, finalImageUrl);
        imageData = `[emoji:${meaning}]`; // 内部存储格式
    } else if (finalImageUrl.startsWith('temp:')) {
        showToast('文件尚未正确存储，请重新上传');
        return;
    } else {
        showToast('无效的图片格式，请重新上传');
        return;
    }
    
    const emoji = { 
        id: Date.now().toString(), 
        tag: meaning,  // 使用tag而不是meaning
        meaning: meaning, // 保留meaning用于显示
        // 新增：如果是fileId格式，保存fileId字段
        ...(finalImageUrl.startsWith('file:') ? { fileId: finalImageUrl.substring(5) } : {})
    };
    emojis.push(emoji);
    await saveDataToDB(); // 使用IndexedDB保存
    renderEmojiGrid();
    closeModal('addEmojiModal');
    showToast('表情添加成功');
    event.target.reset();
}

async function deleteEmoji(emojiId) {
    showConfirmDialog('删除确认', '确定要删除这个表情吗？', async () => {
        const emojiToDelete = emojis.find(e => e.id === emojiId);
        if (emojiToDelete && emojiToDelete.tag) {
            // 删除对应的图片数据
            await deleteEmojiImage(emojiToDelete.tag);
        }
        emojis = emojis.filter(e => e.id !== emojiId);
        await saveDataToDB(); // 使用IndexedDB保存
        renderEmojiGrid();
        showToast('表情已删除');
    });
}

async function renderEmojiGrid() {
    const grid = document.getElementById('emojiGrid');
    grid.innerHTML = '';
    
    for (const emoji of emojis) {
        const item = document.createElement('div');
        item.className = 'emoji-item';
        
        // 获取表情图片
        let imageSrc;
        if (emoji.tag) {
            // 新格式：从emojiImages存储获取
            imageSrc = await getEmojiImage(emoji.tag);
        } else if (emoji.url) {
            // 旧格式：直接使用URL
            imageSrc = emoji.url;
        }
        
        if (imageSrc) {
            item.innerHTML = `<img src="${imageSrc}"><div class="emoji-delete-btn" onclick="event.stopPropagation(); deleteEmoji('${emoji.id}')">×</div>`;
            item.onclick = () => sendEmoji(emoji);
        } else {
            // 如果没有图片数据，显示占位符
            item.innerHTML = `<div style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; width: 80px; height: 80px; border-radius: 8px;">${emoji.meaning || emoji.tag || '?'}</div><div class="emoji-delete-btn" onclick="event.stopPropagation(); deleteEmoji('${emoji.id}')">×</div>`;
            item.onclick = () => sendEmoji(emoji);
        }
        
        grid.appendChild(item);
    }
    
    const addBtn = document.createElement('div');
    addBtn.className = 'add-emoji-btn';
    addBtn.textContent = '+ 添加表情';
    addBtn.onclick = showAddEmojiModal;
    grid.appendChild(addBtn);
}

async function sendRedPacket(event) {
    event.preventDefault();
    if (!currentContact) return;
    const amount = document.getElementById('redPacketAmount').value;
    const message = document.getElementById('redPacketMessage').value || '恭喜发财，大吉大利！';
    if (amount <= 0) { showToast('红包金额必须大于0'); return; }
    const packetData = { amount: parseFloat(amount).toFixed(2), message };
    const packetMessage = { role: 'user', content: JSON.stringify(packetData), type: 'red_packet', time: new Date().toISOString(), senderId: 'user' };
    currentContact.messages.push(packetMessage);
    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
        currentlyDisplayedMessageCount++;
    }
    currentContact.lastMessage = '[红包]';
    currentContact.lastTime = formatContactListTime(new Date().toISOString());
    // 使用addSingleMessage添加消息到界面，避免重新渲染整个聊天
    await addSingleMessage(packetMessage, true);
    await renderContactList();
    await saveDataToDB(); // 使用IndexedDB保存
    closeModal('redPacketModal');
    await sendMessage();
}

async function sendEmoji(emoji) {
    if (!currentContact) return;
    // 使用新的[emoji:tag]格式存储
    const content = emoji.tag ? `[emoji:${emoji.tag}]` : emoji.url;
    const emojiMessage = { role: 'user', content: content, type: 'emoji', time: new Date().toISOString(), senderId: 'user' };
    currentContact.messages.push(emojiMessage);
    if (currentContact.messages.length > currentlyDisplayedMessageCount) {
        currentlyDisplayedMessageCount++;
    }
    currentContact.lastMessage = '[表情]';
    currentContact.lastTime = formatContactListTime(new Date().toISOString());
    // 使用addSingleMessage添加消息到界面，避免重新渲染整个聊天
    await addSingleMessage(emojiMessage, true);
    await renderContactList();
    await saveDataToDB(); // 使用IndexedDB保存
    toggleEmojiPanel(true);
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('请先设置API和模型');
        return;
    }
    showTypingIndicator();
    try {
        const { replies } = await callAPI(currentContact);
        hideTypingIndicator();
        
        // 异步更新记忆表格（使用API队列，不阻塞用户操作）
        if (window.updateMemoryTableWithSecondaryModel) {
            window.updateMemoryTableWithSecondaryModel(currentContact, true);
        }
        if (!replies || replies.length === 0) { showTopNotification('AI没有返回有效回复'); return; }
        for (const response of replies) {
            await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 800));
            const aiMessage = { role: 'assistant', content: removeThinkingChain(response.content), type: response.type, time: new Date().toISOString(), senderId: currentContact.id };
            currentContact.messages.push(aiMessage);
            if (currentContact.messages.length > currentlyDisplayedMessageCount) {
                currentlyDisplayedMessageCount++;
            }
            currentContact.lastMessage = response.type === 'text' ? response.content.substring(0, 20) + '...' : '[表情]';
            currentContact.lastTime = formatContactListTime(new Date().toISOString());
            // 使用addSingleMessage添加AI回复消息，避免重新渲染整个聊天
            await addSingleMessage(aiMessage, true);
            await renderContactList();
            await saveDataToDB();
        }
    } catch (error) {
        hideTypingIndicator();
        console.error('AI回复错误:', error);
        showApiError(error);
    }
}

function toggleEmojiPanel(forceClose = false) {
    const panel = document.getElementById('emojiPanel');
    if (forceClose) {
        panel.style.display = 'none';
        return;
    }
    const isVisible = panel.style.display === 'block';
    // 懒加载：第一次打开时才渲染
    if (!isVisible && !isEmojiGridRendered) {
        renderEmojiGrid();
        isEmojiGridRendered = true;
    }
    panel.style.display = isVisible ? 'none' : 'block';
}

// 打开联系人设置页面
// 页面导航历史管理器
class PageNavigationManager {
    constructor() {
        this.navigationHistory = [];
        this.currentPage = null;
    }
    
    /**
     * 记录页面切换
     * @param {string} fromPage - 源页面ID
     * @param {string} toPage - 目标页面ID
     */
    navigateTo(fromPage, toPage) {
        if (fromPage && fromPage !== toPage) {
            // 避免重复记录相同的导航
            const lastEntry = this.navigationHistory[this.navigationHistory.length - 1];
            if (!lastEntry || lastEntry.from !== fromPage || lastEntry.to !== toPage) {
                this.navigationHistory.push({
                    from: fromPage,
                    to: toPage,
                    timestamp: Date.now()
                });
            }
        }
        this.currentPage = toPage;
    }
    
    /**
     * 获取前一个页面ID
     * @param {string} currentPageId - 当前页面ID
     * @returns {string|null} 前一个页面ID，如果没有则返回默认页面
     */
    getPreviousPage(currentPageId = null) {
        const pageId = currentPageId || this.currentPage;
        
        // 从历史记录中查找最后一次进入当前页面的来源
        for (let i = this.navigationHistory.length - 1; i >= 0; i--) {
            const entry = this.navigationHistory[i];
            if (entry.to === pageId) {
                return entry.from;
            }
        }
        
        // 如果没有找到历史记录，返回默认页面
        return this.getDefaultReturnPage(pageId);
    }
    
    /**
     * 获取默认返回页面
     * @param {string} currentPageId - 当前页面ID
     * @returns {string} 默认页面ID
     */
    getDefaultReturnPage(currentPageId) {
        const pageDefaults = {
            'contactSettingsPage': 'chatPage',
            'userProfilePage': 'chatPage',
            'momentsPage': 'chatPage',
            'weiboPage': 'chatPage'
        };
        
        return pageDefaults[currentPageId] || 'chatPage';
    }
    
    /**
     * 清理过期的导航历史（保留最近50条记录）
     */
    cleanupHistory() {
        if (this.navigationHistory.length > 50) {
            this.navigationHistory = this.navigationHistory.slice(-50);
        }
    }
    
    /**
     * 获取当前激活的页面ID
     * @returns {string|null}
     */
    getCurrentActivePage() {
        const activePages = document.querySelectorAll('.main-container > div.active');
        if (activePages.length > 0) {
            return activePages[0].id;
        }
        return null;
    }
}

/**
 * 通用页面切换函数
 * @param {string} fromPageId - 源页面ID
 * @param {string} toPageId - 目标页面ID
 * @param {Object} options - 切换选项
 * @param {boolean} options.recordHistory - 是否记录导航历史，默认true
 * @param {number} options.animationDelay - 动画延迟时间，默认300ms
 */
function navigateToPage(fromPageId, toPageId, options = {}) {
    const {
        recordHistory = true,
        animationDelay = 300
    } = options;
    
    const fromPage = document.getElementById(fromPageId);
    const toPage = document.getElementById(toPageId);
    
    if (!toPage) {
        console.error(`目标页面 ${toPageId} 不存在`);
        return false;
    }
    
    // 记录导航历史
    if (recordHistory && fromPageId && fromPageId !== toPageId) {
        pageNavManager.navigateTo(fromPageId, toPageId);
    }
    
    // 如果有源页面，先执行退出动画
    if (fromPage && fromPage.classList.contains('active')) {
        fromPage.classList.remove('active');
        
        setTimeout(() => {
            fromPage.style.display = 'none';
            showTargetPage();
        }, animationDelay);
    } else {
        showTargetPage();
    }
    
    function showTargetPage() {
        // 隐藏所有其他活跃页面
        const allPages = document.querySelectorAll('.main-container > div.active');
        allPages.forEach(page => {
            if (page.id !== toPageId) {
                page.classList.remove('active');
            }
        });
        
        // 显示目标页面
        toPage.style.display = 'block';
        requestAnimationFrame(() => {
            toPage.classList.add('active');
        });
    }
    
    return true;
}

/**
 * 智能关闭当前页面并返回到之前页面
 * @param {string} currentPageId - 当前页面ID
 * @param {Object} options - 选项
 */
function smartClosePage(currentPageId, options = {}) {
    const returnPageId = pageNavManager.getPreviousPage(currentPageId);
    return navigateToPage(currentPageId, returnPageId, options);
}

// 调试和测试工具函数
const NavigationDebugger = {
    /**
     * 获取当前导航状态信息
     */
    getNavigationState() {
        return {
            currentPage: pageNavManager.currentPage,
            activePage: pageNavManager.getCurrentActivePage(),
            historyLength: pageNavManager.navigationHistory.length,
            recentHistory: pageNavManager.navigationHistory.slice(-5),
            lastNavigation: pageNavManager.navigationHistory[pageNavManager.navigationHistory.length - 1]
        };
    },
    
    /**
     * 打印导航历史到控制台
     */
    printNavigationHistory() {
        console.group('🧭 页面导航历史');
        console.log('当前页面:', pageNavManager.currentPage);
        console.log('DOM活跃页面:', pageNavManager.getCurrentActivePage());
        console.log('历史记录总数:', pageNavManager.navigationHistory.length);
        
        console.group('最近5次导航:');
        pageNavManager.navigationHistory.slice(-5).forEach((entry, index) => {
            const time = new Date(entry.timestamp).toLocaleTimeString();
            console.log(`${index + 1}. ${time}: ${entry.from} → ${entry.to}`);
        });
        console.groupEnd();
        
        console.groupEnd();
    },
    
    /**
     * 模拟测试导航流程
     */
    testNavigationFlow() {
        console.group('🧪 导航系统测试');
        
        // 测试场景1：chatPage → contactSettingsPage → 返回
        console.log('测试场景1: 聊天页面 → 设置页面 → 智能返回');
        pageNavManager.navigateTo('chatPage', 'contactSettingsPage');
        const returnPage1 = pageNavManager.getPreviousPage('contactSettingsPage');
        console.log(`期望返回: chatPage, 实际返回: ${returnPage1}`);
        
        // 测试场景2：momentsPage → contactSettingsPage → 返回
        console.log('测试场景2: 朋友圈页面 → 设置页面 → 智能返回');
        pageNavManager.navigateTo('momentsPage', 'contactSettingsPage');
        const returnPage2 = pageNavManager.getPreviousPage('contactSettingsPage');
        console.log(`期望返回: momentsPage, 实际返回: ${returnPage2}`);
        
        // 测试场景3：没有历史记录时的默认返回
        pageNavManager.navigationHistory.length = 0; // 清空历史
        const returnPage3 = pageNavManager.getPreviousPage('contactSettingsPage');
        console.log(`无历史记录时返回: ${returnPage3} (应为默认页面)`);
        
        console.groupEnd();
    }
};

// 在开发环境下暴露调试工具到全局
if (typeof window !== 'undefined') {
    window.NavigationDebugger = NavigationDebugger;
    
    // 添加快捷键用于调试 (Ctrl+Shift+N)
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'N') {
            NavigationDebugger.printNavigationHistory();
        }
    });
}

// 全局页面导航管理器实例
const pageNavManager = new PageNavigationManager();

function openContactSettingsPage() {
    showContactSettingsPage();
}

// 已移除废弃的 toggleSettingsMenu 函数，请直接使用：
// - openContactSettingsPage() 打开设置页面
// - closeContactSettingsPage() 关闭设置页面

function showContactSettingsPage() {
    if (!currentContact) {
        showToast('请先选择一个联系人');
        return;
    }
    
    const settingsPage = document.getElementById('contactSettingsPage');
    const settingsTitle = document.getElementById('contactSettingsTitle');
    
    // 记录当前活跃页面，用于返回时导航
    const currentActivePage = pageNavManager.getCurrentActivePage();
    if (currentActivePage && currentActivePage !== 'contactSettingsPage') {
        pageNavManager.navigateTo(currentActivePage, 'contactSettingsPage');
    }
    
    // 设置标题为当前联系人名称
    settingsTitle.textContent = `${currentContact.name} - 设置`;
    
    // 显示页面
    settingsPage.style.display = 'block';
    
    // 使用 requestAnimationFrame 确保样式生效后再添加 active 类
    requestAnimationFrame(() => {
        settingsPage.classList.add('active');
    });
    
    // 隐藏其他页面
    const allPages = document.querySelectorAll('.main-container > div');
    allPages.forEach(page => {
        if (page.id !== 'contactSettingsPage') {
            page.classList.remove('active');
        }
    });
    
    // 定期清理导航历史
    pageNavManager.cleanupHistory();
}

function closeContactSettingsPage() {
    const settingsPage = document.getElementById('contactSettingsPage');
    
    if (settingsPage.classList.contains('active')) {
        // 获取应该返回到的页面
        const returnPageId = pageNavManager.getPreviousPage('contactSettingsPage');
        let returnPage = document.getElementById(returnPageId);
        
        if (!returnPage) {
            console.warn(`返回页面 ${returnPageId} 不存在，使用默认页面 chatPage`);
            const chatPage = document.getElementById('chatPage');
            if (chatPage) {
                returnPage = chatPage;
            } else {
                console.error('chatPage 也不存在，无法返回');
                return;
            }
        }
        
        // 移除 active 类触发滑出动画
        settingsPage.classList.remove('active');
        
        // 记录导航历史
        pageNavManager.navigateTo('contactSettingsPage', returnPage.id);
        
        // 等待动画完成后隐藏页面并显示目标页面
        setTimeout(() => {
            settingsPage.style.display = 'none';
            returnPage.classList.add('active');
        }, 300);
    }
}


async function clearMessages() {
    if (!currentContact) {
        showToast('请先选择一个聊天');
        return;
    }
    showConfirmDialog('清空聊天记录', '确定要清空当前聊天记录吗？此操作不可撤销。', async () => {
        currentContact.messages = [];
        currentlyDisplayedMessageCount = 0; // 重置计数
        currentContact.lastMessage = '暂无消息';
        currentContact.lastTime = formatContactListTime(new Date().toISOString());
        renderMessages(false); // 重新渲染，但不滚动到底部
        await renderContactList();
        await saveDataToDB();
        
        // 清空该角色的记忆数据
        if (window.clearCharacterMemory) {
            await window.clearCharacterMemory(currentContact.id);
            console.log(`[清空聊天] 已清空角色 ${currentContact.id} 的记忆数据`);
        }
        
        showToast('已清空聊天记录');
        closeContactSettingsPage(); // 关闭设置页面
    });
}

/**
 * 删除指定索引的消息
 * @param {number} messageIndex 要删除的消息的索引 (绝对索引)
 */
async function deleteMessage(messageIndex) {
    if (!currentContact || messageIndex === undefined || messageIndex < 0 || messageIndex >= currentContact.messages.length) {
        showToast('无效的消息索引或未选择聊天');
        return;
    }
    
    // 保存被删除的消息，用于记忆更新
    const deletedMessage = currentContact.messages[messageIndex];
    
    currentContact.messages.splice(messageIndex, 1);

    // 如果删除的是已显示的消息，则更新计数
    const displayedMessagesStartRange = currentContact.messages.length - currentlyDisplayedMessageCount;
    if (messageIndex >= displayedMessagesStartRange) {
        currentlyDisplayedMessageCount = Math.max(0, currentlyDisplayedMessageCount - 1);
    }
    
    if (currentContact.messages.length > 0) {
        const lastMsg = currentContact.messages[currentContact.messages.length - 1];
        currentContact.lastMessage = lastMsg.type === 'text' ? lastMsg.content.substring(0, 20) + '...' : (lastMsg.type === 'emoji' ? '[表情]' : '[红包]');
        currentContact.lastTime = formatContactListTime(lastMsg.time);
    } else {
        currentContact.lastMessage = '暂无消息';
        currentContact.lastTime = formatContactListTime(new Date().toISOString());
    }

    renderMessages(false); // 重新渲染，但不滚动到底部
    await renderContactList();
    await saveDataToDB();
    
    // 检查并更新记忆
    if (window.checkAndUpdateMemoryAfterDeletion && deletedMessage) {
        try {
            await window.checkAndUpdateMemoryAfterDeletion(currentContact.id, [deletedMessage], currentContact);
        } catch (error) {
            console.error('删除消息后更新记忆失败:', error);
        }
    }
    
    showToast('消息已删除');
}


/**
 * 删除当前聊天对象（联系人或群聊）
 */
async function deleteCurrentContact() {
    if (!currentContact) {
        showToast('没有选中任何聊天对象');
        return;
    }
    showConfirmDialog('删除聊天对象', `确定要删除 "${currentContact.name}" 吗？此操作将永久删除所有聊天记录，不可撤销。`, async () => {
        await deleteContact(currentContact.id);
        showToast('聊天对象已删除');
        closeChatPage(); // 关闭聊天页面并返回联系人列表
        closeContactSettingsPage(); // 只在确认删除后关闭设置菜单
    });
}

/**
 * 从contacts数组和IndexedDB中删除指定ID的联系人或群聊
 * @param {string} contactId 要删除的联系人/群聊的ID
 */
async function deleteContact(contactId) {
    if (!window.isIndexedDBReady) {
        showToast('数据库未准备好，无法删除。');
        return;
    }

    const initialContactsLength = contacts.length;
    contacts = contacts.filter(c => c.id !== contactId);

    if (contacts.length === initialContactsLength) {
        // 如果长度没变，说明没找到该ID的联系人
        console.warn(`未找到ID为 ${contactId} 的联系人/群聊进行删除。`);
        showToast('未找到要删除的聊天对象');
        return;
    }

    try {
        const transaction = window.db.transaction(['contacts'], 'readwrite');
        const store = transaction.objectStore('contacts');
        await promisifyRequest(store.delete(contactId)); // 从IndexedDB删除

        // 如果删除的是当前正在聊天的对象，需要重置currentContact
        if (currentContact && currentContact.id === contactId) {
            currentContact = null;
    window.currentContact = null;
        }

        await renderContactList(); // 重新渲染联系人列表
        await saveDataToDB(); // 重新保存contacts数组到IndexedDB，确保数据同步
        
        // 清空该角色的记忆数据
        if (window.clearCharacterMemory) {
            await window.clearCharacterMemory(contactId);
            console.log(`[删除联系人] 已清空角色 ${contactId} 的记忆数据`);
        }
        
        showToast('聊天对象已删除');
    } catch (error) {
        console.error('删除联系人/群聊失败:', error);
        showToast('删除失败：' + error.message);
    }
}

/**
 * 显示自定义确认对话框
 * @param {string} title 对话框标题
 * @param {string} message 对话框消息
 * @param {function} onConfirm 用户点击确认按钮时执行的回调
 */
// showConfirmDialog function moved to utils/uiUtils.js

/**
 * 显示消息操作菜单（编辑/删除）
 * @param {number} messageIndex 消息索引
 * @param {HTMLElement} messageElement 消息DOM元素
 */
/**
 * 为消息元素添加长按和右键菜单事件监听器
 * @param {HTMLElement} msgDiv - 消息元素
 * @param {number} originalIndex - 消息在数组中的原始索引
 */
function addMessageActionListeners(msgDiv, originalIndex) {
    let msgPressTimer;
    msgDiv.addEventListener('touchstart', () => { 
        msgPressTimer = setTimeout(() => { 
            showMessageActionMenu(originalIndex, msgDiv); 
        }, 700); 
    });
    msgDiv.addEventListener('touchend', () => clearTimeout(msgPressTimer));
    msgDiv.addEventListener('touchmove', () => clearTimeout(msgPressTimer));
    msgDiv.addEventListener('contextmenu', (e) => { 
        e.preventDefault(); 
        showMessageActionMenu(originalIndex, msgDiv); 
    });
}

function showMessageActionMenu(messageIndex, messageElement) {
    const menuId = 'messageActionMenu';
    let menu = document.getElementById(menuId);
    
    if (!menu) {
        menu = document.createElement('div');
        menu.id = menuId;
        menu.className = 'modal';
        menu.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">消息操作</div>
                    <div class="modal-close" onclick="closeModal('${menuId}')">取消</div>
                </div>
                <div class="modal-body">
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <button class="form-submit" style="background-color: #576b95;" id="editMessageBtn">编辑</button>
                        <button class="form-submit" style="background-color: #ffa500;" id="multiSelectBtn">多选</button>
                        <button class="form-submit delete-button" id="deleteMessageBtn">删除</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(menu);
    }
    
    // 设置按钮点击事件
    document.getElementById('editMessageBtn').onclick = () => {
        closeModal(menuId);
        startEditMessage(messageIndex, messageElement);
    };
    
    document.getElementById('deleteMessageBtn').onclick = () => {
        closeModal(menuId);
        showConfirmDialog('删除消息', '确定要删除这条消息吗？此操作不可撤销。', () => deleteMessage(messageIndex));
    };
    
    document.getElementById('multiSelectBtn').onclick = () => {
        closeModal(menuId);
        enterMultiSelectMode();
    };
    
    showModal(menuId);
}

/**
 * 开始编辑消息
 * @param {number} messageIndex 消息索引
 * @param {HTMLElement} messageElement 消息DOM元素
 */
function startEditMessage(messageIndex, messageElement) {
    if (!currentContact || messageIndex === undefined || messageIndex < 0 || messageIndex >= currentContact.messages.length) {
        showToast('无效的消息索引或未选择聊天');
        return;
    }
    
    const message = currentContact.messages[messageIndex];
    
    // 创建编辑界面
    const editId = 'messageEditModal';
    let editModal = document.getElementById(editId);
    
    if (!editModal) {
        editModal = document.createElement('div');
        editModal.id = editId;
        editModal.className = 'modal';
        editModal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">编辑消息</div>
                    <div class="modal-close" onclick="closeModal('${editId}')">取消</div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">消息内容</label>
                        <textarea id="editMessageTextarea" class="form-textarea" placeholder="输入消息内容..." rows="6"></textarea>
                    </div>
                    <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 20px;">
                        <button class="form-submit" style="background-color: #ccc; flex: 1;" onclick="closeModal('${editId}')">取消</button>
                        <button class="form-submit" style="flex: 1;" id="saveEditedMessageBtn">保存</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(editModal);
    }
    
    // 填充当前消息内容
    document.getElementById('editMessageTextarea').value = message.content;
    
    // 设置保存按钮事件
    document.getElementById('saveEditedMessageBtn').onclick = () => {
        const newContent = document.getElementById('editMessageTextarea').value.trim();
        if (!newContent) {
            showToast('消息内容不能为空');
            return;
        }
        saveEditedMessage(messageIndex, newContent);
        closeModal(editId);
    };
    
    showModal(editId);
    
    // 聚焦到文本域并选中全部文本
    setTimeout(() => {
        const textarea = document.getElementById('editMessageTextarea');
        textarea.focus();
        textarea.select();
    }, 300);
}

/**
 * 保存编辑后的消息
 * @param {number} messageIndex 消息索引
 * @param {string} newContent 新的消息内容
 */
async function saveEditedMessage(messageIndex, newContent) {
    if (!currentContact || messageIndex === undefined || messageIndex < 0 || messageIndex >= currentContact.messages.length) {
        showToast('无效的消息索引或未选择聊天');
        return;
    }
    
    // 更新消息内容
    currentContact.messages[messageIndex].content = newContent;
    currentContact.messages[messageIndex].edited = true;
    currentContact.messages[messageIndex].editTime = new Date().toISOString();
    
    // 重新渲染消息
    renderMessages(false);
    
    // 保存到数据库
    await saveDataToDB();
    
    showToast('消息已更新');
}

// formatContactListTime function moved to utils/formatUtils.js

// formatChatTimestamp function moved to utils/formatUtils.js

// --- 事件监听 ---
document.getElementById('chatInput').addEventListener('keypress', async (e) => { // Make it async
    if (e.key === 'Enter' && !e.shiftKey) { 
        e.preventDefault(); 
        await sendUserMessage(); // Await the user message
    } 
});

document.addEventListener('click', (e) => {
    const settingsPage = document.getElementById('contactSettingsPage');
    
    // 检查新的设置页面 - 如果点击的是页面外部且不是触发按钮，则关闭
    if (settingsPage && settingsPage.classList.contains('active') && 
        !settingsPage.contains(e.target) && !e.target.closest('.chat-more')) {
        // 但是不要在点击模态框时关闭设置页面
        if (!e.target.closest('.modal')) {
            closeContactSettingsPage();
        }
    }
});

// --- 1. 修改你的 DOMContentLoaded 事件监听器 ---
// 找到文件末尾的这个事件监听器，用下面的代码替换它

document.addEventListener('DOMContentLoaded', async () => {
    // 立即设置主应用初始化标志，通知扩展模块
    window.mainAppInitializing = true;
    window.mainAppInitStartTime = Date.now();
    
    // 显示初始化提示
    showInitializationProgress('正在启动应用...', 'system');
    
    try {
        // 验证和初始化APIService
        console.log('=== 页面初始化开始 ===');
        showInitializationProgress('正在检查API服务...', 'api');
        console.log('APIService状态:', !!window.apiService);
        
        if (!window.apiService && typeof APIService !== 'undefined') {
            console.log('重新初始化APIService...');
            window.apiService = new APIService();
            console.log('APIService重新初始化完成');
        }
        
        // 初始化模型能力检测器
        if (!window.modelCapabilityDetector && typeof ModelCapabilityDetector !== 'undefined') {
            console.log('初始化模型能力检测器...');
            window.modelCapabilityDetector = new ModelCapabilityDetector();
            console.log('模型能力检测器初始化完成');
        }
        
        console.log('最终APIService状态:', !!window.apiService);
        console.log('========================');
        
        // 注册Service Worker
        showInitializationProgress('正在注册Service Worker...', 'worker');
        if (window.SystemUtils && typeof window.SystemUtils.registerServiceWorker === 'function') {
            console.log('SystemUtils.registerServiceWorker disabled in single-file mode');
        }
              
        // 检查URL中是否有导入ID
        showInitializationProgress('正在检查URL参数...', 'url');
        const urlParams = new URLSearchParams(window.location.search);
        const importId = urlParams.get('importId');

        if (importId) {
            // 如果有ID，则执行自动导入流程
            showInitializationProgress('正在执行自动导入...', 'import');
            await handleAutoImport(importId);
        } else {
            // 否则，正常初始化应用
            showInitializationProgress('正在初始化数据库...', 'database');
            await init();
        }
        
        // 初始化完成
        const initTime = Date.now() - window.mainAppInitStartTime;
        console.log(`[主应用] 初始化完成，耗时: ${initTime}ms`);
        
        // 发送初始化完成事件
        if (typeof window.dispatchEvent === 'function') {
            window.dispatchEvent(new CustomEvent('mainAppInitComplete', {
                detail: { 
                    initTime: initTime,
                    timestamp: Date.now()
                }
            }));
        }
        
        // 隐藏初始化提示
        hideInitializationProgress();
        
    } catch (error) {
        console.error('[主应用] 初始化失败:', error);
        showInitializationProgress('应用启动失败: ' + error.message, 'error');
        setTimeout(() => hideInitializationProgress(), 5000);
    } finally {
        window.mainAppInitializing = false;
        
        // 启动联系人时间定时更新器
        startContactTimeUpdater();
    }
});

// 全局错误处理器
window.addEventListener('error', (event) => {
    console.error('全局JavaScript错误:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error ? {
            name: event.error.name,
            message: event.error.message,
        } : null,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
    });
});

// 处理Promise rejections（重复的监听器，应该统一处理）
// window.addEventListener('unhandledrejection', (event) => {
//     console.error('未处理的Promise拒绝:', {
//         reason: event.reason,
//         promise: event.promise,
//         timestamp: new Date().toISOString(),
//         userAgent: navigator.userAgent,
//         url: window.location.href
//     });
//     event.preventDefault(); // 阻止默认浏览器提示框
// });
// 注释掉重复的监听器，使用第一个已经有preventDefault的监听器

// --- 新增：帖子选择和手动发帖功能 ---

function showPostChoiceModal() {
    showModal('postChoiceModal');
}

function selectPostType(type) {
    closeModal('postChoiceModal');
    
    if (type === 'manual') {
        showManualPostModal();
    } else if (type === 'generate') {
        showGeneratePostModal();
    }
}

function showManualPostModal() {
    // 设置默认发帖人为用户
    document.getElementById('manualPostAuthor').value = userProfile.name;
    document.getElementById('manualPostTag').value = '碎碎念';
    document.getElementById('manualPostContent').value = '';
    document.getElementById('manualPostImageDesc').value = '';
    
    // manualPostUnsplashKey元素已从HTML中移除，不再恢复Unsplash API Key
    
    showModal('manualPostModal');
}

async function handleManualPost(event) {
    event.preventDefault();
    
    const authorName = document.getElementById('manualPostAuthor').value;
    const relationTag = document.getElementById('manualPostTag').value.trim();
    const postContent = document.getElementById('manualPostContent').value.trim();
    const imageDescription = document.getElementById('manualPostImageDesc').value.trim();
    // manualPostUnsplashKey元素已从HTML中移除，从localStorage直接获取
    const unsplashKey = localStorage.getItem('forumUnsplashApiKey') || '';
    
    if (!postContent) {
        showToast('请填写帖子内容');
        return;
    }
    
    if (!relationTag) {
        showToast('请填写话题标签');
        return;
    }
    
    // Unsplash API Key已从localStorage获取，无需重复保存
    
    closeModal('manualPostModal');
    
    // 生成手动帖子
    await generateManualPost(authorName, relationTag, postContent, imageDescription, unsplashKey);
}

async function generateManualPost(authorName, relationTag, postContent, imageDescription, unsplashKey = null) {
    const now = Date.now();
    const postCreatedAt = new Date(now - (Math.random() * 3 + 2) * 60 * 1000);
    
    // 先创建不带评论的帖子并立即显示
    const weiboData = {
        relation_tag: relationTag,
        posts: [{
            author_type: 'User', // 用户自己发的帖子
            post_content: postContent,
            image_description: imageDescription || '暂无图片描述',
            comments: [], // 先显示空评论，后面再添加
            timestamp: postCreatedAt.toISOString()
        }]
    };
    
    // 为手动帖子生成图片
    if (unsplashKey && imageDescription && imageDescription.trim()) {
        try {
            const imageUrl = await fetchMatchingImageForPublish(imageDescription, unsplashKey);
            if (imageUrl) {
                // 将图片描述替换为实际图片HTML
                weiboData.posts[0].actual_image_url = imageUrl;
                // 保留原始描述用于备份
                weiboData.posts[0].original_image_description = imageDescription;
                weiboData.posts[0].image_description = `<img src="${imageUrl}" alt="${imageDescription}" style="width: 100%; max-width: 300px; border-radius: 8px;">`;
            }
        } catch (imageError) {
            console.warn(`为手动帖子生成图片失败: ${imageError.message}`);
            // 图片生成失败时保持原始文字描述
        }
    }
    
    const newPost = {
        id: Date.now(),
        contactId: null, // 用户自己发的帖子
        relations: relationTag,
        relationDescription: relationTag,
        hashtag: relationTag,
        data: weiboData,
        createdAt: postCreatedAt.toISOString()
    };

    // 保存并立即显示帖子
    await saveWeiboPost(newPost);
    weiboPosts.push(newPost);
    renderAllWeiboPosts();
    showToast('帖子发布成功！');

    // 检查并更新全局记忆（用户发帖内容）
    if (window.characterMemoryManager) {
        const forumContent = `用户发帖：\n标题：${relationTag}\n内容：${postContent}${imageDescription ? '\n图片描述：' + imageDescription : ''}`;
        window.characterMemoryManager.checkAndUpdateGlobalMemory(forumContent);
    }

    // 获取API调用信息，如果未配置则不生成评论
    let apiCallInfo;
    try {
        apiCallInfo = await getApiCallInfo();
    } catch (error) {
        showToast('未配置API或模型，仅发布帖子，无评论生成');
        return;
    }
    
    // 显示加载指示器
    const container = document.getElementById('weiboContainer');
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'loading-text';
    loadingIndicator.textContent = '正在生成评论...';
    loadingIndicator.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; z-index: 1000;';
    document.body.appendChild(loadingIndicator);
    
    try {
        // 调用新的手动帖子提示词构建方法
        const systemPrompt = await window.promptBuilder.buildManualPostPrompt(
            authorName,
            relationTag,
            postContent,
            imageDescription,
            userProfile,
            contacts,
            emojis
        );
        
        const payload = {
            model: apiCallInfo.model,
            messages: [{ role: 'user', content: systemPrompt }],
            response_format: { type: "json_object" },
            temperature: 0.8
        };

        const apiUrl = `${apiCallInfo.url}/chat/completions`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiCallInfo.key}`
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('ERROR: 朋友圈图片生成API失败 - 完整返回:', errorText);
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        let rawText = data.choices[0].message.content;
        
        if (!rawText) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(data, null, 2));
            throw new Error("AI未返回有效内容");
        }
        
        // 使用统一的JSON提取函数清理markdown语法
        let cleanedJson;
        try {
            cleanedJson = window.apiService.extractJSON(rawText);
        } catch (extractError) {
            console.error('ERROR: JSON提取失败 - API完整返回:', rawText);
            console.error('ERROR: JSON提取失败 - 错误详情:', extractError);
            throw new Error(`JSON提取失败: ${extractError.message}`);
        }

        const commentsData = JSON.parse(cleanedJson);
        
        let lastCommentTime = postCreatedAt.getTime();
        
        // 为每个评论添加时间戳
        const comments = commentsData.comments.map(comment => {
            const newCommentTimestamp = lastCommentTime + (Math.random() * 2 * 60 * 1000);
            lastCommentTime = newCommentTimestamp;
            return formatCommentForDataModel({
                ...comment,
                timestamp: new Date(Math.min(newCommentTimestamp, now)).toISOString()
            });
        });

        // 更新帖子数据，添加评论
        newPost.data.posts[0].comments = comments;
        
        // 更新数据库
        await updateWeiboPost(newPost);
        
        // 也需要更新内存中的数组
        const postIndex = weiboPosts.findIndex(p => p.id === newPost.id);
        if (postIndex !== -1) {
            weiboPosts[postIndex] = newPost;
        }
        
        // 重新渲染页面
        renderAllWeiboPosts();
        showToast('评论生成完成！');

    } catch (error) {
        console.error('生成评论失败:', error);
        showApiError(error);
    } finally {
        loadingIndicator.remove();
    }
}

// --- 批量删除消息功能 ---

/**
 * 进入多选模式
 */
function enterMultiSelectMode() {
    if (!currentContact) return;
    
    isMultiSelectMode = true;
    selectedMessages.clear();
    
    // 重新渲染消息以显示多选状态
    renderMessages(false);
    
    // 显示操作按钮
    showMultiSelectButtons();
    
    showToast('多选模式已开启，点击消息进行选择');
}

/**
 * 退出多选模式
 */
function exitMultiSelectMode() {
    isMultiSelectMode = false;
    selectedMessages.clear();
    
    // 重新渲染消息
    renderMessages(false);
    
    // 隐藏操作按钮
    hideMultiSelectButtons();
}

/**
 * 显示多选操作按钮
 */
function showMultiSelectButtons() {
    let buttonsDiv = document.getElementById('multiSelectButtons');
    if (!buttonsDiv) {
        buttonsDiv = document.createElement('div');
        buttonsDiv.id = 'multiSelectButtons';
        buttonsDiv.className = 'multi-select-buttons';
        buttonsDiv.innerHTML = `
            <button class="multi-select-btn cancel-btn" onclick="exitMultiSelectMode()">取消</button>
            <button class="multi-select-btn delete-btn" onclick="deleteSelectedMessages()">删除</button>
        `;
        document.body.appendChild(buttonsDiv);
    }
    buttonsDiv.style.display = 'flex';
    
    // 隐藏底部导航栏
    const bottomNav = document.querySelector('.bottom-nav');
    if (bottomNav) {
        bottomNav.style.display = 'none';
    }
}

/**
 * 隐藏多选操作按钮
 */
function hideMultiSelectButtons() {
    const buttonsDiv = document.getElementById('multiSelectButtons');
    if (buttonsDiv) {
        buttonsDiv.style.display = 'none';
    }
    
    // 显示底部导航栏
    const bottomNav = document.querySelector('.bottom-nav');
    if (bottomNav) {
        bottomNav.style.display = 'flex';
    }
}

/**
 * 切换消息的选中状态
 */
function toggleMessageSelection(messageIndex) {
    if (selectedMessages.has(messageIndex)) {
        selectedMessages.delete(messageIndex);
    } else {
        selectedMessages.add(messageIndex);
    }
    
    // 更新该消息的视觉效果
    updateMessageSelectStyle(messageIndex);
}

/**
 * 更新消息的选中样式
 */
function updateMessageSelectStyle(messageIndex) {
    const messageElements = document.querySelectorAll('.message');
    const messageElement = Array.from(messageElements).find(el => 
        parseInt(el.dataset.messageIndex) === messageIndex
    );
    
    if (messageElement) {
        if (selectedMessages.has(messageIndex)) {
            messageElement.classList.add('message-selected');
        } else {
            messageElement.classList.remove('message-selected');
        }
    }
}

/**
 * 删除选中的消息
 */
function deleteSelectedMessages() {
    if (selectedMessages.size === 0) {
        showToast('请先选择要删除的消息');
        return;
    }
    
    const selectedCount = selectedMessages.size;
    showConfirmDialog('批量删除确认', `即将批量删除所选消息（${selectedCount}条），是否确认？`, async () => {
        try {
            // 将选中的索引转换为数组并排序（从大到小，避免删除时索引变化）
            const sortedIndexes = Array.from(selectedMessages).sort((a, b) => b - a);
            
            // 保存被删除的消息，用于记忆更新
            const deletedMessages = [];
            for (const messageIndex of sortedIndexes) {
                if (messageIndex < currentContact.messages.length) {
                    deletedMessages.push(currentContact.messages[messageIndex]);
                }
            }
            
            // 逐个删除消息
            for (const messageIndex of sortedIndexes) {
                if (messageIndex < currentContact.messages.length) {
                    currentContact.messages.splice(messageIndex, 1);
                }
            }
            
            // 更新联系人最后消息信息
            if (currentContact.messages.length > 0) {
                const lastMsg = currentContact.messages[currentContact.messages.length - 1];
                currentContact.lastMessage = lastMsg.type === 'text' ? lastMsg.content.substring(0, 20) + '...' : 
                                           (lastMsg.type === 'emoji' ? '[表情]' : '[红包]');
                currentContact.lastTime = formatContactListTime(lastMsg.time);
            } else {
                currentContact.lastMessage = '暂无消息';
                currentContact.lastTime = formatContactListTime(new Date().toISOString());
            }
            
            // 更新当前显示的消息数量
            if (currentlyDisplayedMessageCount > currentContact.messages.length) {
                currentlyDisplayedMessageCount = currentContact.messages.length;
            }
            
            // 退出多选模式
            exitMultiSelectMode();
            
            // 重新渲染
            await renderContactList();
            await saveDataToDB();
            
            // 检查并更新记忆
            if (window.checkAndUpdateMemoryAfterDeletion && deletedMessages.length > 0) {
                try {
                    await window.checkAndUpdateMemoryAfterDeletion(currentContact.id, deletedMessages, currentContact);
                } catch (error) {
                    console.error('批量删除消息后更新记忆失败:', error);
                }
            }
            
            showToast(`已成功删除 ${selectedCount} 条消息`);
            
        } catch (error) {
            console.error('批量删除消息失败:', error);
            showToast('删除失败：' + error.message);
        }
    });
}

// === 记忆管理系统 ===
class MemoryManager {
    constructor() {
        // 不再使用localStorage存储，直接使用indexedDB
        this.currentMemoryType = 'global';
        this.currentCharacter = null;
        this.selectedMemoryId = null;
    }

    // 获取全局记忆（从indexedDB读取）
    async getGlobalMemories() {
        if (!window.characterMemoryManager) {
            return [];
        }
        
        const globalMemory = await window.characterMemoryManager.getGlobalMemory();
        if (!globalMemory || !globalMemory.trim()) {
            return [];
        }
        
        // 将全局记忆转换为记忆数组格式
        const memoryItems = this.parseMemoryItems(globalMemory);
        return [{
            id: 'global-memory',
            content: globalMemory,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            items: memoryItems
        }];
    }

    // 获取角色记忆（从indexedDB读取）
    async getCharacterMemories(characterId) {
        if (!window.characterMemoryManager) {
            return [];
        }
        
        const characterMemory = await window.characterMemoryManager.getCharacterMemory(characterId);
        if (!characterMemory || !characterMemory.trim()) {
            return [];
        }
        
        // 将角色记忆转换为记忆数组格式
        const memoryItems = this.parseMemoryItems(characterMemory);
        return [{
            id: `character-memory-${characterId}`,
            content: characterMemory,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            items: memoryItems
        }];
    }

    // 添加全局记忆（直接保存到indexedDB）
    async addGlobalMemory(content) {
        // 清理内容，只保留有效的markdown列表项
        const cleanedContent = this.cleanAndValidateMemoryContent(content);
        
        if (!cleanedContent) {
            throw new Error('无效的记忆格式！请使用 "- 记忆内容" 的格式');
        }
        
        if (!window.characterMemoryManager) {
            throw new Error('记忆管理系统未初始化');
        }
        
        // 获取现有全局记忆
        const existingMemory = await window.characterMemoryManager.getGlobalMemory();
        let combinedMemory;
        
        if (existingMemory && existingMemory.trim()) {
            combinedMemory = existingMemory + '\n' + cleanedContent;
        } else {
            combinedMemory = cleanedContent;
        }
        
        // 直接保存到indexedDB
        const success = await window.characterMemoryManager.saveGlobalMemory(combinedMemory);
        
        if (!success) {
            throw new Error('保存全局记忆失败');
        }
        
        const memory = {
            id: Date.now().toString(),
            content: cleanedContent,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        return memory;
    }

    // 添加角色记忆（直接保存到indexedDB）
    async addCharacterMemory(characterId, content) {
        // 清理内容，只保留有效的markdown列表项
        const cleanedContent = this.cleanAndValidateMemoryContent(content);
        
        if (!cleanedContent) {
            throw new Error('无效的记忆格式！请使用 "- 记忆内容" 的格式');
        }
        
        if (!window.characterMemoryManager) {
            throw new Error('记忆管理系统未初始化');
        }
        
        // 获取现有角色记忆
        const existingMemory = await window.characterMemoryManager.getCharacterMemory(characterId);
        let combinedMemory;
        
        if (existingMemory && existingMemory.trim()) {
            combinedMemory = existingMemory + '\n' + cleanedContent;
        } else {
            combinedMemory = cleanedContent;
        }
        
        // 直接保存到indexedDB
        const success = await window.characterMemoryManager.saveCharacterMemory(characterId, combinedMemory);
        
        if (!success) {
            throw new Error('保存角色记忆失败');
        }
        
        const memory = {
            id: Date.now().toString(),
            content: cleanedContent,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        return memory;
    }

    // 更新记忆（直接更新indexedDB）
    async updateMemory(memoryId, content, isCharacter = false, characterId = null) {
        // 清理内容，只保留有效的markdown列表项
        const cleanedContent = this.cleanAndValidateMemoryContent(content);
        
        if (!cleanedContent) {
            throw new Error('无效的记忆格式！请使用 "- 记忆内容" 的格式');
        }
        
        if (!window.characterMemoryManager) {
            throw new Error('记忆管理系统未初始化');
        }
        
        let success = false;
        
        if (isCharacter && characterId) {
            // 直接替换角色记忆内容
            success = await window.characterMemoryManager.saveCharacterMemory(characterId, cleanedContent);
        } else {
            // 直接替换全局记忆内容
            success = await window.characterMemoryManager.saveGlobalMemory(cleanedContent);
        }
        
        if (!success) {
            throw new Error('更新记忆失败');
        }
        
        const memory = {
            id: memoryId,
            content: cleanedContent,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        return memory;
    }

    // 删除记忆（直接从 indexedDB 删除）
    async deleteMemory(memoryId, isCharacter = false, characterId = null) {
        if (!window.characterMemoryManager) {
            throw new Error('记忆管理系统未初始化');
        }
        
        let success = false;
        
        if (isCharacter && characterId) {
            // 清空角色记忆
            success = await window.characterMemoryManager.saveCharacterMemory(characterId, '');
        } else {
            // 清空全局记忆
            success = await window.characterMemoryManager.saveGlobalMemory('');
        }
        
        return success;
    }

    // 注意：这些同步方法已被上面的异步方法替代
    // 如果代码中有同步调用，会出现错误，需要改为异步调用

    // 清理和验证记忆内容，只保留有效的markdown列表项
    cleanAndValidateMemoryContent(content) {
        if (!content || typeof content !== 'string') {
            return '';
        }
        
        const lines = content.split('\n');
        const validLines = [];
        
        lines.forEach(line => {
            const trimmedLine = line.trim();
            // 只保留以 "- " 开头的行
            if (trimmedLine.startsWith('- ') && trimmedLine.length > 2) {
                validLines.push(trimmedLine);
            }
        });
        
        return validLines.join('\n');
    }
    
    // 将记忆内容分解为单独的记忆项列表
    parseMemoryItems(content) {
        const cleanContent = this.cleanAndValidateMemoryContent(content);
        if (!cleanContent) return [];
        
        return cleanContent.split('\n').map(line => {
            // 移除前面的 "- " 得到纯内容
            return line.replace(/^- /, '').trim();
        }).filter(item => item.length > 0);
    }
    
    // 从记忆项列表重建markdown内容
    buildMemoryContent(items) {
        if (!Array.isArray(items) || items.length === 0) {
            return '';
        }
        
        return items.map(item => `- ${item.trim()}`).join('\n');
    }
    
    // 解析Markdown到HTML（仅支持列表）
    parseMarkdown(content) {
        const cleanContent = this.cleanAndValidateMemoryContent(content);
        if (!cleanContent) return '';
        
        const lines = cleanContent.split('\n');
        const listItems = lines.map(line => {
            const item = line.replace(/^- /, '');
            return `<li>${this.escapeHtml(item)}</li>`;
        }).join('');
        
        return listItems ? `<ul>${listItems}</ul>` : '';
    }
    
    // HTML转义
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// 初始化记忆管理器
const memoryManager = new MemoryManager();

// 显示添加记忆模态框
async function showAddMemoryModal() {
    const modal = document.getElementById('addMemoryModal');
    const memoryType = document.getElementById('memoryType');
    const characterSelectGroup = document.getElementById('characterSelectGroup');
    const memoryCharacterSelect = document.getElementById('memoryCharacterSelect');
    
    // 默认设置为全局记忆类型
    memoryType.value = 'global';
    
    // 如果数据还没准备好，等待一下
    if (!window.contacts || !Array.isArray(window.contacts) || window.contacts.length === 0) {
        console.log('数据未准备好，等待加载...');
        await waitForDataReady();
    }
    
    // 填充角色选择器
    memoryCharacterSelect.innerHTML = '<option value="">选择角色...</option>';
    
    // 确保contacts数组存在
    if (window.contacts && Array.isArray(window.contacts)) {
        let aiCount = 0;
        
        window.contacts.forEach(contact => {
            console.log(`检查联系人: ${contact.name}, 类型: ${contact.type}`);
            if (contact.type === 'private') {
                const option = document.createElement('option');
                option.value = contact.id;
                option.textContent = contact.name;
                memoryCharacterSelect.appendChild(option);
                aiCount++;
            }
        });
        
        if (aiCount === 0) {
            console.warn('没有找到任何AI角色，可能数据有问题');
            const option = document.createElement('option');
            option.value = '';
            option.textContent = '暂无可用角色';
            option.disabled = true;
            memoryCharacterSelect.appendChild(option);
        }
    } else {
        console.warn('contacts数组不可用，无法填充角色选择器');
        const option = document.createElement('option');
        option.value = '';
        option.textContent = '数据加载中...';
        option.disabled = true;
        memoryCharacterSelect.appendChild(option);
    }
    
    // 初始化时确保隐藏角色选择（因为默认是全局记忆）
    characterSelectGroup.classList.add('hidden');
    
    showModal('addMemoryModal');
}

// 处理记忆类型改变
function handleMemoryTypeChange() {
    const memoryType = document.getElementById('memoryType').value;
    const characterSelectGroup = document.getElementById('characterSelectGroup');
    
    if (memoryType === 'character') {
        characterSelectGroup.classList.remove('hidden');
    } else {
        characterSelectGroup.classList.add('hidden');
    }
}

// 处理添加记忆
async function handleAddMemory(event) {
    event.preventDefault();
    
    const memoryType = document.getElementById('memoryType').value;
    let memoryContent = document.getElementById('memoryContent').value.trim();
    const memoryCharacterSelect = document.getElementById('memoryCharacterSelect').value;
    
    // 自动为每行添加 - 前缀
    if (memoryContent) {
        const lines = memoryContent.split('\n');
        const formattedLines = lines.map(line => {
            const trimmedLine = line.trim();
            if (trimmedLine && !trimmedLine.startsWith('- ')) {
                return '- ' + trimmedLine;
            }
            return trimmedLine;
        }).filter(line => line.length > 0);
        memoryContent = formattedLines.join('\n');
    }
    
    if (!memoryContent) {
        showToast('请输入记忆内容');
        return;
    }
    
    if (memoryType === 'character' && !memoryCharacterSelect) {
        console.error('角色记忆但未选择角色:', { memoryType, memoryCharacterSelect });
        showToast('请选择角色');
        return;
    }
    
    // 验证选择的角色是否存在（角色记忆模式）
    if (memoryType === 'character') {
        const selectedContact = window.contacts && window.contacts.find(c => c.id === memoryCharacterSelect);
        if (!selectedContact) {
            console.error('选择的角色不存在:', memoryCharacterSelect);
            showToast('选择的角色不存在，请重新选择');
            return;
        }
    }
    
    try {
        if (memoryType === 'global') {
            await memoryManager.addGlobalMemory(memoryContent);
            showToast('全局记忆添加成功');
            if (memoryManager.currentMemoryType === 'global') {
                loadGlobalMemories();
            }
        } else {
            await memoryManager.addCharacterMemory(memoryCharacterSelect, memoryContent);
            showToast('角色记忆添加成功');
            if (memoryManager.currentMemoryType === 'character' && memoryManager.currentCharacter === memoryCharacterSelect) {
                loadCharacterMemories();
            }
        }
        
        closeModal('addMemoryModal');
        document.getElementById('memoryContent').value = '';
    } catch (error) {
        console.error('添加记忆失败:', error);
        showToast('添加记忆失败');
    }
}

// 切换记忆标签
function switchMemoryTab(type) {
    const globalTab = document.querySelector('.memory-tab:first-child');
    const characterTab = document.querySelector('.memory-tab:last-child');
    const globalSection = document.getElementById('globalMemorySection');
    const characterSection = document.getElementById('characterMemorySection');
    
    // 更新标签样式
    globalTab.classList.toggle('active', type === 'global');
    characterTab.classList.toggle('active', type === 'character');
    
    // 显示对应内容
    globalSection.classList.toggle('hidden', type !== 'global');
    characterSection.classList.toggle('hidden', type !== 'character');
    
    memoryManager.currentMemoryType = type;
    
    if (type === 'global') {
        loadGlobalMemories();
    } else {
        // 切换到角色记忆时重新加载角色选择器
        loadCharacterSelector();
        
        // 如果角色选择器为空，说明数据可能还没加载完成
        const characterSelector = document.getElementById('characterSelector');
        if (characterSelector && characterSelector.options.length <= 1) {
            waitForDataReady().then(() => {
                loadCharacterSelector();
            });
        }
    }
}

// 加载全局记忆
async function loadGlobalMemories() {
    const memoryList = document.getElementById('globalMemoryList');
    if (!memoryList) return;
    
    try {
        const memories = await memoryManager.getGlobalMemories();
        
        if (memories.length === 0) {
            memoryList.innerHTML = '<div class="memory-empty">暂无全局记忆</div>';
            return;
        }
        
        memoryList.innerHTML = memories.map(memory => createMemoryItem(memory, false)).join('');
    } catch (error) {
        console.error('加载全局记忆失败:', error);
        memoryList.innerHTML = '<div class="memory-empty">加载失败</div>';
    }
}

// 加载角色选择器
function loadCharacterSelector() {
    const characterSelector = document.getElementById('characterSelector');
    if (!characterSelector) {
        console.error('角色选择器元素未找到');
        return;
    }
    
    characterSelector.innerHTML = '<option value="">选择角色...</option>';
    
    // 确保contacts数组存在
    if (!window.contacts || !Array.isArray(window.contacts)) {
        console.warn('contacts数组不可用，无法加载角色');
        return;
    }
        
    let aiContactCount = 0;
    let totalContactCount = 0;
    window.contacts.forEach(contact => {
        totalContactCount++;
        if (contact.type === 'private') {
            const option = document.createElement('option');
            option.value = contact.id;
            option.textContent = contact.name;
            characterSelector.appendChild(option);
            aiContactCount++;
        }
    });
    
    
    // 如果没有加载到任何角色，强制刷新一次
    if (aiContactCount === 0 && totalContactCount > 0) {
        setTimeout(() => {
            loadCharacterSelector();
        }, 1000);
    }
}

// 加载角色记忆
async function loadCharacterMemories() {
    const characterSelector = document.getElementById('characterSelector');
    const memoryList = document.getElementById('characterMemoryList');
    
    if (!characterSelector || !memoryList) {
        return;
    }
    
    const characterId = characterSelector.value;
    
    if (!characterId) {
        memoryList.innerHTML = '<div class="memory-empty">请先选择角色</div>';
        return;
    }
    
    // 验证选择的角色是否存在
    const selectedContact = window.contacts && window.contacts.find(c => c.id === characterId);
    if (!selectedContact) {
        memoryList.innerHTML = '<div class="memory-empty">选择的角色不存在，请重新选择</div>';
        return;
    }
    
    try {
        memoryManager.currentCharacter = characterId;
        const memories = await memoryManager.getCharacterMemories(characterId);
        
        if (memories.length === 0) {
            memoryList.innerHTML = '<div class="memory-empty">该角色暂无记忆</div>';
            return;
        }
        
        memoryList.innerHTML = memories.map(memory => createMemoryItem(memory, true, characterId)).join('');
    } catch (error) {
        console.error('加载角色记忆失败:', error);
        memoryList.innerHTML = '<div class="memory-empty">加载失败</div>';
    }
}

// 创建记忆项HTML - 改为单条模式
function createMemoryItem(memory, isCharacter, characterId = null) {
    const date = new Date(memory.createdAt).toLocaleDateString();
    const memoryItems = memoryManager.parseMemoryItems(memory.content);
    
    // 为每个记忆项创建单独的卡片
    return memoryItems.map((item, index) => {
        const itemId = `${memory.id}-${index}`;
        
        return `
            <div class="memory-item single-item" data-id="${itemId}" data-memory-id="${memory.id}" data-item-index="${index}">
                <div class="memory-single-content">
                    <div class="memory-text">${memoryManager.escapeHtml(item)}</div>
                    <div class="memory-meta">
                        <span class="memory-date">${date}</span>
                        <div class="memory-actions">
                            <button class="memory-edit-btn" onclick="editSingleMemoryItem('${memory.id}', ${index}, ${isCharacter}, '${characterId || ''}')">修改</button>
                            <button class="memory-edit-btn delete" onclick="deleteSingleMemoryItem('${memory.id}', ${index}, ${isCharacter}, '${characterId || ''}')">删除</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// 编辑单个记忆项
async function editSingleMemoryItem(memoryId, itemIndex, isCharacter, characterId) {
    let memory;
    if (isCharacter && characterId) {
        const memories = await memoryManager.getCharacterMemories(characterId);
        if (!Array.isArray(memories)) {
            showToast('获取记忆数据失败');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    } else {
        const memories = await memoryManager.getGlobalMemories();
        if (!Array.isArray(memories)) {
            showToast('获取记忆数据失败');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    }
    
    if (!memory) {
        showToast('记忆未找到');
        return;
    }
    
    const memoryItems = memoryManager.parseMemoryItems(memory.content);
    if (itemIndex >= memoryItems.length) {
        showToast('记忆项未找到');
        return;
    }
    
    const currentItem = memoryItems[itemIndex];
    
    // 设置编辑上下文信息
    memoryManager.singleMemoryEditContext = {
        memoryId,
        itemIndex,
        isCharacter,
        characterId,
        memoryItems
    };
    
    // 使用自定义模态窗口进行编辑
    const editSingleContentTextarea = document.getElementById('editSingleMemoryContent');
    editSingleContentTextarea.value = currentItem;
    
    showModal('editSingleMemoryModal');
}

// 删除单个记忆项
async function deleteSingleMemoryItem(memoryId, itemIndex, isCharacter, characterId) {
    if (!confirm('确定要删除这条记忆吗？')) {
        return;
    }
    
    let memory;
    if (isCharacter && characterId) {
        const memories = await memoryManager.getCharacterMemories(characterId);
        if (!Array.isArray(memories)) {
            showToast('获取记忆数据失败');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    } else {
        const memories = await memoryManager.getGlobalMemories();
        if (!Array.isArray(memories)) {
            showToast('获取记忆数据失败');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    }
    
    if (!memory) {
        showToast('记忆未找到');
        return;
    }
    
    const memoryItems = memoryManager.parseMemoryItems(memory.content);
    if (itemIndex >= memoryItems.length) {
        showToast('记忆项未找到');
        return;
    }
    
    // 删除指定项
    memoryItems.splice(itemIndex, 1);
    
    if (memoryItems.length === 0) {
        // 如果没有记忆项了，删除整个记忆
        await memoryManager.deleteMemory(memoryId, isCharacter, characterId);
    } else {
        // 更新记忆内容
        const updatedContent = memoryManager.buildMemoryContent(memoryItems);
        await updateSingleMemory(memoryId, updatedContent, isCharacter, characterId);
    }
    
    // 刷新显示
    if (isCharacter) {
        loadCharacterMemories();
    } else {
        loadGlobalMemories();
    }
    
    showToast('记忆删除成功');
}

// 更新单个记忆的辅助函数
async function updateSingleMemory(memoryId, content, isCharacter, characterId) {
    try {
        const updated = await memoryManager.updateMemory(memoryId, content, isCharacter, characterId);
        if (updated) {
            // 刷新显示
            if (isCharacter) {
                loadCharacterMemories();
            } else {
                loadGlobalMemories();
            }
            showToast('记忆更新成功');
        } else {
            showToast('记忆更新失败');
        }
    } catch (error) {
        console.error('更新记忆失败:', error);
        showToast('记忆更新失败: ' + error.message);
    }
}

// 编辑记忆
async function editMemory(memoryId, isCharacter, characterId) {
    memoryManager.selectedMemoryId = memoryId;
    
    let memory;
    if (isCharacter && characterId) {
        const memories = await memoryManager.getCharacterMemories(characterId);
        if (!Array.isArray(memories)) {
            showToast('获取记忆数据失败');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    } else {
        const memories = await memoryManager.getGlobalMemories();
        if (!Array.isArray(memories)) {
            showToast('获取记忆数据失败');
            return;
        }
        memory = memories.find(m => m.id === memoryId);
    }
    
    if (!memory) {
        showToast('记忆未找到');
        return;
    }
    
    const editContentTextarea = document.getElementById('editMemoryContent');
    editContentTextarea.value = memory.content;
    
    // 存储编辑上下文
    memoryManager.editingContext = {
        isCharacter,
        characterId
    };
    
    showModal('editMemoryModal');
}

// 处理编辑记忆
async function handleEditMemory(event) {
    event.preventDefault();
    
    const newContent = document.getElementById('editMemoryContent').value.trim();
    const memoryId = memoryManager.selectedMemoryId;
    const context = memoryManager.editingContext || {};
    
    if (!newContent) {
        showToast('请输入记忆内容');
        return;
    }
    
    if (!memoryId) {
        showToast('记忆ID丢失');
        return;
    }
    
    try {
        const updated = await memoryManager.updateMemory(memoryId, newContent, context.isCharacter, context.characterId);
        if (updated) {
            showToast('记忆更新成功');
            closeModal('editMemoryModal');
            
            // 刷新显示
            if (context.isCharacter) {
                loadCharacterMemories();
            } else {
                loadGlobalMemories();
            }
        } else {
            showToast('记忆更新失败');
        }
    } catch (error) {
        console.error('更新记忆失败:', error);
        showToast('记忆更新失败');
    }
}

// 处理编辑单个记忆项
async function handleEditSingleMemory(event) {
    event.preventDefault();
    
    const newContent = document.getElementById('editSingleMemoryContent').value.trim();
    const context = memoryManager.singleMemoryEditContext;
    
    if (!newContent) {
        showToast('请输入记忆内容');
        return;
    }
    
    if (!context) {
        showToast('编辑上下文丢失');
        return;
    }
    
    try {
        // 更新记忆项
        context.memoryItems[context.itemIndex] = newContent;
        const updatedContent = memoryManager.buildMemoryContent(context.memoryItems);
        
        // 更新记忆
        await updateSingleMemory(context.memoryId, updatedContent, context.isCharacter, context.characterId);
        
        showToast('记忆项更新成功');
        closeModal('editSingleMemoryModal');
        
        // 清理上下文
        memoryManager.singleMemoryEditContext = null;
        
        // 刷新显示
        if (context.isCharacter) {
            loadCharacterMemories();
        } else {
            loadGlobalMemories();
        }
    } catch (error) {
        console.error('更新记忆项失败:', error);
        showToast('记忆项更新失败');
    }
}

// 删除记忆
async function deleteMemory(memoryId, isCharacter, characterId) {
    const confirmMessage = '确定要删除这条记忆吗？';
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        const deleted = await memoryManager.deleteMemory(memoryId, isCharacter, characterId);
        if (deleted) {
            showToast('记忆删除成功');
            
            // 刷新显示
            if (isCharacter) {
                loadCharacterMemories();
            } else {
                loadGlobalMemories();
            }
        } else {
            showToast('记忆删除失败');
        }
    } catch (error) {
        console.error('删除记忆失败:', error);
        showToast('记忆删除失败');
    }
}

// 初始化记忆管理页面
async function initMemoryManagementPage() {
    
    // 确保数据已经加载
    if (!window.contacts || !Array.isArray(window.contacts) || window.contacts.length === 0) {
        console.log('数据未准备好，等待加载完成...');
        const dataReady = await waitForDataReady();
        if (!dataReady) {
            console.warn('数据加载超时，但继续初始化页面');
        }
    }
    
    try {
        // 从现有系统加载数据
        await loadExistingMemories();
        
        // 默认加载全局记忆
        await loadGlobalMemories();
        loadCharacterSelector();
        
        // 检查角色选择器是否成功加载
        setTimeout(() => {
            const characterSelector = document.getElementById('characterSelector');
            if (characterSelector && characterSelector.options.length <= 1) {
                loadCharacterSelector();
            }
        }, 500);
        
    } catch (error) {
        console.error('初始化记忆管理页面失败:', error);
        // 即使加载失败也显示界面
        await loadGlobalMemories();
        loadCharacterSelector();
    }
}

// 从现有记忆系统加载数据
async function loadExistingMemories() {
    
    try {
        // 加载全局记忆
        const existingGlobalMemory = await getExistingGlobalMemory();
        if (existingGlobalMemory && existingGlobalMemory.trim()) {
            // 清理现有记忆内容
            const cleanedGlobalMemory = memoryManager.cleanAndValidateMemoryContent(existingGlobalMemory);
            
            if (cleanedGlobalMemory) {
                // 由于现在直接使用indexedDB，不需要操作globalMemories数组
                console.log('全局记忆已存在于indexedDB中，跳过重复加载');
                
                // 如果清理后的内容与原内容不同，更新到现有系统
                if (cleanedGlobalMemory !== existingGlobalMemory) {
                    await saveExistingGlobalMemory(cleanedGlobalMemory);
                }
            }
        }
        
        // 加载角色记忆
        if (window.contacts && Array.isArray(window.contacts)) {
            for (const contact of window.contacts) {
                if (contact.type === 'private') {
                    const existingCharacterMemory = await getExistingCharacterMemory(contact.id);
                    if (existingCharacterMemory && existingCharacterMemory.trim()) {
                        // 清理现有角色记忆内容
                        const cleanedCharacterMemory = memoryManager.cleanAndValidateMemoryContent(existingCharacterMemory);
                        
                        if (cleanedCharacterMemory) {
                            // 由于现在直接使用indexedDB，不需要操作characterMemories数组
                            console.log(`角色${contact.id}的记忆已存在于indexedDB中，跳过重复加载`);
                            
                            // 如果清理后的内容与原内容不同，更新到现有系统
                            if (cleanedCharacterMemory !== existingCharacterMemory) {
                                await saveExistingCharacterMemory(contact.id, cleanedCharacterMemory);
                            }
                        }
                    }
                }
            }
        }
        
    } catch (error) {
        console.error('加载现有记忆数据失败:', error);
    }
}

// 等待数据加载完成的函数
async function waitForDataReady() {
    let attempts = 0;
    const maxAttempts = 20; // 最多等待10秒
    
    while (attempts < maxAttempts) {
        if (window.contacts && Array.isArray(window.contacts) && window.isIndexedDBReady) {
            console.log(`数据准备完成，contacts数组长度: ${window.contacts.length}`);
            return true;
        }
        attempts++;
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log(`等待数据加载中... 尝试 ${attempts}/${maxAttempts}`);
    }
    
    console.warn('等待数据加载超时，继续初始化记忆管理页面');
    return false;
}

// 页面显示时初始化记忆管理
document.addEventListener('DOMContentLoaded', function() {
    // 当显示记忆管理页面时初始化
    const originalShowPage = showPage;
    window.showPage = function(pageIdToShow) {
        originalShowPage(pageIdToShow);
        if (pageIdToShow === 'memoryManagementPage') {
            // 等待数据准备完成后再初始化
            waitForDataReady().then((dataReady) => {
                if (dataReady) {
                } else {
                    console.warn('数据准备超时，但仍尝试初始化页面');
                }
                initMemoryManagementPage();
            });
        }
    };
});

// 集成现有的记忆系统 - 添加接口函数
async function getExistingGlobalMemory() {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.getGlobalMemory();
    }
    return '';
}

async function getExistingCharacterMemory(characterId) {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.getCharacterMemory(characterId);
    }
    return null;
}

async function saveExistingGlobalMemory(content) {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.saveGlobalMemory(content);
    }
    return false;
}

async function saveExistingCharacterMemory(characterId, content) {
    if (window.characterMemoryManager) {
        return await window.characterMemoryManager.saveCharacterMemory(characterId, content);
    }
    return false;
}

// 语音图标生成函数
function createVoiceIcon(state = 'default') {
    const baseProps = 'width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"';
    
    switch (state) {
        case 'loading':
            return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6"/></svg>`;
        case 'playing':
            return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
        default:
            return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><path d="M3 10v4 M7 7v10 M12 4v16 M17 7v10 M21 10v4" /></svg>`;
    }
}

// ElevenLabs 语音播放功能
/**
 * [MODIFIED] 播放或停止语音消息 - 支持缓存的 Minimax API
 * @param {HTMLElement} bubbleElement - 被点击的气泡元素
 * @param {string} text - 需要转换为语音的文本
 * @param {string} voiceId - Minimax 的声音ID
 */
async function playVoiceMessage(bubbleElement, text, voiceId) {
    // 1. 直接从localStorage读取 Minimax API 凭证
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    if (!minimaxGroupId || !minimaxApiKey) {
        showToast('请在设置中填写 Minimax Group ID 和 API Key');
        return;
    }
    if (!voiceId) {
        showToast('该角色未设置语音ID');
        return;
    }

    // 2. 判断当前点击的气泡是否正在播放
    const wasPlaying = bubbleElement === currentPlayingElement && !voiceAudio.paused;

    // 3. 如果有任何音频正在播放，先停止它
    if (currentPlayingElement) {
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        const oldVoiceIcon = currentPlayingElement.querySelector('.voice-icon');
        if (oldVoiceIcon) oldVoiceIcon.innerHTML = createVoiceIcon();
        currentPlayingElement.classList.remove('playing', 'loading');
    }

    // 4. 如果点击的是正在播放的气泡，则仅停止，然后退出
    if (wasPlaying) {
        currentPlayingElement = null;
        return;
    }

    // 5. 设置当前气泡为活动状态并更新UI
    currentPlayingElement = bubbleElement;
    const voiceIcon = bubbleElement.querySelector('.voice-icon');

    try {
        // 显示加载状态
        bubbleElement.classList.add('loading');
        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon('loading');

        let audioUrl = null;
        let fromCache = false;

        // 6. 首先检查语音缓存
        if (window.VoiceStorageAPI) {
            try {
                audioUrl = await window.VoiceStorageAPI.getVoiceURL(text, voiceId);
                if (audioUrl) {
                    fromCache = true;
                    console.log('使用语音缓存:', { textLength: text.length, voiceId });
                }
            } catch (error) {
                console.error('检查语音缓存失败:', error);
            }
        }

        // 7. 如果缓存中没有，则调用 API 生成语音
        if (!audioUrl) {
            console.log('语音缓存未命中，调用API生成语音');
            
            const groupId = minimaxGroupId;
            const apiKey = minimaxApiKey;
            
            // Minimax API URL，将 GroupId 放在查询参数中
            const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`;
            
            // 请求体
            const requestBody = {
                "voice_id": voiceId,
                "text": text,
                "model": "speech-01",
                "speed": 1.0,
                "vol": 1.0,
                "pitch": 0
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    // 授权头，注意这里只用 API Key
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            console.log('Minimax TTS API Response Status:', response.status);
            console.log('Minimax TTS API Response Headers:', Object.fromEntries(response.headers.entries()));

            // 处理 API 响应
            const contentType = response.headers.get('content-type') || '';
            
            // 检查是否返回了JSON错误信息（即使状态码是200）
            if (!response.ok || contentType.includes('application/json')) {
                let errorMsg = `语音服务错误 (状态码: ${response.status})`;
                try {
                    const errorData = await response.json();
                    console.error('ERROR: Minimax TTS API 返回错误 - 完整返回:', errorData);
                    
                    // 尝试从返回的JSON中获取更具体的错误信息
                    if (errorData && errorData.base_resp && errorData.base_resp.status_msg) {
                        errorMsg += `: ${errorData.base_resp.status_msg}`;
                    } else if (errorData && errorData.error) {
                        errorMsg += `: ${errorData.error}`;
                    } else if (errorData && errorData.message) {
                        errorMsg += `: ${errorData.message}`;
                    } else {
                        errorMsg += `: ${JSON.stringify(errorData)}`;
                    }
                } catch (e) {
                    // 如果解析JSON失败，则直接显示文本响应
                    const errorText = await response.text();
                    console.error('ERROR: Minimax TTS API 返回错误 (文本) - 完整返回:', errorText);
                    errorMsg += `: ${errorText}`;
                }
                throw new Error(errorMsg);
            }

            // 处理成功的响应
            // 服务器返回的是音频数据流，我们将其转换为 Blob
            const audioBlob = await response.blob();
            
            if (!audioBlob || !audioBlob.type.startsWith('audio/')) {
                console.error("服务器未返回有效的音频。Content-Type:", audioBlob.type);
                throw new Error(`服务器返回了非预期的内容类型: ${audioBlob.type}`);
            }

            // 8. 保存到缓存（异步进行，不阻塞播放）
            if (window.VoiceStorageAPI) {
                window.VoiceStorageAPI.storeVoice(audioBlob, text, voiceId, {
                    model: "speech-01",
                    apiSource: "minimax",
                    generatedAt: new Date().toISOString()
                }).then(() => {
                    console.log('语音已保存到缓存:', { textLength: text.length, voiceId });
                }).catch(error => {
                    console.error('语音缓存保存失败:', error);
                });
            }

            // 创建一个临时的 URL 指向这个 Blob 数据
            audioUrl = URL.createObjectURL(audioBlob);
        }

        // 9. 播放音频
        voiceAudio.src = audioUrl;

        // 当音频元数据加载完成后，显示时长（可选，语音图标方案可以不显示时长）
        voiceAudio.onloadedmetadata = () => {
            if (isFinite(voiceAudio.duration)) {
                // 在新的设计中，我们不需要显示时长，因为没有duration元素
                console.log('语音时长:', voiceAudio.duration + '秒');
            }
        };

        // 播放音频
        await voiceAudio.play();

        // 更新UI为播放状态
        bubbleElement.classList.remove('loading');
        bubbleElement.classList.add('playing');
        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon('playing');

        // 显示缓存状态提示（可选）
        if (fromCache) {
            console.log('语音播放成功（来自缓存）');
        } else {
            console.log('语音播放成功（来自API）');
        }

    } catch (error) {
        // 10. 统一处理所有错误
        console.error('语音播放失败:', error);
        showToast(`语音播放错误: ${error.message}`);
        bubbleElement.classList.remove('loading');
        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
        currentPlayingElement = null; // 重置当前播放元素
    }
}

// 【【【【【这是你要在 script.js 末尾新增的函数】】】】】

async function handleShareData() {
    const shareBtn = document.getElementById('shareDataBtn');
    shareBtn.disabled = true;
    shareBtn.textContent = '生成中...';

    try {
        // 1. 使用你已有的 IndexedDBManager 导出整个数据库的数据
        const exportData = await dbManager.exportDatabase();

        // 2. 将数据发送到我们的Vercel中转站
        const response = await fetch('https://transfer.cdsv.cc/api/transfer-data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(exportData),
        });

        if (!response.ok) {
            throw new Error('创建分享链接失败，请稍后重试。');
        }

        const result = await response.json();
        if (!result.success || !result.id) {
            throw new Error(result.error || '服务器返回数据格式错误。');
        }

        // 3. 构造给Vercel应用使用的链接
        const vercelAppUrl = 'https://chat.whale-llt.top'; 
        const shareLink = `${vercelAppUrl}/?importId=${result.id}`;

        // 4. 显示分享链接给用户
        showShareLinkDialog(shareLink);

    } catch (error) {
        console.error('分享数据失败:', error);
        showToast('分享失败: ' + error.message);
    } finally {
        shareBtn.disabled = false;
        shareBtn.textContent = '🔗 分享到新设备';
    }
}

// 一个用于显示分享链接的对话框函数
function showShareLinkDialog(link) {
    const dialogId = 'shareLinkDialog';
    let dialog = document.getElementById(dialogId);
    if (!dialog) {
        dialog = document.createElement('div');
        dialog.id = dialogId;
        dialog.className = 'modal';
        dialog.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">分享链接已生成</div>
                    <div class="modal-close" onclick="closeModal('${dialogId}')">关闭</div>
                </div>
                <div class="modal-body" style="text-align: center;">
                    <p style="margin-bottom: 15px; font-size: 14px; color: #666;">请复制以下链接，在新设备或浏览器中打开即可自动导入数据。链接15分钟内有效。</p>
                    <textarea id="shareLinkTextarea" class="form-textarea" rows="3" readonly>${link}</textarea>
                    <button class="form-submit" style="margin-top: 15px;" onclick="copyShareLink()">复制链接</button>
                </div>
            </div>
        `;
        document.body.appendChild(dialog);
    } else {
        document.getElementById('shareLinkTextarea').value = link;
    }
    showModal(dialogId);
}

/**
 * 复制链接到剪贴板的辅助函数
 */
function copyShareLink() {
    const textarea = document.getElementById('shareLinkTextarea');
    textarea.select();
    document.execCommand('copy');
    showToast('链接已复制！');
}

/**
 * 处理从URL自动导入的逻辑
 */
async function handleAutoImport(importId) {
    // 1. 清理URL，防止刷新页面时重复导入
    window.history.replaceState({}, document.title, window.location.pathname);

    // 2. 显示一个友好的加载提示
    showToast('检测到分享数据，正在导入...');

    try {
        // 3. 去Vercel中转站取回数据
        const transferUrl = `https://transfer.cdsv.cc/api/transfer-data?id=${importId}`;
        const response = await fetch(transferUrl);

        if (!response.ok) {
            const error = await response.json().catch(() => null);
            throw new Error(error?.error || '数据获取失败，链接可能已失效。');
        }

        const result = await response.json();
        if (!result.success || !result.data) {
            throw new Error(result.error || '服务器返回数据格式错误。');
        }

        const importData = result.data;

        // 🎯 等待UnifiedDB就绪 - 解决单文件构建时序问题
        await new Promise((resolve, reject) => {
            // 检查函数是否已经就绪
            if (window.performImport && typeof window.performImport === 'function') {
                console.log('✅ [Import] 导入功能已就绪，直接继续');
                resolve();
                return;
            }

            console.log('⏳ [Import] 等待导入功能初始化...');

            // 设置超时保护
            const timeout = setTimeout(() => {
                reject(new Error('导入功能初始化超时，请刷新页面后重试'));
            }, 8000);

            // 监听就绪事件
            const handleReady = (event) => {
                clearTimeout(timeout);
                console.log('✅ [Import] 收到就绪通知:', event.detail.message);
                resolve();
            };

            window.addEventListener('unifieddb:ready', handleReady, { once: true });
        });

        // 4. 使用你已有的导入逻辑 (dataMigrator.js)
        if (!window.dbManager) {
            window.dbManager = new IndexedDBManager();
        }
        await dbManager.initDB();
        
        // 5. 调用导入函数，直接覆盖
        const importResult = await dbManager.importDatabase(importData, { overwrite: true });

        // 🔍 宽容的结果检查 - 通常刷新后会自行修复
        if (!importResult) {
            console.warn('⚠️ [Import] 导入返回空结果，但通常刷新后会正常');
            alert('导入功能暂时不可用，请刷新页面后重试。\n\n（这是正常现象，刷新后通常能成功导入）');
            return; // 静默失败，不抛出错误
        }

        if (importResult.success) {
            alert('数据导入成功！页面将自动刷新以应用新数据。');
            setTimeout(() => {
                window.location.reload();
            }, 1500);
        } else {
            throw new Error(importResult.error || '导入数据库时发生未知错误。');
        }

    } catch (error) {
        console.error('自动导入失败:', error);
        alert('自动导入失败: ' + error.message + '\n\n即将正常加载页面。');
        // 如果导入失败，就正常初始化页面
        await init();
    }
}

// === 图片迁移功能 ===

/**
 * 检查图片迁移状态
 */
async function checkImageMigrationStatus() {
    const statusText = document.getElementById('migrationStatusText');
    const statusDetails = document.getElementById('migrationStatusDetails');
    const startMigrationBtn = document.getElementById('startMigrationBtn');
    
    try {
        statusText.textContent = '检查中...';
        statusDetails.innerHTML = '<div>正在检查图片数据状态...</div>';
        
        // 确保迁移管理器已初始化
        if (!window.ImageMigrationManager) {
            throw new Error('图片迁移管理器未加载');
        }
        
        await window.ImageMigrationManager.init();
        
        // 检查迁移状态
        const migrationStatus = await window.ImageMigrationManager.checkMigrationNeeded();
        
        if (migrationStatus.error) {
            statusText.textContent = '检查失败';
            statusDetails.innerHTML = `<div style="color: #dc3545;">错误: ${migrationStatus.error}</div>`;
            return;
        }
        
        if (!migrationStatus.needed) {
            statusText.textContent = '✅ 已优化';
            statusDetails.innerHTML = '<div style="color: #28a745;">太棒了！所有图片数据都已采用高效的存储格式。</div>';
            startMigrationBtn.disabled = true;
            startMigrationBtn.textContent = '✅ 无需优化';
            return;
        }
        
        // 需要迁移
        statusText.textContent = `${migrationStatus.totalFiles} 个文件待优化`;
        
        let detailsHtml = '<div style="margin-bottom: 8px;"><strong>发现以下数据需要优化：</strong></div>';
        
        if (migrationStatus.details.contacts.needsMigration > 0) {
            detailsHtml += `<div>• 联系人头像: ${migrationStatus.details.contacts.needsMigration} 个</div>`;
        }
        if (migrationStatus.details.userProfile.needsMigration > 0) {
            detailsHtml += `<div>• 用户头像: ${migrationStatus.details.userProfile.needsMigration} 个</div>`;
        }
        if (migrationStatus.details.emojiImages.needsMigration > 0) {
            detailsHtml += `<div>• 表情包: ${migrationStatus.details.emojiImages.needsMigration} 个</div>`;
        }
        if (migrationStatus.details.backgrounds.needsMigration > 0) {
            detailsHtml += `<div>• 背景图片: ${migrationStatus.details.backgrounds.needsMigration} 个</div>`;
        }
        if (migrationStatus.details.moments.needsMigration > 0) {
            detailsHtml += `<div>• 朋友圈图片: ${migrationStatus.details.moments.needsMigration} 个</div>`;
        }
        
        // 估算存储空间节省
        const savings = await window.ImageMigrationManager.estimateStorageSavings(migrationStatus);
        detailsHtml += `<div style="margin-top: 8px; color: #ff9500;"><strong>预计节省存储空间: ${savings.formattedSavings}</strong></div>`;
        
        statusDetails.innerHTML = detailsHtml;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = '🚀 开始优化';
        
    } catch (error) {
        console.error('检查迁移状态失败:', error);
        statusText.textContent = '检查失败';
        statusDetails.innerHTML = `<div style="color: #dc3545;">检查失败: ${error.message}</div>`;
    }
}

/**
 * 开始图片数据迁移
 */
async function startImageMigration() {
    const statusText = document.getElementById('migrationStatusText');
    const statusDetails = document.getElementById('migrationStatusDetails');
    const startMigrationBtn = document.getElementById('startMigrationBtn');
    const migrationProgress = document.getElementById('migrationProgress');
    const progressBar = document.getElementById('migrationProgressBar');
    const progressText = document.getElementById('migrationProgressText');
    
    try {
        // 确认操作
        const confirmed = confirm('开始图片存储优化？\n\n这个过程将：\n• 将现有base64图片转换为高效的文件存储格式\n• 显著减少存储空间占用\n• 提升应用性能\n\n优化过程中请勿关闭页面。');
        
        if (!confirmed) {
            return;
        }
        
        // 禁用按钮，显示进度
        startMigrationBtn.disabled = true;
        startMigrationBtn.textContent = '优化中...';
        migrationProgress.style.display = 'block';
        statusText.textContent = '优化中...';
        
        // 进度回调函数
        const progressCallback = (progress) => {
            const percentage = Math.round((progress.current / progress.total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `正在优化 ${progress.type}: ${progress.item} (${progress.current}/${progress.total})`;
        };
        
        // 执行迁移
        const result = await window.ImageMigrationManager.performFullMigration(progressCallback);
        
        if (result.success) {
            // 迁移成功
            statusText.textContent = '✅ 优化完成';
            progressBar.style.width = '100%';
            progressText.textContent = '优化完成！';
            
            let successHtml = `<div style="color: #28a745; margin-bottom: 8px;"><strong>${result.message}</strong></div>`;
            
            if (result.summary) {
                successHtml += `<div>• 成功优化: ${result.summary.totalSuccess} 个文件</div>`;
                if (result.summary.totalFailed > 0) {
                    successHtml += `<div style="color: #dc3545;">• 优化失败: ${result.summary.totalFailed} 个文件</div>`;
                }
            }
            
            successHtml += '<div style="margin-top: 8px; color: #666; font-size: 11px;">图片数据已优化为高效的文件存储格式，存储空间占用显著减少。</div>';
            
            statusDetails.innerHTML = successHtml;
            startMigrationBtn.textContent = '✅ 优化完成';
            
            // 显示成功消息
            if (typeof showToast === 'function') {
                showToast('图片存储优化完成！存储空间占用已显著减少。');
            } else {
                alert('图片存储优化完成！存储空间占用已显著减少。');
            }
            
        } else {
            // 迁移失败
            statusText.textContent = '优化失败';
            statusDetails.innerHTML = `<div style="color: #dc3545;">优化失败: ${result.error}</div>`;
            startMigrationBtn.disabled = false;
            startMigrationBtn.textContent = '🚀 重试优化';
            
            console.error('图片数据迁移失败:', result);
        }
        
    } catch (error) {
        console.error('执行图片迁移失败:', error);
        statusText.textContent = '优化失败';
        statusDetails.innerHTML = `<div style="color: #dc3545;">优化失败: ${error.message}</div>`;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = '🚀 重试优化';
        
        if (typeof showToast === 'function') {
            showToast('图片存储优化失败: ' + error.message);
        }
    } finally {
        // 隐藏进度条
        setTimeout(() => {
            migrationProgress.style.display = 'none';
        }, 3000);
    }
}

// === 聊天记录表情包迁移功能 ===

/**
 * 检查聊天记录表情包迁移状态
 */
async function checkChatEmojiMigrationStatus() {
    const statusText = document.getElementById('chatEmojiMigrationStatusText');
    const statusDetails = document.getElementById('chatEmojiMigrationStatusDetails');
    const startMigrationBtn = document.getElementById('startChatEmojiMigrationBtn');
    
    try {
        statusText.textContent = '检查中...';
        statusDetails.innerHTML = '<div>正在检查聊天记录中的表情包状态...</div>';
        
        // 确保迁移管理器已初始化
        if (!window.ChatEmojiMigrationManager) {
            throw new Error('聊天记录表情包迁移管理器未加载');
        }
        
        await window.ChatEmojiMigrationManager.init();
        
        // 检查迁移状态
        const migrationStatus = await window.ChatEmojiMigrationManager.checkChatEmojiMigrationNeeded();
        
        if (migrationStatus.error) {
            statusText.textContent = '检查失败';
            statusDetails.innerHTML = `<div style="color: #dc3545;">错误: ${migrationStatus.error}</div>`;
            return;
        }
        
        if (!migrationStatus.needed) {
            statusText.textContent = '✅ 已优化';
            statusDetails.innerHTML = '<div style="color: #28a745;">太棒了！聊天记录中的表情包都已采用高效的存储格式。</div>';
            startMigrationBtn.disabled = true;
            startMigrationBtn.textContent = '✅ 无需优化';
            return;
        }
        
        // 需要迁移
        const totalItems = migrationStatus.details.base64EmojisFound + migrationStatus.details.emojiImagesNeedingMigration;
        statusText.textContent = `${totalItems} 个表情待优化`;
        
        let detailsHtml = '<div style="margin-bottom: 8px;"><strong>发现以下数据需要优化：</strong></div>';
        
        if (migrationStatus.details.base64EmojisFound > 0) {
            detailsHtml += `<div>• 聊天记录中的表情: ${migrationStatus.details.base64EmojisFound} 个</div>`;
            detailsHtml += `<div>• 涉及联系人: ${migrationStatus.details.contactsNeedingMigration} 个</div>`;
        }
        
        if (migrationStatus.details.emojiImagesNeedingMigration > 0) {
            detailsHtml += `<div>• 表情图片库: ${migrationStatus.details.emojiImagesNeedingMigration} 个</div>`;
        }
        
        // 估算迁移效果
        const benefits = await window.ChatEmojiMigrationManager.estimateMigrationBenefits(migrationStatus);
        detailsHtml += `<div style="margin-top: 8px; color: #1890ff;"><strong>预计节省存储空间: ${benefits.formattedSavings}</strong></div>`;
        detailsHtml += '<div style="color: #666; font-size: 11px;">优化后API调用将使用[emoji:意思]格式，提升兼容性</div>';
        
        statusDetails.innerHTML = detailsHtml;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = '💬 开始优化';
        
    } catch (error) {
        console.error('检查聊天表情迁移状态失败:', error);
        statusText.textContent = '检查失败';
        statusDetails.innerHTML = `<div style="color: #dc3545;">检查失败: ${error.message}</div>`;
    }
}

/**
 * 开始聊天记录表情包迁移
 */
async function startChatEmojiMigration() {
    const statusText = document.getElementById('chatEmojiMigrationStatusText');
    const statusDetails = document.getElementById('chatEmojiMigrationStatusDetails');
    const startMigrationBtn = document.getElementById('startChatEmojiMigrationBtn');
    const migrationProgress = document.getElementById('chatEmojiMigrationProgress');
    const progressBar = document.getElementById('chatEmojiMigrationProgressBar');
    const progressText = document.getElementById('chatEmojiMigrationProgressText');
    
    try {
        // 确认操作
        const confirmed = confirm('开始聊天记录表情包优化？\n\n这个过程将：\n• 将聊天记录中的base64表情转换为高效的文件存储格式\n• 保持API调用兼容性（使用[emoji:意思]格式）\n• 显著减少存储空间占用\n• 提升聊天记录加载性能\n\n优化过程中请勿关闭页面。');
        
        if (!confirmed) {
            return;
        }
        
        // 禁用按钮，显示进度
        startMigrationBtn.disabled = true;
        startMigrationBtn.textContent = '优化中...';
        migrationProgress.style.display = 'block';
        statusText.textContent = '优化中...';
        
        // 进度回调函数
        const progressCallback = (progress) => {
            const percentage = Math.round((progress.current / progress.total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `正在优化 ${progress.type}: ${progress.item} (${progress.current}/${progress.total})`;
        };
        
        // 执行迁移
        const result = await window.ChatEmojiMigrationManager.performChatEmojiMigration(progressCallback);
        
        if (result.success) {
            // 迁移成功
            statusText.textContent = '✅ 优化完成';
            progressBar.style.width = '100%';
            progressText.textContent = '优化完成！';
            
            let successHtml = `<div style="color: #28a745; margin-bottom: 8px;"><strong>${result.message}</strong></div>`;
            
            if (result.results) {
                successHtml += `<div>• 优化联系人: ${result.results.contactsMigrated} 个</div>`;
                successHtml += `<div>• 优化表情: ${result.results.base64EmojisMigrated} 个</div>`;
                successHtml += `<div>• 优化表情图片: ${result.results.emojiImagesMigrated} 个</div>`;
                
                if (result.results.errors.length > 0) {
                    successHtml += `<div style="color: #ffc107;">• 优化失败: ${result.results.errors.length} 个</div>`;
                }
            }
            
            successHtml += '<div style="margin-top: 8px; color: #666; font-size: 11px;">聊天记录表情包已优化完成，API调用将使用[emoji:意思]格式。</div>';
            
            statusDetails.innerHTML = successHtml;
            startMigrationBtn.textContent = '✅ 优化完成';
            
            // 显示成功消息
            if (typeof showToast === 'function') {
                showToast('聊天记录表情包优化完成！存储格式已统一。');
            } else {
                alert('聊天记录表情包优化完成！存储格式已统一。');
            }
            
            // 刷新当前聊天显示
            if (window.currentContact) {
                await renderMessages(false); // 明确指定非初始加载，避免滚动
            }
            
        } else {
            // 迁移失败
            statusText.textContent = '优化失败';
            statusDetails.innerHTML = `<div style="color: #dc3545;">优化失败: ${result.error}</div>`;
            startMigrationBtn.disabled = false;
            startMigrationBtn.textContent = '💬 重试优化';
            
            console.error('聊天表情迁移失败:', result);
        }
        
    } catch (error) {
        console.error('执行聊天表情迁移失败:', error);
        statusText.textContent = '优化失败';
        statusDetails.innerHTML = `<div style="color: #dc3545;">优化失败: ${error.message}</div>`;
        startMigrationBtn.disabled = false;
        startMigrationBtn.textContent = '💬 重试优化';
        
        if (typeof showToast === 'function') {
            showToast('聊天记录表情包优化失败: ' + error.message);
        }
    } finally {
        // 隐藏进度条
        setTimeout(() => {
            migrationProgress.style.display = 'none';
        }, 3000);
    }
}

// === 自动文件存储迁移功能（版本8→9） ===

/**
 * 执行文件存储迁移（版本8→9升级时自动调用）
 */
async function performFileStorageMigration() {
    try {
        console.log('开始执行文件存储自动迁移...');
        
        if (!window.isIndexedDBReady) {
            console.error('数据库未准备就绪，无法执行迁移');
            return;
        }
        
        // 等待所有管理器初始化完成
        let attempts = 0;
        const maxAttempts = 10;
        
        while (attempts < maxAttempts) {
            if (window.ImageMigrationManager && window.ChatEmojiMigrationManager) {
                break;
            }
            console.log(`等待迁移管理器初始化... (${attempts + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 500));
            attempts++;
        }
        
        if (!window.ImageMigrationManager || !window.ChatEmojiMigrationManager) {
            console.error('迁移管理器未加载，跳过自动迁移');
            return;
        }
        
        console.log('开始自动迁移步骤1：基础图片数据迁移');
        
        // 步骤1：首先执行基础图片迁移（头像、背景、表情包图片）
        try {
            await window.ImageMigrationManager.init();
            const imageMigrationStatus = await window.ImageMigrationManager.checkMigrationNeeded();
            
            if (imageMigrationStatus.needed) {
                console.log(`发现 ${imageMigrationStatus.totalFiles} 个图片文件需要迁移`);
                
                const imageResult = await window.ImageMigrationManager.performFullMigration((progress) => {
                    console.log(`迁移进度: ${progress.type} - ${progress.item} (${progress.current}/${progress.total})`);
                });
                
                if (imageResult.success) {
                    console.log('基础图片数据迁移完成:', imageResult.summary);
                } else {
                    console.error('基础图片数据迁移失败:', imageResult.error);
                }
            } else {
                console.log('无需进行基础图片数据迁移');
            }
        } catch (error) {
            console.error('基础图片迁移过程出错:', error);
        }
        
        console.log('开始自动迁移步骤2：聊天记录表情包迁移');
        
        // 步骤2：然后执行聊天记录表情包迁移
        try {
            await window.ChatEmojiMigrationManager.init();
            const chatEmojiStatus = await window.ChatEmojiMigrationManager.checkChatEmojiMigrationNeeded();
            
            if (chatEmojiStatus.needed) {
                const totalEmojis = chatEmojiStatus.details.base64EmojisFound + chatEmojiStatus.details.emojiImagesNeedingMigration;
                console.log(`发现 ${totalEmojis} 个聊天表情需要迁移`);
                
                const chatResult = await window.ChatEmojiMigrationManager.performChatEmojiMigration((progress) => {
                    console.log(`聊天表情迁移进度: ${progress.type} - ${progress.item} (${progress.current}/${progress.total})`);
                });
                
                if (chatResult.success) {
                    console.log('聊天记录表情包迁移完成:', chatResult.results);
                } else {
                    console.error('聊天记录表情包迁移失败:', chatResult.error);
                }
            } else {
                console.log('无需进行聊天记录表情包迁移');
            }
        } catch (error) {
            console.error('聊天表情迁移过程出错:', error);
        }
        
        console.log('文件存储自动迁移流程完成');
        
        // 刷新当前聊天显示（如果有的话）
        if (window.currentContact) {
            try {
                await renderMessages(false); // 明确指定非初始加载，避免滚动
                console.log('聊天界面已刷新');
            } catch (error) {
                console.warn('刷新聊天界面失败:', error);
            }
        }
        
    } catch (error) {
        console.error('文件存储自动迁移失败:', error);
    }
}

// --- 个人主页功能 ---
let currentUserProfileContact = null;
let userProfilePreviousPage = 'profilePage'; // 记录从哪个页面进入的个人主页

// 显示用户个人主页（自己的主页）
async function showUserProfile() {
    currentUserProfileContact = null; // 表示是自己的主页
    userProfilePreviousPage = 'profilePage'; // 从个人信息页面进入
    showPage('userProfilePage');
    
    // 确保数据已加载
    await waitForDataReady();
    await loadUserProfileData();
}

// 显示其他用户的个人主页
async function showContactProfile(contact) {
    currentUserProfileContact = contact;
    userProfilePreviousPage = 'momentsPage'; // 从朋友圈进入
    showPage('userProfilePage');
    
    // 确保数据已加载
    await waitForDataReady();
    await loadUserProfileData();
}

// 从个人主页返回
function goBackFromUserProfile() {
    showPage(userProfilePreviousPage);
}

// 加载个人主页数据
async function loadUserProfileData() {
    try {
        const userProfileBanner = document.getElementById('userProfileBanner');
        const userProfileAvatar = document.getElementById('userProfileAvatar');
        const userProfileName = document.getElementById('userProfileName');
        const userProfileMomentsList = document.getElementById('userProfileMomentsList');
        const userProfileMomentsEmpty = document.querySelector('.user-profile-moments-empty');
        
        
        if (currentUserProfileContact) {
            // 显示联系人的主页
            const contact = currentUserProfileContact;
            
            // 设置头像 - 使用getAvatarHTML获取头像内容
            try {
                const avatarHTML = await getAvatarHTML(contact, 'contact', 'user-profile-avatar-inner');
                if (avatarHTML.includes('<img')) {
                    // 如果是图片，提取src并设置为背景图片
                    const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        userProfileAvatar.style.backgroundImage = `url(${srcMatch[1]})`;
                        userProfileAvatar.textContent = '';
                    } else {
                        // 回退到旧逻辑
                        userProfileAvatar.style.backgroundImage = '';
                        userProfileAvatar.textContent = contact.name?.charAt(0) || '?';
                    }
                } else {
                    // 如果是文字头像
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = contact.name?.charAt(0) || '?';
                }
            } catch (error) {
                console.warn('获取联系人头像失败，使用回退逻辑:', error);
                if (contact.avatar) {
                    userProfileAvatar.style.backgroundImage = `url(${contact.avatar})`;
                    userProfileAvatar.textContent = '';
                } else {
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = contact.name?.charAt(0) || '?';
                }
            }
            
            // 设置用户名，如果是临时联系人则显示特殊样式
            userProfileName.textContent = contact.name || '未知用户';
            if (contact.isTemporary) {
                userProfileName.style.color = '#ff6b6b';
                userProfileName.style.fontSize = '18px';
            } else {
                userProfileName.style.color = '#fff';
                userProfileName.style.fontSize = '20px';
            }
            
            // 设置banner背景（临时联系人使用不同颜色）
            if (contact.isTemporary) {
                userProfileBanner.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
            } else {
                userProfileBanner.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
            
        } else {
            // 显示自己的主页
            const userProfile = await getUserProfile();
            
            // 设置头像 - 使用getAvatarHTML获取头像内容，支持新的文件系统
            try {
                const avatarHTML = await getAvatarHTML(userProfile, 'user', 'user-profile-avatar-inner');
                if (avatarHTML.includes('<img')) {
                    // 如果是图片，提取src并设置为背景图片
                    const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        userProfileAvatar.style.backgroundImage = `url(${srcMatch[1]})`;
                        userProfileAvatar.textContent = '';
                    } else {
                        // 回退到旧逻辑
                        userProfileAvatar.style.backgroundImage = '';
                        userProfileAvatar.textContent = userProfile.name?.charAt(0) || '我';
                        console.log('设置头像文字（解析失败）:', userProfile.name?.charAt(0) || '我');
                    }
                } else {
                    // 如果是文字头像
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = userProfile.name?.charAt(0) || '我';
                }
            } catch (error) {
                console.warn('获取用户头像失败，使用回退逻辑:', error);
                if (userProfile.avatar) {
                    userProfileAvatar.style.backgroundImage = `url(${userProfile.avatar})`;
                    userProfileAvatar.textContent = '';
                    console.log('设置头像图片（回退）:', userProfile.avatar);
                } else {
                    userProfileAvatar.style.backgroundImage = '';
                    userProfileAvatar.textContent = userProfile.name?.charAt(0) || '我';
                    console.log('设置头像文字（回退）:', userProfile.name?.charAt(0) || '我');
                }
            }
            
            // 设置用户名
            userProfileName.textContent = userProfile.name || '我的昵称';
            
            // 设置banner背景
            userProfileBanner.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        }
        
        // 加载朋友圈动态
        await loadUserProfileMoments();
        
    } catch (error) {
        console.error('加载个人主页数据失败:', error);
    }
}

// 获取所有朋友圈动态
async function getAllMoments() {
    
    // 确保数据已加载
    if (!window.moments && (!moments || moments.length === 0)) {
        await waitForDataReady();
    }
    
    return window.moments || moments || [];
}

// 加载用户的朋友圈动态
async function loadUserProfileMoments() {
    try {
        const userProfileMomentsList = document.getElementById('userProfileMomentsList');
        const userProfileMomentsEmpty = document.querySelector('.user-profile-moments-empty');
        
        // 获取朋友圈数据
        const moments = await getAllMoments();
        
        // 过滤出当前用户的动态
        let userMoments = [];
        
        if (currentUserProfileContact) {
            // 显示联系人的动态
            console.log('筛选联系人动态，联系人姓名:', currentUserProfileContact.name);
            userMoments = moments.filter(moment => 
                moment.authorName === currentUserProfileContact.name
            );
        } else {
            // 显示自己的动态（作者是"我"或用户设置的昵称）
            const userProfile = await getUserProfile();
            const userName = userProfile.name || '我的昵称';
            userMoments = moments.filter(moment => 
                moment.authorName === '我' || moment.authorName === userName
            );
            
            // 如果没有找到，也尝试匹配所有动态的作者名
            if (userMoments.length === 0) {
                moments.forEach((moment, index) => {
                });
            }
        }
        
        if (userMoments.length === 0) {
            userProfileMomentsEmpty.style.display = 'block';
            userProfileMomentsList.style.display = 'none';
        } else {
            userProfileMomentsEmpty.style.display = 'none';
            userProfileMomentsList.style.display = 'block';
            
            // 清空现有内容
            userProfileMomentsList.innerHTML = '';
            
            // 渲染朋友圈动态
            for (const moment of userMoments) {
                const momentElement = await createUserProfileMomentElement(moment);
                userProfileMomentsList.appendChild(momentElement);
            }
        }
        
    } catch (error) {
        console.error('加载用户朋友圈动态失败:', error);
    }
}

// 切换朋友圈菜单显示/隐藏
function toggleMomentMenu(momentId) {
    const menu = document.getElementById(`momentMenu-${momentId}`);
    const allMenus = document.querySelectorAll('.moment-menu');
    
    // 关闭所有其他菜单
    allMenus.forEach(m => {
        if (m !== menu) {
            m.style.display = 'none';
        }
    });
    
    // 切换当前菜单
    if (menu) {
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
}

// 重新生成朋友圈图片
async function regenerateMomentImage(momentId) {
    try {
        // 检查朋友圈操作是否被锁定
        if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
            return;
        }
        
        // 关闭菜单
        const menu = document.getElementById(`momentMenu-${momentId}`);
        if (menu) menu.style.display = 'none';
        
        // 找到对应的朋友圈
        const moment = moments.find(m => m.id === momentId);
        if (!moment) {
            showToast('找不到指定的朋友圈');
            return;
        }
        
        // 检查是否有原始内容可以重新生成图片
        if (!moment.content && !moment.originalContent) {
            showToast('该朋友圈没有内容，无法生成图片');
            return;
        }
        
        const unsplashKey = localStorage.getItem('forumUnsplashApiKey') || localStorage.getItem('unsplashApiKey');
        if (!unsplashKey) {
            showToast('请先配置Unsplash API Key');
            return;
        }
        
        showToast('正在重新生成图片...');
        
        // 使用朋友圈内容生成图片
        const contentForImage = moment.originalContent || moment.content;
        const imageUrl = await fetchMatchingImageForPublish(contentForImage, unsplashKey);
        
        if (imageUrl) {
            // 直接保存Unsplash URL，不存储到IndexedDB
            moment.image = imageUrl;
            moment.imageCount = 1;
            moment.isUnsplashImage = true; // 标记为Unsplash图片
            // 清除本地存储的图片ID（如果之前有的话）
            delete moment.imageFileIds;
            
            // 更新数据库并标记数据修改
            await saveDataToDB();
            isMomentsDataModified = true;
            
            // 重新渲染朋友圈
            await renderMomentsList();
            
            showToast('图片已重新生成！');
        } else {
            showToast('图片生成失败，请稍后重试');
        }
    } catch (error) {
        console.error('重新生成朋友圈图片失败:', error);
        isMomentsDataModified = true; // 即使失败也标记，确保下次切换页面时刷新
        showToast('图片生成失败: ' + error.message);
    }
}

// 删除朋友圈图片
async function removeMomentImage(momentId) {
    try {
        // 关闭菜单
        const menu = document.getElementById(`momentMenu-${momentId}`);
        if (menu) menu.style.display = 'none';
        
        // 找到对应的朋友圈
        const moment = moments.find(m => m.id === momentId);
        if (!moment) {
            showToast('找不到指定的朋友圈');
            return;
        }
        
        // 检查是否有图片可以删除
        if (!moment.image && (!moment.imageFileIds || moment.imageFileIds.length === 0)) {
            showToast('该朋友圈没有图片，无需删除');
            return;
        }
        
        // 删除图片相关数据
        delete moment.image;
        delete moment.imageFileIds;
        delete moment.isUnsplashImage;
        moment.imageCount = 0;
        
        // 更新数据库
        await saveDataToDB();
        
        // 重新渲染朋友圈
        await renderMomentsList();
        
        showToast('图片已删除');
    } catch (error) {
        console.error('删除朋友圈图片失败:', error);
        showToast('删除图片失败: ' + error.message);
    }
}

// 重新生成评论
async function regenerateComments(momentId) {
    try {
        // 检查朋友圈操作是否被锁定
        if (window.momentsLockManager && window.momentsLockManager.checkLocked()) {
            return;
        }
        
        // 关闭菜单
        const menu = document.getElementById(`momentMenu-${momentId}`);
        if (menu) menu.style.display = 'none';
        
        // 找到对应的朋友圈
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) {
            showToast('未找到要重新生成评论的朋友圈');
            return;
        }
        
        const moment = moments[momentIndex];
        showToast('正在重新生成评论...');
        
        // 清空现有评论和点赞
        moment.comments = [];
        moment.likes = 0;
        
        // 重新生成评论
        const newComments = await generateAICommentsWithCurrentTime(moment.content, { location: moment.location });
        moment.comments = newComments;

        // 保存到数据库
        await saveDataToDB();
        
        // 标记朋友圈数据已被修改
        isMomentsDataModified = true;
        
        // 尝试局部更新UI
        try {
            await updateMomentElement(momentId, 'comments');
            console.log('✅ 评论局部更新成功');
        } catch (updateError) {
            console.warn('⚠️ 评论局部更新失败，尝试强制刷新朋友圈列表:', updateError);
            
            // 局部更新失败时，强制重新渲染整个朋友圈列表
            await renderMomentsList();
            console.log('🔄 朋友圈列表重新渲染完成');
        }

        showToast('评论重新生成完成！');
        
    } catch (error) {
        console.error('重新生成评论失败:', error);
        
        // 在出错时也标记数据修改，确保下次页面切换时能刷新
        isMomentsDataModified = true;
        
        // 在出错时也尝试刷新UI，确保数据一致性
        try {
            await renderMomentsList();
            console.log('🔄 错误恢复：朋友圈列表已刷新');
        } catch (renderError) {
            console.error('🔴 严重错误：无法刷新朋友圈列表', renderError);
        }
        
        showApiError(error);
    }
}

// 点击页面其他地方关闭所有菜单
document.addEventListener('click', function(event) {
    if (!event.target.closest('.moment-menu-btn') && !event.target.closest('.moment-menu')) {
        const allMenus = document.querySelectorAll('.moment-menu');
        allMenus.forEach(menu => {
            menu.style.display = 'none';
        });
    }
});

// 处理朋友圈头像点击事件

function toggleMomentActions(momentId) {
    const menu = document.getElementById(`momentActions-${momentId}`);
    if (!menu) {
        console.error('Menu not found for moment:', momentId);
        return;
    }

    const allMenus = document.querySelectorAll('.moment-actions-menu');
    const isActive = menu.classList.contains('active');

    // 统一先关闭所有菜单
    allMenus.forEach(m => {
        m.classList.remove('active');
    });

    if (!isActive) {
        menu.classList.add('active');
    }

    // 点击外部关闭菜单的逻辑（保留，但可以简化）
    if (!isActive) {
        setTimeout(() => {
            const closeHandler = (e) => {
                if (!e.target.closest('.moment-collapse-btn')) {
                     menu.classList.remove('active');
                     document.removeEventListener('click', closeHandler, true);
                }
            };
            document.addEventListener('click', closeHandler, true);
        }, 0);
    }
}

// 点赞朋友圈
async function likeMoment(momentId) {
    try {
        const userProfile = await getUserProfile();
        const userName = userProfile.name || '我';
        
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // 初始化点赞列表
        if (!moment.likes) {
            moment.likes = [];
        }
        
        // 检查是否已点赞
        const hasLiked = moment.likes.includes(userName);
        
        if (hasLiked) {
            // 取消点赞
            moment.likes = moment.likes.filter(name => name !== userName);
            showToast('已取消点赞');
        } else {
            // 添加点赞
            moment.likes.push(userName);
            showToast('点赞成功');
        }
        
        // 保存并标记数据修改
        await saveDataToDB();
        isMomentsDataModified = true;
        
        // 检测当前在哪个页面
        const userProfilePage = document.getElementById('userProfilePage');
        const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
        
        if (isInUserProfile) {
            // 如果在个人主页，重新加载个人主页的朋友圈
            await loadUserProfileMoments();
        } else {
            // 如果在发现页面，使用性能优化的局部更新
            await updateMomentElement(momentId, 'likes');
        }
        
        // 关闭菜单
        const menu = document.getElementById(`momentActions-${momentId}`);
        if (menu) menu.classList.remove('active');
        
    } catch (error) {
        console.error('点赞失败:', error);
        isMomentsDataModified = true; // 即使失败也标记，确保下次切换页面时刷新
        showToast('点赞失败');
    }
}

// 显示朋友圈评论框
function showMomentComment(momentId) {
    // 检测当前在哪个页面
    const userProfilePage = document.getElementById('userProfilePage');
    const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
    
    let replyContainer;
    if (isInUserProfile) {
        // 在个人主页，查找个人主页的回复容器
        replyContainer = userProfilePage.querySelector(`#momentMainReply-${momentId}`);
    } else {
        // 在发现页面，查找发现页面的回复容器
        replyContainer = document.getElementById(`momentMainReply-${momentId}`);
    }
    
    if (!replyContainer) {
        console.error('Reply container not found for moment:', momentId);
        return;
    }
    
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.add('active');
    window.UIManager.safeFocus(textarea, { delay: 100 });
    
    // 关闭菜单（发现页面才有菜单）
    if (!isInUserProfile) {
        const menu = document.getElementById(`momentActions-${momentId}`);
        if (menu) menu.classList.remove('active');
    }
}

// 隐藏朋友圈评论框
function hideMomentComment(momentId) {
    // 检测当前在哪个页面
    const userProfilePage = document.getElementById('userProfilePage');
    const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
    
    let replyContainer;
    if (isInUserProfile) {
        // 在个人主页，查找个人主页的回复容器
        replyContainer = userProfilePage.querySelector(`#momentMainReply-${momentId}`);
    } else {
        // 在发现页面，查找发现页面的回复容器
        replyContainer = document.getElementById(`momentMainReply-${momentId}`);
    }
    
    if (!replyContainer) {
        console.error('Reply container not found for moment:', momentId);
        return;
    }
    
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.remove('active');
    textarea.value = '';
}

// 提交朋友圈评论
async function submitMomentComment(momentId) {
    try {
        const userProfile = await getUserProfile();
        const userName = userProfile.name || '我';
        
        // 检测当前在哪个页面
        const userProfilePage = document.getElementById('userProfilePage');
        const isInUserProfile = userProfilePage && userProfilePage.classList.contains('active');
        
        let replyContainer;
        if (isInUserProfile) {
            // 在个人主页，查找个人主页的回复容器
            replyContainer = userProfilePage.querySelector(`#momentMainReply-${momentId}`);
        } else {
            // 在发现页面，查找发现页面的回复容器
            replyContainer = document.getElementById(`momentMainReply-${momentId}`);
        }
        
        if (!replyContainer) {
            console.error('Reply container not found for moment:', momentId);
            return;
        }
        
        const textarea = replyContainer.querySelector('.moment-reply-input');
        const content = textarea.value.trim();
        
        if (!content) {
            showToast('请输入评论内容');
            return;
        }
        
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // 添加用户评论
        const newComment = {
            author: userName,
            content: content,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        if (!moment.comments) {
            moment.comments = [];
        }
        
        moment.comments.push(newComment);
        
        // 保存并标记数据修改
        await saveDataToDB();
        isMomentsDataModified = true;

        if (isInUserProfile) {
            // 如果在个人主页，重新加载个人主页的朋友圈
            await loadUserProfileMoments();
        } else {
            // 如果在发现页面，使用性能优化的局部更新
            await updateMomentElement(momentId, 'comments');
        }

        showToast('评论成功');
        
        // 触发楼主回复
        setTimeout(() => {
            generateMomentAuthorReply(momentId, userName, content);
        }, 1000);
        
    } catch (error) {
        console.error('评论失败:', error);
        isMomentsDataModified = true; // 即使失败也标记，确保下次切换页面时刷新
        showToast('评论失败');
    }
}

// 显示评论回复框
function showCommentReply(commentId, authorName, momentId) {
    const replyContainer = document.getElementById(`${commentId}-reply`);
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.add('active');
    window.UIManager.safeFocus(textarea, { delay: 100 });
    textarea.setAttribute('placeholder', `回复${authorName}...`);
}

// 隐藏评论回复框
function hideCommentReply(commentId) {
    const replyContainer = document.getElementById(`${commentId}-reply`);
    const textarea = replyContainer.querySelector('.moment-reply-input');
    
    replyContainer.classList.remove('active');
    textarea.value = '';
}

// 提交评论回复
async function submitCommentReply(commentId, replyToAuthor, momentId) {
    try {
        const userProfile = await getUserProfile();
        const userName = userProfile.name || '我';
        
        const replyContainer = document.getElementById(`${commentId}-reply`);
        const textarea = replyContainer.querySelector('.moment-reply-input');
        const content = textarea.value.trim();
        
        if (!content) {
            showToast('请输入回复内容');
            return;
        }
        
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // 添加用户回复
        const newComment = {
            author: userName,
            content: `回复${replyToAuthor}: ${content}`,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        if (!moment.comments) {
            moment.comments = [];
        }
        
        moment.comments.push(newComment);
        
        // 保存并重新渲染
        await saveDataToDB();
        await renderMomentsList();
        
        showToast('回复成功');
        
        // 触发被回复人的回复
        setTimeout(() => {
            generateCommentReply(momentId, replyToAuthor, userName, content);
        }, 1000);
        
    } catch (error) {
        console.error('回复失败:', error);
        showToast('回复失败');
    }
}

// 点击评论作者头像
function handleCommentAuthorClick(authorName) {
    // 复用朋友圈头像点击逻辑
    handleMomentAvatarClick(authorName);
}

// 显示朋友圈评论回复框（发现页面点击评论行）
function showMomentReplyToComment(momentId, commentAuthor) {
    // 显示回复框
    showMomentComment(momentId);
    
    // 预填充@用户名
    const replyInput = document.querySelector(`#momentMainReply-${momentId} .moment-reply-input`);
    if (replyInput) {
        const mention = `@${commentAuthor} `;
        const currentText = replyInput.value;
        
        // 避免重复添加@提及
        if (!currentText.includes(mention)) {
            replyInput.value = mention + currentText;
        }
        
        // 聚焦输入框并设置光标位置
        replyInput.focus();
        replyInput.setSelectionRange(replyInput.value.length, replyInput.value.length);
        
        // 确保回复框滚动到可见位置
        setTimeout(() => {
            replyInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
    }
}

// 生成楼主回复用户评论
async function generateMomentAuthorReply(momentId, commenterName, commentContent) {
    try {
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        const authorName = moment.authorName;
        
        // 如果楼主就是用户，不生成回复
        const userProfile = await getUserProfile();
        if (authorName === userProfile.name) return;
        
        // 查找角色
        const character = window.contacts?.find(c => c.name === authorName);
        if (!character) return;
        
        // 生成回复内容
        const replyContent = await generateCharacterReply(character, commenterName, commentContent, moment.content);
        
        // 添加角色回复
        const authorReply = {
            author: authorName,
            content: `回复${commenterName}: ${replyContent}`,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        moments[momentIndex].comments.push(authorReply);
        
        // 保存并重新渲染
        await saveDataToDB();
        await renderMomentsList();
        
    } catch (error) {
        console.error('生成楼主回复失败:', error);
    }
}

// 生成被回复人的回复
async function generateCommentReply(momentId, repliedAuthor, replierName, replyContent) {
    try {
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) return;
        
        const moment = moments[momentIndex];
        
        // 如果被回复的是用户，不生成回复
        const userProfile = await getUserProfile();
        if (repliedAuthor === userProfile.name) return;
        
        // 查找被回复的角色
        const character = window.contacts?.find(c => c.name === repliedAuthor);
        if (!character) return;
        
        // 生成回复内容
        const responseContent = await generateCharacterReply(character, replierName, replyContent, moment.content);
        
        // 添加角色回复
        const characterReply = {
            author: repliedAuthor,
            content: responseContent,
            like: false,
            timestamp: new Date().toISOString()
        };
        
        moments[momentIndex].comments.push(characterReply);
        
        // 保存并重新渲染
        await saveDataToDB();
        await renderMomentsList();
        
    } catch (error) {
        console.error('生成角色回复失败:', error);
    }
}

// 生成角色回复内容
async function generateCharacterReply(character, replierName, replyContent, momentContent) {
    try {
        const userProfile = await getUserProfile();
        
        const prompt = window.promptBuilder.buildMomentReplyPrompt(character, replierName, replyContent, momentContent);

        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            throw new Error('请先设置API和模型');
        }

        const response = await fetch(`${apiCallInfo.url}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiCallInfo.key}`
            },
            body: JSON.stringify({
                model: apiCallInfo.model,
                messages: [
                    { role: 'user', content: prompt }
                ],
                temperature: 0.8,
                max_tokens: 5000
            })
        });
        
        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status}`);
        }
        
        const data = await response.json();
        return data.choices[0]?.message?.content?.trim() || '哈哈哈';
        
    } catch (error) {
        console.error('生成角色回复失败:', error);
        return '😄';
    }
}

async function handleMomentAvatarClick(authorName) {
    try {
        // 获取用户配置
        const userProfile = await getUserProfile();
        
        // 如果是自己，显示自己的主页
        if (authorName === '我' || authorName === userProfile.name) {
            await showUserProfile();
            return;
        }
        
        // 查找对应的联系人
        const contact = window.contacts?.find(c => c.name === authorName);
        if (contact) {
            await showContactProfile(contact);
        } else {
            console.error('联系人不存在 - 详细信息:');
            console.error('- 查找的联系人姓名:', authorName);
            console.error('- 当前联系人列表:', window.contacts);
            console.error('- 联系人列表长度:', window.contacts ? window.contacts.length : '联系人列表为空');
            if (window.contacts && window.contacts.length > 0) {
                console.error('- 现有联系人姓名列表:', window.contacts.map(c => c.name));
            }
            
            // 显示错误提示
            showToast(`联系人不存在: ${authorName}`);
            
            // 仍然创建临时联系人对象用于显示，但标记为不存在
            const tempContact = {
                name: `${authorName} (联系人不存在)`,
                avatar: null,
                isTemporary: true
            };
            await showContactProfile(tempContact);
        }
    } catch (error) {
        console.error('处理头像点击事件失败:', error);
    }
}

// 创建个人主页朋友圈动态元素
async function createUserProfileMomentElement(moment) {
    const momentDiv = document.createElement('div');
    momentDiv.className = 'user-profile-moment-item';
    
    // 获取当前用户资料用于头像显示
    const userProfile = await getUserProfile();
    
    let imagesHtml = '';
    
    // 处理图片 - 支持新的文件系统和旧的base64格式
    if (moment.imageFileIds && moment.imageCount > 0 && window.ImageStorageAPI) {
        // 新的文件系统存储方式
        const imageUrls = [];
        for (let i = 0; i < moment.imageCount; i++) {
            imageUrls.push(`data:image/jpeg;base64,loading...`); // 占位符，后续异步加载
        }
        imagesHtml = `
            <div class="user-profile-moment-images">
                ${imageUrls.map((image, index) => `
                    <img src="${image}" alt="朋友圈图片" class="user-profile-moment-image" data-moment-id="${moment.id}" data-image-index="${index}">
                `).join('')}
            </div>
        `;
    } else if (moment.image) {
        // 旧的单图片格式
        imagesHtml = `
            <div class="user-profile-moment-images">
                <img src="${moment.image}" alt="朋友圈图片" class="user-profile-moment-image" onclick="showImagePreview('${moment.image}')">
            </div>
        `;
    } else if (moment.images && moment.images.length > 0) {
        // 多图片格式
        imagesHtml = `
            <div class="user-profile-moment-images">
                ${moment.images.map(image => `
                    <img src="${image}" alt="朋友圈图片" class="user-profile-moment-image" onclick="showImagePreview('${image}')">
                `).join('')}
            </div>
        `;
    }
    
    // 使用正确的时间字段
    const timeStr = moment.time || moment.timestamp || new Date().toISOString();
    
    // 处理点赞信息
    const likes = moment.likes || [];
    let likedUsers = [];
    
    // 获取点赞用户列表（包括独立点赞和评论点赞）
    if (likes.length > 0) {
        likedUsers = [...likes];
    }
    
    if (moment.comments && moment.comments.length > 0) {
        const commentLikedUsers = moment.comments
            .filter(comment => comment.like === true)
            .map(comment => comment.commenter_name || comment.author)
            .filter(author => !likedUsers.includes(author)); // 避免重复
        
        likedUsers = [...likedUsers, ...commentLikedUsers];
    }
    
    const likesContent = likedUsers.length > 0 ? 
        `<div class="moment-likes">❤️ ${likedUsers.join(', ')}</div>` : '';
    
    // 处理评论内容 - 个人主页使用完整交互样式
    let commentsContent = '';
    if (moment.comments && moment.comments.length > 0) {
        // 兼容性处理个人资料页朋友圈评论：支持新旧字段名
        // 新代码应使用统一字段：commenter_name, comment_content, timestamp
        const commentsList = moment.comments
            .filter(comment => (comment.comment_content || comment.content) && (comment.comment_content || comment.content).trim())
            .map((comment, index) => {
                const safeContent = (comment.comment_content || comment.content).replace(/'/g, '&#39;');
                const commentTimeStr = comment.timestamp || comment.time || new Date().toISOString();
                const isLiked = comment.like === true ? 'liked' : '';
                const authorName = comment.commenter_name || comment.author;

                const commentAuthorContact = contacts.find(c => c.name === authorName);
                const commentAvatarContent = commentAuthorContact && commentAuthorContact.avatar ?
                    `<img src="${commentAuthorContact.avatar}" alt="头像" style="width: 32px; height: 32px; border-radius: 4px; object-fit: cover;">` :
                    `<div style="width: 32px; height: 32px; border-radius: 4px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 14px;">${authorName.charAt(0)}</div>`;
                
                return `
                    <div class="profile-moment-comment-item" data-comment-index="${index}" style="display: flex; margin-bottom: 12px;">
                        <div style="margin-right: 10px;">${commentAvatarContent}</div>
                        <div style="flex: 1;">
                            <div class="profile-moment-comment-author" onclick="handleCommentAuthorClick('${authorName}')" style="font-weight: 600; color: #576b95; cursor: pointer; line-height: 16px;">${authorName}</div>
                            <div class="profile-moment-comment-text">${safeContent}</div>
                            <div class="profile-moment-comment-actions" style="margin-top: 4px; font-size: 12px; color: #999;">
                                <span class="profile-moment-comment-time">${formatContactListTime(commentTimeStr)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        commentsContent = `<div class="profile-moment-comments">${commentsList}</div>`;
    }
    
    // 个人主页使用独立按钮
    const actionsMenu = `
        <div style="display: flex; gap: 8px;">
            <button onclick="likeMoment('${moment.id}')" style="padding: 4px 8px; background: #f0f0f0; border: none; border-radius: 12px; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px;" title="点赞">
                ❤ 点赞
            </button>
            <button onclick="showMomentComment('${moment.id}')" style="padding: 4px 8px; background: #f0f0f0; border: none; border-radius: 12px; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px;" title="评论">
                💬 评论
            </button>
        </div>
    `;
    
    // 处理作者头像 - 支持新的文件系统格式
    let avatarContent = '';
    const author = window.contacts ? window.contacts.find(c => c.name === moment.authorName) : null;
    
    try {
        if (author) {
            // 使用getAvatarHTML获取联系人头像
            const avatarHTML = await getAvatarHTML(author, 'contact', '');
            if (avatarHTML.includes('<img')) {
                const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                if (srcMatch) {
                    avatarContent = `<img src="${srcMatch[1]}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                }
            }
        } else if (moment.authorName === userProfile.name) {
            // 如果是当前用户的动态，使用getAvatarHTML获取用户头像
            const avatarHTML = await getAvatarHTML(userProfile, 'user', '');
            if (avatarHTML.includes('<img')) {
                const srcMatch = avatarHTML.match(/src="([^"]+)"/);
                if (srcMatch) {
                    avatarContent = `<img src="${srcMatch[1]}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
                }
            }
        }
        
        // 如果没有头像或头像获取失败，使用文字头像
        if (!avatarContent) {
            avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
        }
    } catch (error) {
        console.warn('获取个人主页朋友圈头像失败，使用回退逻辑:', error);
        // 回退到旧的逻辑
        if (author && author.avatar) {
            avatarContent = `<img src="${author.avatar}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
        } else if (moment.authorName === userProfile.name && userProfile.avatar) {
            avatarContent = `<img src="${userProfile.avatar}" alt="头像" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
        } else {
            avatarContent = `<div style="width: 40px; height: 40px; border-radius: 6px; background: #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #333;">${moment.authorName.charAt(0)}</div>`;
        }
    }
    
    momentDiv.innerHTML = `
        <div class="moment-header" style="display: flex; margin-bottom: 8px; align-items: flex-start;">
            <div class="moment-avatar" style="margin-right: 12px; flex-shrink: 0;">${avatarContent}</div>
            <div class="moment-info" style="flex: 1; display: flex; flex-direction: column; justify-content: space-between; min-height: 40px;">
                <div class="moment-name" style="font-weight: 600; color: #576b95; font-size: 15px; line-height: 1.2; margin: 0;">${moment.authorName}</div>
                <div class="user-profile-moment-content">${moment.content}</div>
            </div>
        </div>
        ${imagesHtml}
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
            <div class="user-profile-moment-time-location">
                <span>${formatContactListTime(timeStr)}</span>
                ${moment.location ? `<span class="moment-location">📍 ${moment.location}</span>` : ''}
            </div>
            ${actionsMenu}
        </div>
        ${likesContent}
        ${commentsContent}
        <div class="moment-reply-input-container" id="momentMainReply-${moment.id}" style="display: none;">
            <textarea class="moment-reply-input" placeholder="写评论..."></textarea>
            <div class="moment-reply-actions">
                <button class="moment-reply-btn moment-reply-cancel" onclick="hideMomentComment('${moment.id}')">取消</button>
                <button class="moment-reply-btn moment-reply-submit" onclick="submitMomentComment('${moment.id}')">发送</button>
            </div>
        </div>
    `;
    
    // 异步加载文件系统中的图片
    if (moment.imageFileIds && moment.imageCount > 0 && window.ImageStorageAPI) {
        setTimeout(async () => {
            try {
                await window.ImageStorageAPI.init();
                const imageUrls = await window.ImageStorageAPI.getMomentImagesURLs(moment.id, moment.imageCount);
                const imgElements = momentDiv.querySelectorAll('[data-moment-id="' + moment.id + '"]');
                imgElements.forEach((img, index) => {
                    if (imageUrls[index]) {
                        img.src = imageUrls[index];
                        img.onclick = () => showImagePreview(imageUrls[index]);
                    }
                });
            } catch (error) {
                console.error('加载个人主页朋友圈图片失败:', error);
            }
        }, 100);
    }
    
    return momentDiv;
}

// 页面加载后自动检查迁移状态 - 延迟至数据库初始化完成后
document.addEventListener('DOMContentLoaded', () => {
    // 等待数据库完全初始化后再检查迁移状态
    const checkMigrationWhenReady = async () => {
        // 等待数据库就绪
        let attempts = 0;
        while ((!window.db || !window.isIndexedDBReady) && attempts < 30) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        
        if (!window.db) {
            console.warn('数据库初始化超时，跳过迁移检查');
            return;
        }
        
        // 数据库就绪后执行迁移检查
        if (window.ImageMigrationManager && document.getElementById('migrationStatusText')) {
            try {
                await checkImageMigrationStatus();
            } catch (error) {
                console.error('检查图片迁移状态失败:', error);
            }
        }
        
        // 检查聊天表情迁移状态
        if (window.ChatEmojiMigrationManager && document.getElementById('chatEmojiMigrationStatusText')) {
            try {
                await checkChatEmojiMigrationStatus();
            } catch (error) {
                console.error('检查聊天表情迁移状态失败:', error);
            }
        }
    };
    
    // 异步执行，不阻塞其他初始化
    checkMigrationWhenReady().catch(console.error);
});

// === Banner上传功能 ===

// 全局变量用于存储当前选择的图片
let currentBannerImage = null;
let currentBannerCanvas = null;

// 打开banner上传模态框
function openBannerUploadModal() {
    
    // 检查模态框元素是否存在
    const modal = document.getElementById('bannerUploadModal');
    if (!modal) {
        console.error('Banner上传模态框元素不存在');
        showToast('无法打开上传界面，请刷新页面重试');
        return;
    }
    
    console.log('找到模态框元素，准备显示');
    showModal('bannerUploadModal');
    resetBannerUpload();
}

// 触发文件选择
function triggerBannerFileInput() {
    document.getElementById('bannerFileInput').click();
}

// 处理文件选择
async function handleBannerFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // 验证文件类型
    if (!file.type.match(/^image\/(jpeg|jpg|png)$/)) {
        showToast('请选择 JPG 或 PNG 格式的图片');
        return;
    }
    
    // 验证文件大小（限制为 10MB）
    if (file.size > 10 * 1024 * 1024) {
        showToast('图片文件不能超过 10MB');
        return;
    }
    
    try {
        // 读取图片
        const imageUrl = await readFileAsDataURL(file);
        const img = new Image();
        
        img.onload = () => {
            currentBannerImage = img;
            setupBannerPreview();
        };
        
        img.onerror = () => {
            showToast('图片加载失败，请选择其他图片');
        };
        
        img.src = imageUrl;
        
    } catch (error) {
        console.error('图片处理失败:', error);
        showToast('图片处理失败: ' + error.message);
    }
}

// 设置banner预览
function setupBannerPreview() {
    if (!currentBannerImage) return;
    
    // 显示预览容器
    const uploadArea = document.getElementById('bannerUploadArea');
    const previewContainer = document.getElementById('bannerPreviewContainer');
    
    uploadArea.style.display = 'none';
    previewContainer.style.display = 'block';
    
    // 设置canvas和slider
    currentBannerCanvas = document.getElementById('bannerPreviewCanvas');
    const slider = document.getElementById('bannerCropSlider');
    
    // 重置slider
    slider.value = 50;
    
    // 初始渲染
    updateBannerPreview();
}

// 更新banner预览
function updateBannerPreview() {
    if (!currentBannerImage || !currentBannerCanvas) return;
    
    const canvas = currentBannerCanvas;
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('bannerCropSlider');
    
    // Canvas尺寸 (保持2.5:1的banner比例)
    const canvasWidth = 400;
    const canvasHeight = 160;
    
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    
    // 计算图片尺寸和位置
    const imgWidth = currentBannerImage.width;
    const imgHeight = currentBannerImage.height;
    
    // 计算缩放比例，确保图片宽度完全覆盖canvas
    const scaleX = canvasWidth / imgWidth;
    const scaleY = canvasHeight / imgHeight;
    const scale = Math.max(scaleX, scaleY);
    
    const scaledWidth = imgWidth * scale;
    const scaledHeight = imgHeight * scale;
    
    // 根据slider值计算垂直位置
    const cropOffset = (slider.value / 100) * (scaledHeight - canvasHeight);
    
    // 清空canvas并绘制图片
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.drawImage(
        currentBannerImage,
        (canvasWidth - scaledWidth) / 2, // 水平居中
        -cropOffset, // 根据slider调整垂直位置
        scaledWidth,
        scaledHeight
    );
}

// 重置banner上传
function resetBannerUpload() {
    currentBannerImage = null;
    currentBannerCanvas = null;
    
    const uploadArea = document.getElementById('bannerUploadArea');
    const previewContainer = document.getElementById('bannerPreviewContainer');
    const fileInput = document.getElementById('bannerFileInput');
    
    if (uploadArea) {
        uploadArea.style.display = 'block';
    } else {
        console.error('上传区域元素不存在');
    }
    
    if (previewContainer) {
        previewContainer.style.display = 'none';
    } else {
        console.error('预览容器元素不存在');
    }
    
    if (fileInput) {
        fileInput.value = '';
    } else {
        console.error('文件输入元素不存在');
    }
}

// 保存banner图片
async function saveBannerImage() {
    if (!currentBannerCanvas || !window.ImageStorageAPI) {
        showToast('无法保存图片，请重试');
        return;
    }
    
    try {
        // 将canvas转换为blob
        const blob = await canvasToBlob(currentBannerCanvas);
        
        // 确保 ImageStorageAPI 已初始化
        await window.ImageStorageAPI.init();
        
        // 存储banner图片
        const fileId = await window.ImageStorageAPI.storeBanner(blob, 'user_profile');
        console.log('Banner图片已保存，文件ID:', fileId);
        
        // 更新用户资料中的banner字段
        const profile = await getUserProfile();
        profile.bannerFileId = fileId; // 这里fileId现在应该是字符串了
        await saveDataToDB(); // 保存到IndexedDB
        
        // 应用新的banner背景
        await applyBannerBackground(fileId);
        
        // 关闭模态框
        closeModal('bannerUploadModal');
        showToast('背景图片已更新');
        
        // 尝试重新加载banner
        setTimeout(() => {
            loadUserBanner();
        }, 1000);
        
    } catch (error) {
        console.error('保存banner失败:', error);
        showToast('保存失败: ' + error.message);
    }
}

// 应用banner背景
async function applyBannerBackground(fileId) {
    try {
        
        if (!window.ImageStorageAPI) {
            console.error('ImageStorageAPI 未加载');
            return;
        }
        
        await window.ImageStorageAPI.init();
        const bannerUrl = await window.ImageStorageAPI.getBannerURL('user_profile');
        
        const bannerElement = document.getElementById('userProfileBanner');
        
        // 尝试其他方式查找元素
        const allBanners = document.querySelectorAll('.user-profile-banner');
        
        if (bannerUrl && bannerElement) {
            // 清除原有的渐变背景
            bannerElement.style.background = 'none';
            bannerElement.style.backgroundImage = `url(${bannerUrl})`;
            bannerElement.style.backgroundSize = 'cover';
            bannerElement.style.backgroundPosition = 'center';
            bannerElement.style.backgroundRepeat = 'no-repeat';
        } else {
            console.error('Banner URL或元素为空:', { bannerUrl, bannerElement });
        }
    } catch (error) {
        console.error('应用banner背景失败:', error);
    }
}

// 加载用户banner背景
async function loadUserBanner() {
    try {
        const userProfile = await getUserProfile();
        console.log('用户资料:', userProfile);
        
        if (userProfile.bannerFileId && window.ImageStorageAPI) {
            await applyBannerBackground(userProfile.bannerFileId);
        } else {
        }
    } catch (error) {
        console.error('加载用户banner失败:', error);
    }
}

// 工具函数：读取文件为DataURL
// readFileAsDataURL function moved to utils/formatUtils.js

// 工具函数：Canvas转Blob
// canvasToBlob function moved to utils/formatUtils.js

// 在显示个人主页时加载banner
const originalShowUserProfile = showUserProfile;
showUserProfile = async function() {
    if (originalShowUserProfile) {
        await originalShowUserProfile();
    }
    // 加载banner背景
    setTimeout(loadUserBanner, 100);
};

// ========== 主题色管理功能 ==========

// 默认主题色配置
const defaultThemeColors = [
    { color: '#07c160', name: '鲜绿' },
    { color: '#1890ff', name: '天空蓝' },
    { color: '#722ed1', name: '深紫' },
    { color: '#f5222d', name: '火红' },
    { color: '#fa8c16', name: '橙' },
    { color: '#13c2c2', name: '清新青' },
    { color: '#eb2f96', name: '亮粉' },
    { color: '#2f54eb', name: '海蓝' }
];

// 默认渐变配置
const defaultGradientConfig = {
    enabled: false,
    primaryColor: '#07c160',
    secondaryColor: '#1890ff',
    direction: 'to right'
};

// IndexedDB 主题配置管理器
class ThemeConfigManager {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.db = null;
        this.storeName = 'themeConfig';
    }

    async init() {
        // 使用已有的数据库连接
        if (window.db && window.isIndexedDBReady) {
            this.db = window.db;
            return this.db;
        }
        
        // 等待数据库就绪
        return this.waitForDatabase();
    }

    async waitForDatabase() {
        return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
                if (window.db && window.isIndexedDBReady) {
                    this.db = window.db;
                    clearInterval(checkInterval);
                    resolve(this.db);
                }
            }, 100);
        });
    }


    async saveThemeConfig(type, data) {
        try {
            await this.init();
            
            // 检查存储是否存在
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.warn('themeConfig存储不存在，无法保存配置');
                throw new Error('themeConfig存储不存在');
            }
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([this.storeName], 'readwrite');
                const store = transaction.objectStore(this.storeName);
                
                const config = {
                    type: type,
                    data: data,
                    updatedAt: new Date().toISOString()
                };
                
                const request = store.put(config);
                
                request.onsuccess = () => {
                    console.log(`主题配置已保存到IndexedDB (${type}):`, data);
                    resolve(true);
                };
                
                request.onerror = () => {
                    console.error('保存主题配置失败:', request.error);
                    reject(request.error);
                };
            });
        } catch (error) {
            console.error('保存主题配置时出错:', error);
            return false;
        }
    }

    async getThemeConfig(type) {
        try {
            await this.init();
            
            // 检查存储是否存在
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.warn('themeConfig存储不存在，返回null');
                return null;
            }
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([this.storeName], 'readonly');
                const store = transaction.objectStore(this.storeName);
                const request = store.get(type);
                
                request.onsuccess = () => {
                    const result = request.result;
                    resolve(result ? result.data : null);
                };
                
                request.onerror = () => {
                    console.error('获取主题配置失败:', request.error);
                    resolve(null);
                };
            });
        } catch (error) {
            console.error('获取主题配置时出错:', error);
            return null;
        }
    }

    async getAllThemeConfigs() {
        try {
            await this.init();
            
            // 检查存储是否存在
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.warn('themeConfig存储不存在，返回空配置');
                return {};
            }
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([this.storeName], 'readonly');
                const store = transaction.objectStore(this.storeName);
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const configs = {};
                    request.result.forEach(item => {
                        configs[item.type] = item.data;
                    });
                    resolve(configs);
                };
                
                request.onerror = () => {
                    console.error('获取所有主题配置失败:', request.error);
                    resolve({});
                };
            });
        } catch (error) {
            console.error('获取所有主题配置时出错:', error);
            return {};
        }
    }

    async ensureDefaultConfigs() {
        try {
            await this.init();
            
            // 检查themeConfig存储是否存在
            if (!this.db.objectStoreNames.contains(this.storeName)) {
                console.log('themeConfig存储不存在，需要数据库升级');
                // 返回false表示存储不存在，让调用者决定如何处理
                return { success: false, reason: 'storage_not_exists' };
            }
            
            const configs = await this.getAllThemeConfigs();
            let hasChanges = false;
            
            // 如果没有主题配置，创建默认配置
            if (!configs.theme) {
                await this.saveThemeConfig('theme', { color: '#07c160', name: '鲜绿' });
                console.log('已创建默认主题配置');
                hasChanges = true;
            }
            
            if (!configs.gradient) {
                await this.saveThemeConfig('gradient', defaultGradientConfig);
                console.log('已创建默认渐变配置');
                hasChanges = true;
            }
            
            // 如果从旧格式localStorage迁移数据
            const migrationResult = this.migrateFromOldLocalStorage();
            if (migrationResult && Object.keys(configs).length === 0) {
                await this.saveThemeConfig('theme', migrationResult.theme);
                await this.saveThemeConfig('gradient', migrationResult.gradient);
                console.log('已从localStorage迁移主题配置到IndexedDB');
                hasChanges = true;
            }
            
            if (hasChanges) {
                console.log('主题配置初始化完成');
            }
            
            return true;
        } catch (error) {
            console.error('确保默认配置时出错:', error);
            return false;
        }
    }


    // 从旧格式localStorage迁移数据（同步方法）
    migrateFromOldLocalStorage() {
        try {
            const savedTheme = localStorage.getItem('user-theme-color');
            const savedGradient = localStorage.getItem('user-gradient-config');
            
            if (!savedTheme && !savedGradient) {
                return null;
            }
            
            let themeData = { color: '#07c160', name: '鲜绿' };
            let gradientData = defaultGradientConfig;
            
            if (savedTheme) {
                themeData = JSON.parse(savedTheme);
                console.log('检测到旧格式主题配置:', themeData);
                // 迁移后清理旧数据
                localStorage.removeItem('user-theme-color');
            }
            
            if (savedGradient) {
                gradientData = JSON.parse(savedGradient);
                console.log('检测到旧格式渐变配置:', gradientData);
                // 迁移后清理旧数据
                localStorage.removeItem('user-gradient-config');
            }
            
            return { theme: themeData, gradient: gradientData };
        } catch (error) {
            console.error('迁移旧格式配置失败:', error);
            return null;
        }
    }
}

// 创建全局主题配置管理器实例
const themeConfigManager = new ThemeConfigManager();

// 通用的数据库存储安全检查函数
// safeCreateTransaction function moved to utils/formatUtils.js




// 从IndexedDB加载保存的主题配置
async function loadThemeConfig() {
    try {
        // 确保默认配置存在（包含从localStorage的自动迁移）
        await themeConfigManager.ensureDefaultConfigs();
        
        // 从IndexedDB加载配置
        const configs = await themeConfigManager.getAllThemeConfigs();
        
        let themeData = configs.theme || { color: '#07c160', name: '鲜绿' };
        let gradientData = configs.gradient || defaultGradientConfig;
        
        // 应用主题配置
        if (gradientData.enabled) {
            applyGradientTheme(gradientData.primaryColor, gradientData.secondaryColor, gradientData.direction);
        } else {
            applyThemeColor(themeData.color);
        }
        
        return { theme: themeData, gradient: gradientData };
    } catch (error) {
        console.error('加载主题配置失败:', error);
        // 使用默认配置
        const themeData = { color: '#07c160', name: '鲜绿' };
        const gradientData = defaultGradientConfig;
        applyThemeColor(themeData.color);
        return { theme: themeData, gradient: gradientData };
    }
}



// 兼容旧的函数名
function loadThemeColor() {
    return loadThemeConfig().then(config => config.theme);
}

// 应用主题色到页面
// applyThemeColor function moved to utils/colorUtils.js

// 应用渐变主题
// applyGradientTheme function moved to utils/colorUtils.js

// 保存主题色到IndexedDB
async function saveThemeColor(color, name) {
    try {
        const themeData = { color, name };
        
        await themeConfigManager.saveThemeConfig('theme', themeData);
        
        // 禁用渐变模式
        const gradientConfig = { ...defaultGradientConfig, enabled: false };
        await themeConfigManager.saveThemeConfig('gradient', gradientConfig);
        
        console.log('主题色已保存:', themeData);
    } catch (error) {
        console.error('保存主题色失败:', error);
    }
}

// 保存渐变配置到IndexedDB
async function saveGradientConfig(primaryColor, secondaryColor, direction, enabled = true) {
    try {
        const gradientData = { 
            enabled, 
            primaryColor, 
            secondaryColor, 
            direction 
        };
        
        await themeConfigManager.saveThemeConfig('gradient', gradientData);
        console.log('渐变配置已保存:', gradientData);
    } catch (error) {
        console.error('保存渐变配置失败:', error);
    }
}

// 初始化外观管理页面
async function initAppearanceManagement() {
    // 获取当前主题配置
    const config = await loadThemeConfig();
    const currentTheme = config.theme;
    const currentGradient = config.gradient;
    
    // 设置主题色选项的点击事件
    document.querySelectorAll('.theme-color-option').forEach(option => {
        option.addEventListener('click', function() {
            const color = this.getAttribute('data-color');
            const name = this.getAttribute('data-name');
            
            // 移除其他选项的active状态
            document.querySelectorAll('.theme-color-option').forEach(opt => {
                opt.classList.remove('active');
            });
            
            // 添加当前选项的active状态
            this.classList.add('active');
            
            // 应用并保存主题色
            applyThemeColor(color);
            saveThemeColor(color, name);
            
            // 更新自定义颜色选择器
            updateCustomColorInputs(color);
            
            // 禁用渐变开关
            const gradientToggle = document.getElementById('gradientToggle');
            if (gradientToggle) {
                gradientToggle.checked = false;
                toggleGradientSettings(false);
            }
            
            // 显示提示
            showToast(`已切换到${name}`);
        });
        
        // 设置当前选中的主题色
        if (option.getAttribute('data-color') === currentTheme.color && !currentGradient.enabled) {
            option.classList.add('active');
        }
    });
    
    // 设置自定义颜色选择器
    initCustomColorPicker(currentTheme.color);
    
    // 初始化渐变设置
    initGradientSettings(currentGradient);
}

// 初始化自定义颜色选择器
function initCustomColorPicker(initialColor) {
    const colorPicker = document.getElementById('customColorPicker');
    const colorText = document.getElementById('customColorText');
    const colorPreview = document.getElementById('customColorPreview');
    const applyBtn = document.querySelector('.apply-custom-color-btn');
    
    if (!colorPicker || !colorText || !colorPreview) return;
    
    // 设置初始值
    colorPicker.value = initialColor;
    colorText.value = initialColor.toUpperCase();
    colorPreview.style.backgroundColor = initialColor;
    
    // 颜色选择器变化事件
    colorPicker.addEventListener('input', function() {
        const color = this.value.toUpperCase();
        colorText.value = color;
        colorPreview.style.backgroundColor = color;
        validateColorInput(colorText, applyBtn);
    });
    
    // 文本输入框变化事件
    colorText.addEventListener('input', function() {
        let color = this.value.trim();
        
        // 自动添加#前缀
        if (color && !color.startsWith('#')) {
            color = '#' + color;
            this.value = color;
        }
        
        // 验证颜色格式
        if (isValidHexColor(color)) {
            colorPicker.value = color;
            colorPreview.style.backgroundColor = color;
            this.classList.remove('invalid');
        } else {
            this.classList.add('invalid');
        }
        
        validateColorInput(this, applyBtn);
    });
    
    // 文本框失焦时格式化
    colorText.addEventListener('blur', function() {
        if (this.value && isValidHexColor(this.value)) {
            this.value = this.value.toUpperCase();
        }
    });
    
    // 按回车键应用颜色
    colorText.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && isValidHexColor(this.value)) {
            applyCustomColor();
        }
    });
    
    // 点击预览圆圈触发颜色选择器
    colorPreview.addEventListener('click', function() {
        colorPicker.click();
    });
}

// 更新自定义颜色输入框
function updateCustomColorInputs(color) {
    const colorPicker = document.getElementById('customColorPicker');
    const colorText = document.getElementById('customColorText');
    const colorPreview = document.getElementById('customColorPreview');
    const applyBtn = document.querySelector('.apply-custom-color-btn');
    
    if (colorPicker) colorPicker.value = color;
    if (colorText) {
        colorText.value = color.toUpperCase();
        colorText.classList.remove('invalid');
    }
    if (colorPreview) colorPreview.style.backgroundColor = color;
    if (applyBtn) applyBtn.disabled = false;
}

// 验证颜色输入
// validateColorInput function moved to utils/colorUtils.js

// 应用自定义颜色
function applyCustomColor() {
    const colorText = document.getElementById('customColorText');
    const color = colorText.value.trim();
    
    if (!color) {
        showToast('请输入颜色代码');
        return;
    }
    
    if (!isValidHexColor(color)) {
        showToast('请输入有效的颜色代码（例如：#FF0000）');
        colorText.focus();
        return;
    }
    
    // 移除预设选项的active状态
    document.querySelectorAll('.theme-color-option').forEach(opt => {
        opt.classList.remove('active');
    });
    
    // 应用并保存主题色
    applyThemeColor(color);
    saveThemeColor(color, '自定义颜色');
    
    // 更新预览
    const colorPreview = document.getElementById('customColorPreview');
    if (colorPreview) {
        colorPreview.style.backgroundColor = color;
    }
    
    showToast('自定义颜色已应用：' + color.toUpperCase());
}

// 工具函数：验证十六进制颜色代码

// 初始化渐变设置
function initGradientSettings(gradientConfig) {
    const gradientToggle = document.getElementById('gradientToggle');
    const gradientSettings = document.getElementById('gradientSettings');
    
    if (!gradientToggle) return;
    
    // 设置开关状态
    gradientToggle.checked = gradientConfig.enabled;
    toggleGradientSettings(gradientConfig.enabled);
    
    // 设置渐变开关事件
    gradientToggle.addEventListener('change', function() {
        toggleGradientSettings(this.checked);
    });
    
    // 初始化渐变颜色选择器
    initGradientColorPickers(gradientConfig);
    
    // 初始化渐变方向选择
    initGradientDirectionPickers(gradientConfig.direction);
}

// 切换渐变设置显示/隐藏
function toggleGradientSettings(show) {
    const gradientSettings = document.getElementById('gradientSettings');
    if (gradientSettings) {
        gradientSettings.style.display = show ? 'block' : 'none';
    }
}

// 初始化渐变颜色选择器
function initGradientColorPickers(gradientConfig) {
    // 主色选择器
    initSingleGradientColorPicker('Primary', gradientConfig.primaryColor, updateGradientPreview);
    // 副色选择器
    initSingleGradientColorPicker('Secondary', gradientConfig.secondaryColor, updateGradientPreview);
    
    // 更新预览
    updateGradientPreview();
}

// 初始化单个渐变颜色选择器
function initSingleGradientColorPicker(type, initialColor, callback) {
    const picker = document.getElementById(`gradient${type}Picker`);
    const text = document.getElementById(`gradient${type}Text`);
    const preview = document.getElementById(`gradient${type}Preview`);
    
    if (!picker || !text || !preview) return;
    
    // 设置初始值
    picker.value = initialColor;
    text.value = initialColor.toUpperCase();
    preview.style.backgroundColor = initialColor;
    
    // 颜色选择器变化事件
    picker.addEventListener('input', function() {
        const color = this.value.toUpperCase();
        text.value = color;
        preview.style.backgroundColor = color;
        if (callback) callback();
    });
    
    // 文本输入框变化事件
    text.addEventListener('input', function() {
        let color = this.value.trim();
        
        if (color && !color.startsWith('#')) {
            color = '#' + color;
            this.value = color;
        }
        
        if (isValidHexColor(color)) {
            picker.value = color;
            preview.style.backgroundColor = color;
            this.classList.remove('invalid');
            if (callback) callback();
        } else {
            this.classList.add('invalid');
        }
    });
    
    // 点击预览触发颜色选择器
    preview.addEventListener('click', function() {
        picker.click();
    });
}

// 初始化渐变方向选择器
function initGradientDirectionPickers(initialDirection) {
    const directionInputs = document.querySelectorAll('input[name="gradientDirection"]');
    
    directionInputs.forEach(input => {
        if (input.value === initialDirection) {
            input.checked = true;
        }
        
        input.addEventListener('change', function() {
            if (this.checked) {
                updateGradientPreview();
            }
        });
    });
}

// 更新渐变预览
function updateGradientPreview() {
    const primaryColor = document.getElementById('gradientPrimaryText').value;
    const secondaryColor = document.getElementById('gradientSecondaryText').value;
    const direction = document.querySelector('input[name="gradientDirection"]:checked')?.value || 'to right';
    
    const previewDemo = document.getElementById('gradientPreviewDemo');
    if (previewDemo && isValidHexColor(primaryColor) && isValidHexColor(secondaryColor)) {
        previewDemo.style.background = `linear-gradient(${direction}, ${primaryColor}, ${secondaryColor})`;
    }
}

// 应用渐变主题（从UI调用）
function applyGradientThemeFromUI() {
    const primaryColor = document.getElementById('gradientPrimaryText').value;
    const secondaryColor = document.getElementById('gradientSecondaryText').value;
    const direction = document.querySelector('input[name="gradientDirection"]:checked')?.value || 'to right';
    
    if (!isValidHexColor(primaryColor) || !isValidHexColor(secondaryColor)) {
        showToast('请输入有效的颜色代码');
        return;
    }
    
    // 应用渐变
    applyGradientTheme(primaryColor, secondaryColor, direction);
    
    // 保存配置
    saveGradientConfig(primaryColor, secondaryColor, direction, true);
    
    // 移除预设主题色的选中状态
    document.querySelectorAll('.theme-color-option').forEach(opt => {
        opt.classList.remove('active');
    });
    
    showToast('渐变主题已应用');
}

// 打开气泡设计器
function openBubbleDesigner() {
    try {
        // 在新窗口中打开气泡设计器
        const bubbleWindow = window.open('bubble.html', 'bubbleDesigner', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        
        if (!bubbleWindow) {
            showToast('无法打开气泡设计器，请检查浏览器弹窗设置');
            return;
        }
        
        // 聚焦到新窗口
        bubbleWindow.focus();
        
    } catch (error) {
        console.error('打开气泡设计器时出错:', error);
        showToast('打开气泡设计器失败，请重试');
    }
}

// 在页面加载完成后初始化主题色
document.addEventListener('DOMContentLoaded', async function() {
    // 等待数据库完全初始化后再加载主题配置
    const waitForDatabase = async () => {
        let attempts = 0;
        while ((!window.db || !window.isIndexedDBReady) && attempts < 30) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        
        if (!window.db || !window.isIndexedDBReady) {
            console.warn('数据库初始化超时，使用默认主题配置');
            return false;
        }
        
        // 再次检查themeConfig表是否存在
        if (!window.db.objectStoreNames.contains('themeConfig')) {
            console.warn('themeConfig存储不存在，等待数据库升级');
            // 触发数据库升级
            if (window.dbManager && window.dbManager.autoUpgradeDatabase) {
                try {
                    await window.dbManager.autoUpgradeDatabase();
                    // 重新检查
                    if (window.db && window.db.objectStoreNames.contains('themeConfig')) {
                        console.log('数据库升级完成，themeConfig表已创建');
                        return true;
                    }
                } catch (error) {
                    console.error('数据库升级失败:', error);
                }
            }
            return false;
        }
        
        return true;
    };
    
    const databaseReady = await waitForDatabase();
    
    if (databaseReady) {
        // 加载保存的主题配置
        await loadThemeConfig();
        
        // 加载自定义气泡样式
        await loadCustomBubbleStyle();
    } else {
        // 如果数据库未就绪，应用默认主题
        console.log('数据库未就绪，应用默认主题');
        applyThemeColor('#07c160');
    }
    
    // 当切换到外观管理页面时初始化
    const originalShowPageAsync = showPageAsync;
    window.showPageAsync = async function(pageIdToShow) {
        const result = await originalShowPageAsync(pageIdToShow);
        
        if (pageIdToShow === 'appearanceManagementPage') {
            setTimeout(async () => {
                await initAppearanceManagement();
            }, 100);
        }
        
        return result;
    };
});

// 监听来自气泡设计器的样式应用消息
window.addEventListener('message', async function(event) {
    // 检查消息类型
    if (event.data && event.data.type === 'apply-bubble-style') {
        try {
            const bubbleStyleData = event.data.payload;
            const bubbleType = event.data.bubbleType || 'kare'; // 默认为别人的气泡
            
            // 根据气泡类型存储到不同的键
            const storageKey = bubbleType === 'self' ? 'bubbleStyleSelf' : 'bubbleStyle';
            
            // 存储气泡样式到 IndexedDB
            saveBubbleStyleToStorage(bubbleStyleData, storageKey).then(() => {
                console.log(`${bubbleType === 'self' ? '我的' : '对方的'}气泡样式已保存到存储`);
                
                // 如果当前在聊天页面，立即应用样式
                if (document.getElementById('chatPage').classList.contains('active')) {
                    applyBubbleStyleToCurrentChat();
                }
                
                // 显示成功提示
                if (typeof showToast === 'function') {
                    showToast(`${bubbleType === 'self' ? '我的' : '对方的'}气泡样式已应用！`);
                }
            }).catch(error => {
                console.error('保存气泡样式失败:', error);
                if (typeof showToast === 'function') {
                    showToast('样式保存失败: ' + error.message);
                }
            });
            
        } catch (error) {
            console.error('处理气泡样式消息失败:', error);
        }
    } else if (event.data && event.data.type === 'reset-bubble-style') {
        try {
            // 恢复默认气泡样式
            await resetBubbleStyleToDefault();
            
            // 显示成功提示
            if (typeof showToast === 'function') {
                showToast('已恢复默认气泡样式！');
            }
            
        } catch (error) {
            console.error('恢复默认气泡样式失败:', error);
            if (typeof showToast === 'function') {
                showToast('恢复默认样式失败: ' + error.message);
            }
        }
    }
});

/**
 * 处理HTML中的file:格式图片URL
 */
async function processFileUrlsInHtml(html) {
    if (!html || typeof html !== 'string') return html;
    
    // 使用正则表达式查找所有 src="file:fileId" 格式的图片
    const fileUrlRegex = /src="file:([^"]+)"/g;
    let match;
    const replacements = [];
    
    while ((match = fileUrlRegex.exec(html)) !== null) {
        const fileId = match[1];
        try {
            // 使用 FileStorageManager 获取真实URL
            if (window.FileStorageManager && window.FileStorageManager.createFileURL) {
                const realUrl = await window.FileStorageManager.createFileURL(fileId);
                replacements.push({
                    original: match[0],
                    replacement: `src="${realUrl}"`
                });
            }
        } catch (error) {
            console.warn('处理文件URL失败:', fileId, error);
        }
    }
    
    // 应用所有替换
    let processedHtml = html;
    for (const replacement of replacements) {
        processedHtml = processedHtml.replace(replacement.original, replacement.replacement);
    }
    
    return processedHtml;
}

/**
 * 保存气泡样式到存储
 */
async function saveBubbleStyleToStorage(styleData, storageKey = 'bubbleStyle') {
    try {
        // 保存完整的气泡样式数据（包含所有配置）
        const bubbleStyleConfig = {
            ...styleData,  // 包含所有样式配置
            enabled: true,  // 每次保存都自动启用
            lastModified: new Date().toISOString()  // 添加时间戳以跟踪更新
        };
        
        await themeConfigManager.saveThemeConfig(storageKey, bubbleStyleConfig);
        console.log(`${storageKey}已保存到 themeConfig 并自动启用`);
        
    } catch (error) {
        console.error(`保存${storageKey}失败:`, error);
        throw error;
    }
}

/**
 * 应用气泡样式到当前聊天
 */
async function applyBubbleStyleToCurrentChat() {
    try {
        // 同时读取两种气泡样式
        await themeConfigManager.init();
        const bubbleStyleKare = await themeConfigManager.getThemeConfig('bubbleStyle');
        const bubbleStyleSelf = await themeConfigManager.getThemeConfig('bubbleStyleSelf');
        
        // 如果通过 themeConfigManager 获取不到，直接从数据库读取
        let directBubbleStyleKare = null;
        let directBubbleStyleSelf = null;
        
        if (!bubbleStyleKare || !bubbleStyleSelf) {
            const results = await new Promise((resolve) => {
                const transaction = themeConfigManager.db.transaction(['themeConfig'], 'readonly');
                const store = transaction.objectStore('themeConfig');
                let kare = null, self = null, completed = 0;
                
                const checkComplete = () => {
                    completed++;
                    if (completed === 2) {
                        resolve({ kare, self });
                    }
                };
                
                const requestKare = store.get('bubbleStyle');
                requestKare.onsuccess = () => {
                    kare = requestKare.result;
                    checkComplete();
                };
                requestKare.onerror = () => checkComplete();
                
                const requestSelf = store.get('bubbleStyleSelf');
                requestSelf.onsuccess = () => {
                    self = requestSelf.result;
                    checkComplete();
                };
                requestSelf.onerror = () => checkComplete();
            });
            
            directBubbleStyleKare = results.kare;
            directBubbleStyleSelf = results.self;
        }
        
        // 使用找到的数据
        const styleDataKare = bubbleStyleKare || directBubbleStyleKare;
        const styleDataSelf = bubbleStyleSelf || directBubbleStyleSelf;
        
        // 处理别人的气泡样式
        const isEnabledKare = styleDataKare?.enabled || styleDataKare?.data?.enabled;
        const actualStyleDataKare = styleDataKare?.data || styleDataKare;
        
        const shouldEnableKare = isEnabledKare || 
                                 (styleDataKare && actualStyleDataKare?.html) || 
                                 (styleDataKare && actualStyleDataKare?.borderWidth !== undefined && !('enabled' in styleDataKare));
        
        // 处理自己的气泡样式
        const isEnabledSelf = styleDataSelf?.enabled || styleDataSelf?.data?.enabled;
        const actualStyleDataSelf = styleDataSelf?.data || styleDataSelf;
        
        const shouldEnableSelf = isEnabledSelf || 
                               (styleDataSelf && actualStyleDataSelf?.html) || 
                               (styleDataSelf && actualStyleDataSelf?.borderWidth !== undefined && !('enabled' in styleDataSelf));
        
        // 将自定义样式应用到全局样式变量
        if (styleDataKare && shouldEnableKare && actualStyleDataKare?.html) {
            window.customBubbleStyleKare = actualStyleDataKare;
            console.log('应用对方气泡样式到当前聊天');
        } else {
            window.customBubbleStyleKare = null;
        }
        
        if (styleDataSelf && shouldEnableSelf && actualStyleDataSelf?.html) {
            window.customBubbleStyleSelf = actualStyleDataSelf;
            console.log('应用我的气泡样式到当前聊天');
        } else {
            window.customBubbleStyleSelf = null;
        }
        
        // 兼容旧版本：如果有旧的customBubbleStyle，保持向后兼容
        if (window.customBubbleStyleKare && !window.customBubbleStyle) {
            window.customBubbleStyle = window.customBubbleStyleKare;
        }
        
        // 动态加载所需字体
        if (window.fontLoader) {
            const fontsToLoad = new Set();
            
            if (actualStyleDataKare?.fontFamily && shouldEnableKare) {
                fontsToLoad.add(actualStyleDataKare.fontFamily);
            }
            
            if (actualStyleDataSelf?.fontFamily && shouldEnableSelf) {
                fontsToLoad.add(actualStyleDataSelf.fontFamily);
            }
            
            if (fontsToLoad.size > 0) {
                console.log('开始加载气泡样式所需字体:', Array.from(fontsToLoad));
                try {
                    const fontResults = await Promise.all(
                        Array.from(fontsToLoad).map(font => window.fontLoader.loadFont(font))
                    );
                    const loadedCount = fontResults.filter(Boolean).length;
                    console.log(`气泡字体加载完成: ${loadedCount}/${fontsToLoad.size} 成功`);
                } catch (error) {
                    console.warn('加载气泡字体时发生错误:', error);
                }
            }
        }

        // 重新渲染当前聊天消息以应用新样式
        if (window.currentContact && (window.customBubbleStyleKare || window.customBubbleStyleSelf)) {
            await renderMessages(false); // 明确指定非初始加载，避免滚动
            console.log('气泡样式已应用到当前聊天');
        } else if (!window.customBubbleStyleKare && !window.customBubbleStyleSelf) {
            // 清除自定义样式，使用默认样式
            window.customBubbleStyle = null;
            console.log('未找到启用的气泡样式，使用默认样式');
        }
        
    } catch (error) {
        console.error('应用气泡样式失败:', error);
    }
}

/**
 * 获取当前联系人ID
 */
function getCurrentContactId() {
    // 从当前活动的聊天页面获取联系人ID
    const chatTitle = document.getElementById('chatTitle');
    if (chatTitle && chatTitle.dataset.contactId) {
        return chatTitle.dataset.contactId;
    }
    
    // 备用方法：从全局变量或当前联系人获取
    return window.currentContactId || (window.currentContact && window.currentContact.id) || null;
}

/**
 * 加载自定义气泡样式
 */
async function loadCustomBubbleStyle() {
    try {
        // 同时读取两种气泡样式
        await themeConfigManager.init();
        const bubbleStyleKare = await themeConfigManager.getThemeConfig('bubbleStyle');
        const bubbleStyleSelf = await themeConfigManager.getThemeConfig('bubbleStyleSelf');
        
        // 如果通过 themeConfigManager 获取不到，直接从数据库读取
        let directBubbleStyleKare = null;
        let directBubbleStyleSelf = null;
        
        if (!bubbleStyleKare || !bubbleStyleSelf) {
            const results = await new Promise((resolve) => {
                const transaction = themeConfigManager.db.transaction(['themeConfig'], 'readonly');
                const store = transaction.objectStore('themeConfig');
                let kare = null, self = null, completed = 0;
                
                const checkComplete = () => {
                    completed++;
                    if (completed === 2) {
                        resolve({ kare, self });
                    }
                };
                
                const requestKare = store.get('bubbleStyle');
                requestKare.onsuccess = () => {
                    kare = requestKare.result;
                    checkComplete();
                };
                requestKare.onerror = () => checkComplete();
                
                const requestSelf = store.get('bubbleStyleSelf');
                requestSelf.onsuccess = () => {
                    self = requestSelf.result;
                    checkComplete();
                };
                requestSelf.onerror = () => checkComplete();
            });
            
            directBubbleStyleKare = results.kare;
            directBubbleStyleSelf = results.self;
        }
        
        // 使用找到的数据
        const styleDataKare = bubbleStyleKare || directBubbleStyleKare;
        const styleDataSelf = bubbleStyleSelf || directBubbleStyleSelf;
        
        // console.log('加载的对方气泡样式配置:', styleDataKare);
        // console.log('加载的我的气泡样式配置:', styleDataSelf);
        
        // 处理对方气泡样式
        const isEnabledKare = styleDataKare?.enabled || styleDataKare?.data?.enabled;
        const actualStyleDataKare = styleDataKare?.data || styleDataKare;
        
        const shouldEnableKare = isEnabledKare || 
                                 (styleDataKare && actualStyleDataKare?.html) || 
                                 (styleDataKare && actualStyleDataKare?.borderWidth !== undefined && !('enabled' in styleDataKare));
        
        // 处理我的气泡样式
        const isEnabledSelf = styleDataSelf?.enabled || styleDataSelf?.data?.enabled;
        const actualStyleDataSelf = styleDataSelf?.data || styleDataSelf;
        
        const shouldEnableSelf = isEnabledSelf || 
                               (styleDataSelf && actualStyleDataSelf?.html) || 
                               (styleDataSelf && actualStyleDataSelf?.borderWidth !== undefined && !('enabled' in styleDataSelf));
        
        // 应用对方气泡样式
        if (styleDataKare && shouldEnableKare && actualStyleDataKare?.html) {
            window.customBubbleStyleKare = actualStyleDataKare;
            console.log('对方气泡样式已从 themeConfig 加载并启用');
        } else {
            window.customBubbleStyleKare = null;
            console.log('未找到启用的对方气泡样式，使用默认样式');
        }
        
        // 应用我的气泡样式
        if (styleDataSelf && shouldEnableSelf && actualStyleDataSelf?.html) {
            window.customBubbleStyleSelf = actualStyleDataSelf;
            console.log('我的气泡样式已从 themeConfig 加载并启用');
        } else {
            window.customBubbleStyleSelf = null;
            console.log('未找到启用的我的气泡样式，使用默认样式');
        }
        
        // 兼容旧版本：如果有对方气泡样式，保持向后兼容
        if (window.customBubbleStyleKare && !window.customBubbleStyle) {
            window.customBubbleStyle = window.customBubbleStyleKare;
            console.log('设置向后兼容的 customBubbleStyle');
        } else if (!window.customBubbleStyleKare && !window.customBubbleStyleSelf) {
            // 清除任何之前的自定义样式
            window.customBubbleStyle = null;
        }
        
    } catch (error) {
        console.error('加载气泡样式失败:', error);
    }
}

/**
 * 恢复默认气泡样式
 */
async function resetBubbleStyleToDefault() {
    try {
        // 从数据库删除自定义气泡样式配置
        await themeConfigManager.init();
        await themeConfigManager.deleteThemeConfig('bubbleStyle');
        
        // 清除内存中的自定义样式
        window.customBubbleStyle = null;
        
        console.log('自定义气泡样式已清除，恢复默认样式');
        
        // 如果当前在聊天页面，重新渲染消息以应用默认样式
        if (window.currentContact && document.getElementById('chatPage').classList.contains('active')) {
            await renderMessages(false); // 明确指定非初始加载，避免滚动
        }
        
    } catch (error) {
        console.error('恢复默认气泡样式失败:', error);
        throw error;
    }
}


// ===== 图片关键词优化相关函数 =====

// 检查图片关键词优化配置状态
async function checkImageKeywordStatus() {
    try {
        const statusElement = document.getElementById('imageKeywordStatus');
        const configStatusElement = document.getElementById('imageKeywordConfigStatus');
        
        // 检查元素是否存在
        if (!statusElement || !configStatusElement) {
            console.warn('图片关键词状态元素未找到');
            return;
        }
        
        // 检查API配置
        let hasApiConfig = false;
        try {
            const apiCallInfo = await getApiCallInfo();
            hasApiConfig = !!(apiCallInfo && apiCallInfo.url && apiCallInfo.key && apiCallInfo.model);
        } catch (error) {
            hasApiConfig = false;
        }
        const hasUnsplashKey = localStorage.getItem('forumUnsplashApiKey') || localStorage.getItem('unsplashApiKey');
        
        let statusText = '';
        let statusColor = '';
        let configDetails = '';
        
        if (!hasApiConfig && !hasUnsplashKey) {
            statusText = '未配置';
            statusColor = '#dc3545';
            configDetails = `
                <div style="color: #dc3545;">❌ 功能未配置</div>
                <div style="margin-top: 5px;">需要配置：</div>
                <ul style="margin: 5px 0; padding-left: 15px;">
                    <li>AI API 配置（用于生成关键词）</li>
                    <li>Unsplash API Key（用于搜索图片）</li>
                </ul>
            `;
        } else if (!hasApiConfig) {
            statusText = '部分配置';
            statusColor = '#ffc107';
            configDetails = `
                <div style="color: #ffc107;">⚠️ AI API 未配置</div>
                <div style="margin-top: 5px;">✅ Unsplash API Key 已配置</div>
                <div style="margin-top: 5px; color: #666;">需要配置 AI API 才能生成关键词</div>
            `;
        } else if (!hasUnsplashKey) {
            statusText = '部分配置';
            statusColor = '#ffc107';
            configDetails = `
                <div style="color: #28a745;">✅ AI API 已配置</div>
                <div style="color: #ffc107; margin-top: 5px;">⚠️ Unsplash API Key 未配置</div>
                <div style="margin-top: 5px; color: #666;">需要配置 Unsplash API Key 才能搜索图片</div>
            `;
        } else {
            statusText = '完全配置';
            statusColor = '#28a745';
            const isReady = window.imageKeywordGenerator && await window.imageKeywordGenerator.isReady();
            configDetails = `
                <div style="color: #28a745;">✅ AI API 已配置</div>
                <div style="color: #28a745; margin-top: 5px;">✅ Unsplash API Key 已配置</div>
                <div style="color: #28a745; margin-top: 5px;">✅ 图片关键词生成器：${isReady ? '就绪' : '初始化中'}</div>
                <div style="margin-top: 5px; color: #666;">功能完全可用</div>
            `;
        }
        
        statusElement.textContent = statusText;
        statusElement.style.color = statusColor;
        configStatusElement.innerHTML = configDetails;
        
        showToast('配置状态已更新');
    } catch (error) {
        console.error('检查图片关键词配置状态失败:', error);
        showToast('检查状态失败: ' + error.message);
    }
}

// 打开图片关键词设置
function openImageKeywordSettings() {
    showModal('apiSettingsModal');
    showToast('请在 API 配置中设置 AI API 和 Unsplash API Key');
}

// 监听数据管理页面显示的安全方式
function enhanceShowPageForImageKeyword() {
    if (typeof window.showPage === 'function') {
        const originalShowPage = window.showPage;
        window.showPage = function(pageId) {
            const result = originalShowPage.call(this, pageId);
            if (pageId === 'dataManagementPage') {
                setTimeout(() => {
                    checkImageKeywordStatus();
                }, 200);
            }
            return result;
        };
    } else {
        // 如果showPage还未定义，延迟执行
        setTimeout(enhanceShowPageForImageKeyword, 500);
    }
}

// 页面加载完成后执行增强
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', enhanceShowPageForImageKeyword);
} else {
    enhanceShowPageForImageKeyword();
}

// ===== API请求队列系统 =====

/**
 * API请求队列管理器
 */
class APIRequestQueue {
    constructor() {
        this.queue = [];
        this.isProcessing = false;
        this.currentRequest = null;
        this.maxRetries = 3;
        
        // 优先级常量
        this.PRIORITY = {
            URGENT: 1,    // 聊天消息
            HIGH: 2,      // 用户主动操作
            NORMAL: 3,    // 后台任务
            LOW: 4        // 七夕节等特殊任务
        };
    }
    
    /**
     * 添加API请求到队列
     */
    async addRequest(apiCall, options = {}) {
        const requestItem = {
            id: generateId(),
            apiCall,
            priority: options.priority || this.PRIORITY.NORMAL,
            retries: 0,
            maxRetries: options.maxRetries || this.maxRetries,
            description: options.description || '未知请求',
            onProgress: options.onProgress || null,
            onComplete: options.onComplete || null,
            onError: options.onError || null,
            timestamp: Date.now()
        };
        
        console.log(`[队列] 添加请求: ${requestItem.description}, 优先级: ${requestItem.priority}`);
        
        // 插入到合适的位置（按优先级排序）
        let insertIndex = this.queue.length;
        for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i].priority > requestItem.priority) {
                insertIndex = i;
                break;
            }
        }
        
        this.queue.splice(insertIndex, 0, requestItem);
        
        // 如果没有在处理请求，立即开始处理
        if (!this.isProcessing) {
            this.processQueue();
        }
        
        return requestItem.id;
    }
    
    /**
     * 处理队列中的请求
     */
    async processQueue() {
        if (this.isProcessing || this.queue.length === 0) {
            return;
        }
        
        this.isProcessing = true;
        console.log(`[队列] 开始处理，队列中有 ${this.queue.length} 个请求`);
        
        while (this.queue.length > 0) {
            const request = this.queue.shift();
            this.currentRequest = request;
            
            try {
                console.log(`[队列] 处理请求: ${request.description}`);
                
                if (request.onProgress) {
                    request.onProgress(request.id, '开始处理');
                }
                
                const result = await request.apiCall();
                
                if (request.onComplete) {
                    request.onComplete(request.id, result);
                }
                
                console.log(`[队列] 请求完成: ${request.description}`);
                
            } catch (error) {
                console.error(`[队列] 请求失败: ${request.description}`, error);
                
                request.retries++;
                if (request.retries < request.maxRetries) {
                    console.log(`[队列] 重试请求 (${request.retries}/${request.maxRetries}): ${request.description}`);
                    // 重新加入队列，但降低优先级
                    request.priority = Math.min(request.priority + 1, this.PRIORITY.LOW);
                    this.queue.unshift(request);
                } else {
                    console.error(`[队列] 请求最终失败: ${request.description}`);
                    if (request.onError) {
                        request.onError(request.id, error);
                    }
                }
            }
            
            this.currentRequest = null;
            
            // 添加小延迟避免过快请求
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        this.isProcessing = false;
        console.log('[队列] 所有请求处理完成');
    }
    
    /**
     * 获取队列状态
     */
    getStatus() {
        return {
            queueLength: this.queue.length,
            isProcessing: this.isProcessing,
            currentRequest: this.currentRequest ? {
                id: this.currentRequest.id,
                description: this.currentRequest.description,
                priority: this.currentRequest.priority
            } : null
        };
    }
    
    /**
     * 取消指定请求
     */
    cancelRequest(requestId) {
        const index = this.queue.findIndex(req => req.id === requestId);
        if (index !== -1) {
            const removed = this.queue.splice(index, 1)[0];
            console.log(`[队列] 取消请求: ${removed.description}`);
            return true;
        }
        return false;
    }
    
    /**
     * 清空队列
     */
    clearQueue() {
        this.queue = [];
        console.log('[队列] 队列已清空');
    }
}

// 创建全局队列实例
window.apiRequestQueue = new APIRequestQueue();

// ===== 通用工具函数 =====

/**
 * 生成唯一ID
 */
// generateId function moved to utils/formatUtils.js

// ===== 渐变背景管理系统 =====

/**
 * 渐变背景管理器 - 管理特殊活动的自定义渐变背景
 */
class GradientBackgroundManager {
    constructor() {
        this.storageKey = 'statusBallCustomGradients';
        this.customGradients = this.loadCustomGradients();
        this.presets = this.getGradientPresets();
    }
    
    /**
     * 获取预设渐变
     */
    getGradientPresets() {
        return {
            // 七夕节预设
            qixi_classic: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            qixi_romantic: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
            qixi_dreamy: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
            
            // 生日预设
            birthday_cake: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)',
            birthday_party: 'linear-gradient(135deg, #ff6b6b 0%, #feca57 100%)',
            birthday_joy: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
            
            // 节日预设
            holiday_festival: 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)',
            holiday_fireworks: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
            holiday_celebration: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
            
            // 通用预设
            sunrise: 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)',
            ocean: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            forest: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
            sunset: 'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)',
            galaxy: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            aurora: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'
        };
    }
    
    /**
     * 从本地存储加载自定义渐变
     */
    loadCustomGradients() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            return stored ? JSON.parse(stored) : {};
        } catch (error) {
            console.error('加载自定义渐变失败:', error);
            return {};
        }
    }
    
    /**
     * 保存自定义渐变到本地存储
     */
    saveCustomGradients() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.customGradients));
        } catch (error) {
            console.error('保存自定义渐变失败:', error);
        }
    }
    
    /**
     * 设置自定义渐变
     * @param {string} eventType - 事件类型
     * @param {string} gradient - 渐变CSS
     * @param {string} name - 渐变名称（可选）
     */
    setCustomGradient(eventType, gradient, name = '') {
        if (!this.customGradients[eventType]) {
            this.customGradients[eventType] = {};
        }
        
        const gradientId = 'custom_' + Date.now();
        this.customGradients[eventType][gradientId] = {
            gradient: gradient,
            name: name || `自定义渐变 ${Object.keys(this.customGradients[eventType]).length + 1}`,
            createdAt: new Date().toISOString()
        };
        
        this.saveCustomGradients();
        return gradientId;
    }
    
    /**
     * 获取事件类型的渐变
     * @param {string} eventType - 事件类型
     * @param {string} gradientId - 渐变ID（可选，不提供则使用默认）
     */
    getGradient(eventType, gradientId = null) {
        // 如果指定了gradientId，尝试获取自定义渐变
        if (gradientId && this.customGradients[eventType] && this.customGradients[eventType][gradientId]) {
            return this.customGradients[eventType][gradientId].gradient;
        }
        
        // 尝试获取事件类型的默认自定义渐变
        if (this.customGradients[eventType]) {
            const customGradientsForEvent = Object.values(this.customGradients[eventType]);
            if (customGradientsForEvent.length > 0) {
                // 返回最新的自定义渐变
                return customGradientsForEvent[customGradientsForEvent.length - 1].gradient;
            }
        }
        
        // 返回预设渐变
        const presetKey = `${eventType}_classic`;
        return this.presets[presetKey] || this.presets.sunrise;
    }
    
    /**
     * 获取事件类型的所有渐变
     * @param {string} eventType - 事件类型
     */
    getAllGradientsForEvent(eventType) {
        const gradients = [];
        
        // 添加预设渐变
        Object.keys(this.presets).forEach(key => {
            if (key.startsWith(eventType + '_')) {
                gradients.push({
                    id: key,
                    name: this.getPresetName(key),
                    gradient: this.presets[key],
                    type: 'preset'
                });
            }
        });
        
        // 添加自定义渐变
        if (this.customGradients[eventType]) {
            Object.entries(this.customGradients[eventType]).forEach(([id, data]) => {
                gradients.push({
                    id: id,
                    name: data.name,
                    gradient: data.gradient,
                    type: 'custom',
                    createdAt: data.createdAt
                });
            });
        }
        
        return gradients;
    }
    
    /**
     * 获取预设名称
     */
    getPresetName(presetKey) {
        const names = {
            qixi_classic: '七夕经典',
            qixi_romantic: '七夕浪漫',
            qixi_dreamy: '七夕梦幻',
            birthday_cake: '生日蛋糕',
            birthday_party: '生日派对',
            birthday_joy: '生日欢乐',
            holiday_festival: '节日庆典',
            holiday_fireworks: '节日烟花',
            holiday_celebration: '节日庆祝',
            sunrise: '日出',
            ocean: '海洋',
            forest: '森林',
            sunset: '日落',
            galaxy: '星河',
            aurora: '极光'
        };
        return names[presetKey] || presetKey;
    }
    
    /**
     * 删除自定义渐变
     * @param {string} eventType - 事件类型
     * @param {string} gradientId - 渐变ID
     */
    deleteCustomGradient(eventType, gradientId) {
        if (this.customGradients[eventType] && this.customGradients[eventType][gradientId]) {
            delete this.customGradients[eventType][gradientId];
            
            // 如果该事件类型没有自定义渐变了，删除整个条目
            if (Object.keys(this.customGradients[eventType]).length === 0) {
                delete this.customGradients[eventType];
            }
            
            this.saveCustomGradients();
            return true;
        }
        return false;
    }
    
    /**
     * 创建渐变选择器UI
     * @param {string} eventType - 事件类型
     * @param {Function} onSelect - 选择回调
     */
    createGradientSelector(eventType, onSelect) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        `;
        
        const gradients = this.getAllGradientsForEvent(eventType);
        
        content.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0;">选择渐变背景</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="text" id="customGradientInput" 
                           placeholder="输入CSS渐变，如: linear-gradient(135deg, #ff0000 0%, #0000ff 100%)"
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <button onclick="addCustomGradient()" 
                            style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        添加
                    </button>
                </div>
            </div>
            <div id="gradientList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">
                ${gradients.map(g => `
                    <div class="gradient-item" 
                         style="cursor: pointer; border-radius: 8px; overflow: hidden; border: 2px solid transparent;"
                         data-gradient="${g.gradient.replace(/"/g, '&quot;')}"
                         data-id="${g.id}">
                        <div style="height: 80px; background: ${g.gradient};"></div>
                        <div style="padding: 8px; background: #f5f5f5; font-size: 12px; text-align: center;">
                            ${g.name}
                            ${g.type === 'custom' ? '<br><small style="color: #666;">自定义</small>' : ''}
                        </div>
                    </div>
                `).join('')}
            </div>
            <div style="text-align: right; margin-top: 20px;">
                <button onclick="closeGradientSelector()" 
                        style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    关闭
                </button>
            </div>
        `;
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // 添加事件处理
        window.addCustomGradient = () => {
            const input = document.getElementById('customGradientInput');
            const gradient = input.value.trim();
            if (gradient) {
                const gradientId = this.setCustomGradient(eventType, gradient);
                onSelect(gradient, gradientId);
                closeGradientSelector();
            }
        };
        
        window.closeGradientSelector = () => {
            modal.remove();
            delete window.addCustomGradient;
            delete window.closeGradientSelector;
        };
        
        // 添加渐变选择事件
        modal.querySelectorAll('.gradient-item').forEach(item => {
            item.addEventListener('click', () => {
                const gradient = item.dataset.gradient.replace(/&quot;/g, '"');
                const gradientId = item.dataset.id;
                onSelect(gradient, gradientId);
                closeGradientSelector();
            });
            
            // 悬停效果
            item.addEventListener('mouseenter', () => {
                item.style.borderColor = '#2196F3';
            });
            
            item.addEventListener('mouseleave', () => {
                item.style.borderColor = 'transparent';
            });
        });
        
        // 点击背景关闭
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeGradientSelector();
            }
        });
    }
}

// 创建全局渐变管理器实例
window.gradientManager = new GradientBackgroundManager();

// ===== 状态球事件类型配置 =====

const STATUS_BALL_CONFIGS = {
    qixi: {
        name: '七夕节',
        emoji: '🌟',
        completedEmoji: '🎉',
        theme: {
            primary: '#e91e63',
            gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',  // 蓝紫渐变
            alternativeGradients: [
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',  // 粉红渐变
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',  // 蓝青渐变
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',  // 暖色渐变
                'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'   // 清新渐变
            ]
        },
        titles: {
            loading: '七夕节特殊准备中',
            processing: '七夕节祝福生成中',
            completed: '七夕节朋友圈生成完成'
        },
        descriptions: {
            loading: '我们正在准备应用',
            processing: '后台处理，不影响聊天',
            completed: '已为好友生成祝福'
        }
    },
    birthday: {
        name: '生日',
        emoji: '🎂',
        completedEmoji: '🎉',
        theme: {
            primary: '#ff9800',
            gradient: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)',  // 橙色渐变
            alternativeGradients: [
                'linear-gradient(135deg, #ff6b6b 0%, #feca57 100%)',  // 红橙渐变
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',  // 杏色渐变
                'linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%)',  // 粉橙渐变
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)'   // 温暖渐变
            ]
        },
        titles: {
            loading: '生日特殊准备中',
            processing: '生日祝福生成中',
            completed: '生日朋友圈生成完成'
        },
        descriptions: {
            loading: '我们正在准备生日内容',
            processing: '后台处理，不影响聊天',
            completed: '已为好友生成生日祝福'
        }
    },
    holiday: {
        name: '节日',
        emoji: '🎊',
        completedEmoji: '🎉',
        theme: {
            primary: '#4caf50',
            gradient: 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)',  // 绿色渐变
            alternativeGradients: [
                'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',  // 青绿渐变
                'linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%)',  // 薄荷渐变
                'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',  // 深蓝渐变
                'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)'   // 彩虹渐变
            ]
        },
        titles: {
            loading: '节日特殊准备中',
            processing: '节日祝福生成中',
            completed: '节日朋友圈生成完成'
        },
        descriptions: {
            loading: '我们正在准备节日内容',
            processing: '后台处理，不影响聊天',
            completed: '已为好友生成节日祝福'
        }
    },
    // 新增：春节特殊配置
    spring_festival: {
        name: '春节',
        emoji: '🧧',
        completedEmoji: '🎊',
        theme: {
            primary: '#d32f2f',
            gradient: 'linear-gradient(135deg, #d32f2f 0%, #f44336 50%, #ff9800 100%)',  // 红橙渐变
            alternativeGradients: [
                'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)',    // 红色渐变
                'linear-gradient(135deg, #f85032 0%, #e73827 100%)',  // 深红渐变
                'linear-gradient(135deg, #ff6b6b 0%, #ffd93d 100%)',  // 红黄渐变
                'linear-gradient(135deg, #e52d27 0%, #b31217 100%)'   // 暗红渐变
            ]
        },
        titles: {
            loading: '春节特殊准备中',
            processing: '春节祝福生成中',
            completed: '春节朋友圈生成完成'
        },
        descriptions: {
            loading: '我们正在准备春节内容',
            processing: '后台处理，不影响聊天',
            completed: '已为好友生成春节祝福'
        }
    },
    // 新增：中秋特殊配置
    mid_autumn: {
        name: '中秋节',
        emoji: '🌕',
        completedEmoji: '🥮',
        theme: {
            primary: '#ffc107',
            gradient: 'linear-gradient(135deg, #ffc107 0%, #ff9800 50%, #f57c00 100%)',  // 金黄渐变
            alternativeGradients: [
                'linear-gradient(135deg, #fff3a3 0%, #ffc107 100%)',  // 明黄渐变
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',  // 月光渐变
                'linear-gradient(135deg, #434343 0%, #000000 100%)',  // 夜空渐变
                'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)'   // 深夜渐变
            ]
        },
        titles: {
            loading: '中秋节特殊准备中',
            processing: '中秋祝福生成中',
            completed: '中秋节朋友圈生成完成'
        },
        descriptions: {
            loading: '我们正在准备中秋内容',
            processing: '后台处理，不影响聊天',
            completed: '已为好友生成中秋祝福'
        }
    }
};

// ===== 通用状态球管理系统 =====

/**
 * 状态球管理器 - 统一管理所有类型的悬浮球状态
 */
class StatusBallManager {
    constructor() {
        this.activeStates = new Map(); // 当前活跃的状态
        this.currentState = null;      // 当前显示的状态
        this.stateConfigs = new Map(); // 状态配置
        this.priorityOrder = ['api_queue', 'special_event', 'system']; // 状态优先级
        
        // 初始化状态配置
        this.initializeStateConfigs();
        
        // 监听API队列变化
        this.startMonitoringAPIQueue();
    }
    
    /**
     * 初始化各种状态的配置
     */
    initializeStateConfigs() {
        // API队列状态配置
        this.stateConfigs.set('api_queue', {
            name: 'API队列',
            emoji: '✨',
            completedEmoji: '✅',
            theme: {
                primary: '#2196F3',
                gradient: 'linear-gradient(135deg, #42A5F5 0%, #1976D2 100%)'
            },
            titles: {
                loading: 'API队列处理中',
                processing: 'API请求处理中',
                completed: 'API队列处理完成'
            },
            descriptions: {
                loading: '正在处理API请求',
                processing: '后台处理，不影响使用',
                completed: '所有API请求已处理完成'
            },
            priority: 1 // 最高优先级
        });
        
        // 特殊事件状态配置（继承原有的配置，并使用自定义渐变）
        Object.keys(STATUS_BALL_CONFIGS).forEach(eventType => {
            const baseConfig = STATUS_BALL_CONFIGS[eventType];
            const customGradient = window.gradientManager ? 
                window.gradientManager.getGradient(eventType) : 
                baseConfig.theme.gradient;
                
            this.stateConfigs.set(`special_event_${eventType}`, {
                ...baseConfig,
                type: 'special_event',
                priority: 2,
                theme: {
                    ...baseConfig.theme,
                    gradient: customGradient
                }
            });
        });
        
        // 系统状态配置
        this.stateConfigs.set('system', {
            name: '系统',
            emoji: '🔧',
            completedEmoji: '✅',
            theme: {
                primary: '#607D8B',
                gradient: 'linear-gradient(135deg, #78909C 0%, #455A64 100%)'
            },
            titles: {
                loading: '系统处理中',
                processing: '后台任务执行中',
                completed: '系统任务完成'
            },
            descriptions: {
                loading: '正在执行系统任务',
                processing: '后台处理，不影响使用',
                completed: '系统任务已完成'
            },
            priority: 3
        });
    }
    
    /**
     * 开始监控API队列状态
     */
    startMonitoringAPIQueue() {
        // 每秒检查一次API队列状态
        setInterval(() => {
            this.updateAPIQueueStatus();
        }, 1000);
        
        // 初始检查
        this.updateAPIQueueStatus();
    }
    
    /**
     * 更新API队列状态
     */
    updateAPIQueueStatus() {
        if (!window.apiRequestQueue) return;
        
        const status = window.apiRequestQueue.getStatus();
        const hasActiveQueue = status.queueLength >= 2 || (status.isProcessing && status.queueLength >= 1);
        
        if (hasActiveQueue) {
            // 计算进度
            const totalTasks = status.queueLength + (status.currentRequest ? 1 : 0);
            const completedTasks = status.currentRequest ? 1 : 0;
            
            const queueState = {
                type: 'api_queue',
                completedTasks: completedTasks,
                totalTasks: totalTasks,
                currentRequest: status.currentRequest,
                queueLength: status.queueLength,
                isProcessing: status.isProcessing,
                config: this.stateConfigs.get('api_queue')
            };
            
            this.updateState('api_queue', queueState);
        } else {
            this.removeState('api_queue');
        }
    }
    
    /**
     * 显示特殊事件状态
     */
    showSpecialEvent(eventType, queueState) {
        const stateKey = `special_event_${eventType}`;
        const enhancedQueueState = {
            ...queueState,
            type: 'special_event',
            eventType: eventType
        };
        
        this.updateState(stateKey, enhancedQueueState);
    }
    
    /**
     * 更新状态
     */
    updateState(stateKey, stateData) {
        this.activeStates.set(stateKey, stateData);
        
        // 检查是否需要切换显示的状态
        this.checkAndSwitchState();
    }
    
    /**
     * 移除状态
     */
    removeState(stateKey) {
        this.activeStates.delete(stateKey);
        
        // 如果移除的是当前显示的状态，切换到下一个状态
        if (this.currentState === stateKey) {
            this.currentState = null;
            this.checkAndSwitchState();
        }
    }
    
    /**
     * 检查并切换到最高优先级的状态
     */
    checkAndSwitchState() {
        if (this.activeStates.size === 0) {
            // 没有活跃状态，隐藏悬浮窗
            this.hideStatusBall();
            return;
        }
        
        // 找到最高优先级的活跃状态
        let highestPriorityState = null;
        let highestPriority = Infinity;
        
        for (const [stateKey, state] of this.activeStates) {
            const config = this.stateConfigs.get(stateKey);
            if (config && config.priority < highestPriority) {
                highestPriority = config.priority;
                highestPriorityState = stateKey;
            }
        }
        
        // 如果需要切换状态
        if (highestPriorityState && highestPriorityState !== this.currentState) {
            this.switchToState(highestPriorityState);
        } else if (this.currentState) {
            // 更新当前状态
            this.updateCurrentState();
        }
    }
    
    /**
     * 切换到指定状态
     */
    switchToState(stateKey) {
        const state = this.activeStates.get(stateKey);
        if (!state) return;
        
        this.currentState = stateKey;
        
        if (state.type === 'api_queue') {
            this.showAPIQueueStatus(state);
        } else if (state.type === 'special_event') {
            this.showSpecialEventStatus(state);
        }
    }
    
    /**
     * 显示API队列状态
     */
    showAPIQueueStatus(queueState) {
        if (window.statusBallWindowState && window.statusBallWindowState.type === 'api_queue') {
            // 更新现有悬浮窗
            this.updateAPIQueueFloatingWindow(queueState);
        } else {
            // 创建新的悬浮窗
            this.createAPIQueueFloatingWindow(queueState);
        }
    }
    
    /**
     * 创建API队列悬浮窗
     */
    createAPIQueueFloatingWindow(queueState) {
        // 先移除可能已存在的悬浮窗
        hideStatusBallFloatingWindow();
        
        const config = queueState.config;
        
        // 创建容器
        const container = document.createElement('div');
        container.id = 'statusBallFloatingContainer';
        container.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;
        
        // 创建详情窗口
        const detailWindow = document.createElement('div');
        detailWindow.id = 'statusBallDetailWindow';
        detailWindow.style.cssText = `
            width: 300px;
            background: ${config.theme.gradient};
            color: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: block;
        `;
        
        detailWindow.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 12px;">
                <div style="font-size: 18px;">${config.emoji}</div>
                <div style="flex: 1; margin-left: 8px;">
                    <div style="font-weight: bold; font-size: 14px;">${config.titles.processing}</div>
                    <div style="font-size: 11px; opacity: 0.8;">${config.descriptions.processing}</div>
                </div>
                <button onclick="window.statusBallManager.collapseCurrentWindow()" 
                        style="background: none; border: none; color: white; font-size: 16px; cursor: pointer; opacity: 0.7; padding: 2px 6px; border-radius: 3px;">
                    −
                </button>
            </div>
            
            <div id="statusBallInfo" style="font-size: 12px; margin-bottom: 8px; opacity: 0.9;">
                队列长度: ${queueState.queueLength} | 正在处理: ${queueState.isProcessing ? '是' : '否'}
            </div>
            
            <div id="statusBallCurrentRequest" style="font-size: 11px; margin-bottom: 8px; opacity: 0.8;">
                ${queueState.currentRequest ? `当前: ${queueState.currentRequest.description}` : '等待中...'}
            </div>
            
            <div style="background: rgba(255,255,255,0.2); height: 4px; border-radius: 2px; overflow: hidden;">
                <div id="statusBallProgressBar" 
                     style="height: 100%; background: rgba(255,255,255,0.8); transition: width 0.3s; width: 0%;"></div>
            </div>
            
            <div id="statusBallStatus" style="font-size: 11px; margin-top: 8px; opacity: 0.8;">
                监控API队列状态...
            </div>
        `;
        
        // 创建小球
        const floatingBall = document.createElement('div');
        floatingBall.id = 'statusBallFloatingBall';
        floatingBall.style.cssText = `
            width: 50px;
            height: 50px;
            background: ${config.theme.gradient};
            color: white;
            border-radius: 50%;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
            backdrop-filter: blur(10px);
        `;
        
        floatingBall.innerHTML = `
            <div style="position: relative;">
                ${config.emoji}
                <div id="statusBallBadge" style="
                    position: absolute;
                    top: -8px;
                    right: -8px;
                    background: #ff4757;
                    color: white;
                    border-radius: 10px;
                    padding: 1px 6px;
                    font-size: 10px;
                    font-weight: bold;
                    min-width: 16px;
                    text-align: center;
                    ${queueState.queueLength === 0 ? 'display: none;' : ''}
                ">${queueState.queueLength}</div>
            </div>
        `;
        
        // 添加到容器
        container.appendChild(detailWindow);
        container.appendChild(floatingBall);
        document.body.appendChild(container);
        
        // 添加功能
        makeDraggable(floatingBall, container);
        floatingBall.addEventListener('click', () => this.expandCurrentWindow());
        
        // 存储状态
        window.statusBallWindowState = {
            container,
            detailWindow,
            floatingBall,
            type: 'api_queue',
            state: queueState,
            isExpanded: true
        };
    }
    
    /**
     * 更新API队列悬浮窗
     */
    updateAPIQueueFloatingWindow(queueState) {
        if (!window.statusBallWindowState) return;
        
        const infoElement = document.getElementById('statusBallInfo');
        const currentRequestElement = document.getElementById('statusBallCurrentRequest');
        const statusElement = document.getElementById('statusBallStatus');
        const badge = document.getElementById('statusBallBadge');
        
        if (infoElement) {
            infoElement.textContent = `队列长度: ${queueState.queueLength} | 正在处理: ${queueState.isProcessing ? '是' : '否'}`;
        }
        
        if (currentRequestElement) {
            currentRequestElement.textContent = queueState.currentRequest 
                ? `当前: ${queueState.currentRequest.description}` 
                : '等待中...';
        }
        
        if (statusElement) {
            statusElement.textContent = queueState.isProcessing ? '正在处理请求...' : '监控API队列状态...';
        }
        
        if (badge) {
            badge.textContent = queueState.queueLength;
            badge.style.display = queueState.queueLength === 0 ? 'none' : 'block';
        }
        
        // 更新存储的状态
        window.statusBallWindowState.state = queueState;
    }
    
    /**
     * 显示特殊事件状态
     */
    showSpecialEventStatus(eventState) {
        // 复用现有的悬浮窗函数
        showStatusBallFloatingWindow(eventState);
        
        // 更新类型标记
        if (window.statusBallWindowState) {
            window.statusBallWindowState.type = 'special_event';
            window.statusBallWindowState.state = eventState;
        }
    }
    
    /**
     * 更新当前状态
     */
    updateCurrentState() {
        if (!this.currentState) return;
        
        const state = this.activeStates.get(this.currentState);
        if (!state) return;
        
        if (state.type === 'api_queue') {
            this.updateAPIQueueFloatingWindow(state);
        } else if (state.type === 'special_event') {
            updateStatusBallFloatingWindow(state);
        }
    }
    
    /**
     * 展开当前窗口
     */
    expandCurrentWindow() {
        if (!window.statusBallWindowState) return;
        
        const { detailWindow, floatingBall } = window.statusBallWindowState;
        
        detailWindow.style.display = 'block';
        floatingBall.style.display = 'none';
        window.statusBallWindowState.isExpanded = true;
        
        // 清除动画
        floatingBall.style.animation = '';
    }
    
    /**
     * 收起当前窗口
     */
    collapseCurrentWindow() {
        if (!window.statusBallWindowState) return;
        
        const { detailWindow, floatingBall } = window.statusBallWindowState;
        
        detailWindow.style.display = 'none';
        floatingBall.style.display = 'flex';
        window.statusBallWindowState.isExpanded = false;
        
        // 添加脉冲动画
        floatingBall.style.animation = 'statusBallPulse 2s ease-in-out 3';
    }
    
    /**
     * 隐藏状态球
     */
    hideStatusBall() {
        hideStatusBallFloatingWindow();
        this.currentState = null;
    }
    
    /**
     * 获取当前状态
     */
    getCurrentState() {
        return this.currentState ? this.activeStates.get(this.currentState) : null;
    }
    
    /**
     * 获取所有活跃状态
     */
    getActiveStates() {
        return Array.from(this.activeStates.values());
    }
}

// 创建全局状态球管理器实例
window.statusBallManager = new StatusBallManager();


/**
 * 开始特殊事件流程
 * @param {string} eventType - 事件类型 ('qixi', 'birthday', 'holiday' 等)
 */
async function startSpecialEventFlow(eventType = 'qixi') {
    try {
        const config = STATUS_BALL_CONFIGS[eventType];
        if (!config) {
            throw new Error(`未知的事件类型: ${eventType}`);
        }
        
        // 获取用户资料和联系人信息
        const userProfile = await getUserProfile();
        if (!userProfile || !userProfile.name) {
            throw new Error('无法获取用户资料');
        }
        
        const contactsInfo = await getAllContactsInfo();
        if (!contactsInfo || contactsInfo.length === 0) {
            throw new Error('没有找到任何联系人');
        }
        
        // 锁定朋友圈操作
        window.momentsLockManager.lock(`发布朋友圈功能暂时被锁定：${config.name}`);
        
        // 显示初始加载弹窗
        showStatusBallLoadingModal(config);
        updateStatusBallProgress(0, 1, '等待AI响应', config);
        
        // 第一步：添加获取祝福人员列表的请求到队列
        const queueState = {
            completedTasks: 0,
            totalTasks: 1, // 初始只有1个任务（获取列表）
            blessers: [],
            eventType: eventType,
            config: config
        };
        
        const getBlessersRequestId = await window.apiRequestQueue.addRequest(
            () => getBlessersFromAI(contactsInfo, userProfile, eventType),
            {
                priority: window.apiRequestQueue.PRIORITY.LOW,
                description: `获取${config.name}祝福人员列表`,
                onComplete: (requestId, blessers) => {
                    console.log('获取到祝福人员列表:', blessers);
                    queueState.blessers = blessers;
                    queueState.totalTasks = blessers.length + 1;
                    queueState.completedTasks = 1;
                    
                    // 转换为悬浮窗
                    hideStatusBallLoadingModal();
                    // 使用状态球管理器显示特殊事件
                    window.statusBallManager.showSpecialEvent(eventType, queueState);
                    
                    // 添加生成朋友圈的请求
                    addEventMomentsToQueue(blessers, contactsInfo, userProfile, queueState);
                },
                onError: (requestId, error) => {
                    console.error('获取祝福人员失败:', error);
                    hideStatusBallLoadingModal();
                    window.momentsLockManager.unlock(); // 出错时解锁
                    showApiError(error);
                }
            }
        );
        
    } catch (error) {
        console.error(`${eventType}流程启动失败:`, error);
        hideStatusBallLoadingModal();
        window.momentsLockManager.unlock(); // 出错时解锁
        const config = STATUS_BALL_CONFIGS[eventType] || STATUS_BALL_CONFIGS.qixi;
        showApiError(error);
    }
}

// 暴露特殊事件流程函数到全局
window.startSpecialEventFlow = startSpecialEventFlow;

/**
 * 显示状态球加载弹窗
 * @param {Object} config - 事件配置
 */
function showStatusBallLoadingModal(config) {
    const modal = document.createElement('div');
    modal.id = 'statusBallLoadingModal';
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content" style="text-align: center; padding: 30px;">
            <h3 style="color: ${config.theme.primary}; margin-bottom: 20px;">${config.emoji} ${config.titles.loading} ${config.emoji}</h3>
            <p style="margin-bottom: 20px;">请稍等。<br>${config.descriptions.loading}。<br>正在等待API响应……</p>
            <div id="statusBallProgress" style="margin-bottom: 15px; font-weight: bold; color: ${config.theme.primary};">(0/1)</div>
            <div style="width: 100%; height: 4px; background-color: #f0f0f0; border-radius: 2px; overflow: hidden;">
                <div id="statusBallProgressBar" style="width: 0%; height: 100%; background-color: ${config.theme.primary}; transition: width 0.3s;"></div>
            </div>
            <p style="margin-top: 15px; font-size: 12px; color: #666;">请不要关闭应用</p>
        </div>
    `;
    document.body.appendChild(modal);
    modal.style.display = 'block';
}

/**
 * 更新状态球进度
 * @param {number} current - 当前进度
 * @param {number} total - 总进度
 * @param {string} message - 进度消息
 * @param {Object} config - 事件配置
 */
function updateStatusBallProgress(current, total, message = '', config) {
    const progressElement = document.getElementById('statusBallProgress');
    const progressBar = document.getElementById('statusBallProgressBar');
    
    if (progressElement && progressBar) {
        const percentage = Math.round((current / total) * 100);
        progressElement.textContent = `(${current}/${total}) ${message}`;
        progressBar.style.width = percentage + '%';
    }
}

/**
 * 隐藏状态球加载弹窗
 */
function hideStatusBallLoadingModal() {
    const modal = document.getElementById('statusBallLoadingModal');
    if (modal) {
        modal.remove();
    }
}

/**
 * 显示七夕节完成弹窗
 */
function showQixiCompleteModal() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content" style="text-align: center; padding: 30px;">
            <h3 style="color: #e91e63; margin-bottom: 20px;">🎉 欢迎 🎉</h3>
            <p style="margin-bottom: 20px;">朋友圈 更新了一些新内容~</p>
            <button onclick="this.parentElement.parentElement.remove()" 
                    style="background-color: #e91e63; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                查看朋友圈
            </button>
        </div>
    `;
    document.body.appendChild(modal);
    modal.style.display = 'block';
    
    // 3秒后自动关闭
    setTimeout(() => {
        modal.remove();
    }, 3000);
}

/**
 * 获取所有联系人信息
 */
async function getAllContactsInfo() {
    try {
        // 确保contacts已加载
        if (!window.contacts || window.contacts.length === 0) {
            console.warn('联系人列表为空，尝试从数据库重新加载');
            await loadDataFromDB();
        }
        
        return window.contacts.filter(contact => contact.type === 'private');
    } catch (error) {
        console.error('获取联系人信息失败:', error);
        throw error;
    }
}

/**
 * 通过AI判断可能送祝福的人员
 * @param {Array} contactsInfo - 联系人信息
 * @param {Object} userProfile - 用户资料
 * @param {string} eventType - 事件类型
 */
async function getBlessersFromAI(contactsInfo, userProfile, eventType = 'qixi') {
    try {
        if (!window.apiService || !apiSettings) {
            throw new Error('API服务未初始化');
        }
        
        // 构建联系人信息字符串
        const contactsString = contactsInfo.map(contact => 
            `【${contact.name}】人设为：${contact.personality}`
        ).join('\n');
        
        // 获取事件配置
        const config = STATUS_BALL_CONFIGS[eventType];
        const eventName = config ? config.name : '特殊日子';
        
        // 根据事件类型构建不同的prompt
        let eventDescription = '';
        switch (eventType) {
            case 'qixi':
                eventDescription = '今天是中国传统节日【七夕节】';
                break;
            case 'birthday':
                eventDescription = `今天是用户【${userProfile.name}】的生日`;
                break;
            case 'holiday':
                eventDescription = '今天是特殊节日';
                break;
            default:
                eventDescription = '今天是特殊日子';
        }
        
        // 构建请求prompt
        const prompt = `${eventDescription}。请判断以下人物中，可能在${eventName}给用户（${userProfile.name}）送上祝福的有谁？输出所有可能的人名为列表，如["A", "B"]。

${contactsString}

用户${userProfile.name}的人设为：${userProfile.personality || '无'}

请直接返回JSON格式的列表，列表内的名字必须为【】内的用户名。不要包含其他解释。`;

        // 使用新的API调用信息接口获取连接和模型信息
        let apiCallInfo;
        try {
            apiCallInfo = await getApiCallInfo();
        } catch (error) {
            showToast('请先设置API和模型');
            throw new Error('API或模型未配置');
        }

        // 调用API
        const response = await window.apiService.callOpenAIAPI(
            apiCallInfo.url,
            apiCallInfo.key,
            apiCallInfo.model,
            [{ role: 'user', content: prompt }],
            {
                temperature: 0.7,
                max_tokens: 5000,
            },
            (apiCallInfo.timeout || 60) * 1000
        );
        
        const rawContent = response.choices[0]?.message?.content;
        console.log('AI返回的原始内容:', rawContent);
        
        if (!rawContent) {
            console.error('ERROR: AI返回的内容为空 - API完整返回:', JSON.stringify(response, null, 2));
            throw new Error('AI返回空内容');
        }
        
        // 提取人名列表
        let blessers = [];
        try {
            // 尝试直接解析JSON
            const match = rawContent.match(/\[.*?\]/);
            if (match) {
                blessers = JSON.parse(match[0]);
            } else {
                // 如果没有找到JSON数组，尝试提取引号中的名字
                const names = rawContent.match(/"([^"]+)"/g);
                if (names) {
                    blessers = names.map(name => name.replace(/"/g, ''));
                }
            }
        } catch (parseError) {
            console.warn('解析AI回复失败，尝试正则提取:', parseError);
            // 使用正则表达式提取可能的人名
            const names = rawContent.match(/["']([^"']+)["']/g);
            if (names) {
                blessers = names.map(name => name.replace(/["']/g, ''));
            }
        }
        
        // 验证人名是否存在于联系人中
        const validBlessers = blessers.filter(name => 
            contactsInfo.some(contact => contact.name === name)
        );
        
        console.log('有效的祝福人员:', validBlessers);
        return validBlessers;
        
    } catch (error) {
        console.error('AI判断祝福人员失败:', error);
        throw error;
    }
}

/**
 * 为指定联系人生成特殊事件朋友圈
 * @param {Object} contact - 联系人信息
 * @param {Object} userProfile - 用户资料
 * @param {string} eventType - 事件类型
 */
async function generateEventMoment(contact, userProfile, eventType = 'qixi') {
    try {
        const config = STATUS_BALL_CONFIGS[eventType];
        const eventName = config ? config.name : '特殊日子';
        const topic = `${eventName}给${userProfile.name}的祝福`;
        
        // 调用现有的朋友圈生成函数
        const result = await generateMomentAndComments(contact, userProfile, topic);
        
        if (result && result.content) {
            console.log(`成功为 ${contact.name} 生成${eventName}朋友圈:`, result.content);
            
            // 生成事件日期
            const eventDate = new Date();
            
            // 根据事件类型设置日期
            if (eventType === 'qixi') {
                eventDate.setMonth(7); // 8月（月份从0开始）
                eventDate.setDate(29);
            } else if (eventType === 'birthday') {
                // 生日保持当前日期
            } else {
                // 其他节日保持当前日期
            }
            
            eventDate.setHours(0, 0, 0, 0); // 零点整
            
            // 只随机化秒数，保持都在零点零分
            const randomSeconds = Math.floor(Math.random() * 60); // 0-59秒
            eventDate.setSeconds(randomSeconds);
            
            // 保存朋友圈到数据库
            const moment = {
                id: generateId(),
                authorId: contact.id,
                authorName: contact.name,
                content: result.content,
                imageUrl: null, // 暂时不处理图片
                likes: [],
                comments: result.comments || [], // 稍后处理评论时间
                timestamp: eventDate.toISOString(),
                time: eventDate.toISOString(), // 添加time字段，朋友圈渲染需要这个
                topic: topic // 添加主题标记
            };
            
            // 修正评论的时间戳也为事件当天零点
            if (moment.comments && moment.comments.length > 0) {
                moment.comments.forEach((comment, index) => {
                    // 给每个评论一个稍晚的时间（在朋友圈发布后的几秒内）
                    const commentTime = new Date(eventDate);
                    commentTime.setSeconds(commentTime.getSeconds() + 10 + index * 5); // 朋友圈发布后10秒开始，每个评论间隔5秒
                    comment.timestamp = commentTime.toISOString();
                });
            }
            
            // 添加到全局朋友圈列表
            console.log(`当前朋友圈数量: ${moments.length}`);
            moments.unshift(moment);
            console.log(`添加后朋友圈数量: ${moments.length}`);
            console.log(`新添加的朋友圈:`, { 
                id: moment.id, 
                authorName: moment.authorName, 
                content: moment.content.substring(0, 50) + '...' 
            });
            
            // 保存到数据库
            await saveDataToDB();
            console.log('朋友圈已保存到数据库');
            
            console.log(`${eventName}朋友圈已保存到数据库: ${contact.name}`);
            return result;
        } else {
            throw new Error('生成的朋友圈内容为空');
        }
    } catch (error) {
        console.error(`为 ${contact.name} 生成${eventName}朋友圈失败:`, error);
        throw error;
    }
}

/**
 * 将特殊事件朋友圈生成请求添加到队列
 */
async function addEventMomentsToQueue(blessers, contactsInfo, userProfile, queueState) {
    for (const blesserName of blessers) {
        const contact = contactsInfo.find(c => c.name === blesserName);
        if (contact) {
            await window.apiRequestQueue.addRequest(
                () => generateEventMoment(contact, userProfile, queueState.eventType),
                {
                    priority: window.apiRequestQueue.PRIORITY.LOW,
                    description: `生成${blesserName}的${queueState.config.name}祝福朋友圈`,
                    onProgress: (requestId, status) => {
                        // 确保使用七夕渐变
                        if (queueState.eventType === 'qixi' && window.statusBallWindowState) {
                            const { detailWindow } = window.statusBallWindowState;
                            if (detailWindow) {
                                // 强制应用七夕渐变
                                detailWindow.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                            }
                        }
                        updateStatusBallFloatingWindow(queueState, `正在为 ${blesserName} 生成祝福...`);
                    },
                    onComplete: (requestId, result) => {
                        queueState.completedTasks++;
                        updateStatusBallFloatingWindow(queueState, `已完成 ${blesserName} 的祝福`);
                        
                        // 如果所有任务都完成了，显示完成提示
                        if (queueState.completedTasks >= queueState.totalTasks) {
                            setTimeout(() => {
                                // 解锁朋友圈操作
                                window.momentsLockManager.unlock();
                                
                                // 显示完成状态
                                showStatusBallCompletionState(queueState);
                                // 通知状态球管理器任务完成
                                if (queueState.eventType && window.statusBallManager) {
                                    // 特殊事件完成后自动移除状态，让API队列状态（如果有）可以显示
                                    setTimeout(() => {
                                        window.statusBallManager.removeState(`special_event_${queueState.eventType}`);
                                    }, 3000); // 3秒后自动移除
                                }
                            }, 1000);
                        }
                    },
                    onError: (requestId, error) => {
                        console.error(`为 ${blesserName} 生成朋友圈失败:`, error);
                        queueState.completedTasks++;
                        updateStatusBallFloatingWindow(queueState, `${blesserName} 生成失败`);
                    }
                }
            );
        }
    }
}

/**
 * 显示状态球悬浮窗
 */
function showStatusBallFloatingWindow(queueState) {
    // 先移除可能已存在的悬浮窗
    hideStatusBallFloatingWindow();
    
    // 创建容器
    const container = document.createElement('div');
    container.id = 'statusBallFloatingContainer';
    container.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    
    // 获取事件配置
    const config = queueState.config;
    
    // 创建详情窗口（默认显示）
    const detailWindow = document.createElement('div');
    detailWindow.id = 'statusBallDetailWindow';
    
    // 获取渐变样式
    const gradientStyle = queueState.eventType === 'qixi' 
        ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'  // 强制使用七夕蓝紫渐变
        : config.theme.gradient;
    
    console.log(`显示悬浮窗，事件类型: ${queueState.eventType}, 使用渐变: ${gradientStyle}`);
    
    detailWindow.style.cssText = `
        width: 280px;
        background: ${gradientStyle};
        color: white;
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        display: block;
    `;
    
    detailWindow.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 12px;">
            <div style="font-size: 18px;">${config.emoji}</div>
            <div style="flex: 1; margin-left: 8px;">
                <div style="font-weight: bold; font-size: 14px;">${config.titles.processing}</div>
                <div style="font-size: 11px; opacity: 0.8;">${config.descriptions.processing}</div>
            </div>
            <button onclick="collapseStatusBallWindow()" 
                    style="background: none; border: none; color: white; font-size: 16px; cursor: pointer; opacity: 0.7; padding: 2px 6px; border-radius: 3px;">
                −
            </button>
        </div>
        
        <div id="statusBallFloatingProgress" style="font-size: 12px; margin-bottom: 8px; opacity: 0.9;">
            (${queueState.completedTasks}/${queueState.totalTasks}) 正在处理...
        </div>
        
        <div style="background: rgba(255,255,255,0.2); height: 4px; border-radius: 2px; overflow: hidden;">
            <div id="statusBallFloatingProgressBar" 
                 style="height: 100%; background: rgba(255,255,255,0.8); transition: width 0.3s; width: ${Math.round((queueState.completedTasks / queueState.totalTasks) * 100)}%;"></div>
        </div>
        
        <div id="statusBallFloatingStatus" style="font-size: 11px; margin-top: 8px; opacity: 0.8;">
            正在生成朋友圈...
        </div>
    `;
    
    // 创建小球（默认隐藏）
    const floatingBall = document.createElement('div');
    floatingBall.id = 'statusBallFloatingBall';
    
    // 使用相同的渐变样式
    floatingBall.style.cssText = `
        width: 50px;
        height: 50px;
        background: ${gradientStyle};
        color: white;
        border-radius: 50%;
        box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        cursor: pointer;
        user-select: none;
        transition: all 0.3s ease;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        position: relative;
        backdrop-filter: blur(10px);
    `;
    
    floatingBall.innerHTML = `
        <div style="position: relative;">
            ${config.emoji}
            <div id="statusBallBadge" style="
                position: absolute;
                top: -8px;
                right: -8px;
                background: #ff4757;
                color: white;
                border-radius: 10px;
                padding: 1px 6px;
                font-size: 10px;
                font-weight: bold;
                min-width: 16px;
                text-align: center;
            ">${queueState.totalTasks - queueState.completedTasks}</div>
        </div>
    `;
    
    // 添加到容器
    container.appendChild(detailWindow);
    container.appendChild(floatingBall);
    document.body.appendChild(container);
    
    // 添加小球的拖拽功能
    makeDraggable(floatingBall, container);
    
    // 添加小球点击展开功能
    floatingBall.addEventListener('click', expandStatusBallWindow);
    
    // 存储状态
    window.statusBallWindowState = {
        container,
        detailWindow,
        floatingBall,
        queueState,
        isExpanded: true
    };
}

/**
 * 更新状态球悬浮窗
 */
function updateStatusBallFloatingWindow(queueState, message = '') {
    const progressElement = document.getElementById('statusBallFloatingProgress');
    const progressBar = document.getElementById('statusBallFloatingProgressBar');
    const statusElement = document.getElementById('statusBallFloatingStatus');
    const badge = document.getElementById('statusBallBadge');
    
    if (progressElement && progressBar && statusElement) {
        const percentage = Math.round((queueState.completedTasks / queueState.totalTasks) * 100);
        progressElement.textContent = `(${queueState.completedTasks}/${queueState.totalTasks}) 正在处理...`;
        progressBar.style.width = percentage + '%';
        statusElement.textContent = message || '正在生成朋友圈...';
    }
    
    // 更新小球上的徽章数字
    if (badge) {
        const remaining = queueState.totalTasks - queueState.completedTasks;
        badge.textContent = remaining;
        if (remaining === 0) {
            badge.style.display = 'none';
        }
    }
    
    // 更新全局状态
    if (window.statusBallWindowState) {
        window.statusBallWindowState.queueState = queueState;
    }
}

/**
 * 隐藏状态球悬浮窗
 */
function hideStatusBallFloatingWindow() {
    const container = document.getElementById('statusBallFloatingContainer');
    if (container) {
        container.remove();
    }
    window.statusBallWindowState = null;
}

/**
 * 收起悬浮窗，显示小球
 */
function collapseStatusBallWindow() {
    if (!window.statusBallWindowState) return;
    
    const { detailWindow, floatingBall } = window.statusBallWindowState;
    
    // 隐藏详情窗口，显示小球
    detailWindow.style.display = 'none';
    floatingBall.style.display = 'flex';
    
    window.statusBallWindowState.isExpanded = false;
    
    // 添加小球闪烁效果提示用户
    floatingBall.style.animation = 'statusBallPulse 2s ease-in-out 3';
    
    // 添加CSS动画
    if (!document.getElementById('statusBallAnimations')) {
        const style = document.createElement('style');
        style.id = 'statusBallAnimations';
        style.textContent = `
            @keyframes statusBallPulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
            }
        `;
        document.head.appendChild(style);
    }
}

/**
 * 展开悬浮窗，隐藏小球
 */
function expandStatusBallWindow() {
    if (!window.statusBallWindowState) return;
    
    const { container, detailWindow, floatingBall } = window.statusBallWindowState;
    
    // 在展开前调整容器位置，确保详情窗口在屏幕内
    adjustContainerPosition(container, detailWindow);
    
    // 显示详情窗口，隐藏小球
    floatingBall.style.display = 'none';
    detailWindow.style.display = 'block';
    
    window.statusBallWindowState.isExpanded = true;
    
    // 清除小球动画
    floatingBall.style.animation = '';
}

/**
 * 调整容器位置，确保详情窗口在屏幕内
 */
function adjustContainerPosition(container, detailWindow) {
    // 获取当前容器位置
    const containerRect = container.getBoundingClientRect();
    
    // 获取窗口尺寸
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // 获取详情窗口的实际尺寸
    // 暂时显示详情窗口以获取准确尺寸
    const wasVisible = detailWindow.style.display !== 'none';
    if (!wasVisible) {
        detailWindow.style.display = 'block';
        detailWindow.style.visibility = 'hidden'; // 隐藏但占用空间
    }
    
    const detailRect = detailWindow.getBoundingClientRect();
    const detailWindowWidth = detailRect.width || 280;
    const detailWindowHeight = detailRect.height || 200;
    
    // 恢复原始显示状态
    if (!wasVisible) {
        detailWindow.style.display = 'none';
        detailWindow.style.visibility = 'visible';
    }
    
    // 安全边距
    const safeMargin = 20;
    
    // 计算当前容器位置
    let currentLeft = containerRect.left;
    let currentTop = containerRect.top;
    
    // 记录是否进行了调整
    let adjusted = false;
    
    // 检查并调整水平位置
    if (currentLeft + detailWindowWidth + safeMargin > windowWidth) {
        // 如果右边超出，向左调整
        currentLeft = windowWidth - detailWindowWidth - safeMargin;
        adjusted = true;
    }
    if (currentLeft < safeMargin) {
        // 如果左边超出，向右调整
        currentLeft = safeMargin;
        adjusted = true;
    }
    
    // 检查并调整垂直位置
    if (currentTop + detailWindowHeight + safeMargin > windowHeight) {
        // 如果下边超出，向上调整
        currentTop = windowHeight - detailWindowHeight - safeMargin;
        adjusted = true;
    }
    if (currentTop < safeMargin) {
        // 如果上边超出，向下调整
        currentTop = safeMargin;
        adjusted = true;
    }
    
    // 只在需要调整时应用新位置
    if (adjusted) {
        container.style.left = currentLeft + 'px';
        container.style.top = currentTop + 'px';
        container.style.right = 'auto';
        container.style.bottom = 'auto';
        
        console.log(`[悬浮窗] 位置调整: (${Math.round(containerRect.left)}, ${Math.round(containerRect.top)}) -> (${Math.round(currentLeft)}, ${Math.round(currentTop)})`);
    } else {
        console.log(`[悬浮窗] 位置无需调整: (${Math.round(containerRect.left)}, ${Math.round(containerRect.top)})`);
    }
}

/**
 * 计算智能边界限制
 */
function calculateSmartBounds(proposedLeft, proposedTop, container) {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // 详情窗口尺寸
    const detailWindowWidth = 280;
    const detailWindowHeight = 200;
    
    // 小球尺寸
    const ballSize = 50;
    
    // 安全边距
    const safeMargin = 20;
    
    let newLeft = proposedLeft;
    let newTop = proposedTop;
    
    // 水平边界检查
    // 确保小球本身不超出屏幕
    newLeft = Math.max(safeMargin, newLeft);
    newLeft = Math.min(windowWidth - ballSize - safeMargin, newLeft);
    
    // 额外检查：确保从任意位置都能展开详情窗口
    // 如果小球在屏幕右边缘，但详情窗口无法完全显示，则限制小球位置
    const maxLeftForExpansion = windowWidth - detailWindowWidth - safeMargin;
    if (newLeft > maxLeftForExpansion) {
        // 小球可以在右边缘，但展开时会自动调整位置
        // 这里不强制限制，让智能定位函数处理
    }
    
    // 垂直边界检查
    newTop = Math.max(safeMargin, newTop);
    newTop = Math.min(windowHeight - ballSize - safeMargin, newTop);
    
    // 额外检查：确保从任意位置都能展开详情窗口
    const maxTopForExpansion = windowHeight - detailWindowHeight - safeMargin;
    if (newTop > maxTopForExpansion) {
        // 同样，让智能定位函数处理
    }
    
    return { newLeft, newTop };
}

/**
 * 使元素可拖拽
 */
function makeDraggable(element, container) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    let hasMoved = false;
    
    function onMouseDown(e) {
        isDragging = true;
        hasMoved = false;
        
        const rect = container.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        startLeft = rect.left;
        startTop = rect.top;
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        
        e.preventDefault();
    }
    
    function onMouseMove(e) {
        if (!isDragging) return;
        
        hasMoved = true;
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newLeft = startLeft + deltaX;
        let newTop = startTop + deltaY;
        
        // 智能边界限制，考虑详情窗口展开的空间需求
        const { newLeft: adjustedLeft, newTop: adjustedTop } = calculateSmartBounds(newLeft, newTop, container);
        
        container.style.left = adjustedLeft + 'px';
        container.style.top = adjustedTop + 'px';
        container.style.right = 'auto';
        container.style.bottom = 'auto';
    }
    
    function onMouseUp(e) {
        isDragging = false;
        
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        
        // 如果没有移动，则触发点击事件
        if (!hasMoved) {
            expandStatusBallWindow();
        }
    }
    
    // 触摸事件支持
    function onTouchStart(e) {
        const touch = e.touches[0];
        onMouseDown({
            clientX: touch.clientX,
            clientY: touch.clientY,
            preventDefault: () => e.preventDefault()
        });
    }
    
    function onTouchMove(e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        onMouseMove({
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        e.preventDefault();
    }
    
    function onTouchEnd(e) {
        onMouseUp({});
        e.preventDefault();
    }
    
    // 绑定事件
    element.addEventListener('mousedown', onMouseDown);
    element.addEventListener('touchstart', onTouchStart, { passive: false });
    element.addEventListener('touchmove', onTouchMove, { passive: false });
    element.addEventListener('touchend', onTouchEnd, { passive: false });
}

/**
 * 显示状态球完成状态
 */
function showStatusBallCompletionState(queueState) {
    if (!window.statusBallWindowState) return;
    
    const { detailWindow, floatingBall } = window.statusBallWindowState;
    const config = queueState.config;
    
    // 更新详情窗口内容为完成状态
    detailWindow.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 15px;">
            <div style="font-size: 24px;">${config.completedEmoji}</div>
            <div style="flex: 1; margin-left: 8px;">
                <div style="font-weight: bold; font-size: 14px;">${config.titles.completed}</div>
                <div style="font-size: 11px; opacity: 0.8;">${config.descriptions.completed} ${queueState.totalTasks - 1} 位好友</div>
            </div>
            <button onclick="hideStatusBallFloatingWindow()" 
                    style="background: none; border: none; color: white; font-size: 16px; cursor: pointer; opacity: 0.7; padding: 2px 6px; border-radius: 3px;">
                ×
            </button>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <div style="font-size: 14px; margin-bottom: 15px; line-height: 1.4;">
                所有朋友圈已生成完毕<br>
                是否刷新页面查看新内容？
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="refreshMomentsPage()" 
                        style="background: rgba(255,255,255,0.9); color: ${config.theme.primary}; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                    刷新页面
                </button>
                <button onclick="collapseStatusBallWindow()" 
                        style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px;">
                    稍后查看
                </button>
            </div>
        </div>
    `;
    
    // 如果当前是收起状态，则展开显示完成信息
    if (!window.statusBallWindowState.isExpanded) {
        // 在展开前调整位置，确保完成界面完全可见
        adjustContainerPosition(window.statusBallWindowState.container, detailWindow);
        
        // 显示详情窗口，隐藏小球
        window.statusBallWindowState.floatingBall.style.display = 'none';
        detailWindow.style.display = 'block';
        window.statusBallWindowState.isExpanded = true;
    }
    
    // 添加完成动画
    detailWindow.style.animation = 'statusBallComplete 0.5s ease-out';
    
    // 更新小球为完成状态
    floatingBall.innerHTML = `
        <div style="position: relative;">
            ${config.completedEmoji}
        </div>
    `;
    
    // 添加CSS动画
    if (!document.getElementById('statusBallCompleteAnimations')) {
        const style = document.createElement('style');
        style.id = 'statusBallCompleteAnimations';
        style.textContent = `
            @keyframes statusBallComplete {
                0% { transform: scale(0.9); opacity: 0.8; }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
    }
}

/**
 * 刷新朋友圈页面
 */
async function refreshMomentsPage() {
    try {
        console.log('[特殊事件] 开始刷新朋友圈页面');
        
        // 显示加载提示
        if (window.statusBallWindowState && window.statusBallWindowState.detailWindow) {
            const detailWindow = window.statusBallWindowState.detailWindow;
            detailWindow.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 20px; margin-bottom: 10px;">🔄</div>
                    <div style="font-size: 14px;">正在刷新朋友圈...</div>
                </div>
            `;
        }
        
        // 重新从数据库加载数据
        await loadDataFromDB();
        
        // 如果当前在朋友圈页面，刷新显示
        if (typeof renderMomentsList === 'function') {
            await renderMomentsList();
        }
        
        // 显示成功提示并关闭悬浮窗
        showToast('朋友圈已刷新完成！');
        setTimeout(() => {
            hideQixiFloatingWindow();
        }, 1500);
        
        console.log('[特殊事件] 朋友圈页面刷新完成');
        
    } catch (error) {
        console.error('[七夕节] 刷新朋友圈页面失败:', error);
        showToast('刷新失败，请手动刷新页面');
    }
}

// 将函数设为全局可访问
// 向后兼容的别名（如果需要的话）
window.hideQixiFloatingWindow = hideStatusBallFloatingWindow;
window.collapseQixiWindow = collapseStatusBallWindow;
window.expandQixiWindow = expandStatusBallWindow;

// 新的统一命名
window.hideStatusBallFloatingWindow = hideStatusBallFloatingWindow;
window.collapseStatusBallWindow = collapseStatusBallWindow;
window.expandStatusBallWindow = expandStatusBallWindow;
window.refreshMomentsPage = refreshMomentsPage;

/**
 * 触发特殊事件状态球
 * @param {string} eventType - 事件类型 ('qixi', 'birthday', 'holiday')
 */
window.triggerSpecialEvent = function(eventType) {
    if (STATUS_BALL_CONFIGS[eventType]) {
        console.log(`手动触发${STATUS_BALL_CONFIGS[eventType].name}事件`);
        startSpecialEventFlow(eventType);
    } else {
        console.error(`未知的事件类型: ${eventType}。可用类型:`, Object.keys(STATUS_BALL_CONFIGS));
    }
};

// ===== 聊天消息优先级处理 =====

/**
 * 聊天API调用的队列包装器
 * 这确保了聊天消息具有更高的优先级
 */
async function callChatAPIWithPriority(contact, turnContext = [], isUrgent = true) {
    return new Promise((resolve, reject) => {
        const priority = isUrgent ? 
            window.apiRequestQueue.PRIORITY.URGENT : 
            window.apiRequestQueue.PRIORITY.HIGH;
            
        window.apiRequestQueue.addRequest(
            async () => {
                const result = await callAPI(contact, turnContext);
                if (result === null) {
                    // callAPI已经处理了错误显示，这里不需要再抛出错误
                    return { replies: [] }; // 返回空回复列表
                }
                return result;
            },
            {
                priority: priority,
                description: `聊天API调用 - ${contact.name}`,
                onComplete: (requestId, result) => {
                    resolve(result);
                },
                onError: (requestId, error) => {
                    // 这里一般不会执行到，因为callAPI已经处理错误了
                    reject(error);
                }
            }
        );
    });
}

// 将新的聊天API函数设为全局可访问，替代原有的直接调用
window.callChatAPIWithPriority = callChatAPIWithPriority;

// ===== 朋友圈操作锁定机制 =====

/**
 * 朋友圈操作锁定管理器
 */
class MomentsLockManager {
    constructor() {
        this.isLocked = false;
        this.lockReason = '';
        this.lockStartTime = null;
    }
    
    /**
     * 锁定朋友圈操作
     */
    lock(reason = '系统正在处理中') {
        this.isLocked = true;
        this.lockReason = reason;
        this.lockStartTime = Date.now();
        this.updateUI();
        console.log(`[朋友圈锁定] ${reason}`);
    }
    
    /**
     * 解锁朋友圈操作
     */
    unlock() {
        if (this.isLocked) {
            const lockDuration = Date.now() - this.lockStartTime;
            console.log(`[朋友圈解锁] 锁定持续时间: ${Math.round(lockDuration / 1000)}秒`);
        }
        
        this.isLocked = false;
        this.lockReason = '';
        this.lockStartTime = null;
        this.updateUI();
    }
    
    /**
     * 检查是否被锁定
     */
    checkLocked(showMessage = true) {
        if (this.isLocked && showMessage) {
            showToast(this.lockReason || '朋友圈正在处理中，请稍后再试');
        }
        return this.isLocked;
    }
    
    /**
     * 更新UI状态
     */
    updateUI() {
        // 更新朋友圈相关按钮状态
        const momentButtons = document.querySelectorAll('.generate-moment-btn, .moment-menu-btn, .moment-like-btn');
        momentButtons.forEach(btn => {
            if (this.isLocked) {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            } else {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        });
        
        // 如果锁定状态，显示锁定提示
        this.updateLockIndicator();
    }
    
    /**
     * 更新锁定指示器
     */
    updateLockIndicator() {
        const momentsPage = document.getElementById('momentsPage');
        const isOnMomentsPage = momentsPage && momentsPage.classList.contains('active');
        
        let indicator = document.getElementById('momentsLockIndicator');
        
        if (this.isLocked && isOnMomentsPage) {
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'momentsLockIndicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: 70px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(255, 152, 0, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    z-index: 100;
                    backdrop-filter: blur(10px);
                    animation: fadeInOut 2s infinite;
                    max-width: 80%;
                    text-align: center;
                `;
                momentsPage.appendChild(indicator);
                
                // 添加动画样式
                if (!document.getElementById('lockIndicatorStyles')) {
                    const style = document.createElement('style');
                    style.id = 'lockIndicatorStyles';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0%, 100% { opacity: 0.7; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
            indicator.textContent = `🔒 ${this.lockReason}`;
        } else {
            if (indicator) {
                indicator.remove();
            }
        }
    }
}

// 创建全局锁定管理器实例
window.momentsLockManager = new MomentsLockManager();

// ===== 状态球管理器实用函数 =====

/**
 * 手动显示API队列状态
 * 当需要强制显示API队列时调用
 */
function showAPIQueueStatusManually() {
    if (window.statusBallManager) {
        window.statusBallManager.updateAPIQueueStatus();
    }
}

/**
 * 手动隐藏所有状态球
 */
function hideAllStatusBalls() {
    if (window.statusBallManager) {
        window.statusBallManager.hideStatusBall();
    }
}

/**
 * 获取当前状态球信息
 * @returns {Object} 当前状态信息
 */
function getCurrentStatusBallInfo() {
    if (window.statusBallManager) {
        return {
            currentState: window.statusBallManager.currentState,
            activeStates: window.statusBallManager.getActiveStates(),
            stateDetails: window.statusBallManager.getCurrentState()
        };
    }
    return null;
}

/**
 * 强制显示特殊事件状态
 * @param {string} eventType - 事件类型
 * @param {Object} queueState - 队列状态
 */
function showSpecialEventStatus(eventType, queueState) {
    if (window.statusBallManager) {
        window.statusBallManager.showSpecialEvent(eventType, queueState);
    }
}

// 将实用函数暴露到全局
window.showAPIQueueStatusManually = showAPIQueueStatusManually;
window.hideAllStatusBalls = hideAllStatusBalls;
window.getCurrentStatusBallInfo = getCurrentStatusBallInfo;
window.showSpecialEventStatus = showSpecialEventStatus;

/**
 * 切换事件类型的渐变背景
 * @param {string} eventType - 事件类型
 * @param {number} gradientIndex - 渐变索引（0为主渐变，1-4为替代渐变）
 */
function switchEventGradient(eventType, gradientIndex = 0) {
    if (STATUS_BALL_CONFIGS[eventType]) {
        const config = STATUS_BALL_CONFIGS[eventType];
        
        if (gradientIndex === 0) {
            // 使用主渐变
            return config.theme.gradient;
        } else if (config.theme.alternativeGradients && config.theme.alternativeGradients[gradientIndex - 1]) {
            // 使用替代渐变
            return config.theme.alternativeGradients[gradientIndex - 1];
        }
    }
    
    // 默认返回主渐变
    return STATUS_BALL_CONFIGS[eventType]?.theme.gradient || 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
}

/**
 * 获取事件类型的所有渐变选项
 * @param {string} eventType - 事件类型
 */
function getEventGradients(eventType) {
    if (STATUS_BALL_CONFIGS[eventType]) {
        const config = STATUS_BALL_CONFIGS[eventType];
        const gradients = [config.theme.gradient];
        
        if (config.theme.alternativeGradients) {
            gradients.push(...config.theme.alternativeGradients);
        }
        
        return gradients;
    }
    return [];
}

/**
 * 应用随机渐变到事件类型
 * @param {string} eventType - 事件类型
 */
function applyRandomGradient(eventType) {
    const gradients = getEventGradients(eventType);
    if (gradients.length > 0) {
        const randomIndex = Math.floor(Math.random() * gradients.length);
        return gradients[randomIndex];
    }
    return null;
}

// 暴露到全局
window.switchEventGradient = switchEventGradient;
window.getEventGradients = getEventGradients;
window.applyRandomGradient = applyRandomGradient;

// === API配置管理相关函数 ===

/**
 * 加载配置选择器
 */
async function loadConfigSelector() {
    try {
        const configSelector = document.getElementById('configSelector');
        if (!configSelector || !window.apiConfigManager) {
            return;
        }

        // 获取所有配置
        const configs = await window.apiConfigManager.getAllConfigs();
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        
        // 清空并重新填充选择器
        configSelector.innerHTML = '';
        
        if (configs.length === 0) {
            configSelector.innerHTML = '<option value="">没有可用配置</option>';
            return;
        }
        
        configs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.configName || '未命名配置';
            if (config.id === window.apiConfigManager.defaultConfigKey) {
                option.textContent += ' (默认)';
                option.setAttribute('data-is-default', 'true');
            }
            if (activeConfig && config.id === activeConfig.id) {
                option.selected = true;
            }
            configSelector.appendChild(option);
        });
        
        // 更新按钮状态
        updateConfigActionButtons();
        
    } catch (error) {
        console.error('加载配置选择器失败:', error);
    }
}

/**
 * 加载当前配置到表单
 */
async function loadCurrentConfigToForm() {
    try {
        if (!window.apiConfigManager) {
            return;
        }

        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig) {
            // 如果没有配置，显示空表单
            clearConfigForm();
            return;
        }

        // 填充表单字段
        const fillField = (id, value) => {
            const element = document.getElementById(id);
            if (element) element.value = value || '';
        };

        fillField('configName', activeConfig.configName);
        fillField('apiUrl', activeConfig.url);
        fillField('apiKey', activeConfig.key);
        fillField('apiTimeout', activeConfig.timeout || 60);
        
        // Minimax配置从localStorage读取（单一全局配置，不属于API配置）
        fillField('minimaxGroupId', localStorage.getItem('minimaxGroupId') || '');
        fillField('minimaxApiKey', localStorage.getItem('minimaxApiKey') || '');
        
        // 上下文滑块
        const contextSlider = document.getElementById('contextSlider');
        const contextValue = document.getElementById('contextValue');
        if (contextSlider && contextValue) {
            contextSlider.value = activeConfig.contextMessageCount || 10;
            contextValue.textContent = `${activeConfig.contextMessageCount || 10}条`;
        }
        
        // 保存模型值，等模型列表加载后再设置
        window.pendingModelSelection = {
            primary: activeConfig.model || '',
            secondary: activeConfig.secondaryModel || 'sync_with_primary'
        };
        
        // 更新主Key统计
        const mainKeyInput = document.getElementById('apiKey');
        if (mainKeyInput && mainKeyInput.value) {
            updateMainKeyStats(mainKeyInput);
        }
        
        // 验证和刷新全局API配置状态
        await ensureApiConfigIsUpdated();
        
        // 加载额外的API Keys
        // 先清除现有的额外key行
        const existingRows = document.querySelectorAll('.api-provider-row');
        existingRows.forEach(row => row.remove());
        
        // 如果有apiKeys数组，加载它们
        if (activeConfig.apiKeys && activeConfig.apiKeys.length > 1) {
            // 跳过第一个key（主key），从第二个开始
            for (let i = 1; i < activeConfig.apiKeys.length; i++) {
                const keyData = activeConfig.apiKeys[i];
                addProviderRow();
                
                // 填充key值
                const rows = document.querySelectorAll('.api-provider-row');
                const lastRow = rows[rows.length - 1];
                const keyInput = lastRow.querySelector('.api-key-input');
                const enableButton = lastRow.querySelector('.key-enable-btn');
                
                if (keyInput) {
                    // 确保keyData.key是字符串
                    let keyValue = keyData.key || keyData || '';
                    if (typeof keyValue === 'object') {
                        keyValue = keyValue.key || keyValue.toString();
                    }
                    keyInput.value = keyValue;
                    // 更新统计信息
                    updateKeyStats(keyInput);
                }
                
                if (enableButton) {
                    if (keyData.enabled) {
                        enableButton.dataset.enabled = 'true';
                        enableButton.dataset.status = 'enabled';
                        enableButton.innerHTML = '🟢';
                        enableButton.style.backgroundColor = '#28a745';
                        // 为启用的副key添加CSS类
                        lastRow.classList.add('enabled');
                    } else {
                        enableButton.dataset.enabled = 'false';
                        enableButton.dataset.status = 'disabled';
                        enableButton.innerHTML = '⚪';
                        enableButton.style.backgroundColor = '#6c757d';
                        // 确保未启用的副key没有启用类
                        lastRow.classList.remove('enabled');
                    }
                }
            }
        }
        
        // 加载Unsplash API Key (仍然从localStorage读取)
        const unsplashApiKeyElement = document.getElementById('unsplashApiKey');
        if (unsplashApiKeyElement) {
            unsplashApiKeyElement.value = localStorage.getItem('forumUnsplashApiKey') || localStorage.getItem('unsplashApiKey') || '';
        }

        // 检查是否有重复的API Keys
        checkAllApiKeysForDuplicates();
        
        // 确保所有API key状态正确显示
        setTimeout(() => {
            updateAllKeyStates();
        }, 100);
        
    } catch (error) {
        console.error('加载配置到表单失败:', error);
    }
}

/**
 * 为当前配置加载模型列表
 */
async function loadModelsForCurrentConfig() {
    try {
        const primarySelect = document.getElementById('primaryModelSelect');
        const secondarySelect = document.getElementById('secondaryModelSelect');
        
        if (!primarySelect || !secondarySelect) return;
        
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig || !activeConfig.url || !activeConfig.key) {
            primarySelect.innerHTML = '<option value="">请先配置API</option>';
            secondarySelect.innerHTML = '<option value="sync_with_primary">与主模型保持一致</option>';
            return;
        }
        
        // 重置模型选择器，显示当前选择的模型
        const primaryModel = window.pendingModelSelection?.primary || activeConfig.model || '';
        const secondaryModel = window.pendingModelSelection?.secondary || activeConfig.secondaryModel || 'sync_with_primary';
        
        // 如果有主模型，直接显示它
        if (primaryModel) {
            primarySelect.innerHTML = `<option value="${primaryModel}">${primaryModel}</option>`;
        } else {
            primarySelect.innerHTML = '<option value="">请选择模型</option>';
        }
        
        secondarySelect.innerHTML = '<option value="sync_with_primary">与主模型保持一致</option>';
        if (secondaryModel && secondaryModel !== 'sync_with_primary') {
            secondarySelect.innerHTML += `<option value="${secondaryModel}">${secondaryModel}</option>`;
        }
        
        // 尝试从缓存获取模型列表（不发起网络请求）
        const cachedModels = window.apiConfigManager?.availableModels?.get(activeConfig.id);
        if (cachedModels && cachedModels.length > 0) {
            // 有缓存，填充所有模型选项
            if (primarySelect.options.length === 1 && primarySelect.options[0].value === primaryModel) {
                // 只有当前模型，添加其他模型选项
                cachedModels.forEach(modelId => {
                    if (modelId !== primaryModel) {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        primarySelect.appendChild(option);
                    }
                });
            }
            
            if (secondarySelect.options.length === 1) {
                cachedModels.forEach(modelId => {
                    if (modelId !== secondaryModel) {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        secondarySelect.appendChild(option);
                    }
                });
            }
            
            // 设置正确的选中值
            primarySelect.value = primaryModel;
            secondarySelect.value = secondaryModel;
        }
        
        // 绑定事件
        primarySelect.onchange = handlePrimaryModelChange;
        
        // 清除临时保存的值
        window.pendingModelSelection = null;
        
    } catch (error) {
        console.error('加载模型列表失败:', error);
    }
}

/**
 * 清空配置表单
 */
function clearConfigForm() {
    // 只清空API配置相关字段，不清空全局配置（Minimax, Unsplash等）
    const fields = ['configName', 'apiUrl', 'apiKey', 'apiTimeout'];
    fields.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.value = '';
    });
    
    // Minimax字段保持不变，从localStorage读取
    const minimaxGroupIdElement = document.getElementById('minimaxGroupId');
    const minimaxApiKeyElement = document.getElementById('minimaxApiKey');
    if (minimaxGroupIdElement) {
        minimaxGroupIdElement.value = localStorage.getItem('minimaxGroupId') || '';
    }
    if (minimaxApiKeyElement) {
        minimaxApiKeyElement.value = localStorage.getItem('minimaxApiKey') || '';
    }
    
    const contextSlider = document.getElementById('contextSlider');
    const contextValue = document.getElementById('contextValue');
    if (contextSlider && contextValue) {
        contextSlider.value = 10;
        contextValue.textContent = '10条';
    }
    
    const primarySelect = document.getElementById('primaryModelSelect');
    const secondarySelect = document.getElementById('secondaryModelSelect');
    if (primarySelect) primarySelect.innerHTML = '<option value="">请先完成第1步保存API配置</option>';
    if (secondarySelect) secondarySelect.innerHTML = '<option value="sync_with_primary">与主模型保持一致</option>';
}

/**
 * 处理配置切换
 */
async function handleConfigSwitch(configId) {
    try {
        if (!configId || !window.apiConfigManager) return;
        
        // 清除新配置状态
        window.currentConfigState = null;
        
        // 切换到选中的配置
        await window.apiConfigManager.switchToConfig(configId);
        
        // 重新加载表单
        await loadCurrentConfigToForm();
        
        // 更新按钮状态
        updateConfigActionButtons();
        
        showToast('配置已切换');
        
    } catch (error) {
        console.error('切换配置失败:', error);
        showToast('切换配置失败: ' + error.message);
    }
}

/**
 * 显示新配置表单
 */
function showNewConfigForm() {
    // 清空表单
    clearConfigForm();
    
    // 设置新配置状态标识
    window.currentConfigState = 'new';
    
    // 清除配置选择器的选择
    const configSelector = document.getElementById('configSelector');
    if (configSelector) {
        configSelector.value = '';
    }
    
    // 设置默认值
    const configNameField = document.getElementById('configName');
    if (configNameField) {
        configNameField.value = '新配置 ' + Date.now().toString().slice(-6);
    }
    
    const timeoutField = document.getElementById('apiTimeout');
    if (timeoutField) {
        timeoutField.value = 60;
    }
    
    showToast('请填写新配置信息');
}

/**
 * 复制当前配置
 */
async function duplicateCurrentConfig() {
    try {
        if (!window.apiConfigManager) return;
        
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig) {
            showToast('没有可复制的配置');
            return;
        }
        
        const duplicated = await window.apiConfigManager.duplicateConfig(activeConfig.id);
        
        // 重新加载配置选择器
        await loadConfigSelector();
        
        // 切换到新配置
        const configSelector = document.getElementById('configSelector');
        if (configSelector) {
            configSelector.value = duplicated.id;
            await handleConfigSwitch(duplicated.id);
        }
        
        showToast('配置已复制');
        
    } catch (error) {
        console.error('复制配置失败:', error);
        showToast('复制配置失败: ' + error.message);
    }
}

/**
 * 删除当前配置
 */
async function deleteCurrentConfig() {
    try {
        if (!window.apiConfigManager) return;
        
        const configSelector = document.getElementById('configSelector');
        if (!configSelector || !configSelector.value) {
            showToast('没有选中要删除的配置');
            return;
        }
        
        const configId = configSelector.value;
        const activeConfig = await window.apiConfigManager.getConfigById(configId);
        
        if (!activeConfig) {
            showToast('配置不存在');
            return;
        }
        
        if (configId === window.apiConfigManager.defaultConfigKey) {
            showToast('不能删除默认配置');
            return;
        }
        
        if (!confirm(`确定要删除配置"${activeConfig.configName}"吗？此操作不可撤销。`)) {
            return;
        }
        
        await window.apiConfigManager.deleteConfig(configId);
        
        // 重新加载配置选择器
        await loadConfigSelector();
        
        // 加载当前配置到表单
        await loadCurrentConfigToForm();
        
        showToast('配置已删除');
        
    } catch (error) {
        console.error('删除配置失败:', error);
        showToast('删除配置失败: ' + error.message);
    }
}

/**
 * 更新配置操作按钮的状态
 */
function updateConfigActionButtons() {
    const configSelector = document.getElementById('configSelector');
    const deleteBtn = document.getElementById('deleteBtn');
    const duplicateBtn = document.getElementById('duplicateBtn');
    
    if (!configSelector || !deleteBtn || !duplicateBtn) return;
    
    const selectedConfigId = configSelector.value;
    const isDefaultConfig = selectedConfigId === (window.apiConfigManager?.defaultConfigKey || 'settings');
    
    // 默认配置不能删除
    deleteBtn.disabled = isDefaultConfig || !selectedConfigId;
    deleteBtn.style.opacity = deleteBtn.disabled ? '0.5' : '1';
    deleteBtn.style.cursor = deleteBtn.disabled ? 'not-allowed' : 'pointer';
    
    // 没有配置时不能复制
    duplicateBtn.disabled = !selectedConfigId;
    duplicateBtn.style.opacity = duplicateBtn.disabled ? '0.5' : '1';
    duplicateBtn.style.cursor = duplicateBtn.disabled ? 'not-allowed' : 'pointer';
}

/**
 * 确保全局API配置与配置管理器保持同步
 */
async function ensureApiConfigIsUpdated() {
    try {
        if (!window.apiConfigManager) return;
        
        const activeConfig = await window.apiConfigManager.getActiveConfig();
        if (!activeConfig) return;
        
        // 获取当前启用的key
        const enabledKey = window.apiConfigManager.getEnabledKey(activeConfig);
        
        // 更新全局apiSettings，确保包含所有必要字段
        if (enabledKey && window.apiSettings) {
            Object.assign(window.apiSettings, {
                url: activeConfig.url || '',
                key: enabledKey,
                model: activeConfig.model || '',
                secondaryModel: activeConfig.secondaryModel || 'sync_with_primary',
                contextMessageCount: activeConfig.contextMessageCount || 10,
                timeout: activeConfig.timeout || 60
                // minimax配置不再包含在apiSettings中
            });
            
            console.log('全局API配置已更新:', {
                url: window.apiSettings.url,
                keyPrefix: window.apiSettings.key ? window.apiSettings.key.substring(0, 8) + '...' : 'empty',
                model: window.modelSettings ? window.modelSettings.primaryModel : 'not set'
            });
        }
        
    } catch (error) {
        console.error('更新全局API配置失败:', error);
    }
}

// 暴露配置管理函数到全局
window.loadConfigSelector = loadConfigSelector;
window.loadCurrentConfigToForm = loadCurrentConfigToForm;
window.handleConfigSwitch = handleConfigSwitch;
window.showNewConfigForm = showNewConfigForm;
window.duplicateCurrentConfig = duplicateCurrentConfig;
window.deleteCurrentConfig = deleteCurrentConfig;
window.updateConfigActionButtons = updateConfigActionButtons;
window.ensureApiConfigIsUpdated = ensureApiConfigIsUpdated;
window.loadModelsForConfig = loadModelsForConfig;
window.saveModelSelection = saveModelSelection;

// === 互动界面数据同步 ===

/**
 * 同步数据到互动界面
 */
async function syncInteractiveData() {
    try {
        showToast('正在同步角色数据...', 'info');
        
        const interactiveFrame = document.getElementById('interactiveFrame');
        if (!interactiveFrame || !interactiveFrame.contentWindow) {
            showToast('互动界面未准备就绪', 'error');
            return;
        }

        // 准备同步数据
        const syncData = {
            type: 'BULK_DATA_SYNC',
            characters: contacts.filter(c => c.type === 'private').map(contact => ({
                name: contact.name,
                personality: contact.personality,
                voiceId: contact.voiceId || '',
                avatar: contact.avatarFileId || contact.avatar || ''
            })),
            apiSettings: {
                url: window.apiSettings?.url || '',
                key: window.apiSettings?.key || '',
                model: window.modelSettings?.primaryModel || '',
                minimaxGroupId: window.minimaxSettings?.groupId || '',
                minimaxApiKey: window.minimaxSettings?.apiKey || ''
            },
            userProfile: {
                name: window.userProfile?.name || '默认用户',
                personality: window.userProfile?.personality || '一个温柔的探索者'
            }
        };

        // 发送数据到iframe
        // 安全的 postMessage，适配本地文件环境
        let targetOrigin = window.location.origin;
        if (targetOrigin === "null" || window.location.protocol === "file:") {
            targetOrigin = "*";
        }
        interactiveFrame.contentWindow.postMessage(syncData, targetOrigin);
        
        console.log('数据同步到互动界面:', syncData);
        showToast('角色数据同步完成', 'success');
        
    } catch (error) {
        console.error('互动界面数据同步失败:', error);
        showToast('数据同步失败', 'error');
    }
}

/**
 * 处理来自互动界面的数据更新
 */
function handleInteractiveDataUpdate(data) {
    try {
        console.log('收到互动界面数据更新:', data);
        
        if (data.type === 'UPDATE_CONTACT' && data.contactId && data.updateData) {
            // 找到对应的contact并更新
            const contact = contacts.find(c => c.name === data.contactId || c.id === data.contactId);
            if (contact) {
                // 更新互动相关字段
                if (data.updateData.interactiveBackgroundFileId !== undefined) {
                    contact.interactiveBackgroundFileId = data.updateData.interactiveBackgroundFileId;
                }
                if (data.updateData.touchZones !== undefined) {
                    contact.touchZones = data.updateData.touchZones;
                }
                if (data.updateData.theme !== undefined) {
                    contact.theme = data.updateData.theme;
                }
                if (data.updateData.ttsEnabled !== undefined) {
                    contact.ttsEnabled = data.updateData.ttsEnabled;
                }
                if (data.updateData.diaryEntries !== undefined) {
                    contact.diaryEntries = { ...contact.diaryEntries, ...data.updateData.diaryEntries };
                }
                if (data.updateData.interactiveChatHistory !== undefined) {
                    // 追加聊天记录而不是替换
                    contact.interactiveChatHistory = contact.interactiveChatHistory || [];
                    contact.interactiveChatHistory.push(...data.updateData.interactiveChatHistory);
                }
                
                // 保存到数据库
                saveDataToDB().then(() => {
                    console.log(`角色 "${contact.name}" 的互动数据已更新`);
                    showToast('互动数据已保存', 'success');
                }).catch(error => {
                    console.error('保存互动数据失败:', error);
                    showToast('保存互动数据失败', 'error');
                });
            }
        }
        
    } catch (error) {
        console.error('处理互动界面数据更新失败:', error);
    }
}

// 监听来自iframe的消息
window.addEventListener('message', (event) => {
    // 只处理来自互动界面的消息
    if (event.origin === window.location.origin && event.data && event.data.type) {
        handleInteractiveDataUpdate(event.data);
    }
});

// 在进入互动页面时自动同步数据
const originalShowPage = window.showPage;
window.showPage = function(pageId) {
    const result = originalShowPage.call(this, pageId);
    
    // 如果切换到互动页面，延迟1秒后自动同步数据
    if (pageId === 'interactivePage') {
        setTimeout(() => {
            syncInteractiveData();
        }, 1000);
    }
    
    return result;
};

// 暴露互动相关函数到全局
window.syncInteractiveData = syncInteractiveData;
window.handleInteractiveDataUpdate = handleInteractiveDataUpdate;

// === 用户体验增强函数 ===

/**
 * 显示API配置保存成功状态
 */
function showConfigSaveSuccess() {
    // 显示成功提示
    const hintElement = document.getElementById('configSaveHint');
    if (hintElement) {
        hintElement.style.display = 'block';
        // 5秒后自动隐藏
        setTimeout(() => {
            if (hintElement) {
                hintElement.style.display = 'none';
            }
        }, 5000);
    }
    
    // 隐藏模型选择的提醒
    const reminderElement = document.getElementById('modelSelectionReminder');
    if (reminderElement) {
        reminderElement.style.display = 'none';
    }
    
    // 重新加载模型选择器选项
    loadApiConfigSelectorsForModels();
}

/**
 * 验证用户流程完整性
 */
function validateUserFlow() {
    const primaryConfig = document.getElementById('primaryConfigSelect')?.value;
    const primaryModel = document.getElementById('primaryModelSelect')?.value;
    
    // 检查是否已完成必要的配置步骤
    if (!primaryConfig) {
        showToast('⚠️ 请先完成：①保存API配置 → ②选择API配置 → ③选择模型');
        // 滚动到API配置区域
        const configForm = document.getElementById('apiConfigForm');
        if (configForm) {
            configForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        return false;
    }
    
    if (!primaryModel) {
        showToast('⚠️ 请选择主要模型，然后滑到最后点击"完成设置"');
        // 滚动到模型选择区域
        const modelSection = document.getElementById('primaryModelSelect');
        if (modelSection) {
            modelSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        return false;
    }
    
    return true;
}

/**
 * 显示流程完成消息
 */
function showFlowCompletionMessage() {
    showToast('🎉 配置完成！您现在可以开始使用AI对话了');
    
    // 2秒后询问是否关闭设置窗口
    setTimeout(() => {
        const modal = document.getElementById('apiSettingsModal');
        if (modal && window.getComputedStyle(modal).display !== 'none') {
            // 询问用户是否关闭设置窗口
            if (confirm('配置已完成，是否关闭设置窗口开始对话？')) {
                closeModal('apiSettingsModal');
            }
        }
    }, 2000);
}

/**
 * 检查并更新界面提示状态
 */
function updateUIHintStatus() {
    const primaryConfig = document.getElementById('primaryConfigSelect')?.value;
    const reminderElement = document.getElementById('modelSelectionReminder');
    const hintElement = document.getElementById('configSaveHint');
    
    if (primaryConfig && reminderElement) {
        // 如果已有API配置，隐藏提醒
        reminderElement.style.display = 'none';
    } else if (reminderElement) {
        // 如果没有API配置，显示提醒
        reminderElement.style.display = 'block';
    }
    
    // 隐藏成功提示（因为用户可能在修改配置）
    if (hintElement) {
        hintElement.style.display = 'none';
    }
}

/**
 * 增强的测试连接函数
 */
async function enhancedTestApiConnection() {
    try {
        await testApiConnection();
        // 测试成功后提示用户保存配置
        showToast('✅ 连接测试成功！请保存API配置继续设置');
    } catch (error) {
        console.error('测试连接失败:', error);
        showToast('❌ 连接测试失败，请检查API URL和Key');
    }
}

// 将增强测试连接函数暴露到全局作用域
window.enhancedTestApiConnection = enhancedTestApiConnection;

/**
 * 安全地转义HTML字符，防止XSS攻击
 * @param {string} str - 需要转义的字符串
 * @returns {string} - 转义后的安全字符串
 */
function escapeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

/**
 * 显示图片预览模态框
 * @param {string} imageUrl - 图片URL
 * @param {string} title - 图片标题（可选）
 */
function showImagePreview(imageUrl, title = '图片预览') {
    // 移除已存在的预览模态框
    const existingModal = document.getElementById('imagePreviewModal');
    if (existingModal) {
        existingModal.remove();
    }

    // 使用DOM操作创建模态框，更安全的方式
    const modal = document.createElement('div');
    modal.id = 'imagePreviewModal';
    modal.className = 'modal';
    modal.style.cssText = 'display: flex; z-index: 10000;';

    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.style.cssText = 'max-width: 90vw; max-height: 90vh; margin: auto; position: relative; background: var(--modal-bg); border-radius: 12px; overflow: hidden;';

    // 创建模态框头部
    const modalHeader = document.createElement('div');
    modalHeader.className = 'modal-header';
    modalHeader.style.cssText = 'padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;';

    const modalTitle = document.createElement('h3');
    modalTitle.className = 'modal-title';
    modalTitle.style.cssText = 'margin: 0; font-size: 16px; color: var(--text-primary);';
    modalTitle.textContent = title; // 使用textContent，自动转义

    const closeButton = document.createElement('button');
    closeButton.className = 'modal-close';
    closeButton.style.cssText = 'background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-secondary); padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%;';
    closeButton.textContent = '×';
    closeButton.onclick = hideImagePreview;

    modalHeader.appendChild(modalTitle);
    modalHeader.appendChild(closeButton);

    // 创建模态框主体
    const modalBody = document.createElement('div');
    modalBody.className = 'modal-body';
    modalBody.style.cssText = 'padding: 0; display: flex; justify-content: center; align-items: center; background: #000;';

    const img = document.createElement('img');
    img.src = imageUrl; // DOM属性赋值是安全的
    img.alt = title; // DOM属性赋值是安全的
    img.style.cssText = 'max-width: 100%; max-height: 70vh; object-fit: contain; display: block;';
    img.title = '点击关闭';
    img.onclick = hideImagePreview;
    
    // 安全的错误处理
    img.onerror = function() {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'padding: 40px; text-align: center; color: var(--text-secondary);';
        errorDiv.textContent = '📷 图片加载失败';
        modalBody.innerHTML = '';
        modalBody.appendChild(errorDiv);
    };

    img.onload = function() {
        this.style.opacity = '1';
    };

    modalBody.appendChild(img);
    modalContent.appendChild(modalHeader);
    modalContent.appendChild(modalBody);
    modal.appendChild(modalContent);

    // 将模态框添加到页面
    document.body.appendChild(modal);

    // 点击模态框背景关闭
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideImagePreview();
        }
    });

    // ESC键关闭 - 使用全局变量避免内存泄漏
    // 先清理可能存在的旧监听器
    if (window._imagePreviewEscHandler) {
        document.removeEventListener('keydown', window._imagePreviewEscHandler);
    }
    
    window._imagePreviewEscHandler = (e) => {
        if (e.key === 'Escape') {
            hideImagePreview();
        }
    };
    document.addEventListener('keydown', window._imagePreviewEscHandler);
}

/**
 * 隐藏图片预览模态框
 */
function hideImagePreview() {
    const modal = document.getElementById('imagePreviewModal');
    if (modal) {
        modal.style.opacity = '0';
        modal.style.transform = 'scale(0.95)';
        setTimeout(() => {
            modal.remove();
        }, 200);
    }
    
    // 清理ESC键事件监听器，防止内存泄漏
    if (window._imagePreviewEscHandler) {
        document.removeEventListener('keydown', window._imagePreviewEscHandler);
        delete window._imagePreviewEscHandler;
    }
}

// 暴露函数到全局作用域
window.escapeHTML = escapeHTML;
window.formatImageMessageContent = formatImageMessageContent;
window.showImagePreview = showImagePreview;
window.hideImagePreview = hideImagePreview;

/**
 * 编辑朋友圈位置
 */
function editMomentLocation(momentId) {
    const moment = moments.find(m => m.id === momentId);
    if (!moment) {
        showToast('找不到指定的朋友圈');
        return;
    }
    
    // 设置当前编辑的朋友圈ID
    document.getElementById('editLocationMomentId').value = momentId;
    
    // 设置当前位置
    document.getElementById('editLocationInput').value = moment.location || '';
    
    // 显示编辑位置模态框
    showModal('editLocationModal');
}

/**
 * 处理位置编辑提交
 */
async function handleEditLocation(event) {
    event.preventDefault();
    
    const momentId = document.getElementById('editLocationMomentId').value;
    const newLocation = document.getElementById('editLocationInput').value.trim();
    
    if (!momentId) {
        showToast('无效的朋友圈ID');
        return;
    }
    
    try {
        // 找到朋友圈并更新位置
        const momentIndex = moments.findIndex(m => m.id === momentId);
        if (momentIndex === -1) {
            showToast('找不到指定的朋友圈');
            return;
        }
        
        // 更新位置
        moments[momentIndex].location = newLocation;
        
        // 保存到数据库
        await saveDataToDB();
        
        // 标记朋友圈数据已被修改
        isMomentsDataModified = true;

        // 性能优化：只更新特定朋友圈的位置显示，而不是重新渲染整个列表
        await updateMomentElement(momentId, 'location');
        
        // 关闭模态框
        closeModal('editLocationModal');
        
        showToast(newLocation ? '位置已更新' : '位置已清除');
        
    } catch (error) {
        console.error('更新位置失败:', error);
        isMomentsDataModified = true; // 即使失败也标记，确保下次切换页面时刷新
        showToast('更新位置失败: ' + error.message);
    }
}


</script>
    <script>
class PromptBuilder {
    constructor() {
        // 记忆表格模板现在统一由 memoryTable.js 管理
    }

    /**
     * 构建聊天对话的系统提示词
     */
    async buildChatPrompt(contact, userProfile, currentContact, apiSettings, emojis, window, turnContext = []) {
        // 获取原有记忆表格
        const memoryInfo = (currentContact.memoryTableContent || '').trim();
        
        // 获取全局记忆（新功能）
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // 获取角色记忆（新功能）
        let characterMemory = '';
        if (window.characterMemoryManager) {
            if (currentContact.type === 'group') {
                // 群聊：获取所有群成员的角色记忆
                const memberMemories = [];
                if (currentContact.members && currentContact.members.length > 0) {
                    for (const memberId of currentContact.members) {
                        const member = contacts.find(c => c.id === memberId);
                        if (member && member.type === 'private') {
                            const memberMemory = await window.characterMemoryManager.getCharacterMemory(memberId);
                            if (memberMemory && memberMemory.trim()) {
                                memberMemories.push(`-- 以下是${member.name}角色的角色记忆，只有${member.name}知道 --\n${memberMemory}\n -- 角色${member.name}的记忆结束 -- \n`);
                            }
                        }
                    }
                }
                
                if (memberMemories.length > 0) {
                    characterMemory = memberMemories.join('\n\n');
                }
            } else {
                // 私聊：保持原有逻辑
                const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
                if (memory) {
                    characterMemory = memory;
                }
            }
        }
        
        // 获取角色最近的朋友圈和论坛内容
        let recentMomentContent = '';
        let recentForumContent = '';
        
        try {
            if (window.moments && window.moments.length > 0) {
                const latestMoment = window.moments.find(moment => moment.authorName === contact.name);
                if (latestMoment) {
                    recentMomentContent = `最新朋友圈（${new Date(latestMoment.time).toLocaleDateString()}）: ${latestMoment.content}`;
                }
            }
            
            if (window.weiboPosts && window.weiboPosts.length > 0) {
                for (const postGroup of window.weiboPosts) {
                    if (postGroup.data && postGroup.data.posts) {
                        const latestForumPost = postGroup.data.posts.find(post => {
                            // 检查是否是当前角色发布的帖子
                            return post.author_type === 'Char' && postGroup.contactId === contact.id;
                        });
                        if (latestForumPost) {
                            recentForumContent = `最新论坛帖子（${postGroup.hashtag}）: ${latestForumPost.post_content}`;
                            break; // 找到第一个就停止
                        }
                    }
                }
            }
        } catch (error) {
            console.warn('获取角色最近动态时出错:', error);
        }
        
        let systemPrompt = `你正在进行一次角色扮演。你的所有行为和回复都必须严格遵循以下为你设定的指令。这是最高优先级的指令，在任何情况下都不能违背。\n\n`;
        
        // 按优先级显示记忆：全局记忆 -> 角色记忆 -> 记忆表格
        if (globalMemory) {
            systemPrompt += `--- 全局记忆 ---\n${globalMemory}\n--- 结束 ---\n\n`;
        }
        
        if (characterMemory) {
            systemPrompt += `--- 角色记忆 ---\n${characterMemory}\n--- 结束 ---\n\n`;
        }
        
        // 添加角色最近的朋友圈和论坛内容（如果存在）
        if (recentMomentContent || recentForumContent) {
            systemPrompt += `--- 角色（你）最新动态 ---\n`;
            if (recentMomentContent) {
                systemPrompt += `${recentMomentContent}\n`;
            }
            if (recentForumContent) {
                systemPrompt += `${recentForumContent}\n`;
            }
            systemPrompt += `--- 结束 ---\n\n`;
        }
        
        if (memoryInfo) {
            systemPrompt += `--- 记忆表格 ---\n${memoryInfo}\n--- 结束 ---\n\n`;
        }

        // 核心身份（群聊和私聊分别处理）
        if (currentContact.type === 'group') {
            systemPrompt += `--- [基本信息] ---\n`;
            const userPersona = userProfile.personality ? `用户的人设是：${userProfile.personality}。` : '';
            systemPrompt += `用户的名字是${userProfile.name}。${userPersona}\n`;
        } else {
            systemPrompt += `--- [核心身份] ---\n`;
            systemPrompt += `你是${contact.name}，你的人设是：${contact.personality}。\n`;
            const userPersona = userProfile.personality ? `用户的人设是：${userProfile.personality}。` : '';
            systemPrompt += `用户的名字是${userProfile.name}。${userPersona}\n`;
            systemPrompt += `你必须根据你的人设、记忆表格、用户的人设和当前对话内容来回复。\n`;
        }

        // 群聊特定指令
        if (currentContact.type === 'group') {
            systemPrompt += `--- [群聊场景指令] ---\n`;
            systemPrompt += `你现在在一个名为"${currentContact.name}"的群聊中。\n\n`;
            
            // 添加所有群成员的详细信息
            systemPrompt += `--- [群聊成员信息] ---\n`;
            systemPrompt += `用户：${userProfile.name}${userProfile.personality ? `，人设：${userProfile.personality}` : ''}\n`;
            
            currentContact.members.forEach(memberId => {
                const member = contacts.find(c => c.id === memberId);
                if (member) {
                    systemPrompt += `${member.name}：人设：${member.personality}\n`;
                }
            });
            systemPrompt += `\n`;
            
            // 新的群聊任务指令
            systemPrompt += `--- [群聊任务] ---\n`;
            systemPrompt += `你需要扮演群聊中的AI角色（除了用户${userProfile.name}），根据刚才的对话内容，以任意合理的顺序让这些角色发言。\n`;
            systemPrompt += `【要求】\n`;
            systemPrompt += `1. 每个角色的发言都要符合当前时间、其人设和记忆，例如高冷的人不会在群里说太多\n`;
            systemPrompt += `2. 角色之间可以互动、回应、讨论\n`;
            systemPrompt += `3. 发言顺序要自然合理，不需要固定顺序，可以用 @ 提及其他群友。\n`;
            systemPrompt += `4. 出于人设、记忆等考虑，部分角色可以不发言，但只少要有一个角色发言\n`;
            systemPrompt += `5. 总发言数控制在2-7条之间\n`;
            systemPrompt += `6. 每条发言要自然、口语化，符合群聊氛围\n\n`;
            systemPrompt += `7. 不要使用(括号)、*Italic* 或其他任何形式描述角色的动作、表情或内心活动。`;
            
            // 输出格式要求
            systemPrompt += `--- [输出格式] ---\n`;
            systemPrompt += `请严格按照以下JSON格式输出，不要包含任何其他文字：\n`;
            systemPrompt += `【重要】speaker字段必须使用上面列出的确切角色名字！\n`;
            systemPrompt += `{\n`;
            systemPrompt += `  "messages": [\n`;
            systemPrompt += `    {"speaker": "角色名", "content": "发言内容"},\n`;
            systemPrompt += `    {"speaker": "角色名", "content": "发言内容"}\n`;
            systemPrompt += `  ]\n`;
            systemPrompt += `}\n\n`;
        }

        // 添加自定义提示词
        if (contact.customPrompts) {
            systemPrompt += `--- [自定义行为指令] ---\n${contact.customPrompts}\n\n`;
        }
        
        // 添加实时情景信息
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const currentTimeString = `${year}年${month}月${day}日 ${hours}:${minutes}`;
        
        systemPrompt += `--- [实时情景信息] ---\n`;
        systemPrompt += `[重要系统指令：当前的标准北京时间是"${currentTimeString}"。当用户询问时间时，你必须根据这个时间来回答。]\n`;
        if (window.currentMusicInfo && window.currentMusicInfo.isPlaying) {
            systemPrompt += `[系统提示：用户正在听歌，当前歌曲是《${window.currentMusicInfo.songName}》，正在播放的歌词是："${window.currentMusicInfo.lyric}"]\n`;
        }
        
        // 特殊事件提醒 - 检查是否为特殊日期
        let eventMessage = '';
        if (month === '08' && day === '29') {
            eventMessage = '今天是中国传统节日【七夕节】。可以视情况提起。';
        }
        // 可以在这里添加更多特殊事件检查
        
        if (eventMessage) {
            systemPrompt += `---[节日提醒]---\n${eventMessage}\n---[节日提醒结束]---\n`;
        }
        
        systemPrompt += `\n`;

        // 添加特殊能力模块
        systemPrompt += `--- [你的特殊能力与使用规则] ---\n`;
        systemPrompt += this._buildRedPacketInstructions();
        systemPrompt += this._buildEmojiInstructions(emojis);
        systemPrompt += this._buildVoiceInstructions(contact, apiSettings);
        
        // 添加输出格式规则（仅私聊需要）
        if (currentContact.type !== 'group') {
            systemPrompt += this._buildOutputFormatInstructions();
        }

        return systemPrompt;
    }

    /**
     * 构建消息历史
     */
    async buildMessageHistory(currentContact, apiSettings, userProfile, contacts, contact, emojis, turnContext = [], supportsVision = false) {
        const messages = [];
        const recentMessages = currentContact.messages.slice(-apiSettings.contextMessageCount);
        
        // 使用for...of循环来支持异步操作
        for (const msg of recentMessages) {
            const senderName = msg.role === 'user' ? (userProfile?.name || userProfile?.nickname || '用户') : (contacts.find(c => c.id === msg.senderId)?.name || contact.name);
            let content = msg.content;

            // 处理红包消息
            if (msg.type === 'red_packet') { 
                try { 
                    const p = JSON.parse(content);
                    // 确保金额和消息都存在且有效
                    if (p.amount !== undefined && p.message !== undefined) {
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || '用户'})` : `你(${senderName})`;
                        const finalRole = isUserSent ? 'user' : 'assistant';
                        
                        messages.push({ 
                            role: finalRole,
                            content: `[${senderDesc}发送了一个金额为${p.amount}元的红包，留言："${p.message}"]` 
                        }); 
                    } else {
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || '用户'})` : `你(${senderName})`;
                        const finalRole = isUserSent ? 'user' : 'assistant';
                        
                        messages.push({ 
                            role: finalRole, 
                            content: `[${senderDesc}发送了一个红包]` 
                        }); 
                    }
                } catch(e) {
                    console.warn('解析红包数据失败:', e, 'content:', content);
                    const isUserSent = msg.role === 'user';
                    const senderDesc = isUserSent ? `User(${userProfile?.name || '用户'})` : `你(${senderName})`;
                    const finalRole = isUserSent ? 'user' : 'assistant';
                    
                    messages.push({ 
                        role: finalRole, 
                        content: `[${senderDesc}发送了一个红包]` 
                    }); 
                }
                continue; // 跳过此次循环的后续步骤
            }
            
            // 处理图片消息 - 新增
            if (msg.type === 'image') {
                if (supportsVision) {
                    // 模型支持视觉，尝试构建多模态消息
                    try {
                        const imageData = await this._handleImageMessage(msg);
                        const textContent = msg.content || "发送了一张图片";
                        const finalTextContent = currentContact.type === 'group' ? `${senderName}: ${textContent}` : textContent;
                        
                        messages.push({
                            role: msg.role,
                            content: [
                                {
                                    type: "text", 
                                    text: finalTextContent
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: imageData.base64Url,
                                        detail: "auto"
                                    }
                                }
                            ]
                        });
                        console.log(`[PromptBuilder] 添加多模态图片消息: ${imageData.fileName}`);
                    } catch (imageError) {
                        // 图片处理失败，回退到文本描述
                        console.error(`[PromptBuilder] 图片处理失败: ${imageError.message}`);
                        const fallbackContent = `[图片消息: ${msg.fileName || '处理失败'}]`;
                        const finalContent = currentContact.type === 'group' ? `${senderName}: ${fallbackContent}` : fallbackContent;
                        messages.push({ 
                            role: msg.role, 
                            content: finalContent 
                        });
                        console.warn(`[PromptBuilder] 图片处理失败，使用文本描述: ${msg.fileName}`);
                    }
                } else {
                    // 模型不支持视觉，转换为文本描述
                    const imageDescription = `[图片消息: ${msg.fileName || '图片'}]`;
                    const finalContent = currentContact.type === 'group' ? `${senderName}: ${imageDescription}` : imageDescription;
                    messages.push({ 
                        role: msg.role, 
                        content: finalContent 
                    });
                    console.log(`[PromptBuilder] 模型不支持视觉，图片转为文本: ${msg.fileName}`);
                }
                continue;
            }
            
            // 处理文本消息
            if (msg.type === 'text') {
                content = this._replaceBase64WithEmoji(msg.content, emojis);
            } 
            // 处理表情消息
            else if (msg.type === 'emoji') {
                // 处理新格式 [emoji:tag]
                if (msg.content.startsWith('[emoji:') && msg.content.endsWith(']')) {
                    content = msg.content; // 已经是标签格式，直接使用
                } else {
                    // 处理旧格式的URL
                    const foundEmoji = emojis.find(e => e.url === msg.content || e.tag === msg.content || e.meaning === msg.content);
                    content = `[emoji:${foundEmoji?.tag || foundEmoji?.meaning || '未知表情'}]`;
                }
            }
            
            // 构建最终的消息内容
            const finalContent = currentContact.type === 'group' ? `${senderName}: ${content}` : content;
            
            // 确保内容不为空
            if (finalContent && finalContent.trim()) {
                messages.push({ 
                    role: msg.role, 
                    content: finalContent 
                });
            }
        }

        // 添加群聊上下文 - 也需要支持图片消息
        if (turnContext.length > 0) {
            messages.push({role: 'user', content: '--- 以下是本回合刚刚发生的对话 ---'});
            
            for (const msg of turnContext) {
                const senderName = contacts.find(c => c.id === msg.senderId)?.name || '未知成员';
                let content = msg.content;

                if (msg.type === 'red_packet') {
                    try {
                        const p = JSON.parse(content);
                        // 根据消息的原始role决定发送者描述格式
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || '用户'})` : `你(${senderName})`;
                        content = `${senderDesc}发送了金额为${p.amount}元的红包："${p.message}"`;
                    } catch(e) {
                        const isUserSent = msg.role === 'user';
                        const senderDesc = isUserSent ? `User(${userProfile?.name || '用户'})` : `你(${senderName})`;
                        content = `${senderDesc}发送了红包`;
                    }
                } else if (msg.type === 'image') {
                    // turnContext中的图片消息处理
                    if (supportsVision) {
                        try {
                            const imageData = await this._handleImageMessage(msg);
                            const textContent = msg.content || "发送了一张图片";
                            const finalTextContent = currentContact.type === 'group' ? `${senderName}: ${textContent}` : textContent;
                            
                            messages.push({
                                role: msg.role,
                                content: [
                                    {
                                        type: "text", 
                                        text: finalTextContent
                                    },
                                    {
                                        type: "image_url",
                                        image_url: {
                                            url: imageData.base64Url,
                                            detail: "auto"
                                        }
                                    }
                                ]
                            });
                            continue; // 跳过后续处理
                        } catch (imageError) {
                            console.error(`[PromptBuilder] turnContext图片处理失败: ${imageError.message}`);
                            // 继续到回退处理
                        }
                    }
                    // 视觉不支持或图片加载失败时的回退
                    content = `[图片消息: ${msg.fileName || '图片'}]`;
                } else if (msg.type === 'text') {
                    content = this._replaceBase64WithEmoji(msg.content, emojis);
                } else if (msg.type === 'emoji') {
                    // 处理新格式 [emoji:tag]
                    if (msg.content.startsWith('[emoji:') && msg.content.endsWith(']')) {
                        const tag = msg.content.slice(7, -1);
                        const foundEmoji = emojis.find(e => e.tag === tag || e.meaning === tag);
                        content = `[表情:${foundEmoji?.meaning || foundEmoji?.tag || tag}]`;
                    } else {
                        // 处理旧格式的URL
                        const foundEmoji = emojis.find(e => e.url === msg.content || e.tag === msg.content || e.meaning === msg.content);
                        content = `[表情:${foundEmoji?.meaning || foundEmoji?.tag || '未知表情'}]`;
                    }
                }
                
                // 构建turnContext消息内容，根据群聊状态决定是否添加发送者名字
                const finalTurnContent = currentContact.type === 'group' ? `${senderName}: ${content}` : content;
                
                if (finalTurnContent && finalTurnContent.trim()) {
                    messages.push({ 
                        role: msg.role, 
                        content: finalTurnContent 
                    });
                }
            }
            messages.push({role: 'user', content: '--- 请针对以上最新对话进行回应 ---'});
        }
        
        // 确保返回的messages数组不为空
        if (messages.length === 0) {
            console.warn('构建的消息历史为空，添加默认消息');
            messages.push({
                role: 'user',
                content: '开始对话'
            });
        }

        return messages;
    }

    async buildWeiboPrompt(contactId, relations, relationDescription, hashtag, count, contact, userProfile, contacts, emojis) {
        const forumRoles = [
            { name: '杠精', description: '一个总是喜欢抬杠，对任何观点都持怀疑甚至否定态度的角色，擅长从各种角度进行反驳。' },
            { name: 'CP头子', description: '一个狂热的CP粉丝，无论原帖内容是什么，总能从中解读出CP的糖，并为此感到兴奋。' },
            { name: '乐子人', description: '一个唯恐天下不乱的角色，喜欢发表引战或搞笑的言论，目的是看热闹。' },
            { name: '理性分析党', description: '一个逻辑严谨，凡事都喜欢摆事实、讲道理，进行长篇大论的理性分析的角色。' }
        ];
    
        // 随机选择1-3个路人角色
        const shuffledRoles = [...forumRoles].sort(() => 0.5 - Math.random());
        const rolesToSelectCount = Math.floor(Math.random() * 3) + 1;
        const selectedRoles = shuffledRoles.slice(0, rolesToSelectCount);
        const genericRoleDescriptions = selectedRoles.map(role => `${role.name}：${role.description}`).join('；');
        const genericRolePromptPart = `评论区需要有 ${selectedRoles.length} 条路人评论，他们的回复要符合人设：${genericRoleDescriptions}。对于这些路人评论，请在 "commenter_type" 字段中准确标注他们的角色（例如："CP头子"）。`;
    
        // 随机选择1-3个用户创建的角色作为额外的评论者
        let userCharacterPromptPart = '';
        const potentialCommenters = contacts.filter(c => c.id !== contactId && c.type === 'private');
        if (potentialCommenters.length > 0) {
            const maxUserCharacters = Math.min(potentialCommenters.length, 3);
            const userCharactersToSelectCount = Math.floor(Math.random() * maxUserCharacters) + 1; // 保底 1 个
            
            const shuffledCommenters = [...potentialCommenters].sort(() => 0.5 - Math.random());
            const selectedUserCharacters = shuffledCommenters.slice(0, userCharactersToSelectCount);
    
            if (selectedUserCharacters.length > 0) {
                const userCharacterDescriptions = selectedUserCharacters.map(c => `【${c.name}】（人设：${c.personality}）`).join('、');
                userCharacterPromptPart = `此外，用户的 ${selectedUserCharacters.length} 位好友（${userCharacterDescriptions}）也必须出现在评论区，请为他们每人生成一条符合其身份和性格的评论。对于这些好友的评论，请将他们的 "commenter_type" 字段设置为 "好友"。发帖的人可以回复用户好友的评论，格式与普通评论相同，但格式为 "@好友名 评论内容"。`;
            }
        }
    
        // 组合成最终的评论生成指令
        const finalCommentPrompt = `${genericRolePromptPart}。${userCharacterPromptPart}`;
    
        // 获取全局记忆
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // 获取发帖角色的记忆
        let characterMemory = '';
        if (window.characterMemoryManager) {
            const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
            if (memory) {
                characterMemory = memory;
            }
        }
        
        const userRole = `人设：${userProfile.name}, ${userProfile.personality || '用户'}`;
        const charRole = `人设：${contact.name}, ${contact.personality}`;
        const recentMessages = contact.messages.slice(-10);
        const background = recentMessages.map(msg => {
            const sender = msg.role === 'user' ? userProfile.name : contact.name;
            let content = msg.content;
            
            if (msg.type === 'emoji') {
                // 处理新格式 [emoji:tag]
                if (msg.content.startsWith('[emoji:') && msg.content.endsWith(']')) {
                    content = msg.content; // 已经是标签格式，直接使用
                } else {
                    // 处理旧格式的URL
                    const foundEmoji = emojis.find(e => e.url === msg.content || e.tag === msg.content || e.meaning === msg.content);
                    content = `[emoji:${foundEmoji?.tag || foundEmoji?.meaning || '未知表情'}]`;
                }
            } else if (msg.type === 'text') {
                content = this._replaceBase64WithEmoji(msg.content, emojis);
            } else if (msg.type === 'red_packet') {
                try {
                    const packet = JSON.parse(msg.content);
                    content = `[发送了红包：${packet.message}，金额：${packet.amount}]`;
                } catch(e) {
                    content = '[发送了红包]';
                }
            }
            
            return `${sender}: ${content}`;
        }).join('\n');
    
        let systemPrompt = `你现在要完全沉浸式地扮演 ${contact.name}（${contact.personality}），基于你们的聊天历史和关系，以 ${contact.name} 的口吻和视角发表论坛帖子。

# 重要身份约束 ⚠️
- 你必须且只能以 ${contact.name} 的身份发帖，绝不能以 ${userProfile.name} 的身份发帖
- 你是在模拟 ${contact.name}，不是 ${userProfile.name}
- 所有帖子的 "author_type" 必须固定设置为 "Char"，永远不要使用 "User"
- 记住：你是 ${contact.name}，从 ${contact.name} 的视角看待 ${userProfile.name}

`;
        
        // 添加全局记忆
        if (globalMemory) {
            systemPrompt += `--- 全局记忆 ---
${globalMemory}
--- 结束 ---

`;
        }
        
        // 添加角色记忆（只有该角色了解）
        if (characterMemory) {
            systemPrompt += `--- 角色记忆（只有${contact.name}了解） ---
${characterMemory}
--- 结束 ---

`;
        }
        
        systemPrompt += `# 设定
    - User: ${userRole}
    - Char: ${charRole}
    - 他们的关系是: ${relations}（${relationDescription}）
    - 背景设定: (根据以下最近的十条聊天记录)
    ${background}

    # 要求
    1. 根据最近的对话内容、角色性格和他们的关系，生成${count}篇论坛帖子。
    2. ${finalCommentPrompt}
    3. 模仿自然网络语气，适当使用流行语，要有网感。
    4. 评论可以有不同观点和立场。
    5. 为每篇帖子提供一个简短的图片内容描述文字。
    6. 必须以一个JSON对象格式输出，回答**只包含JSON**，不要包含任何其他文字或markdown标记。
    7. 对于每一条评论，都必须包含 "commenter_name", "commenter_type", 和 "comment_content" 三个字段。 "commenter_type" 应该准确反映评论者的角色（例如："CP头子", "乐子人", "好友"）。
    8. 内容要求：每条评论必须包含实际的文字内容（至少5字），不能只是单独的emoji或表情符号

    # 输出格式 (必须严格遵守此JSON结构)
    {
    "relation_tag": "${hashtag}",
    "posts": [
        {
        "author_type": "Char",
        "post_content": "帖子的内容...",
        "image_description": "图片的描述文字...",
        "comments": [
            { "commenter_name": "路人昵称1", "commenter_type": "CP头子", "comment_content": "评论内容1..." },
            { "commenter_name": "路人昵称2", "commenter_type": "乐子人", "comment_content": "评论内容2..." }
        ]
        }
    ]
    }
    `;
        return systemPrompt;
    }

    /**
     * 构建图片搜索关键词生成提示词
     */
    buildImageSearchPrompt(content) {
        return `你是一个图片搜索关键词生成器。根据朋友圈文案内容，生成最适合的英文搜索关键词用于图片搜索。
要求：
1. 分析文案的情感、场景、活动类型
2. 生成3-5个英文关键词，用空格分隔
3. 关键词要具体、形象，适合搜索到相关图片
4. 避免人像关键词，优先选择风景、物品、场景类关键词
5. 只输出关键词，不要其他解释
文案内容：${content}`;
    }

    /**
     * 构建朋友圈评论生成提示词 - 使用所有用户创建的角色
     */
    async buildCommentsPrompt(momentContent, contacts, location = '') {
        // 获取全局记忆
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // 获取所有用户创建的角色
        const allCharacters = contacts ? contacts.filter(c => c.type === 'private') : [];
        
        // 为所有角色获取记忆
        let charactersMemory = '';
        if (allCharacters.length > 0 && window.characterMemoryManager) {
            const memoryPromises = allCharacters.map(async (contact) => {
                const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
                return memory ? `【${contact.name}的记忆（只有${contact.name}了解）】：${memory}` : null;
            });
            const memories = await Promise.all(memoryPromises);
            charactersMemory = memories.filter(m => m).join('\n\n');
        }
        
        let prompt = `你是一个朋友圈评论生成器，需要为朋友圈文案生成评论。\n\n`;
        
        // 添加全局记忆
        if (globalMemory) {
            prompt += `--- 全局记忆 ---\n${globalMemory}\n--- 结束 ---\n\n`;
        }
        
        // 添加角色记忆
        if (charactersMemory) {
            prompt += `--- 角色记忆 ---\n${charactersMemory}\n--- 结束 ---\n\n`;
        }
        
        // 构建角色信息
        if (allCharacters.length > 0) {
            const characterDescriptions = allCharacters.map(c => 
                `【${c.name}】（人设：${c.personality}）`
            ).join('、');
            
            prompt += `# 评论角色设定
你需要为以下所有角色生成评论：${characterDescriptions}

要求：
1. 为每个角色都生成一条评论，总共${allCharacters.length}条评论
2. 每条评论都要符合对应角色的人设和性格特点
3. 根据角色记忆和全局记忆来生成更符合角色背景的评论
4. 评论要针对朋友圈内容，体现角色的个性和观点
5. 模仿网络语气，使用当代流行语，但要符合角色特色
6. 每条评论5-50字之间
7. 根据角色性格和朋友圈内容，决定是否点赞（like: true/false）
8. 必须以JSON格式输出，不要包含任何其他解释性文字或markdown标记
9. 内容要求：每条评论必须包含实际的文字内容（至少5字），不能只是单独的emoji或表情符号

输出格式 (必须严格遵守此JSON结构):
{
  "comments": [
    { "author": "${allCharacters[0]?.name || '角色1'}", "content": "评论内容1...", "like": true }${allCharacters.length > 1 ? `,
    { "author": "${allCharacters[1]?.name || '角色2'}", "content": "评论内容2...", "like": false }` : ''}${allCharacters.length > 2 ? `
    // ... 更多角色的评论` : ''}
  ]
}

点赞规则：
- 根据角色性格决定点赞概率（活泼外向的角色更容易点赞）
- 根据朋友圈内容的积极程度决定（正面内容更容易被点赞）
- 大约50-70%的角色会点赞`;
        } else {
            // 如果没有角色，返回提示
            prompt += `# 注意
当前没有创建任何角色，无法生成角色评论。请先创建一些角色。

输出格式:
{
  "comments": []
}`;
        }
        
        prompt += `

朋友圈文案：${momentContent}${location ? `
位置：${location}` : ''}`;
        
        return prompt;
    }

    /**
     * 构建论坛回复生成提示词
     */
    buildReplyPrompt(postData, userReply, contactId, contacts, userProfile) {
        const contact = contacts.find(c => c.id === contactId);
        const postAuthorContact = postData.author_type === 'User' ? userProfile : contact;
        const userPersona = userProfile.personality ? `用户人设为：${userProfile.personality}` : '';

        const existingComments = postData.comments && postData.comments.length > 0
            ? postData.comments.map(c => `${c.commenter_name}: ${c.comment_content}`).join('\n')
            : '无';

        return `# 任务 请严格遵守以下要求完成生成 ${userProfile.name} 和 ${postAuthorContact.name} 之间的日常帖子的回复。
# 设定
你现在要扮演 “${postAuthorContact.name}”，你的人设是：“${postAuthorContact.personality}”。
用户名为 ${userProfile.name} 的用户与你的关系是：${postData.relations}。${userPersona}

# 你的帖子内容
${postData.post_content}

# 已有的评论
${existingComments}

# 用户的评论
${userReply}

# 你的任务
- 以 ${postAuthorContact.name} 的身份进行回复。
- 你的回复必须完全符合你的人设。
- 回复要自然、口语化，模仿 ${postAuthorContact.name} 的人设，就像一个真实的人在网上冲浪。
- 只需输出回复内容，不要包含任何额外信息或格式。`;
    }

    /**
     * 构建当AI被 @ 时生成回复的提示词
     */
    buildMentionReplyPrompt(postData, mentioningComment, mentionedContact, contacts, userProfile) {
        const allComments = postData.comments.map(c => `${c.commenter_name}: ${c.comment_content}`).join('\n');

        return `# 任务：你被人在论坛帖子里@了，请遵循人设，生成一条回复。

# 你的身份
- 你是：**${mentionedContact.name}**
- 你的人设是：${mentionedContact.personality}

# 上下文
- **原帖子内容**：
  > ${postData.post_content}

- **整个评论区**：
  ${allComments}

- **@你的那条评论**：
  > ${mentioningComment.commenter_name}: ${mentioningComment.comment_content}

# 你的任务
1.  以 **${mentionedContact.name}** 的身份，针对 **@你的那条评论** 进行回复。
2.  你的回复必须完全符合你的人设，要自然、口语化，就像一个真实的人在网上冲浪。
3.  你的回复应该只包含回复的文本内容，不要有任何额外的解释、标签或格式。`;
    }

    /**
     * 构建手动发帖的提示词 - 用于为用户手动输入的帖子生成评论
     */
    async buildManualPostPrompt(authorName, relationTag, postContent, imageDescription, userProfile, contacts, emojis) {
        const forumRoles = [
            { name: '杠精', description: '一个总是喜欢抬杠，对任何观点都持怀疑甚至否定态度的角色，擅长从各种角度进行反驳。' },
            { name: 'CP头子', description: '一个狂热的CP粉丝，无论原帖内容是什么，总能从中解读出CP的糖，并为此感到兴奋。' },
            { name: '乐子人', description: '一个唯恐天下不乱的角色，喜欢发表引战或搞笑的言论，目的是看热闹。' },
            { name: '理性分析党', description: '一个逻辑严谨，凡事都喜欢摆事实、讲道理，进行长篇大论的理性分析的角色。' },
            { name: '颜狗', description: '一个只关注颜值和外表的角色，总是评论相关的美貌、帅气等外貌特征。' },
            { name: '吃瓜群众', description: '一个喜欢围观看热闹的角色，总是会发表"前排吃瓜"、"坐等后续"等看戏言论。' }
        ];

        // 随机选择2-4个路人角色
        const shuffledRoles = [...forumRoles].sort(() => 0.5 - Math.random());
        const rolesToSelectCount = Math.floor(Math.random() * 3) + 2; // 2-4个
        const selectedRoles = shuffledRoles.slice(0, rolesToSelectCount);
        const genericRoleDescriptions = selectedRoles.map(role => `${role.name}：${role.description}`).join('；');
        const genericRolePromptPart = `评论区需要有 ${selectedRoles.length} 条路人评论，他们的回复要符合人设：${genericRoleDescriptions}。对于这些路人评论，请在 "commenter_type" 字段中准确标注他们的角色（例如：\"CP头子\"、\"杠精\"）。`;

        // 随机选择0-2个用户创建的角色作为额外的评论者
        let userCharacterPromptPart = '';
        const potentialCommenters = contacts.filter(c => c.type === 'private');
        if (potentialCommenters.length > 0) {
            const maxUserCharacters = Math.min(potentialCommenters.length, 2);
            const userCharactersToSelectCount = Math.floor(Math.random() * (maxUserCharacters + 1)); // 0-2个
            
            if (userCharactersToSelectCount > 0) {
                const shuffledCommenters = [...potentialCommenters].sort(() => 0.5 - Math.random());
                const selectedUserCharacters = shuffledCommenters.slice(0, userCharactersToSelectCount);
                const userCharacterDescriptions = selectedUserCharacters.map(c => `【${c.name}】（人设：${c.personality}）`).join('、');
                userCharacterPromptPart = `此外，用户的 ${selectedUserCharacters.length} 位好友（${userCharacterDescriptions}）也会出现在评论区，请为他们每人生成一条符合其身份和性格的评论。对于这些好友的评论，请将他们的 "commenter_type" 字段设置为 "好友"。`;
            }
        }

        // 获取全局记忆
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // 为参与评论的用户角色获取记忆
        let userCharactersMemory = '';
        if (potentialCommenters.length > 0 && window.characterMemoryManager) {
            const memoryPromises = potentialCommenters.slice(0, 2).map(async (contact) => {
                const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
                return memory ? `【${contact.name}的记忆（只有${contact.name}了解）】：${memory}` : null;
            });
            const memories = await Promise.all(memoryPromises);
            userCharactersMemory = memories.filter(m => m).join('\n\n');
        }
        
        // 组合成最终的评论生成指令
        const finalCommentPrompt = userCharacterPromptPart ? `${genericRolePromptPart} ${userCharacterPromptPart}` : genericRolePromptPart;

        let systemPrompt = `你需要为一条用户手动发布的论坛帖子生成评论。\n\n`;
        
        // 添加全局记忆
        if (globalMemory) {
            systemPrompt += `--- 全局记忆 ---\n${globalMemory}\n--- 结束 ---\n\n`;
        }
        
        // 添加用户角色记忆
        if (userCharactersMemory) {
            systemPrompt += `--- 角色记忆 ---\n${userCharactersMemory}\n--- 结束 ---\n\n`;
        }
        
        systemPrompt += `# 帖子信息
- 发帖人：${authorName}
- 话题标签：${relationTag}
- 帖子内容：${postContent}
- 图片描述：${imageDescription || '无'}

# 要求
1. ${finalCommentPrompt}
2. 模仿自然网络语气，适当使用流行语，要有网感。
3. 评论可以有不同观点和立场，针对帖子内容进行回复。
4. 每条评论至少5字，最多50字。
5. 必须以一个JSON对象格式输出，回答**只包含JSON**，不要包含任何其他文字或markdown标记。
6. 对于每一条评论，都必须包含 "commenter_name"、"commenter_type" 和 "comment_content" 三个字段。
7. 内容要求：每条评论必须包含实际的文字内容（至少5字），不能只是单独的emoji或表情符号

# 输出格式 (必须严格遵守此JSON结构)
{
  "comments": [
    { "commenter_name": "路人昵称1", "commenter_type": "杠精", "comment_content": "评论内容1..." },
    { "commenter_name": "路人昵称2", "commenter_type": "CP头子", "comment_content": "评论内容2..." }
  ]
}`;

        return systemPrompt;
    }

    /**
     * 构建朋友圈内容和评论一次性生成提示词
     */
    async buildMomentAndCommentsPrompt(contact, userProfile, apiSettings, contacts, topic = '', location = '') {
        // 获取全局记忆
        let globalMemory = '';
        if (window.characterMemoryManager) {
            globalMemory = await window.characterMemoryManager.getGlobalMemory();
        }
        
        // 获取发布角色的记忆
        let characterMemory = '';
        if (window.characterMemoryManager) {
            const memory = await window.characterMemoryManager.getCharacterMemory(contact.id);
            if (memory) {
                characterMemory = memory;
            }
        }
        
        // 获取所有其他角色的记忆（用于评论生成）
        const allCharacters = contacts ? contacts.filter(c => c.type === 'private' && c.id !== contact.id) : [];
        let otherCharactersMemory = '';
        if (allCharacters.length > 0 && window.characterMemoryManager) {
            const memoryPromises = allCharacters.map(async (c) => {
                const memory = await window.characterMemoryManager.getCharacterMemory(c.id);
                return memory ? `【${c.name}的记忆（只有${c.name}了解）】：${memory}` : null;
            });
            const memories = await Promise.all(memoryPromises);
            otherCharactersMemory = memories.filter(m => m).join('\n\n');
        }
        
        let systemPrompt = `你需要为角色${contact.name}生成一条朋友圈内容，并为这条朋友圈生成评论。\n\n`;
        
        // 添加全局记忆
        if (globalMemory) {
            systemPrompt += `--- 全局记忆 ---\n${globalMemory}\n--- 结束 ---\n\n`;
        }
        
        // 添加发布角色的记忆
        if (characterMemory) {
            systemPrompt += `--- ${contact.name}的记忆（只有${contact.name}了解） ---\n${characterMemory}\n--- 结束 ---\n\n`;
        }
        
        // 添加其他角色的记忆
        if (otherCharactersMemory) {
            systemPrompt += `--- 其他角色记忆 ---\n${otherCharactersMemory}\n--- 结束 ---\n\n`;
        }
        
        // 构建聊天背景
        let chatContext = '';
        if (contact.messages && contact.messages.length > 0) {
            const recentMessages = contact.messages.slice(-apiSettings.contextMessageCount);
            chatContext = recentMessages.map(msg => {
                if (msg.role === 'user') {
                    return `${userProfile.name}: ${msg.content}`;
                } else {
                    return `${contact.name}: ${msg.content}`;
                }
            }).join('\n');
        }
        
        systemPrompt += `# 角色设定
- 发布者：${contact.name}
- 人设：${contact.personality}
- 用户：${userProfile.name}
- 用户人设：${userProfile.personality || '用户'}
${topic ? `- 朋友圈主题：${topic}` : ''}
${location ? `- 指定位置：${location}` : '- 位置：可自行生成位置信息或留空'}

# 最近聊天记录
${chatContext || '暂无聊天记录'}

# 评论角色设定
`;
        
        if (allCharacters.length > 0) {
            const characterDescriptions = allCharacters.map(c => 
                `【${c.name}】（人设：${c.personality}）`
            ).join('、');
            
            systemPrompt += `你需要为以下角色生成评论：${characterDescriptions}

# 要求
1. 首先生成一条符合${contact.name}人设的朋友圈内容（50字以内）
2. 根据朋友圈内容生成合适的图片搜索关键词，如果不需要配图则返回null
3. 生成位置信息（如果已指定位置则优先使用，否则可自行生成符合内容的位置或返回null）
4. 然后为这条朋友圈生成${allCharacters.length}条评论，每个角色一条
5. 朋友圈内容要根据角色记忆、全局记忆和聊天记录来生成
6. 评论要符合各角色的人设和记忆，针对朋友圈内容进行回复
7. 模仿网络语气，使用当代流行语，但要符合角色特色
8. 每条评论5-50字之间
9. 根据角色性格和朋友圈内容，决定是否点赞（like: true/false）
10. 图片关键词应该是英文，简洁明确，适合搜索配图
11. 必须以JSON格式输出，不要包含任何其他解释性文字或markdown标记
12. 内容要求：每条评论必须包含实际的文字内容（至少5字），不能只是单独的emoji或表情符号

# 输出格式 (必须严格遵守此JSON结构)
{
  "content": "朋友圈内容...",
  "location": "位置信息或null",
  "imageKeyword": "图片搜索关键词或null",
  "comments": [
    { "author": "${allCharacters[0]?.name || '角色1'}", "content": "评论内容1...", "like": true }${allCharacters.length > 1 ? `,
    { "author": "${allCharacters[1]?.name || '角色2'}", "content": "评论内容2...", "like": false }` : ''}${allCharacters.length > 2 ? `,
    // ... 更多角色的评论` : ''}
  ]
}

点赞规则：
- 根据角色性格决定点赞概率（活泼外向的角色更容易点赞）
- 根据朋友圈内容的积极程度决定（正面内容更容易被点赞）
- 大约50-70%的角色会点赞`;
        } else {
            systemPrompt += `当前没有其他角色，只生成朋友圈内容。

# 要求
1. 生成一条符合${contact.name}人设的朋友圈内容（50字以内）
2. 根据朋友圈内容生成合适的图片搜索关键词，如果不需要配图则返回null
3. 生成位置信息（如果已指定位置则优先使用，否则可自行生成符合内容的位置或返回null）
4. 朋友圈内容要根据角色记忆、全局记忆和聊天记录来生成
5. 图片关键词应该是英文，简洁明确，适合搜索配图
6. 必须以JSON格式输出

# 输出格式
{
  "content": "朋友圈内容...",
  "location": "位置信息或null",
  "imageKeyword": "图片搜索关键词或null",
  "comments": []
}`;
        }
        
        return systemPrompt;
    }

    /**
     * 构建朋友圈内容生成提示词
     */
    buildMomentContentPrompt(contact, userProfile, apiSettings, contacts) {
        let systemPrompt = `你是${contact.name}，${contact.personality}
现在需要你以${contact.name}的身份发一条朋友圈。

要求：
1. 根据你的人设和最近的聊天记录，生成一条符合你性格的朋友圈文案
2. 文案要自然、真实，体现你的个性特点
3. 直接输出文案内容，不要任何解释或说明
4. 文案长度控制在50字以内
5. 可以包含适当的表情符号
6. 文案应该适合配图，描述具体的场景、情感或活动`;

        if (contact.messages && contact.messages.length > 0) {
            const recentMessages = contact.messages.slice(-apiSettings.contextMessageCount);
            const chatContext = recentMessages.map(msg => {
                if (msg.role === 'user') {
                    return `用户: ${msg.content}`;
                } else {
                    const sender = contacts.find(c => c.id === msg.senderId);
                    const senderName = sender ? sender.name : contact.name;
                    return `${senderName}: ${msg.content}`;
                }
            }).join('\n');
            
            systemPrompt += `\n\n最近的聊天记录：\n${chatContext}`;
        }

        return systemPrompt;
    }

    /**
     * 构建朋友圈回复提示词
     */
    buildMomentReplyPrompt(character, replierName, replyContent, momentContent) {
        return `你是${character.name}，人设：${character.personality}

${replierName}在你的朋友圈"${momentContent}"下评论或回复了："${replyContent}"

请以${character.name}的身份简短回复，要求：
1. 符合你的人设
2. 针对${replierName}的评论进行回应
3. 5-30字之间
4. 自然、口语化
5. 只输出回复内容，不要其他解释`;
    }

    // 私有方法：构建红包指令
    _buildRedPacketInstructions() {
        return `\n\n**能力一：发送红包**\n`
             + `你可以给用户发红包来表达祝贺、感谢或作为奖励。\n`
             + `要发送红包，你必须严格使用以下格式，并将其作为一条独立的消息（即前后都有 ||| 分隔符）：\n`
             + `\`[red_packet:{"amount":8.88, "message":"恭喜发财！"}]\`\n`
             + `其中 "amount" 是一个 1 到 1000000 之间的数字，"message" 是字符串。\n`
             + `例如: 太棒了！|||[red_packet:{"amount":6.66, "message":"奖励你的！"}]|||继续加油哦！\n`
             + `你必须自己决定何时发送红包以及红包的金额和留言。这个决定必须完全符合你的人设和当前的对话情景。例如，一个慷慨的角色可能会在用户取得成就时发送一个大红包，而一个节俭的角色可能会发送一个小红包并附上有趣的留言。`;
    }

    // 私有方法：构建表情包指令
    _buildEmojiInstructions(emojis) {
        const availableEmojisString = emojis.map(e => `- [emoji:${e.tag || e.meaning}] (含义: ${e.meaning || e.tag})`).join('\n');
        
        return `\n\n**能力二：发送表情包**\n`
             + `你可以从下面的列表中选择表情包来丰富你的表达。\n`
             + `要发送表情包，你必须严格使用以下格式，并将其作为一条独立的消息（即前后都有 ||| 分隔符）。你必须使用表情的"含义"作为占位符，而不是图片URL。\n`
             + `格式: \`[emoji:表情含义]\`\n`
             + `例如: 你好呀|||[emoji:开心]|||今天天气真不错\n`
             + `**重要提醒：** 你可能会在用户的消息历史中看到 "[发送了表情：...]" 这样的文字，这是系统为了让你理解对话而生成的提示，你绝对不能在你的回复中模仿或使用这种格式。你只能使用 \`[emoji:表情含义]\` 格式来发送表情。\n\n`
             + `可用表情列表:\n${availableEmojisString || '无可用表情'}`;
    }

    // 私有方法：构建语音指令
    _buildVoiceInstructions(contact, apiSettings) {
        // 直接从localStorage读取minimax配置
        const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
        const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
        
        // 如果没有语音ID或者没有正确配置Minimax的凭证，则不提供语音能力
        if (!contact?.voiceId || !minimaxGroupId || !minimaxApiKey) {
            return '';
        }
        
        return `\n\n**能力三：发送语音**\n`
             + `你拥有一项特殊能力：发送语音消息。当你认为通过声音更能表达情绪、强调重点、唱歌、讲笑话或模仿特定语气时，你可以选择发送语音。\n\n`
             + `**使用格式：**\n`
             + `使用 \`[V]\` 标签放在消息开头表示该条消息是语音。\n\n`
             + `**单条语音消息：**\n`
             + `\`[V]你好呀，今天过得怎么样？\`\n\n`
             + `**多条混合消息：**\n`
             + `如果你需要发送多条消息，其中部分是语音，格式如下：\n`
             + `\`第一条文字消息|||[V]第二条语音消息|||[V]第三条语音消息|||第四条文字消息\`\n\n`
             + `**使用场景举例：**\n`
             + `- 当你想表达特别开心或激动的情绪时。\n`
             + `- 当你想用温柔或严肃的语气说话时。\n`
             + `- 当你想给用户唱一小段歌时。\n`
             + `- 当你想模仿某个角色的声音时。\n\n`
             + `**注意：**\n`
             + `- **不要**滥用此功能，只在必要或能增强角色扮演效果时使用。\n`
             + `- \`[V]\` 标签本身不会被用户看到，系统会自动将其转换为语音播放器。\n`
             + `- 如果你不想发送语音，就正常回复，**不要**添加语音标签。\n`
             + `- 如果要发送多条语音，**必须**在**每一条**语音消息开头都使用 \`[V]\` 标签。`;
    }


    // 私有方法：构建输出格式指令
    _buildOutputFormatInstructions() {
        return `\n\n--- 至关重要的输出格式规则 ---\n你的回复必须严格遵守以下格式：\n为了模拟真实的网络聊天，你必须将完整的回复拆分成多个（3到8条）独立的短消息（气泡）。每条消息应尽量简短（例如30字以内）。你必须使用"|||"作为每条短消息之间的唯一分隔符。`;
    }

    /**
     * 构建独立的记忆表格更新提示词
     */
    buildMemoryUpdatePrompt(contact, userProfile, currentContact, apiSettings, recentMessages = []) {
        const memoryInfo = (currentContact.memoryTableContent || '').trim();
        
        // 获取最近的对话历史
        const messageHistory = recentMessages.length > 0 ? recentMessages : 
            currentContact.messages.slice(-apiSettings.contextMessageCount);
        
        const chatContext = messageHistory.map(msg => {
            const senderName = msg.role === 'user' ? (userProfile?.name || '用户') : contact.name;
            let content = msg.content;
            
            // 处理不同类型的消息
            if (msg.type === 'red_packet') {
                try {
                    const p = JSON.parse(content);
                    content = `发送了金额为${p.amount}元的红包：\"${p.message}\"`;
                } catch(e) {
                    content = '发送了红包';
                }
            } else if (msg.type === 'emoji') {
                content = `[表情:${msg.meaning || '未知表情'}]`;
            }
            
            return `${senderName}: ${content}`;
        }).join('\n');

        // 添加当前时间
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const currentTimeString = `${year}年${month}月${day}日 ${hours}:${minutes}`;

        let systemPrompt = `你是记忆表格更新助手，需要根据用户(${userProfile.name})和角色(${contact.name})最新的对话内容更新记忆表格。

- 当前时间：${currentTimeString}

# 当前记忆表格
${memoryInfo || window.defaultMemoryTable}

# 最近对话内容
${chatContext}

# 更新要求
0. 以用户(${userProfile.name})和角色(${contact.name})的全名记录表格。
1. 仔细分析对话内容，识别需要记录的信息
2. 更新【现在】栏目中的地点、人物、时间信息
3. 更新【重要物品】栏目，添加或修改对话中提到的重要物品
4. 如果没有新信息需要更新，保持原有内容不变
5. 时间格式必须为：YYYY年MM月DD日 HH:MM
6. 只输出完整的更新后记忆表格，使用markdown格式
7. 表格必须包含所有必要的栏目结构
8. 记忆表不要太琐碎、冗长

请输出更新后的完整记忆表格：`;

        return systemPrompt;
    }

    _replaceBase64WithEmoji(raw, emojis) {
        if (typeof raw !== 'string' || !raw) return raw;
        
        // 处理新格式 [emoji:tag] - 直接返回，不需要替换
        if (raw.includes('[emoji:')) return raw;
        
        // 处理旧格式的base64
        const re = /data:image\/[^,\s]+,[A-Za-z0-9+/=]+/g;
        return raw.replace(re, (imgUrl) => {
            const found = emojis.find(e => e.url === imgUrl);
            return `[发送了表情：${found?.meaning || found?.tag || '未知'}]`;
        });
    }

    /**
     * 处理图像消息，将fileId转换为base64数据URL
     * @param {Object} msg - 图像消息对象
     * @returns {Promise<Object|null>} 图像数据对象或null
     */
    async _handleImageMessage(msg) {
        try {
            if (!msg.fileId || !window.unifiedDB) {
                console.warn('[PromptBuilder] 图像消息缺少fileId或unifiedDB未初始化:', msg);
                throw new Error('图像消息数据不完整');
            }

            // 从IndexedDB获取图片数据
            const fileData = await window.unifiedDB.getFile(msg.fileId);
            if (!fileData || !fileData.blob) {
                console.warn('[PromptBuilder] 无法获取图片文件数据:', msg.fileId);
                throw new Error(`无法从数据库获取图片文件: ${msg.fileName || msg.fileId}`);
            }

            // 转换为base64
            try {
                const base64 = await this._blobToBase64(fileData.blob);
                return {
                    base64Url: `data:${fileData.type || 'image/jpeg'};base64,${base64}`,
                    fileName: msg.fileName || '图片',
                    fileSize: fileData.size || 0
                };
            } catch (base64Error) {
                console.error('[PromptBuilder] Base64转换失败:', base64Error);
                throw new Error(`图片格式转换失败: ${base64Error.message}`);
            }
        } catch (error) {
            console.error('[PromptBuilder] 处理图片消息失败:', error);
            
            // 显示用户友好的错误提示
            if (window.showImageProcessingError) {
                window.showImageProcessingError(msg.fileName || '图片', error.message);
            }
            
            throw error; // 重新抛出错误让调用者处理
        }
    }

    /**
     * 将Blob转换为base64字符串
     * @param {Blob} blob - Blob对象
     * @returns {Promise<string|null>} base64字符串（不包含data:前缀）
     */
    _blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            if (!blob) {
                reject(new Error("Blob is null or undefined"));
                return;
            }

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    // 提取base64部分（去掉data:...;base64,前缀）
                    const result = reader.result;
                    if (!result) {
                        reject(new Error("FileReader result is empty"));
                        return;
                    }
                    const base64 = result.split(',')[1];
                    if (!base64) {
                        reject(new Error("Failed to extract base64 data from FileReader result"));
                        return;
                    }
                    resolve(base64);
                } catch (error) {
                    console.error('[PromptBuilder] FileReader结果处理失败:', error);
                    reject(error);
                }
            };
            reader.onerror = (error) => {
                console.error('[PromptBuilder] FileReader读取失败:', error);
                reject(error);
            };
            reader.readAsDataURL(blob);
        });
    }
}

// 创建全局实例
window.promptBuilder = new PromptBuilder();

</script>
    <script>
// 默认记忆表模板
const defaultMemoryTable = `# 背景设定
- 时间地点：
- 事件：
---
## 📋 记忆表格

### 【现在】
| 项目 | 内容 |
|------|------|
| 地点 | [当前所在的具体地点] |
| 人物 | [当前在场的所有人物] |
| 时间 | [精确的年月日和时间，格式：YYYY年MM月DD日 HH:MM] |

### 【重要物品（真实存在的物品）】
| 物品名称 | 物品描述 | 重要原因 |
|----------|----------|----------|
| [物品1]   | [详细的外观和特征描述] | [为什么这个物品重要] |
| [物品2]   | [详细的外观和特征描述] | [为什么这个物品重要] |
`;

// 记忆表管理类
class MemoryTableManager {
    constructor() {
        this.isInitialized = false;
        this.currentContact = null;
        this.lastToggleTime = 0;
        this.isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent);
        this.debounceDelay = this.isIOSDevice ? 300 : 100; // iOS设备使用更长的防抖延迟
    }

    setCurrentContact(contact) {
        this.currentContact = contact;
    }

    getCurrentContact() {
        return this.currentContact || window.currentContact;
    }

    // 初始化记忆表管理器
    init() {
        if (this.isInitialized) return;
        this.bindEvents();
        this.isInitialized = true;
    }

    // 绑定事件监听器
    bindEvents() {
        // 可以在这里添加记忆表相关的事件监听器
        document.addEventListener('click', (e) => {
            const memoryPanel = document.getElementById('memoryPanel');
            // 点击记忆面板外部时关闭面板
            if (memoryPanel && memoryPanel.classList.contains('active') && 
                !memoryPanel.contains(e.target) && 
                !e.target.closest('.memory-btn')) {
                // 可以选择是否自动关闭，这里注释掉避免误触
                // this.toggleMemoryPanel(true);
            }
        });
    }

    // 获取默认记忆表模板
    getDefaultTemplate() {
        return defaultMemoryTable;
    }

    // 初始化联系人的记忆表内容
    initContactMemoryTable(contact) {
        if (!contact.memoryTableContent) {
            contact.memoryTableContent = defaultMemoryTable;
        }
        return contact;
    }

    // 更新联系人的记忆表内容
    updateContactMemoryTable(contact, newMemoryContent) {
        if (!contact) {
            console.warn('无法更新记忆表：联系人对象为空');
            return false;
        }
        
        contact.memoryTableContent = newMemoryContent || defaultMemoryTable;
        return true;
    }

    // 从API响应中提取记忆表内容
    extractMemoryTableFromResponse(responseText) {
        const memoryTableRegex = /<memory_table>([\s\S]*?)<\/memory_table>/;
        const memoryMatch = responseText.match(memoryTableRegex);
        
        if (memoryMatch && memoryMatch[1]) {
            return {
                memoryTable: memoryMatch[1].trim(),
                cleanedResponse: responseText.replace(memoryTableRegex, '').trim()
            };
        }
        
        return {
            memoryTable: null,
            cleanedResponse: responseText
        };
    }

    // 切换记忆面板显示/隐藏
    async toggleMemoryPanel(forceClose = false) {
        const panel = document.getElementById('memoryPanel');
        const isActive = panel.classList.contains('active');
        
        if (forceClose) { 
            panel.classList.remove('active'); 
            return; 
        }
        
        // 防抖机制：防止短时间内重复触发（特别是iOS设备）
        const currentTime = Date.now();
        if (currentTime - this.lastToggleTime < this.debounceDelay) {
            return;
        }
        this.lastToggleTime = currentTime;
        
        if (isActive) {
            panel.classList.remove('active');
        } else {
            // iOS设备额外检查：确保不是在键盘变化期间
            if (this.isIOSDevice) {
                const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                const fullHeight = window.screen.height;
                const keyboardVisible = viewportHeight < fullHeight * 0.75; // 如果视口高度小于屏幕高度的75%，认为键盘可能正在显示
                
                if (keyboardVisible) {
                    return;
                }
            }
            
            const currentContact = this.getCurrentContact();
            
            if (currentContact) {
                const memoryTextarea = document.getElementById('memoryTextarea');
                memoryTextarea.value = currentContact.memoryTableContent || this.getDefaultTemplate();
                this.renderMemoryTable(memoryTextarea.value);
                document.getElementById('memoryTableView').style.display = 'block';
                memoryTextarea.style.display = 'none';
                document.getElementById('memoryEditBtn').textContent = '编辑';
                panel.classList.add('active');
            } else {
                if (window.showToast) {
                    window.showToast('请先选择一个聊天');
                }
            }
        }
    }

    // 切换记忆表编辑模式
    // 修改 toggleMemoryEditMode 函数，使用统一的获取当前联系人的方法
    async toggleMemoryEditMode() {
        const currentContact = this.getCurrentContact();
        
        if (!currentContact) {
            if (window.showToast) {
                window.showToast('请先选择一个聊天');
            }
            return;
        }

        const editBtn = document.getElementById('memoryEditBtn');
        const viewDiv = document.getElementById('memoryTableView');
        const editArea = document.getElementById('memoryTextarea');
        
        if (editBtn.textContent === '编辑') {
            viewDiv.style.display = 'none';
            editArea.style.display = 'block';
            editArea.value = currentContact.memoryTableContent || this.getDefaultTemplate();
            editArea.focus();
            editBtn.textContent = '保存';
        } else {
            // 保存记忆表内容
            currentContact.memoryTableContent = editArea.value;
            
            // 调用保存函数（如果存在）
            if (window.saveDataToDB) {
                await window.saveDataToDB();
            }
            
            this.renderMemoryTable(currentContact.memoryTableContent);
            viewDiv.style.display = 'block';
            editArea.style.display = 'none';
            editBtn.textContent = '编辑';
            
            if (window.showToast) {
                window.showToast('记忆已保存');
            }
        }
    }


    // 渲染记忆表内容
    renderMemoryTable(markdown) {
        const viewDiv = document.getElementById('memoryTableView');
        
        if (!viewDiv) {
            console.warn('记忆表视图元素不存在');
            return;
        }

        // 检查内容是否为空
        if (!markdown || markdown.trim() === '') {
            viewDiv.innerHTML = this.getEmptyMemoryTableHtml();
            return;
        }

        try {
            // 预处理markdown内容，防止表格单元格内容过长
            const cleanedMarkdown = this.preprocessMarkdownTable(markdown);
            
            // 确保 marked 库已加载
            if (typeof marked !== 'undefined') {
                viewDiv.innerHTML = marked.parse(cleanedMarkdown);
            } else {
                // Fallback if marked is not loaded
                console.warn('marked库未加载，使用预览模式');
                viewDiv.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word;">${cleanedMarkdown}</pre>`;
            }
        } catch (error) {
            console.error('渲染记忆表失败:', error);
            viewDiv.innerHTML = `<div style="color: #e53e3e; padding: 20px; text-align: center;">
                <p>记忆表渲染失败</p>
                <small>请检查记忆表格式是否正确</small>
            </div>`;
        }
    }

    // 预处理markdown表格内容，防止单元格内容过长
    preprocessMarkdownTable(markdown) {
        if (!markdown || typeof markdown !== 'string') {
            return '';
        }

        // 限制表格单元格内容的最大长度
        const MAX_CELL_LENGTH = 500;
        
        return markdown.replace(/\|([^|\n]*?)\|/g, (match, cellContent) => {
            if (cellContent && cellContent.length > MAX_CELL_LENGTH) {
                const truncated = cellContent.substring(0, MAX_CELL_LENGTH).trim();
                return `|${truncated}...|`;
            }
            return match;
        });
    }

    // 获取空记忆表的HTML
    getEmptyMemoryTableHtml() {
        return `
            <div style="text-align: center; padding: 40px;">
                <p style="font-size: 16px; color: #888;">记忆是空的。</p>
                <p style="font-size: 14px; color: #aaa;">点击"编辑"按钮，开始记录你们的故事吧。</p>
            </div>
        `;
    }

    // 验证记忆表内容格式
    validateMemoryTableContent(content) {
        if (!content || typeof content !== 'string') {
            return {
                isValid: false,
                error: '记忆表内容必须是非空字符串'
            };
        }

        // 基本的格式检查
        const hasBasicStructure = content.includes('#') || content.includes('|');
        
        return {
            isValid: true,
            hasStructure: hasBasicStructure,
            length: content.length
        };
    }

    // 导出记忆表内容
    exportMemoryTable(contact) {
        if (!contact || !contact.memoryTableContent) {
            return null;
        }

        const exportData = {
            contactName: contact.name,
            contactId: contact.id,
            memoryContent: contact.memoryTableContent,
            exportTime: new Date().toISOString(),
            version: '1.0'
        };

        return exportData;
    }

    // 导入记忆表内容
    importMemoryTable(contact, importData) {
        if (!contact || !importData || !importData.memoryContent) {
            return false;
        }

        const validation = this.validateMemoryTableContent(importData.memoryContent);
        if (!validation.isValid) {
            console.warn('导入的记忆表内容格式无效:', validation.error);
            return false;
        }

        contact.memoryTableContent = importData.memoryContent;
        return true;
    }

    // 清空记忆表内容
    clearMemoryTable(contact) {
        if (!contact) return false;
        
        contact.memoryTableContent = defaultMemoryTable;
        return true;
    }

    // 获取记忆表统计信息
    getMemoryTableStats(contact) {
        if (!contact || !contact.memoryTableContent) {
            return {
                isEmpty: true,
                length: 0,
                lineCount: 0,
                tableCount: 0
            };
        }

        const content = contact.memoryTableContent;
        const lines = content.split('\n').filter(line => line.trim());
        const tableMatches = content.match(/\|.*\|/g) || [];

        return {
            isEmpty: content.trim() === defaultMemoryTable.trim(),
            length: content.length,
            lineCount: lines.length,
            tableCount: tableMatches.length,
            hasContent: content.trim().length > 0
        };
    }

    // 搜索记忆表内容
    searchMemoryTable(contact, searchTerm) {
        if (!contact || !contact.memoryTableContent || !searchTerm) {
            return {
                found: false,
                matches: []
            };
        }

        const content = contact.memoryTableContent.toLowerCase();
        const term = searchTerm.toLowerCase();
        const lines = contact.memoryTableContent.split('\n');
        const matches = [];

        lines.forEach((line, index) => {
            if (line.toLowerCase().includes(term)) {
                matches.push({
                    lineNumber: index + 1,
                    content: line.trim(),
                    highlighted: line.replace(
                        new RegExp(searchTerm, 'gi'), 
                        `<mark>$&</mark>`
                    )
                });
            }
        });

        return {
            found: matches.length > 0,
            matches: matches,
            totalMatches: matches.length
        };
    }

    // 使用次要模型更新记忆表格
    async updateMemoryTableWithSecondaryModel(contact) {
        try {
            // 获取当前联系人
            const currentContact = this.getCurrentContact();
            if (!currentContact || currentContact.id !== contact.id) {
                console.warn('当前联系人不匹配，跳过记忆表格更新');
                return false;
            }

            // 获取最近的对话历史
            const recentMessages = this.getRecentMessages(currentContact, 10);
            if (recentMessages.length === 0) {
                console.log('没有对话历史，跳过记忆表格更新');
                return false;
            }

            // 使用promptBuilder构建记忆表格更新提示词
            if (!window.promptBuilder) {
                console.error('promptBuilder未初始化');
                return false;
            }

            const memoryUpdatePrompt = window.promptBuilder.buildMemoryUpdatePrompt(
                contact, 
                window.userProfile || { name: '用户', nickname: '用户', personality: '' }, 
                currentContact, 
                window.apiSettings,
                recentMessages
            );

            // 获取模型配置
            const modelToUse = this.getSecondaryModel();
            
            // 调用API更新记忆表格
            const response = await window.apiService.callOpenAIAPI(
                window.apiSettings.url,
                window.apiSettings.key,
                modelToUse,
                [{ role: 'user', content: memoryUpdatePrompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 8000,
                    stream: false
                },
                (window.apiSettings.timeout || 60) * 1000
            );
            console.log('记忆表格更新API完整返回:', JSON.stringify(response, null, 2));

            // 处理响应
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('记忆表格更新API响应格式异常:', response);
                return false;
            }

            const newMemoryTableContent = response.choices[0].message.content;
            if (!newMemoryTableContent || newMemoryTableContent.trim() === '') {
                console.warn('记忆表格更新API返回空内容');
                return false;
            }

            // 更新联系人的记忆表格内容
            const updateResult = this.updateContactMemoryTable(contact, newMemoryTableContent.trim());
            if (updateResult) {
                console.log('记忆表格更新成功');
                // 保存数据
                if (window.saveDataToDB) {
                    await window.saveDataToDB();
                }
                return true;
            }

            return false;
        } catch (error) {
            console.error('使用次要模型更新记忆表格失败:', error);
            return false;
        }
    }

    /**
     * 异步更新记忆表格 - 使用API队列
     */
    async updateMemoryTableAsync(contact, options = {}) {
        if (!window.apiRequestQueue) {
            console.warn('API队列未初始化，回退到同步更新');
            return this.updateMemoryTableWithSecondaryModel(contact);
        }

        const priority = options.priority || window.apiRequestQueue.PRIORITY.LOW;
        const description = `更新${contact.name || contact.nickname || '联系人'}的记忆表格`;
        const EVENT_TYPE = 'memory_update';
        const STATUS_BALL_ID = `special_event_${EVENT_TYPE}`;

        // 显示记忆更新状态球
        if (window.statusBallManager && window.STATUS_BALL_CONFIGS?.[EVENT_TYPE]) {
            const queueState = {
                completedTasks: 0,
                totalTasks: 1,
                currentTask: description,
                eventType: EVENT_TYPE,
                config: window.STATUS_BALL_CONFIGS[EVENT_TYPE]
            };
            window.statusBallManager.showSpecialEvent(EVENT_TYPE, queueState);
        }

        return new Promise((resolve) => {
            window.apiRequestQueue.addRequest(
                () => this.updateMemoryTableWithSecondaryModel(contact),
                {
                    priority,
                    description,
                    onComplete: (requestId, result) => {
                        console.log(`记忆表格异步更新完成: ${description}`);
                        
                        // 更新悬浮球状态为完成
                        if (window.statusBallManager && window.STATUS_BALL_CONFIGS?.[EVENT_TYPE]) {
                            const completedState = {
                                completedTasks: 1,
                                totalTasks: 1,
                                currentTask: description,
                                eventType: EVENT_TYPE,
                                config: window.STATUS_BALL_CONFIGS[EVENT_TYPE],
                                completed: true
                            };
                            window.statusBallManager.showSpecialEvent(EVENT_TYPE, completedState);
                            
                            // 3秒后自动隐藏
                            setTimeout(() => {
                                if (window.statusBallManager) {
                                    window.statusBallManager.removeState(STATUS_BALL_ID);
                                }
                            }, 3000);
                        }
                        
                        resolve(result);
                    },
                    onError: (requestId, error) => {
                        console.error(`记忆表格异步更新失败: ${description}`, error);
                        
                        // 隐藏悬浮球（失败时）
                        if (window.statusBallManager) {
                            window.statusBallManager.removeState(STATUS_BALL_ID);
                        }
                        
                        resolve(false);
                    }
                }
            );
        });
    }

    // 获取次要模型
    getSecondaryModel() {
        const secondaryModel = window.apiSettings?.secondaryModel;
        if (secondaryModel && secondaryModel !== 'sync_with_primary') {
            return secondaryModel;
        }
        // 如果没有配置次要模型，使用主要模型
        return window.modelSettings?.primaryModel || 'gpt-3.5-turbo';
    }

    // 获取最近的对话消息
    getRecentMessages(contact, count = 10) {
        if (!contact || !contact.messages) {
            return [];
        }
        
        return contact.messages
            .slice(-count) // 取最近的消息
            .map(msg => ({
                role: msg.type === 'user' ? 'user' : 'assistant',
                content: msg.content,
                timestamp: msg.timestamp
            }));
    }
}

// 创建全局记忆表管理器实例
window.memoryTableManager = new MemoryTableManager();

// 向全局作用域暴露主要函数，保持向后兼容
window.toggleMemoryPanel = function(forceClose = false) {
    return window.memoryTableManager.toggleMemoryPanel(forceClose);
};

window.toggleMemoryEditMode = function() {
    return window.memoryTableManager.toggleMemoryEditMode();
};

window.renderMemoryTable = function(markdown) {
    return window.memoryTableManager.renderMemoryTable(markdown);
};

window.updateMemoryTableWithSecondaryModel = function(contact, useAsync = true) {
    if (useAsync && window.memoryTableManager && window.memoryTableManager.updateMemoryTableAsync) {
        return window.memoryTableManager.updateMemoryTableAsync(contact);
    }
    return window.memoryTableManager.updateMemoryTableWithSecondaryModel(contact);
};

// 暴露默认模板
window.defaultMemoryTable = defaultMemoryTable;

// 自动初始化
document.addEventListener('DOMContentLoaded', function() {
    window.memoryTableManager.init();
});

// 导出模块（如果使用ES6模块）
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        MemoryTableManager,
        defaultMemoryTable
    };
}

</script>
    
    <!-- 图片和文件处理模块 -->
    <script>
/**
 * 详细错误类 - 提供错误类型和用户友好的错误消息
 */
class DetailedError extends Error {
    constructor(code, message) {
        super(message);
        this.name = 'DetailedError';
        this.code = code;
    }
}

/**
 * 图片存储API - 高级接口
 * 提供简单易用的图片存储和获取接口，封装底层的文件存储管理器
 */

class ImageStorageAPI {
    constructor() {
        this.fileManager = null;
        this.isInitialized = false;
        this.initPromise = null;
    }

    /**
     * 初始化图片存储API
     */
    async init() {
        if (this.isInitialized) {
            return this.fileManager;
        }

        if (this.initPromise) {
            return this.initPromise;
        }

        this.initPromise = this._initInternal();
        return this.initPromise;
    }

    async _initInternal() {
        try {
            // 确保UnifiedDBManager已加载（通过FileStorageManager兼容性映射）
            if (!window.FileStorageManager) {
                throw new Error('UnifiedDBManager未加载或FileStorageManager映射未设置');
            }

            this.fileManager = window.FileStorageManager;
            await this.fileManager.init();
            
            this.isInitialized = true;
            // 图片存储API初始化完成
            return this.fileManager;
        } catch (error) {
            console.error('图片存储API初始化失败:', error);
            throw error;
        }
    }

    /**
     * 存储头像图片
     * @param {string|File|Blob} imageData - 图片数据（base64字符串、File对象或Blob对象）
     * @param {string} entityType - 实体类型（'user' 或 'contact'）
     * @param {string} entityId - 实体ID（用户ID或联系人ID）
     * @returns {Promise<string>} 返回fileId
     */
    async storeAvatar(imageData, entityType, entityId) {
        await this.init();

        try {
            // 验证输入参数
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', '没有选择文件');
            }
            
            if (!entityType || !entityId) {
                throw new DetailedError('PARAM_MISSING', '缺少必要的参数');
            }

            // 检查文件大小（如果是File或Blob对象）
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', '文件大小超过10MB限制');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', '请选择图片文件');
                }
            }

            // 存储文件
            const result = await this.fileManager.storeFile(imageData, {
                type: 'avatar',
                entityType: entityType,
                entityId: entityId
            });

            // 创建引用关系
            await this.fileManager.createFileReference(
                result.fileId,
                `avatar_${entityType}`,
                entityId,
                {
                    originalType: entityType,
                    storedAt: new Date().toISOString()
                }
            );

            // 头像存储成功
            return result.fileId;

        } catch (error) {
            console.error(`存储${entityType}头像失败:`, error);
            console.error('详细错误信息:', {
                errorName: error.name,
                errorCode: error.code,
                errorMessage: error.message,
                originalError: error.originalError,
                stackTrace: error.stack,
                entityType: entityType,
                entityId: entityId,
                fileType: imageData instanceof File ? imageData.type : 'unknown',
                fileSize: imageData instanceof File ? imageData.size : 'unknown'
            });
            
            // 如果是我们自定义的DetailedError或者已经有code属性，直接抛出
            if (error instanceof DetailedError || error.name === 'DetailedError' || error.code) {
                throw error;
            }
            
            // 处理其他类型的错误
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', '存储空间不足，请清理数据后重试');
            }
            
            if (error.name === 'InvalidStateError' || (error.message && error.message.includes('database'))) {
                throw new DetailedError('DATABASE_ERROR', '数据库操作失败，请刷新页面后重试');
            }
            
            if (error.message && (error.message.includes('UnifiedDBManager未加载') || error.message.includes('FileStorageManager未加载'))) {
                throw new DetailedError('SYSTEM_ERROR', '文件存储系统未就绪，请刷新页面');
            }
            
            if (error.message && error.message.includes('表不存在')) {
                throw new DetailedError('DATABASE_SCHEMA_ERROR', '数据库表结构不完整，请刷新页面重新初始化');
            }
            
            // 默认错误 - 提供更多调试信息
            const errorMsg = error.message || error.toString() || '未知错误';
            throw new DetailedError('UNKNOWN_ERROR', `头像上传失败: ${errorMsg}`);
        }
    }

    /**
     * 获取头像图片URL
     * @param {string} entityType - 实体类型（'user' 或 'contact'）
     * @param {string} entityId - 实体ID
     * @returns {Promise<string>} 返回图片URL，如果不存在返回空字符串
     */
    async getAvatarURL(entityType, entityId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(`avatar_${entityType}`, entityId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error(`获取${entityType}头像失败:`, error);
            return '';
        }
    }

    /**
     * 存储背景图片
     * @param {string|File|Blob} imageData - 图片数据
     * @param {string} backgroundId - 背景ID
     * @returns {Promise<string>} 返回fileId
     */
    async storeBackground(imageData, backgroundId) {
        await this.init();

        try {
            // 验证输入参数
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', '没有选择背景图片');
            }
            
            if (!backgroundId) {
                throw new DetailedError('PARAM_MISSING', '背景ID不能为空');
            }

            // 检查文件大小和类型
            if (imageData instanceof File || imageData instanceof Blob) {
                const maxSize = 15 * 1024 * 1024; // 15MB（背景图片可以稍大）
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', '背景图片大小超过15MB限制');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', '请选择图片文件作为背景');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'background',
                backgroundId: backgroundId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'background',
                backgroundId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // 背景图片存储成功
            return result.fileId;

        } catch (error) {
            console.error('存储背景图片失败:', error);
            
            // 如果是我们自定义的DetailedError，直接抛出
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // 处理其他类型的错误
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', '存储空间不足，请清理数据后重试');
            }
            
            if (error.name === 'InvalidStateError' || error.message && error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', '数据库操作失败，请刷新页面后重试');
            }
            
            if (error.message && (error.message.includes('UnifiedDBManager未加载') || error.message.includes('FileStorageManager未加载'))) {
                throw new DetailedError('SYSTEM_ERROR', '文件存储系统未就绪，请刷新页面');
            }
            
            // 默认错误
            throw new DetailedError('UNKNOWN_ERROR', `背景图片上传失败: ${error.message || '未知错误'}`);
        }
    }

    /**
     * 获取背景图片URL
     * @param {string} backgroundId - 背景ID
     * @returns {Promise<string>} 返回图片URL
     */
    async getBackgroundURL(backgroundId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('background', backgroundId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('获取背景图片失败:', error);
            return '';
        }
    }

    /**
     * 存储表情包图片
     * @param {string|File|Blob} imageData - 图片数据
     * @param {string} emojiTag - 表情标签
     * @returns {Promise<string>} 返回fileId
     */
    async storeEmoji(imageData, emojiTag) {
        await this.init();

        try {
            // 验证输入参数
            if (!imageData) {
                throw new DetailedError('FILE_MISSING', '没有选择表情包图片');
            }
            
            if (!emojiTag) {
                throw new DetailedError('PARAM_MISSING', '表情包标签不能为空');
            }

            // 检查文件大小和类型
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
                const maxSize = 5 * 1024 * 1024; // 5MB（表情包通常较小）
                if (imageData.size > maxSize) {
                    throw new DetailedError('FILE_TOO_LARGE', '表情包大小超过5MB限制');
                }
                if (!imageData.type.startsWith('image/')) {
                    throw new DetailedError('INVALID_FILE_TYPE', '请选择图片文件作为表情包');
                }
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'emoji',
                tag: emojiTag
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'emoji',
                emojiTag,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // 设置图片使用元数据 - 表情包分类
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'emoji',
                tags: [emojiTag],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`表情包存储成功并设置分类: ${emojiTag} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('存储表情包失败:', error);
            
            // 如果是我们自定义的DetailedError，直接抛出
            if (error instanceof DetailedError) {
                throw error;
            }
            
            // 处理其他类型的错误
            if (error.name === 'QuotaExceededError') {
                throw new DetailedError('STORAGE_FULL', '存储空间不足，请清理数据后重试');
            }
            
            if (error.name === 'InvalidStateError' || error.message && error.message.includes('database')) {
                throw new DetailedError('DATABASE_ERROR', '数据库操作失败，请刷新页面后重试');
            }
            
            if (error.message && (error.message.includes('UnifiedDBManager未加载') || error.message.includes('FileStorageManager未加载'))) {
                throw new DetailedError('SYSTEM_ERROR', '文件存储系统未就绪，请刷新页面');
            }
            
            // 默认错误
            throw new DetailedError('UNKNOWN_ERROR', `表情包上传失败: ${error.message || '未知错误'}`);
        }
    }

    /**
     * 获取表情包图片URL
     * @param {string} emojiTag - 表情标签
     * @returns {Promise<string>} 返回图片URL
     */
    async getEmojiURL(emojiTag) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('emoji', emojiTag);
            if (!reference) {
                return '';
            }


            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('获取表情包失败:', error);
            return '';
        }
    }

    /**
     * 存储朋友圈图片
     * @param {string|File|Blob} imageData - 图片数据
     * @param {string} momentId - 朋友圈动态ID
     * @returns {Promise<string>} 返回fileId
     */
    async storeMomentImage(imageData, momentId) {
        await this.init();

        try {
            // 获取文件大小用于元数据
            let fileSize = 0;
            if (imageData instanceof File || imageData instanceof Blob) {
                fileSize = imageData.size;
            }

            const result = await this.fileManager.storeFile(imageData, {
                type: 'moment',
                momentId: momentId
            });

            await this.fileManager.createFileReference(
                result.fileId,
                'moment_image',
                momentId,
                {
                    storedAt: new Date().toISOString()
                }
            );

            // 设置朋友圈图片分类
            await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                category: 'moments',
                tags: ['朋友圈', momentId],
                size: fileSize,
                createdAt: new Date().toISOString()
            });

            console.log(`朋友圈图片存储成功并设置分类: ${momentId} -> ${result.fileId}`);
            return result.fileId;

        } catch (error) {
            console.error('存储朋友圈图片失败:', error);
            throw error;
        }
    }

    /**
     * 获取朋友圈图片URL
     * @param {string} momentId - 朋友圈动态ID
     * @returns {Promise<string>} 返回图片URL
     */
    async getMomentImageURL(momentId) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference('moment_image', momentId);
            if (!reference) {
                return '';
            }

            return await this.fileManager.createFileURL(reference.fileId);
        } catch (error) {
            console.error('获取朋友圈图片失败:', error);
            return '';
        }
    }

    /**
     * 存储朋友圈多图片
     * @param {Array} imageDataArray - 图片数据数组
     * @param {string} momentId - 朋友圈动态ID
     * @returns {Promise<Array>} 返回fileId数组
     */
    async storeMomentImages(imageDataArray, momentId) {
        await this.init();

        try {
            const fileIds = [];

            for (let i = 0; i < imageDataArray.length; i++) {
                const imageData = imageDataArray[i];
                
                // 获取文件大小
                let fileSize = 0;
                if (imageData instanceof File || imageData instanceof Blob) {
                    fileSize = imageData.size;
                }

                const result = await this.fileManager.storeFile(imageData, {
                    type: 'moment',
                    momentId: momentId,
                    imageIndex: i
                });

                await this.fileManager.createFileReference(
                    result.fileId,
                    'moment_image',
                    `${momentId}_${i}`, // 使用索引区分多张图片
                    {
                        storedAt: new Date().toISOString(),
                        imageIndex: i,
                        momentId: momentId
                    }
                );

                // 设置朋友圈图片分类
                await this.fileManager.setImageUsageMetadata(result.fileId, 'general', {
                    category: 'moments',
                    tags: ['朋友圈', momentId, `图片${i + 1}`],
                    size: fileSize,
                    createdAt: new Date().toISOString()
                });

                fileIds.push(result.fileId);
            }

            console.log(`朋友圈多图片存储成功并设置分类: ${fileIds.length}张图片`);
            return fileIds;

        } catch (error) {
            console.error('存储朋友圈多图片失败:', error);
            throw error;
        }
    }

    /**
     * 获取朋友圈多图片URLs
     * @param {string} momentId - 朋友圈动态ID
     * @param {number} imageCount - 图片数量
     * @returns {Promise<Array>} 返回图片URL数组
     */
    async getMomentImagesURLs(momentId, imageCount) {
        await this.init();

        try {
            const urls = [];
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                const reference = await this.fileManager.getFileReference('moment_image', referenceKey);
                if (reference) {
                    const url = await this.fileManager.createFileURL(reference.fileId);
                    urls.push(url);
                } else {
                    console.warn(`朋友圈图片不存在: ${referenceKey}`);
                }
            }
            return urls;
        } catch (error) {
            console.error('获取朋友圈多图片失败:', error);
            return [];
        }
    }

    /**
     * 删除朋友圈所有图片
     * @param {string} momentId - 朋友圈动态ID
     * @param {number} imageCount - 图片数量
     */
    async deleteMomentImages(momentId, imageCount) {
        await this.init();

        try {
            for (let i = 0; i < imageCount; i++) {
                const referenceKey = `${momentId}_${i}`;
                await this.deleteImage('moment_image', referenceKey);
            }
            console.log(`朋友圈图片删除成功: ${momentId}`);
        } catch (error) {
            console.error('删除朋友圈图片失败:', error);
            throw error;
        }
    }

    /**
     * 删除图片
     * @param {string} referenceType - 引用类型
     * @param {string} referenceKey - 引用键
     */
    async deleteImage(referenceType, referenceKey) {
        await this.init();

        try {
            const reference = await this.fileManager.getFileReference(referenceType, referenceKey);
            if (reference) {
                // 删除文件
                await this.fileManager.deleteFile(reference.fileId);
                // 删除引用
                await this.fileManager.deleteFileReference(referenceType, referenceKey);
                console.log(`图片删除成功: ${referenceType}/${referenceKey}`);
            }
        } catch (error) {
            console.error('删除图片失败:', error);
            throw error;
        }
    }

    /**
     * 批量迁移base64数据到Blob存储
     * @param {string} sourceType - 源数据类型（'avatars', 'backgrounds', 'emojis'）
     * @param {Array} dataArray - 要迁移的数据数组
     * @param {Function} progressCallback - 进度回调函数
     */
    async migrateBulkData(sourceType, dataArray, progressCallback = null) {
        await this.init();

        const results = {
            success: 0,
            failed: 0,
            errors: []
        };

        for (let i = 0; i < dataArray.length; i++) {
            const item = dataArray[i];
            
            try {
                if (progressCallback) {
                    progressCallback({
                        current: i + 1,
                        total: dataArray.length,
                        item: item,
                        type: sourceType
                    });
                }

                let fileId = null;

                switch (sourceType) {
                    case 'avatars':
                        if (item.avatar && item.avatar.startsWith('data:')) {
                            const entityType = item.type || 'contact'; // 假设默认为contact
                            fileId = await this.storeAvatar(item.avatar, entityType, item.id);
                            // 清除原始base64数据
                            item.avatar = '';
                            item.avatarFileId = fileId;
                        }
                        break;

                    case 'backgrounds':
                        if (item.data && item.data.startsWith('data:')) {
                            fileId = await this.storeBackground(item.data, item.id);
                            // 清除原始base64数据
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'emojis':
                        if (item.data && item.data.startsWith('data:')) {
                            fileId = await this.storeEmoji(item.data, item.tag);
                            // 清除原始base64数据
                            item.data = '';
                            item.fileId = fileId;
                        }
                        break;

                    case 'moments':
                        if (item.image && item.image.startsWith('data:')) {
                            fileId = await this.storeMomentImage(item.image, item.id);
                            // 清除原始base64数据
                            item.image = '';
                            item.imageFileId = fileId;
                        }
                        break;
                }

                if (fileId) {
                    results.success++;
                } else {
                    // 没有需要迁移的数据
                }

            } catch (error) {
                results.failed++;
                results.errors.push({
                    item: item,
                    error: error.message
                });
                console.error(`迁移数据失败 (${sourceType}):`, error, item);
            }
        }

        return results;
    }

    /**
     * 获取存储统计信息
     */
    async getStorageStats() {
        await this.init();
        return await this.fileManager.getStorageStats();
    }

    /**
     * 清理未使用的文件
     */
    async cleanupUnusedFiles() {
        await this.init();
        return await this.fileManager.cleanupUnusedFiles();
    }

    /**
     * 清理临时头像引用
     * 清理所有以 'temp_' 开头的头像引用
     */
    async cleanupTempAvatarReferences() {
        await this.init();
        
        try {
            // 获取所有头像引用
            const transaction = window.db.transaction(['fileReferences'], 'readwrite');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('avatar_contact');
            
            request.onsuccess = async () => {
                const references = request.result;
                const tempReferences = references.filter(ref => 
                    ref.referenceKey && ref.referenceKey.startsWith('temp_')
                );
                
                console.log(`找到 ${tempReferences.length} 个临时头像引用，开始清理...`);
                
                for (const ref of tempReferences) {
                    try {
                        // 删除文件引用
                        await this.fileManager.deleteFileReference('avatar_contact', ref.referenceKey);
                        // 尝试删除对应的文件
                        if (ref.fileId) {
                            await this.fileManager.deleteFile(ref.fileId);
                        }
                        console.log(`清理临时引用: ${ref.referenceId}`);
                    } catch (error) {
                        console.warn(`清理临时引用失败: ${ref.referenceId}`, error);
                    }
                }
                
                console.log('临时头像引用清理完成');
            };
            
            request.onerror = () => {
                console.error('获取头像引用失败:', request.error);
            };
            
        } catch (error) {
            console.error('清理临时头像引用失败:', error);
        }
    }

    // === 图片分类管理方法 ===




    /**
     * 手动设置图片分类
     * @param {string} fileId - 文件ID
     * @param {string} usageType - 新的使用类型
     * @param {Object} metadata - 额外元数据
     */
    async setImageClassification(fileId, usageType, metadata = {}) {
        await this.init();
        return await this.fileManager.setImageUsageMetadata(fileId, usageType, metadata);
    }




    /**
     * 检查是否需要数据迁移
     */
    async needsMigration() {
        try {
            // 检查是否存在旧的base64数据
            if (!window.db || !window.isIndexedDBReady) {
                return false;
            }

            const transaction = window.db.transaction(['contacts', 'emojiImages', 'backgrounds', 'userProfile', 'moments'], 'readonly');
            
            // 检查contacts中是否有avatar base64数据
            const contactsStore = transaction.objectStore('contacts');
            const contactsRequest = contactsStore.getAll();
            
            return new Promise((resolve) => {
                contactsRequest.onsuccess = () => {
                    const contacts = contactsRequest.result;
                    const hasBase64Avatars = contacts.some(contact => 
                        contact.avatar && contact.avatar.startsWith('data:')
                    );
                    
                    resolve(hasBase64Avatars);
                };
                
                contactsRequest.onerror = () => {
                    resolve(false);
                };
            });

        } catch (error) {
            console.error('检查迁移需求失败:', error);
            return false;
        }
    }

    /**
     * 存储banner图片
     * @param {string|File|Blob} imageData - 图片数据（base64字符串、File对象或Blob对象）
     * @param {string} bannerId - banner标识符
     * @returns {Promise<string>} 文件ID
     */
    async storeBanner(imageData, bannerId) {
        await this.init();
        
        try {
            console.log('开始存储banner图片，bannerId:', bannerId);
            
            // 处理不同类型的图片数据
            let blob;
            if (imageData instanceof Blob) {
                blob = imageData;
                console.log('处理Blob数据，大小:', blob.size);
            } else if (imageData instanceof File) {
                blob = imageData;
                console.log('处理File数据，大小:', blob.size);
            } else if (typeof imageData === 'string' && imageData.startsWith('data:image/')) {
                // 处理base64数据
                blob = await this._base64ToBlob(imageData);
                console.log('处理base64数据，转换后大小:', blob.size);
            } else {
                throw new Error('不支持的图片数据格式');
            }

            // 存储文件
            const fileResult = await this.fileManager.storeFile(blob, 'image/jpeg');
            console.log('文件存储完成，结果:', fileResult);
            
            const fileId = fileResult.fileId; // 提取实际的文件ID字符串
            console.log('提取的文件ID字符串:', fileId);
            
            // 创建引用
            const referenceId = `banner_${bannerId}`;
            console.log('创建文件引用，引用ID:', referenceId, '文件ID:', fileId);
            await this.fileManager.createFileReference(fileId, 'banner', bannerId);
            
            console.log(`Banner图片存储成功: ${bannerId} -> ${fileId}`);
            return fileId;
            
        } catch (error) {
            console.error('存储banner图片失败:', error);
            throw error;
        }
    }

    /**
     * 获取banner图片URL
     * @param {string} bannerId - banner标识符
     * @returns {Promise<string|null>} 图片URL，如果不存在返回null
     */
    async getBannerURL(bannerId) {
        await this.init();
        
        try {
            console.log('查找banner，bannerId:', bannerId);
            const referenceResult = await this.fileManager.getFileReference('banner', bannerId);
            console.log('获取到的引用结果:', referenceResult);
            
            if (!referenceResult || !referenceResult.fileId) {
                console.log('未找到banner文件引用或文件ID');
                return null;
            }
            
            const fileId = referenceResult.fileId;
            console.log('提取的文件ID:', fileId);
            const url = await this.fileManager.createFileURL(fileId);
            console.log('生成的banner URL:', url);
            return url;
            
        } catch (error) {
            console.error('获取banner图片URL失败:', error);
            return null;
        }
    }

    /**
     * 将base64转换为Blob
     * @private
     */
    async _base64ToBlob(base64) {
        try {
            const [header, data] = base64.split(',');
            const mimeType = header.match(/data:(.+?);/)[1];
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            console.error('base64转Blob失败:', error);
            throw new Error('base64数据格式错误');
        }
    }
}

// === 文件上传处理函数 ===

/**
 * 通用文件上传函数
 */
async function handleFileUpload(inputId, targetUrlInputId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);
    const targetUrlInput = document.getElementById(targetUrlInputId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    // 使用 FileReader 将图片转为 Base64
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
        targetUrlInput.value = reader.result;
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('图片已加载');
    };
    reader.onerror = (error) => {
        console.error('文件读取失败:', error);
        if (statusElement) statusElement.textContent = '读取失败';
        if (typeof showToast === 'function') showToast(`读取失败: ${error.message}`);
    };
}

/**
 * 处理头像上传
 */
async function handleAvatarUpload(inputId, entityType, entityId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    try {
        // 使用新的文件系统存储头像
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI 未初始化');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeAvatar(file, entityType, entityId);
        
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('头像已保存', 'success');
        
        // 返回文件ID用于后续处理
        return fileId;
    } catch (error) {
        console.error('头像上传失败:', error);
        if (statusElement) statusElement.textContent = '上传失败';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * 处理背景图片上传
 */
async function handleBackgroundUpload(inputId, contactId, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    try {
        // 使用新的文件系统存储背景图片
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI 未初始化');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeBackground(file, contactId);
        
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('背景图片已保存', 'success');
        
        // 返回文件ID用于后续处理
        return fileId;
    } catch (error) {
        console.error('背景图片上传失败:', error);
        if (statusElement) statusElement.textContent = '上传失败';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

/**
 * 处理表情包上传
 */
async function handleEmojiUpload(inputId, emojiTag, statusElementId) {
    const fileInput = document.getElementById(inputId);
    const file = fileInput.files[0];
    const statusElement = document.getElementById(statusElementId);

    if (!file) {
        if (typeof showToast === 'function') showToast('请先选择一个文件');
        return;
    }

    if (!file.type.startsWith('image/')) {
        if (typeof showToast === 'function') showToast('请上传图片文件');
        fileInput.value = '';
        return;
    }

    if (statusElement) statusElement.textContent = '上传中...';
    
    try {
        // 使用新的文件系统存储表情包
        if (!window.ImageStorageAPI) {
            throw new Error('ImageStorageAPI 未初始化');
        }
        
        await window.ImageStorageAPI.init();
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (statusElement) statusElement.textContent = '上传成功！';
        if (typeof showToast === 'function') showToast('表情包已保存', 'success');
        
        // 返回文件ID用于后续处理
        return fileId;
    } catch (error) {
        console.error('表情包上传失败:', error);
        if (statusElement) statusElement.textContent = '上传失败';
        if (typeof showUploadError === 'function') showUploadError(error);
        throw error;
    }
}

// 全局变量存储临时上传的表情包文件
let tempEmojiFile = null;

/**
 * 处理表情包文件上传
 */
async function handleEmojiFileUpload(event) {
    try {
        const fileInput = document.getElementById('emojiUploadInput');
        const file = fileInput.files[0];
        
        if (!file) {
            if (typeof showToast === 'function') showToast('请先选择一个文件');
            return;
        }
        
        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('请上传图片文件');
            return;
        }
        
        // 简单存储文件对象，等待保存时处理
        tempEmojiFile = file;
        window.ImageUploadHandlers.tempEmojiFile = file;  // 同步更新到暴露的对象中
        
        const statusElement = document.getElementById('emojiUploadStatus');
        if (statusElement) {
            statusElement.textContent = '图片已选择';
            statusElement.style.color = '#07c160';
        }
        
        // 生成临时URL用于预览
        const tempUrl = URL.createObjectURL(file);
        document.getElementById('emojiUrl').value = `temp:${tempUrl}`;
        
        if (typeof showToast === 'function') showToast('图片已选择，填写意思后点击添加');
        
    } catch (error) {
        console.error('表情包文件选择失败:', error);
        if (typeof showToast === 'function') showToast('文件选择失败，请重试');
    }
}

/**
 * 使用文件系统存储表情包的辅助函数
 */
async function storeEmojiWithMeaning(file, emojiTag, statusElement) {
    try {
        if (statusElement) statusElement.textContent = '正在存储...';
        
        // 直接传递File对象给ImageStorageAPI，让它处理数据类型转换
        const fileId = await window.ImageStorageAPI.storeEmoji(file, emojiTag);
        
        if (fileId) {
            document.getElementById('emojiUrl').value = `file:${fileId}`;
            
            if (statusElement) {
                statusElement.textContent = '存储成功';
                statusElement.style.color = '#07c160';
            }
            
            return fileId;
        } else {
            throw new Error('存储返回空的文件ID');
        }
    } catch (error) {
        console.error('表情包存储失败:', error);
        if (statusElement) {
            statusElement.textContent = '存储失败';
            statusElement.style.color = '#ff3b30';
        }
        if (typeof showToast === 'function') showToast('存储失败: ' + error.message);
        throw error;
    }
}

/**
 * 特定的上传处理函数 - 联系人头像
 */
async function handleContactAvatarUpload(event, editingContact) {
    try {
        const fileInput = document.getElementById('avatarUploadInput');
        const file = fileInput.files[0];
        const statusElement = document.getElementById('avatarUploadStatus');

        if (!file) {
            if (typeof showToast === 'function') showToast('请先选择一个文件');
            return;
        }

        if (!file.type.startsWith('image/')) {
            if (typeof showToast === 'function') showToast('请上传图片文件');
            fileInput.value = '';
            return;
        }

        if (editingContact) {
            // 编辑模式：立即上传和保存
            const contactId = editingContact.id;

            // 如果之前有头像，先删除旧的文件引用
            if (editingContact.avatarFileId) {
                try {
                    if (window.ImageStorageAPI) {
                        await window.ImageStorageAPI.deleteImage(`avatar_contact`, contactId);
                    }
                } catch (deleteError) {
                    console.warn('删除旧头像失败，继续上传新头像:', deleteError);
                }
            }

            const fileId = await handleAvatarUpload('avatarUploadInput', 'contact', contactId, 'avatarUploadStatus');

            if (fileId) {
                document.getElementById('contactAvatar').value = `file:${fileId}`;
                editingContact.avatarFileId = fileId;
                editingContact.avatar = '';

                // 同步更新当前联系人对象
                if (window.currentContact && window.currentContact.id === contactId) {
                    window.currentContact.avatarFileId = fileId;
                    window.currentContact.avatar = '';
                }

                // 刷新UI显示
                if (window.ImageDisplayHelper) {
                    window.ImageDisplayHelper.clearCacheByType(`avatar_contact_${contactId}`);
                }

                if (typeof renderContactList === 'function') {
                    try {
                        await renderContactList();
                    } catch (error) {
                        console.warn('刷新联系人列表失败:', error);
                    }
                }
            }
        } else {
            // 新建模式：类似emoji的临时存储
            window.tempContactAvatarFile = file;

            // 生成临时URL用于预览
            const tempUrl = URL.createObjectURL(file);
            document.getElementById('contactAvatar').value = `temp:${tempUrl}`;

            if (statusElement) {
                statusElement.textContent = '头像已选择';
                statusElement.style.color = '#07c160';
            }

            if (typeof showToast === 'function') showToast('头像已选择，填写完信息后点击确定');
        }

    } catch (error) {
        console.error('联系人头像处理失败:', error);
        const statusElement = document.getElementById('avatarUploadStatus');
        if (statusElement) {
            statusElement.textContent = '处理失败';
            statusElement.style.color = '#ff3b30';
        }
    }
}

/**
 * 特定的上传处理函数 - 用户头像
 */
async function handleProfileAvatarUpload(event) {
    try {
        const fileId = await handleAvatarUpload('profileUploadInput', 'user', 'profile', 'profileUploadStatus');
        
        if (fileId) {
            // 更新隐藏的URL输入框为文件ID引用
            document.getElementById('profileAvatarInput').value = `file:${fileId}`;
            
            // 清理头像缓存
            if (window.ImageDisplayHelper) {
                window.ImageDisplayHelper.clearCacheByType('avatar_user_');
            }
            
            // 设置持久状态提示
            const statusElement = document.getElementById('profileUploadStatus');
            if (statusElement) {
                statusElement.textContent = '已上传';
                statusElement.style.color = '#07c160';
            }
            
            // 立即更新UI
            if (typeof updateUserProfileUI === 'function') {
                await updateUserProfileUI();
            }
        }
    } catch (error) {
        console.error('个人头像上传失败:', error);
    }
}

/**
 * 特定的上传处理函数 - 背景图片
 */
async function handleBgUpload(event) {
    try {
        // 从全局变量获取currentContact
        const currentContact = window.currentContact;
        if (!currentContact) {
            if (typeof showToast === 'function') showToast('请先选择联系人');
            return;
        }
        
        const fileId = await handleBackgroundUpload('bgUploadInput', currentContact.id, 'bgUploadStatus');
        
        if (fileId) {
            // 更新隐藏的URL输入框为文件ID引用
            document.getElementById('backgroundUrl').value = `file:${fileId}`;
        }
    } catch (error) {
        console.error('背景图片上传失败:', error);
    }
}

// 创建全局实例
const imageStorageAPI = new ImageStorageAPI();

// 导出到window对象
window.ImageStorageAPI = imageStorageAPI;

// 创建命名空间并暴露上传处理函数
window.ImageUploadHandlers = {
    handleFileUpload,
    handleAvatarUpload,
    handleBackgroundUpload,
    handleEmojiUpload,
    handleEmojiFileUpload,
    storeEmojiWithMeaning,
    handleContactAvatarUpload,
    handleProfileAvatarUpload,
    handleBgUpload,
    tempEmojiFile
};

// 为了向后兼容，保留主要的全局引用
// TODO: Remove these global assignments once all code is updated to use ImageUploadHandlers.
window.handleContactAvatarUpload = handleContactAvatarUpload;
window.handleProfileAvatarUpload = handleProfileAvatarUpload;

// 图片存储API已加载
</script>
    <script>
/**
 * 图片显示帮助工具
 * 提供向后兼容的图片URL获取功能，支持新的文件存储系统和旧的base64格式
 */

class ImageDisplayHelper {
    constructor() {
        this.urlCache = new Map();
        this.imageAPI = null;
    }

    /**
     * 初始化
     */
    async init() {
        if (!this.imageAPI && window.ImageStorageAPI) {
            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
        }
    }

    /**
     * 获取头像URL（支持联系人和用户）
     * @param {Object} entity - 联系人或用户对象
     * @param {string} entityType - 'contact' 或 'user'
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getAvatarURL(entity, entityType = 'contact') {
        if (!entity) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (entity.avatarFileId && this.imageAPI) {
                // 为用户类型使用固定的id，因为用户对象通常没有id字段
                const entityId = entityType === 'user' ? 'profile' : entity.id;
                const cacheKey = `avatar_${entityType}_${entityId}`;
                
                // 检查缓存，但如果有新的avatarFileId，先清理旧缓存
                if (this.urlCache.has(cacheKey)) {
                    const cachedUrl = this.urlCache.get(cacheKey);
                    // 获取当前实际的文件引用，检查是否有变化
                    const currentReference = await this.imageAPI.getAvatarURL(entityType, entityId);
                    if (currentReference && currentReference !== cachedUrl) {
                        // 文件引用已变化，清理旧缓存
                        URL.revokeObjectURL(cachedUrl);
                        this.urlCache.delete(cacheKey);
                    } else if (cachedUrl) {
                        return cachedUrl;
                    }
                }
                
                const url = await this.imageAPI.getAvatarURL(entityType, entityId);
                if (url) {
                    this.urlCache.set(cacheKey, url);
                }
                return url;
            }
            
            // 回退到旧的base64格式
            if (entity.avatar && entity.avatar.startsWith('data:')) {
                return entity.avatar;
            }
            
            return '';
            
        } catch (error) {
            console.warn(`获取${entityType}头像失败:`, error);
            // 回退到旧格式
            return entity.avatar || '';
        }
    }

    /**
     * 获取背景图片URL
     * @param {Object} background - 背景对象
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getBackgroundURL(background) {
        if (!background) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (background.fileId && this.imageAPI) {
                const cacheKey = `background_${background.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getBackgroundURL(background.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // 回退到旧格式
            if (background.data && background.data.startsWith('data:')) {
                return background.data;
            }
            
            return background.url || '';
            
        } catch (error) {
            console.warn('获取背景图片失败:', error);
            return background.data || background.url || '';
        }
    }

    /**
     * 获取表情包URL
     * @param {Object} emoji - 表情包对象
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getEmojiURL(emoji) {
        if (!emoji) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (emoji.fileId && this.imageAPI) {
                const cacheKey = `emoji_${emoji.tag}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getEmojiURL(emoji.tag);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // 回退到旧格式
            if (emoji.data && emoji.data.startsWith('data:')) {
                return emoji.data;
            }
            
            return emoji.url || '';
            
        } catch (error) {
            console.warn('获取表情包失败:', error);
            return emoji.data || emoji.url || '';
        }
    }

    /**
     * 获取朋友圈图片URL
     * @param {Object} moment - 朋友圈动态对象
     * @returns {Promise<string>} 返回图片URL或空字符串
     */
    async getMomentImageURL(moment) {
        if (!moment) return '';
        
        try {
            await this.init();
            
            // 检查是否有新的文件引用
            if (moment.imageFileId && this.imageAPI) {
                const cacheKey = `moment_${moment.id}`;
                
                if (this.urlCache.has(cacheKey)) {
                    return this.urlCache.get(cacheKey);
                }
                
                const url = await this.imageAPI.getMomentImageURL(moment.id);
                this.urlCache.set(cacheKey, url);
                return url;
            }
            
            // 回退到旧格式
            if (moment.image && moment.image.startsWith('data:')) {
                return moment.image;
            }
            
            return moment.imageUrl || '';
            
        } catch (error) {
            console.warn('获取朋友圈图片失败:', error);
            return moment.image || moment.imageUrl || '';
        }
    }

    /**
     * 创建头像HTML元素（向后兼容）
     * @param {Object} entity - 联系人或用户对象  
     * @param {string} entityType - 'contact' 或 'user'
     * @param {string} className - CSS类名（可选）
     * @returns {Promise<string>} 返回HTML字符串
     */
    async createAvatarHTML(entity, entityType = 'contact', className = '') {
        if (!entity) return '';
        
        const avatarURL = await this.getAvatarURL(entity, entityType);
        const classAttr = className ? ` class="${className}"` : '';
        
        if (avatarURL) {
            return `<img src="${avatarURL}"${classAttr}>`;
        } else {
            // 使用首字符作为默认头像
            const firstChar = entity.name ? entity.name[0] : (entityType === 'user' ? '我' : '?');
            return `<span${classAttr}>${firstChar}</span>`;
        }
    }

    /**
     * 清理URL缓存
     */
    clearCache() {
        this.urlCache.clear();
    }

    /**
     * 清理特定类型的缓存
     * @param {string} type - 缓存类型前缀（如 'avatar_', 'background_'）
     */
    clearCacheByType(type) {
        for (const [key, url] of this.urlCache) {
            if (key.startsWith(type)) {
                // 释放Blob URL以防止内存泄漏
                if (url && url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
                this.urlCache.delete(key);
            }
        }
    }
}

// 创建全局实例
const imageDisplayHelper = new ImageDisplayHelper();

// 导出到window对象
window.ImageDisplayHelper = imageDisplayHelper;

// 图片显示帮助工具已加载
</script>
    <script>
/**
 * 图片数据迁移管理器
 * 负责将现有的base64图片数据迁移到新的文件存储系统
 */

class ImageMigrationManager {
    constructor() {
        this.imageAPI = null;
        this.isInitialized = false;
    }

    /**
     * 初始化迁移管理器
     */
    async init() {
        if (this.isInitialized) {
            return;
        }

        try {
            // 确保图片存储API已加载
            if (!window.ImageStorageAPI) {
                throw new Error('ImageStorageAPI未加载');
            }

            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
            
            this.isInitialized = true;
            // 图片迁移管理器初始化完成
        } catch (error) {
            console.error('图片迁移管理器初始化失败:', error);
            throw error;
        }
    }

    /**
     * 检查是否需要进行图片数据迁移
     */
    async checkMigrationNeeded() {
        if (!window.db || !window.isIndexedDBReady) {
            return {
                needed: false,
                reason: '数据库未准备就绪'
            };
        }

        try {
            const migrationStatus = {
                needed: false,
                details: {
                    contacts: { count: 0, needsMigration: 0 },
                    userProfile: { count: 0, needsMigration: 0 },
                    emojiImages: { count: 0, needsMigration: 0 },
                    backgrounds: { count: 0, needsMigration: 0 },
                    moments: { count: 0, needsMigration: 0 }
                },
                totalFiles: 0
            };

            // 检查联系人头像
            const contactsData = await this.getDataFromStore('contacts');
            migrationStatus.details.contacts.count = contactsData.length;
            migrationStatus.details.contacts.needsMigration = contactsData.filter(
                contact => contact.avatar && contact.avatar.startsWith('data:') && !contact.avatarFileId
            ).length;

            // 检查用户资料头像
            const userProfileData = await this.getDataFromStore('userProfile');
            migrationStatus.details.userProfile.count = userProfileData.length;
            migrationStatus.details.userProfile.needsMigration = userProfileData.filter(
                profile => profile.avatar && profile.avatar.startsWith('data:') && !profile.avatarFileId
            ).length;

            // 检查表情包图片
            const emojiImagesData = await this.getDataFromStore('emojiImages');
            migrationStatus.details.emojiImages.count = emojiImagesData.length;
            migrationStatus.details.emojiImages.needsMigration = emojiImagesData.filter(
                emoji => emoji.data && emoji.data.startsWith('data:') && !emoji.fileId
            ).length;

            // 检查背景图片 - backgrounds以特殊方式存储为单个记录
            const backgroundsRecord = await this.getBackgroundsRecord();
            let backgroundsCount = 0;
            let backgroundsNeedsMigration = 0;
            
            if (backgroundsRecord && backgroundsRecord.id === 'backgroundsMap') {
                // 检查每个联系人的背景图片
                for (const [contactId, backgroundUrl] of Object.entries(backgroundsRecord)) {
                    if (contactId === 'id') continue; // 跳过id字段
                    backgroundsCount++;
                    if (backgroundUrl && backgroundUrl.startsWith('data:')) {
                        backgroundsNeedsMigration++;
                    }
                }
            }
            
            migrationStatus.details.backgrounds.count = backgroundsCount;
            migrationStatus.details.backgrounds.needsMigration = backgroundsNeedsMigration;

            // 检查朋友圈图片
            const momentsData = await this.getDataFromStore('moments');
            migrationStatus.details.moments.count = momentsData.length;
            migrationStatus.details.moments.needsMigration = momentsData.filter(
                moment => moment.image && moment.image.startsWith('data:') && !moment.imageFileId
            ).length;

            // 计算总计
            migrationStatus.totalFiles = Object.values(migrationStatus.details)
                .reduce((sum, detail) => sum + detail.needsMigration, 0);

            migrationStatus.needed = migrationStatus.totalFiles > 0;

            return migrationStatus;

        } catch (error) {
            console.error('检查迁移状态失败:', error);
            return {
                needed: false,
                error: error.message
            };
        }
    }

    /**
     * 从指定存储获取数据
     */
    async getDataFromStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 获取backgrounds记录（特殊存储结构）
     */
    async getBackgroundsRecord() {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction(['backgrounds'], 'readonly');
            const store = transaction.objectStore('backgrounds');
            const request = store.get('backgroundsMap');

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 更新backgrounds记录（特殊存储结构）
     */
    async updateBackgroundsRecord(backgroundsRecord) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction(['backgrounds'], 'readwrite');
            const store = transaction.objectStore('backgrounds');
            const request = store.put(backgroundsRecord);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 更新存储中的数据
     */
    async updateDataInStore(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const updatePromises = data.map(item => {
                return new Promise((resolveItem, rejectItem) => {
                    const request = store.put(item);
                    request.onsuccess = () => resolveItem();
                    request.onerror = () => rejectItem(request.error);
                });
            });

            Promise.all(updatePromises)
                .then(() => resolve())
                .catch(error => reject(error));
        });
    }

    /**
     * 执行完整的数据迁移
     */
    async performFullMigration(progressCallback = null) {
        await this.init();

        const migrationStatus = await this.checkMigrationNeeded();
        if (!migrationStatus.needed) {
            return {
                success: true,
                message: '无需迁移，所有图片数据已是最新格式',
                results: {}
            };
        }

        const results = {
            contacts: { success: 0, failed: 0, errors: [] },
            userProfile: { success: 0, failed: 0, errors: [] },
            emojiImages: { success: 0, failed: 0, errors: [] },
            backgrounds: { success: 0, failed: 0, errors: [] },
            moments: { success: 0, failed: 0, errors: [] }
        };

        let totalProcessed = 0;
        const totalFiles = migrationStatus.totalFiles;

        try {
            // 迁移联系人头像
            if (migrationStatus.details.contacts.needsMigration > 0) {
                const contactsData = await this.getDataFromStore('contacts');
                const contactsToMigrate = contactsData.filter(
                    contact => contact.avatar && contact.avatar.startsWith('data:') && !contact.avatarFileId
                );

                for (const contact of contactsToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: '联系人头像',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: contact.name || contact.id
                            });
                        }

                        const fileId = await this.imageAPI.storeAvatar(contact.avatar, 'contact', contact.id);
                        contact.avatar = ''; // 清除base64数据
                        contact.avatarFileId = fileId; // 保存文件引用
                        
                        results.contacts.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.contacts.failed++;
                        results.contacts.errors.push({
                            item: contact,
                            error: error.message
                        });
                        console.error('迁移联系人头像失败:', error);
                    }
                }

                // 更新联系人数据
                await this.updateDataInStore('contacts', contactsData);
            }

            // 迁移用户资料头像
            if (migrationStatus.details.userProfile.needsMigration > 0) {
                const userProfileData = await this.getDataFromStore('userProfile');
                const profilesToMigrate = userProfileData.filter(
                    profile => profile.avatar && profile.avatar.startsWith('data:') && !profile.avatarFileId
                );

                for (const profile of profilesToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: '用户头像',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: profile.name || '用户资料'
                            });
                        }

                        const fileId = await this.imageAPI.storeAvatar(profile.avatar, 'user', profile.id);
                        profile.avatar = '';
                        profile.avatarFileId = fileId;
                        
                        results.userProfile.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.userProfile.failed++;
                        results.userProfile.errors.push({
                            item: profile,
                            error: error.message
                        });
                        console.error('迁移用户头像失败:', error);
                    }
                }

                await this.updateDataInStore('userProfile', userProfileData);
            }

            // 迁移表情包图片
            if (migrationStatus.details.emojiImages.needsMigration > 0) {
                const emojiImagesData = await this.getDataFromStore('emojiImages');
                const emojisToMigrate = emojiImagesData.filter(
                    emoji => emoji.data && emoji.data.startsWith('data:') && !emoji.fileId
                );

                for (const emoji of emojisToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: '表情包',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: emoji.tag
                            });
                        }

                        const fileId = await this.imageAPI.storeEmoji(emoji.data, emoji.tag);
                        emoji.data = '';
                        emoji.fileId = fileId;
                        
                        results.emojiImages.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.emojiImages.failed++;
                        results.emojiImages.errors.push({
                            item: emoji,
                            error: error.message
                        });
                        console.error('迁移表情包失败:', error);
                    }
                }

                await this.updateDataInStore('emojiImages', emojiImagesData);
            }

            // 迁移背景图片 - 特殊处理backgrounds的存储结构
            if (migrationStatus.details.backgrounds.needsMigration > 0) {
                const backgroundsRecord = await this.getBackgroundsRecord();
                
                if (backgroundsRecord && backgroundsRecord.id === 'backgroundsMap') {
                    for (const [contactId, backgroundUrl] of Object.entries(backgroundsRecord)) {
                        if (contactId === 'id') continue; // 跳过id字段
                        
                        if (backgroundUrl && backgroundUrl.startsWith('data:')) {
                            try {
                                if (progressCallback) {
                                    progressCallback({
                                        type: '背景图片',
                                        current: totalProcessed + 1,
                                        total: totalFiles,
                                        item: `联系人 ${contactId}`
                                    });
                                }

                                const fileId = await this.imageAPI.storeBackground(backgroundUrl, contactId);
                                
                                // 清空base64数据，标记为已迁移
                                // 迁移后的背景将通过getBackgroundImageURL函数动态获取
                                backgroundsRecord[contactId] = `file:${fileId}`;
                                
                                results.backgrounds.success++;
                                totalProcessed++;
                            } catch (error) {
                                results.backgrounds.failed++;
                                results.backgrounds.errors.push({
                                    item: { contactId, backgroundUrl },
                                    error: error.message
                                });
                                console.error(`迁移背景图片失败 (联系人 ${contactId}):`, error);
                            }
                        }
                    }

                    await this.updateBackgroundsRecord(backgroundsRecord);
                }
            }

            // 迁移朋友圈图片
            if (migrationStatus.details.moments.needsMigration > 0) {
                const momentsData = await this.getDataFromStore('moments');
                const momentsToMigrate = momentsData.filter(
                    moment => moment.image && moment.image.startsWith('data:') && !moment.imageFileId
                );

                for (const moment of momentsToMigrate) {
                    try {
                        if (progressCallback) {
                            progressCallback({
                                type: '朋友圈图片',
                                current: totalProcessed + 1,
                                total: totalFiles,
                                item: moment.authorName || '动态'
                            });
                        }

                        const fileId = await this.imageAPI.storeMomentImage(moment.image, moment.id);
                        moment.image = '';
                        moment.imageFileId = fileId;
                        
                        results.moments.success++;
                        totalProcessed++;
                    } catch (error) {
                        results.moments.failed++;
                        results.moments.errors.push({
                            item: moment,
                            error: error.message
                        });
                        console.error('迁移朋友圈图片失败:', error);
                    }
                }

                await this.updateDataInStore('moments', momentsData);
            }

            // 汇总结果
            const totalSuccess = Object.values(results).reduce((sum, result) => sum + result.success, 0);
            const totalFailed = Object.values(results).reduce((sum, result) => sum + result.failed, 0);

            return {
                success: true,
                message: `迁移完成！成功: ${totalSuccess}, 失败: ${totalFailed}`,
                results: results,
                summary: {
                    totalProcessed: totalSuccess + totalFailed,
                    totalSuccess: totalSuccess,
                    totalFailed: totalFailed
                }
            };

        } catch (error) {
            console.error('数据迁移过程出错:', error);
            return {
                success: false,
                error: error.message,
                results: results
            };
        }
    }

    /**
     * 估算迁移后的存储空间节省
     */
    async estimateStorageSavings(migrationStatus) {
        if (!migrationStatus || !migrationStatus.needed) {
            return {
                estimatedSavings: 0,
                details: {}
            };
        }

        // base64比原始二进制数据大约多33%
        const base64Overhead = 0.33;
        
        // 这里只是一个粗略估算，实际节省取决于具体的图片大小
        const estimatedSavingsPerFile = 50 * 1024; // 假设平均每个文件节省50KB
        const totalEstimatedSavings = migrationStatus.totalFiles * estimatedSavingsPerFile;

        return {
            estimatedSavings: totalEstimatedSavings,
            formattedSavings: this.formatBytes(totalEstimatedSavings),
            details: {
                filesToMigrate: migrationStatus.totalFiles,
                averageSavingsPerFile: estimatedSavingsPerFile,
                base64Overhead: base64Overhead
            }
        };
    }

    /**
     * 格式化字节数
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// 创建全局实例
const imageMigrationManager = new ImageMigrationManager();

// 导出到window对象
window.ImageMigrationManager = imageMigrationManager;

// 图片迁移管理器已加载
</script>
    <script>
/**
 * 聊天记录表情包迁移管理器
 * 专门处理聊天记录中表情包从base64到新文件存储系统的迁移
 */

class ChatEmojiMigrationManager {
    constructor() {
        this.imageAPI = null;
        this.isInitialized = false;
    }

    /**
     * 初始化迁移管理器
     */
    async init() {
        if (this.isInitialized) {
            return;
        }

        try {
            // 确保图片存储API已加载
            if (!window.ImageStorageAPI) {
                throw new Error('ImageStorageAPI未加载');
            }

            this.imageAPI = window.ImageStorageAPI;
            await this.imageAPI.init();
            
            this.isInitialized = true;
            // 聊天记录表情包迁移管理器初始化完成
        } catch (error) {
            console.error('聊天记录表情包迁移管理器初始化失败:', error);
            throw error;
        }
    }

    /**
     * 检查聊天记录中是否存在需要迁移的表情包
     */
    async checkChatEmojiMigrationNeeded() {
        if (!window.db || !window.isIndexedDBReady) {
            return {
                needed: false,
                reason: '数据库未准备就绪'
            };
        }

        try {
            const migrationStatus = {
                needed: false,
                details: {
                    totalContacts: 0,
                    contactsNeedingMigration: 0,
                    totalMessages: 0,
                    messagesNeedingMigration: 0,
                    base64EmojisFound: 0,
                    emojiImagesNeedingMigration: 0
                },
                contactDetails: []
            };

            // 获取所有联系人数据
            const contactsData = await this.getDataFromStore('contacts');
            migrationStatus.details.totalContacts = contactsData.length;

            // 检查每个联系人的聊天记录
            for (const contact of contactsData) {
                if (contact.messages && Array.isArray(contact.messages)) {
                    const contactDetail = {
                        contactId: contact.id,
                        contactName: contact.name,
                        messagesCount: contact.messages.length,
                        base64EmojisCount: 0,
                        needsMigration: false
                    };

                    migrationStatus.details.totalMessages += contact.messages.length;

                    for (const message of contact.messages) {
                        if (message.content && typeof message.content === 'string') {
                            // 检查base64图片
                            const base64Matches = message.content.match(/data:image\/[^;]+;base64,[A-Za-z0-9+\/=]+/g);
                            if (base64Matches) {
                                contactDetail.base64EmojisCount += base64Matches.length;
                                migrationStatus.details.base64EmojisFound += base64Matches.length;
                                contactDetail.needsMigration = true;
                            }
                        }
                    }

                    if (contactDetail.needsMigration) {
                        migrationStatus.details.contactsNeedingMigration++;
                        migrationStatus.details.messagesNeedingMigration += contactDetail.base64EmojisCount;
                        migrationStatus.contactDetails.push(contactDetail);
                    }
                }
            }

            // 检查emojiImages表中是否有数据需要迁移到新系统
            const emojiImagesData = await this.getDataFromStore('emojiImages');
            const emojiImagesNeedingMigration = emojiImagesData.filter(img => img.data && img.data.startsWith('data:'));
            migrationStatus.details.emojiImagesNeedingMigration = emojiImagesNeedingMigration.length;

            // 判断是否需要迁移
            migrationStatus.needed = migrationStatus.details.base64EmojisFound > 0 || 
                                   migrationStatus.details.emojiImagesNeedingMigration > 0;

            return migrationStatus;

        } catch (error) {
            console.error('检查聊天记录表情包迁移状态失败:', error);
            return {
                needed: false,
                error: error.message
            };
        }
    }

    /**
     * 从指定存储获取数据
     */
    async getDataFromStore(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 更新存储中的数据
     */
    async updateDataInStore(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = window.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const updatePromises = data.map(item => {
                return new Promise((resolveItem, rejectItem) => {
                    const request = store.put(item);
                    request.onsuccess = () => resolveItem();
                    request.onerror = () => rejectItem(request.error);
                });
            });

            Promise.all(updatePromises)
                .then(() => resolve())
                .catch(error => reject(error));
        });
    }

    /**
     * 执行聊天记录表情包迁移
     */
    async performChatEmojiMigration(progressCallback = null) {
        await this.init();

        const migrationStatus = await this.checkChatEmojiMigrationNeeded();
        if (!migrationStatus.needed) {
            return {
                success: true,
                message: '无需迁移，聊天记录中的表情包已是最新格式',
                results: {}
            };
        }

        const results = {
            contactsMigrated: 0,
            messagesMigrated: 0,
            emojiImagesMigrated: 0,
            base64EmojisMigrated: 0,
            errors: []
        };

        let totalProcessed = 0;
        const totalItems = migrationStatus.details.base64EmojisFound + 
                          migrationStatus.details.emojiImagesNeedingMigration;

        try {
            // 第一步：迁移emojiImages表中的数据到新的文件存储
            const emojiImagesData = await this.getDataFromStore('emojiImages');
            const emojiImagesNeedingMigration = emojiImagesData.filter(img => img.data && img.data.startsWith('data:'));

            for (const emojiImage of emojiImagesNeedingMigration) {
                try {
                    if (progressCallback) {
                        progressCallback({
                            type: '表情包图片',
                            current: totalProcessed + 1,
                            total: totalItems,
                            item: emojiImage.tag
                        });
                    }

                    // 将base64数据迁移到新的文件存储
                    const fileId = await this.imageAPI.storeEmoji(emojiImage.data, emojiImage.tag);
                    
                    // 更新emojiImage记录
                    emojiImage.data = ''; // 清除base64数据
                    emojiImage.fileId = fileId; // 保存文件引用
                    
                    results.emojiImagesMigrated++;
                    totalProcessed++;

                } catch (error) {
                    results.errors.push({
                        type: 'emojiImage',
                        item: emojiImage,
                        error: error.message
                    });
                    console.error('迁移表情图片失败:', error);
                }
            }

            // 更新emojiImages数据
            if (emojiImagesNeedingMigration.length > 0) {
                await this.updateDataInStore('emojiImages', emojiImagesData);
            }

            // 第二步：迁移联系人聊天记录中的base64表情包
            const contactsData = await this.getDataFromStore('contacts');
            const contactsNeedingMigration = migrationStatus.contactDetails;

            for (const contactDetail of contactsNeedingMigration) {
                const contact = contactsData.find(c => c.id === contactDetail.contactId);
                if (!contact || !contact.messages) continue;

                let contactModified = false;

                for (const message of contact.messages) {
                    if (message.content && typeof message.content === 'string') {
                        // 查找所有base64图片
                        const base64Matches = message.content.match(/data:image\/[^;]+;base64,[A-Za-z0-9+\/=]+/g);
                        if (base64Matches) {
                            let newContent = message.content;

                            for (const base64Url of base64Matches) {
                                try {
                                    if (progressCallback) {
                                        progressCallback({
                                            type: '聊天表情',
                                            current: totalProcessed + 1,
                                            total: totalItems,
                                            item: `${contact.name}的消息`
                                        });
                                    }

                                    // 查找是否存在对应的表情记录
                                    const existingEmoji = await this.findEmojiByBase64(base64Url);
                                    let emojiTag;

                                    if (existingEmoji && existingEmoji.meaning) {
                                        emojiTag = existingEmoji.meaning;
                                        
                                        // 确保该表情的图片已经迁移到新系统
                                        if (!existingEmoji.tag) {
                                            existingEmoji.tag = existingEmoji.meaning;
                                        }
                                        
                                        // 如果还没有fileId，为其创建
                                        if (!await this.hasEmojiFileId(emojiTag)) {
                                            await this.imageAPI.storeEmoji(base64Url, emojiTag);
                                        }
                                    } else {
                                        // 创建临时标签
                                        emojiTag = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                                        await this.imageAPI.storeEmoji(base64Url, emojiTag);
                                        
                                        // 添加到emojis数组
                                        window.emojis.push({
                                            id: Date.now().toString(),
                                            meaning: emojiTag,
                                            tag: emojiTag,
                                            url: '' // 清空URL，使用新的文件存储
                                        });
                                    }

                                    // 替换聊天记录中的base64为标签格式
                                    newContent = newContent.replace(base64Url, `[emoji:${emojiTag}]`);
                                    
                                    results.base64EmojisMigrated++;
                                    totalProcessed++;
                                    contactModified = true;

                                } catch (error) {
                                    results.errors.push({
                                        type: 'chatEmoji',
                                        contactId: contact.id,
                                        error: error.message
                                    });
                                    console.error('迁移聊天表情失败:', error);
                                }
                            }

                            message.content = newContent;
                        }
                    }
                }

                if (contactModified) {
                    results.contactsMigrated++;
                    results.messagesMigrated += contactDetail.base64EmojisCount;
                }
            }

            // 更新联系人数据
            await this.updateDataInStore('contacts', contactsData);

            // 更新全局emojis数组
            await this.updateDataInStore('emojis', window.emojis);

            return {
                success: true,
                message: `聊天记录表情包迁移完成！迁移了${results.base64EmojisMigrated}个表情，涉及${results.contactsMigrated}个联系人`,
                results: results
            };

        } catch (error) {
            console.error('聊天记录表情包迁移过程出错:', error);
            return {
                success: false,
                error: error.message,
                results: results
            };
        }
    }

    /**
     * 通过base64 URL查找对应的表情记录
     */
    async findEmojiByBase64(base64Url) {
        if (!window.emojis || !Array.isArray(window.emojis)) {
            return null;
        }

        return window.emojis.find(emoji => emoji.url === base64Url);
    }

    /**
     * 检查表情是否已经有对应的fileId
     */
    async hasEmojiFileId(emojiTag) {
        try {
            const reference = await window.FileStorageManager.getFileReference('emoji', emojiTag);
            return !!reference;
        } catch (error) {
            return false;
        }
    }

    /**
     * 估算迁移效果
     */
    async estimateMigrationBenefits(migrationStatus) {
        if (!migrationStatus || !migrationStatus.needed) {
            return {
                spaceSavings: 0,
                performanceImprovement: '无',
                details: {}
            };
        }

        // 估算空间节省（base64比原始数据大约多33%）
        const estimatedSavingsPerEmoji = 30 * 1024; // 假设平均每个表情节省30KB
        const totalEmojis = migrationStatus.details.base64EmojisFound + 
                           migrationStatus.details.emojiImagesNeedingMigration;
        const totalSavings = totalEmojis * estimatedSavingsPerEmoji;

        return {
            spaceSavings: totalSavings,
            formattedSavings: this.formatBytes(totalSavings),
            performanceImprovement: '中等',
            details: {
                totalEmojisToMigrate: totalEmojis,
                averageSavingsPerEmoji: estimatedSavingsPerEmoji,
                contactsAffected: migrationStatus.details.contactsNeedingMigration
            }
        };
    }

    /**
     * 格式化字节数
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// 创建全局实例
const chatEmojiMigrationManager = new ChatEmojiMigrationManager();

// 导出到window对象
window.ChatEmojiMigrationManager = chatEmojiMigrationManager;

// 聊天记录表情包迁移管理器已加载
</script>
    <script>
/**
 * 语音存储API
 * 用于缓存语音文件，避免重复请求TTS API
 */

class VoiceStorageAPI {
    constructor() {
        this.fileStorageManager = null;
        this.initPromise = this.init();
    }

    /**
     * 初始化语音存储API
     */
    async init() {
        // 等待UnifiedDBManager初始化
        if (window.unifiedDB) {
            this.fileStorageManager = window.unifiedDB;
            await this.fileStorageManager.init();
        } else if (window.FileStorageManager) {
            // 向后兼容
            this.fileStorageManager = window.FileStorageManager;
            await this.fileStorageManager.init();
        } else {
            throw new Error('UnifiedDBManager未初始化');
        }
    }

    /**
     * 生成语音缓存键
     * 基于文本内容和语音ID生成唯一标识
     */
    generateVoiceCacheKey(text, voiceId) {
        // 清理文本：去除换行、多余空格，转为小写以提高缓存命中率
        const cleanText = text.trim().toLowerCase().replace(/\s+/g, ' ');
        // 使用简单的哈希算法生成固定长度的键
        const textHash = this.simpleHash(cleanText);
        return `voice_${voiceId}_${textHash}`;
    }

    /**
     * 简单哈希函数
     */
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转为32位整数
        }
        return Math.abs(hash).toString(36);
    }

    /**
     * 存储语音文件
     * @param {Blob} audioBlob - 音频数据
     * @param {string} text - 原始文本
     * @param {string} voiceId - 语音ID
     * @param {Object} metadata - 元数据
     * @returns {Promise<string>} fileId
     */
    async storeVoice(audioBlob, text, voiceId, metadata = {}) {
        await this.initPromise;
        
        try {
            // 存储文件到FileStorage
            const storeResult = await this.fileStorageManager.storeFile(audioBlob, {
                originalText: text,
                voiceId: voiceId,
                type: 'voice',
                ...metadata
            });

            // 创建引用关系
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            await this.fileStorageManager.createFileReference(
                storeResult.fileId,
                'voice',
                cacheKey,
                {
                    text: text,
                    voiceId: voiceId,
                    createdAt: new Date().toISOString()
                }
            );

            console.log('语音文件存储成功:', {
                fileId: storeResult.fileId,
                cacheKey: cacheKey,
                textLength: text.length,
                voiceId: voiceId
            });

            return storeResult.fileId;
        } catch (error) {
            console.error('语音文件存储失败:', error);
            throw error;
        }
    }

    /**
     * 获取缓存的语音文件URL
     * @param {string} text - 文本内容
     * @param {string} voiceId - 语音ID
     * @returns {Promise<string|null>} 语音文件URL或null
     */
    async getVoiceURL(text, voiceId) {
        await this.initPromise;
        
        try {
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            console.log('查找语音缓存:', { cacheKey, textLength: text.length, voiceId });
            
            // 查找文件引用
            const reference = await this.fileStorageManager.getFileReference('voice', cacheKey);
            
            if (!reference) {
                console.log('语音缓存未找到');
                return null;
            }

            // 创建文件URL
            const url = await this.fileStorageManager.createFileURL(reference.fileId);
            console.log('语音缓存命中:', { fileId: reference.fileId, url: url ? '已生成' : '生成失败' });
            
            return url;
        } catch (error) {
            console.error('获取语音缓存失败:', error);
            return null;
        }
    }

    /**
     * 检查语音是否已缓存
     * @param {string} text - 文本内容
     * @param {string} voiceId - 语音ID
     * @returns {Promise<boolean>}
     */
    async isVoiceCached(text, voiceId) {
        await this.initPromise;
        
        try {
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            const reference = await this.fileStorageManager.getFileReference('voice', cacheKey);
            return !!reference;
        } catch (error) {
            console.error('检查语音缓存失败:', error);
            return false;
        }
    }

    /**
     * 删除语音缓存
     * @param {string} text - 文本内容
     * @param {string} voiceId - 语音ID
     * @returns {Promise<boolean>}
     */
    async deleteVoiceCache(text, voiceId) {
        await this.initPromise;
        
        try {
            const cacheKey = this.generateVoiceCacheKey(text, voiceId);
            const reference = await this.fileStorageManager.getFileReference('voice', cacheKey);
            
            if (reference) {
                // 删除文件引用
                await this.fileStorageManager.deleteFileReference('voice', cacheKey);
                // 删除文件本身
                await this.fileStorageManager.deleteFile(reference.fileId);
                console.log('语音缓存删除成功:', cacheKey);
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('删除语音缓存失败:', error);
            return false;
        }
    }

    /**
     * 获取语音缓存统计信息
     * @returns {Promise<Object>}
     */
    async getVoiceCacheStats() {
        await this.initPromise;
        
        try {
            // 获取所有语音类型的引用
            const transaction = this.fileStorageManager.db.transaction(['fileReferences'], 'readonly');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('voice');

            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const voiceReferences = request.result;
                    const stats = {
                        totalVoices: voiceReferences.length,
                        voiceByVoiceId: {},
                        oldestCache: null,
                        newestCache: null
                    };

                    voiceReferences.forEach(ref => {
                        const voiceId = ref.metadata?.voiceId || 'unknown';
                        if (!stats.voiceByVoiceId[voiceId]) {
                            stats.voiceByVoiceId[voiceId] = 0;
                        }
                        stats.voiceByVoiceId[voiceId]++;

                        const createdAt = new Date(ref.createdAt);
                        if (!stats.oldestCache || createdAt < new Date(stats.oldestCache)) {
                            stats.oldestCache = ref.createdAt;
                        }
                        if (!stats.newestCache || createdAt > new Date(stats.newestCache)) {
                            stats.newestCache = ref.createdAt;
                        }
                    });

                    resolve(stats);
                };

                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('获取语音缓存统计失败:', error);
            return {
                totalVoices: 0,
                voiceByVoiceId: {},
                oldestCache: null,
                newestCache: null
            };
        }
    }

    /**
     * 清理过期的语音缓存
     * @param {number} daysOld - 清理多少天前的缓存
     * @returns {Promise<Object>}
     */
    async cleanupOldVoiceCache(daysOld = 30) {
        await this.initPromise;
        
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysOld);

            const transaction = this.fileStorageManager.db.transaction(['fileReferences'], 'readonly');
            const store = transaction.objectStore('fileReferences');
            const index = store.index('category');
            const request = index.getAll('voice');

            return new Promise((resolve, reject) => {
                request.onsuccess = async () => {
                    const voiceReferences = request.result;
                    const oldReferences = voiceReferences.filter(ref => 
                        new Date(ref.createdAt) < cutoffDate
                    );

                    let deletedCount = 0;
                    let errors = 0;

                    for (const ref of oldReferences) {
                        try {
                            await this.fileStorageManager.deleteFileReference('voice', ref.referenceKey);
                            await this.fileStorageManager.deleteFile(ref.fileId);
                            deletedCount++;
                        } catch (error) {
                            console.error('删除过期语音缓存失败:', ref.referenceId, error);
                            errors++;
                        }
                    }

                    resolve({
                        deletedCount,
                        errors,
                        message: `清理完成，删除了 ${deletedCount} 个过期语音缓存，${errors} 个删除失败`
                    });
                };

                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('清理过期语音缓存失败:', error);
            return { deletedCount: 0, errors: 1, message: '清理失败' };
        }
    }
}

// 创建全局实例
const voiceStorageAPI = new VoiceStorageAPI();

// 导出到window对象供其他模块使用
window.VoiceStorageAPI = voiceStorageAPI;

console.log('语音存储API已加载');
</script>
    <script>
/**
 * 文件存储导出器
 * 专门处理图片、表情包、背景等文件数据的导入导出
 * 支持ZIP格式打包，保持原始文件格式
 */

class FileStorageExporter {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.dbVersion = 14;
        this.db = null;
        this.fileManager = null;
        
        // 支持的文件类型
        this.supportedFileTypes = ['avatar', 'background', 'emoji', 'moment', 'banner'];
        
        // 文件夹映射
        this.folderMapping = {
            'avatar_contact': 'avatars',
            'avatar_user': 'user_avatars', 
            'background': 'backgrounds',
            'emoji': 'emojis',
            'moment_image': 'moments',
            'banner': 'banners'
        };

        // 文件扩展名映射
        this.mimeToExtension = {
            'image/jpeg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.webp',
            'image/bmp': '.bmp',
            'image/svg+xml': '.svg',
            'image/jpg': '.jpg'
        };
    }

    /**
     * 初始化
     */
    async init() {
        if (!this.db) {
            if (window.db && window.isIndexedDBReady) {
                this.db = window.db;
            } else {
                throw new Error('数据库未初始化');
            }
        }

        if (!this.fileManager) {
            if (window.unifiedDB) {
                this.fileManager = window.unifiedDB;
                await this.fileManager.init();
            } else {
                throw new Error('UnifiedDBManager未加载');
            }
        }

        return true;
    }

    /**
     * 导出所有文件存储数据为ZIP格式
     * @param {Object} options - 导出选项
     * @returns {Object} 导出结果
     */
    async exportFileStorageAsZip(options = {}) {
        await this.init();
        
        const {
            includeAvatars = true,
            includeBackgrounds = true,
            includeEmojis = true,
            includeMoments = true
        } = options;

        try {
            // 加载JSZip库
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip库未加载，请确保页面中包含了JSZip');
            }

            const zip = new JSZip();
            
            // 创建元数据
            const metadata = {
                exportTime: new Date().toISOString(),
                version: this.dbVersion,
                format: 'file_storage_zip_export',
                description: '文件存储ZIP导出包',
                structure: {
                    avatars: '用户和联系人头像',
                    user_avatars: '用户头像',
                    backgrounds: '聊天背景图片', 
                    emojis: '表情包图片',
                    moments: '朋友圈图片'
                }
            };

            const statistics = {
                totalFiles: 0,
                totalSize: 0,
                folderBreakdown: {}
            };

            // 获取所有文件存储数据
            const allFiles = await this.getAllFiles();
            const allReferences = await this.getAllReferences();

            // 按类型处理文件
            for (const file of allFiles) {
                const references = allReferences.filter(ref => ref.fileId === file.fileId);
                
                for (const reference of references) {
                    const category = reference.category;
                    
                    // 根据选项过滤
                    if (!this.shouldIncludeCategory(category, {
                        includeAvatars,
                        includeBackgrounds,
                        includeEmojis,
                        includeMoments
                    })) {
                        continue;
                    }

                    // 确定文件夹和文件名
                    const folderName = this.folderMapping[category] || 'others';
                    const extension = this.getFileExtension(file.type);
                    const fileName = this.generateFileName(reference, extension);
                    const filePath = `${folderName}/${fileName}`;

                    // 确保文件数据是JSZip支持的格式
                    let fileData = file.blob;
                    
                    // 检查blob数据类型并转换为ArrayBuffer
                    if (fileData instanceof Blob) {
                        try {
                            // 将Blob转换为ArrayBuffer，这是JSZip最兼容的格式
                            fileData = await fileData.arrayBuffer();
                        } catch (blobError) {
                            console.warn(`无法转换Blob为ArrayBuffer，文件: ${filePath}`, blobError);
                            // 尝试读取为base64再转换
                            try {
                                const base64 = await this.blobToBase64(fileData);
                                const base64Data = base64.split(',')[1];
                                const byteCharacters = atob(base64Data);
                                const byteNumbers = new Uint8Array(byteCharacters.length);
                                for (let i = 0; i < byteCharacters.length; i++) {
                                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                                }
                                fileData = byteNumbers.buffer;
                            } catch (base64Error) {
                                console.error(`文件数据转换失败，跳过文件: ${filePath}`, base64Error);
                                continue;
                            }
                        }
                    } else if (typeof fileData === 'string') {
                        // 如果是字符串，可能是base64格式
                        if (fileData.startsWith('data:')) {
                            const base64Data = fileData.split(',')[1];
                            const byteCharacters = atob(base64Data);
                            const byteNumbers = new Uint8Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            fileData = byteNumbers.buffer;
                        } else {
                            console.error(`不支持的字符串格式，跳过文件: ${filePath}`);
                            continue;
                        }
                    } else if (!(fileData instanceof ArrayBuffer) && !ArrayBuffer.isView(fileData)) {
                        console.error(`不支持的文件数据类型: ${typeof fileData}，跳过文件: ${filePath}`);
                        continue;
                    }

                    // 添加文件到ZIP - 使用ArrayBuffer格式
                    zip.file(filePath, fileData);

                    // 创建文件信息记录
                    const fileInfo = {
                        originalPath: filePath,
                        fileId: file.fileId,
                        type: file.type,
                        size: file.size,
                        createdAt: file.createdAt,
                        reference: {
                            category: reference.category,
                            referenceKey: reference.referenceKey,
                            referenceId: reference.referenceId,
                            metadata: reference.metadata || {}
                        }
                    };

                    // 添加到元数据的文件列表
                    if (!metadata.files) {
                        metadata.files = {};
                    }
                    if (!metadata.files[folderName]) {
                        metadata.files[folderName] = [];
                    }
                    metadata.files[folderName].push(fileInfo);

                    // 更新统计信息
                    statistics.totalFiles++;
                    statistics.totalSize += file.size;
                    
                    if (!statistics.folderBreakdown[folderName]) {
                        statistics.folderBreakdown[folderName] = { count: 0, size: 0 };
                    }
                    statistics.folderBreakdown[folderName].count++;
                    statistics.folderBreakdown[folderName].size += file.size;
                }
            }

            // 添加元数据和统计信息到ZIP
            metadata.statistics = statistics;
            zip.file('metadata.json', JSON.stringify(metadata, null, 2));

            console.log('文件存储ZIP导出完成:', statistics);

            return {
                zip: zip,
                metadata: metadata,
                statistics: statistics
            };

        } catch (error) {
            console.error('导出文件存储ZIP失败:', error);
            throw new Error(`导出失败: ${error.message}`);
        }
    }

    /**
     * 导入文件存储数据
     * @param {Object} importData - 导入的数据
     * @param {Object} options - 导入选项
     * @returns {Object} 导入结果
     */
    async importFileStorage(importData, options = {}) {
        await this.init();
        
        const {
            overwrite = false,
            autoMatch = true,
            createMissing = true
        } = options;

        try {
            // 验证导入数据格式
            const validation = this.validateImportData(importData);
            if (!validation.valid) {
                throw new Error(`数据格式无效: ${validation.error}`);
            }

            const importResults = {
                success: 0,
                failed: 0,
                matched: 0,
                created: 0,
                errors: [],
                summary: {}
            };

            // 按类型处理导入
            for (const [groupKey, files] of Object.entries(importData.files)) {
                console.log(`开始导入 ${groupKey} 类型文件，共 ${files.length} 个`);
                
                const groupResult = await this.importFileGroup(
                    groupKey, 
                    files, 
                    { overwrite, autoMatch, createMissing }
                );
                
                // 合并结果
                importResults.success += groupResult.success;
                importResults.failed += groupResult.failed;
                importResults.matched += groupResult.matched;
                importResults.created += groupResult.created;
                importResults.errors.push(...groupResult.errors);
                importResults.summary[groupKey] = groupResult;
            }

            console.log('文件存储导入完成:', importResults);
            return { success: true, results: importResults };

        } catch (error) {
            console.error('导入文件存储失败:', error);
            throw new Error(`导入失败: ${error.message}`);
        }
    }

    /**
     * 导入一组文件
     */
    async importFileGroup(groupKey, files, options) {
        const results = {
            success: 0,
            failed: 0,
            matched: 0,
            created: 0,
            errors: []
        };

        for (const fileRecord of files) {
            try {
                // 检查是否已存在
                const existingReference = await this.fileManager.getFileReference(
                    fileRecord.reference.category,
                    fileRecord.reference.referenceKey
                );

                let shouldImport = true;
                let isMatched = false;

                if (existingReference) {
                    if (!options.overwrite) {
                        // 已存在且不覆盖，跳过
                        results.matched++;
                        isMatched = true;
                        shouldImport = false;
                    } else {
                        // 删除现有文件和引用
                        await this.fileManager.deleteFile(existingReference.fileId);
                        await this.fileManager.deleteFileReference(
                            fileRecord.reference.category,
                            fileRecord.reference.referenceKey
                        );
                    }
                }

                if (shouldImport) {
                    // 转换base64为Blob
                    const blob = this.base64ToBlob(fileRecord.data);
                    
                    // 存储新文件
                    const storeResult = await this.fileManager.storeFile(blob, fileRecord.metadata);
                    
                    // 创建引用
                    await this.fileManager.createFileReference(
                        storeResult.fileId,
                        fileRecord.reference.category,
                        fileRecord.reference.referenceKey,
                        fileRecord.reference.metadata
                    );

                    if (isMatched) {
                        results.matched++;
                    } else {
                        results.created++;
                    }
                    results.success++;
                }

            } catch (error) {
                results.failed++;
                results.errors.push({
                    fileRecord: fileRecord,
                    error: error.message
                });
                console.error(`导入文件失败:`, error, fileRecord);
            }
        }

        return results;
    }

    /**
     * 下载文件存储数据为ZIP格式
     */
    async downloadFileStorageAsZip(options = {}) {
        try {
            const { zip, statistics } = await this.exportFileStorageAsZip(options);
            
            // 生成ZIP文件
            const zipBlob = await zip.generateAsync({ 
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: {
                    level: 6
                }
            });
            
            // 下载ZIP文件
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `whale-files-${timestamp}.zip`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            
            return { 
                success: true, 
                message: `文件存储导出成功！导出了 ${statistics.totalFiles} 个文件，总大小 ${this.formatBytes(statistics.totalSize)}`,
                statistics: statistics
            };
            
        } catch (error) {
            console.error('下载ZIP文件失败:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * 从文件读取并导入
     */
    async importFromFile(file, options = {}) {
        try {
            const importData = await this.readImportFile(file);
            return await this.importFileStorage(importData, options);
        } catch (error) {
            throw new Error(`从文件导入失败: ${error.message}`);
        }
    }

    // === 辅助方法 ===

    /**
     * 获取所有文件
     */
    async getAllFiles() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['fileStorage'], 'readonly');
            const store = transaction.objectStore('fileStorage');
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 获取所有引用
     */
    async getAllReferences() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['fileReferences'], 'readonly');
            const store = transaction.objectStore('fileReferences');
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 判断是否应该包含某个分类
     */
    shouldIncludeCategory(category, options) {
        switch (category) {
            case 'avatar_contact':
            case 'avatar_user':
                return options.includeAvatars;
            case 'background':
                return options.includeBackgrounds;
            case 'emoji':
                return options.includeEmojis;
            case 'moment_image':
                return options.includeMoments;
            default:
                return true;
        }
    }

    /**
     * 获取文件扩展名
     */
    getFileExtension(mimeType) {
        return this.mimeToExtension[mimeType] || '.jpg';
    }

    /**
     * 生成文件名
     */
    generateFileName(reference, extension) {
        // 使用引用键作为基础文件名，确保安全
        let baseName = reference.referenceKey || reference.fileId || 'unknown';
        
        // 清理文件名中的非法字符
        baseName = baseName.replace(/[<>:"/\\|?*]/g, '_');
        
        // 如果文件名太长，截取前50个字符
        if (baseName.length > 50) {
            baseName = baseName.substring(0, 50);
        }
        
        return baseName + extension;
    }

    /**
     * 格式化字节数
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * 获取文件分组键
     */
    getFileGroupKey(category) {
        return this.folderMapping[category] || category;
    }

    /**
     * 获取相关引用信息
     */
    async getRelatedReferences(allReferences) {
        const references = {};
        
        for (const ref of allReferences) {
            const groupKey = this.getFileGroupKey(ref.category);
            if (!references[groupKey]) {
                references[groupKey] = [];
            }
            references[groupKey].push({
                referenceId: ref.referenceId,
                category: ref.category,
                referenceKey: ref.referenceKey,
                fileId: ref.fileId
            });
        }
        
        return references;
    }

    /**
     * Blob转base64
     */
    async blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    /**
     * base64转Blob
     */
    base64ToBlob(base64String) {
        try {
            const [header, data] = base64String.split(',');
            const mimeMatch = header.match(/data:([^;]+);base64/);
            const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';
            
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            throw new Error(`base64转换失败: ${error.message}`);
        }
    }

    /**
     * 验证导入数据
     */
    validateImportData(importData) {
        if (!importData || typeof importData !== 'object') {
            return { valid: false, error: '数据格式无效' };
        }

        if (!importData._metadata) {
            return { valid: false, error: '缺少元数据' };
        }

        if (importData._metadata.format !== 'file_storage_export') {
            return { valid: false, error: '文件格式不匹配，这不是文件存储导出文件' };
        }

        if (!importData.files || typeof importData.files !== 'object') {
            return { valid: false, error: '缺少文件数据' };
        }

        return { valid: true };
    }

    /**
     * 读取导入文件
     */
    async readImportFile(file) {
        return new Promise((resolve, reject) => {
            if (!file) {
                reject(new Error('请选择要导入的文件'));
                return;
            }
            
            if (!file.name.endsWith('.json')) {
                reject(new Error('只支持 JSON 格式的文件存储导出文件'));
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const data = JSON.parse(text);
                    resolve(data);
                } catch (error) {
                    reject(new Error('文件格式错误，无法解析 JSON'));
                }
            };
            
            reader.onerror = () => {
                reject(new Error('文件读取失败'));
            };
            
            reader.readAsText(file, 'utf-8');
        });
    }

    /**
     * 获取存储统计信息
     */
    async getStorageStatistics() {
        await this.init();
        
        const stats = await this.fileManager.getStorageStats();
        const allReferences = await this.getAllReferences();
        
        // 按类型分类统计
        const categoryStats = {};
        for (const ref of allReferences) {
            const groupKey = this.getFileGroupKey(ref.category);
            if (!categoryStats[groupKey]) {
                categoryStats[groupKey] = { count: 0, references: [] };
            }
            categoryStats[groupKey].count++;
            categoryStats[groupKey].references.push(ref);
        }
        
        return {
            ...stats,
            categoryBreakdown: categoryStats,
            totalReferences: allReferences.length
        };
    }
}

// 创建全局实例
const fileStorageExporter = new FileStorageExporter();

// 导出到window对象
window.FileStorageExporter = fileStorageExporter;
</script>
    <script>
/**
 * 文件存储导入器
 * 专门处理文件存储数据的智能导入和匹配
 */

class FileStorageImporter {
    constructor() {
        this.dbName = 'WhaleLLTDB';
        this.dbVersion = 14;
        this.db = null;
        this.fileManager = null;
        
        // 自动匹配规则
        this.matchingRules = {
            // 头像匹配规则
            avatars: {
                keyFields: ['id', 'name', 'contactId'],
                tolerance: 0.8, // 匹配容忍度
                autoCreate: true
            },
            // 背景匹配规则
            backgrounds: {
                keyFields: ['contactId', 'id'],
                tolerance: 0.9,
                autoCreate: true
            },
            // 表情包匹配规则
            emojis: {
                keyFields: ['tag', 'meaning'],
                tolerance: 0.95,
                autoCreate: true
            },
            // 朋友圈图片匹配规则
            moments: {
                keyFields: ['momentId', 'id', 'timestamp'],
                tolerance: 0.8,
                autoCreate: false // 朋友圈图片不自动创建
            }
        };
    }

    /**
     * 初始化
     */
    async init() {
        if (!this.db) {
            if (window.db && window.isIndexedDBReady) {
                this.db = window.db;
            } else {
                throw new Error('数据库未初始化');
            }
        }

        if (!this.fileManager) {
            if (window.unifiedDB) {
                this.fileManager = window.unifiedDB;
                await this.fileManager.init();
            } else {
                throw new Error('UnifiedDBManager未加载');
            }
        }

        return true;
    }

    /**
     * 从ZIP文件导入文件存储数据
     * @param {File} zipFile - ZIP文件
     * @param {Object} options - 导入选项
     * @returns {Object} 导入结果
     */
    async importFromZipFile(zipFile, options = {}) {
        try {
            // 加载JSZip库
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip库未加载，请确保页面中包含了JSZip');
            }

            const zip = new JSZip();
            const zipContent = await zip.loadAsync(zipFile);

            // 读取元数据
            const metadataFile = zipContent.file('metadata.json');
            if (!metadataFile) {
                throw new Error('ZIP文件中缺少metadata.json文件');
            }

            const metadataText = await metadataFile.async('text');
            const metadata = JSON.parse(metadataText);

            // 验证格式
            if (metadata.format !== 'file_storage_zip_export') {
                throw new Error('不是有效的文件存储ZIP导出文件');
            }

            // 执行导入
            return await this.importFromZipContent(zipContent, metadata, options);

        } catch (error) {
            console.error('从ZIP文件导入失败:', error);
            throw new Error(`导入失败: ${error.message}`);
        }
    }

    /**
     * 从ZIP内容导入
     */
    async importFromZipContent(zipContent, metadata, options) {
        await this.init();
        
        const {
            autoMatch = true,
            overwrite = false,
            createMissing = true,
            matchTolerance = 0.8,
            progressCallback = null
        } = options;

        const importResults = {
            totalFiles: 0,
            processed: 0,
            matched: 0,
            created: 0,
            skipped: 0,
            failed: 0,
            errors: [],
            matchingDetails: {},
            summary: {}
        };

        // 获取现有数据用于匹配
        const existingData = await this.getExistingData();
        
        // 计算总文件数
        const totalFiles = Object.values(metadata.files || {})
            .reduce((sum, files) => sum + files.length, 0);
        importResults.totalFiles = totalFiles;

        // 按文件夹处理导入
        for (const [folderName, files] of Object.entries(metadata.files || {})) {
            if (progressCallback) {
                progressCallback({
                    phase: 'processing',
                    folderName,
                    totalFolders: Object.keys(metadata.files).length,
                    currentFolder: Object.keys(importResults.summary).length + 1
                });
            }

            const folderResult = await this.processZipFolder(
                folderName,
                files,
                zipContent,
                existingData,
                {
                    autoMatch,
                    overwrite,
                    createMissing,
                    matchTolerance,
                    progressCallback
                }
            );

            // 合并结果
            importResults.processed += folderResult.processed;
            importResults.matched += folderResult.matched;
            importResults.created += folderResult.created;
            importResults.skipped += folderResult.skipped;
            importResults.failed += folderResult.failed;
            importResults.errors.push(...folderResult.errors);
            importResults.matchingDetails[folderName] = folderResult.matchingDetails;
            importResults.summary[folderName] = folderResult;
        }

        console.log('ZIP文件导入完成:', importResults);
        return { success: true, results: importResults };
    }

    /**
     * 处理ZIP文件夹中的文件
     */
    async processZipFolder(folderName, files, zipContent, existingData, options) {
        const results = {
            processed: 0,
            matched: 0,
            created: 0,
            skipped: 0,
            failed: 0,
            errors: [],
            matchingDetails: []
        };

        const matchingRule = this.getMatchingRuleByFolder(folderName);
        
        for (const fileInfo of files) {
            try {
                results.processed++;
                
                if (options.progressCallback) {
                    options.progressCallback({
                        phase: 'importing',
                        folderName,
                        current: results.processed,
                        total: files.length,
                        file: fileInfo
                    });
                }

                // 从ZIP中读取文件
                const zipFile = zipContent.file(fileInfo.originalPath);
                if (!zipFile) {
                    throw new Error(`找不到文件: ${fileInfo.originalPath}`);
                }

                const fileBlob = await zipFile.async('blob');

                // 尝试匹配现有数据
                const matchResult = options.autoMatch ? 
                    await this.findBestMatchFromFileInfo(fileInfo, existingData, folderName, matchingRule) :
                    null;

                let importAction = 'create';
                let shouldImport = true;
                let matchingDetails = null;

                if (matchResult && matchResult.score >= options.matchTolerance) {
                    matchingDetails = matchResult;
                    
                    // 检查是否已存在文件
                    const existingReference = await this.fileManager.getFileReference(
                        fileInfo.reference.category,
                        matchResult.match.referenceKey || fileInfo.reference.referenceKey
                    );

                    if (existingReference) {
                        if (options.overwrite) {
                            // 删除现有文件
                            await this.fileManager.deleteFile(existingReference.fileId);
                            await this.fileManager.deleteFileReference(
                                fileInfo.reference.category,
                                existingReference.referenceKey
                            );
                            importAction = 'replace';
                        } else {
                            // 跳过已存在的文件
                            results.skipped++;
                            results.matched++;
                            shouldImport = false;
                            importAction = 'skip';
                        }
                    } else {
                        importAction = 'match_create';
                        results.matched++;
                    }
                } else if (!options.createMissing && !matchingRule.autoCreate) {
                    // 没有匹配且不允许创建新文件
                    results.skipped++;
                    shouldImport = false;
                    importAction = 'skip_no_match';
                }

                if (shouldImport) {
                    // 执行导入
                    await this.importSingleFileFromBlob(fileInfo, fileBlob, matchResult);
                    
                    if (importAction === 'create' || importAction === 'match_create') {
                        results.created++;
                    }
                }

                // 记录匹配详情
                results.matchingDetails.push({
                    originalPath: fileInfo.originalPath,
                    referenceKey: fileInfo.reference.referenceKey,
                    action: importAction,
                    matchScore: matchResult?.score || 0,
                    matchedItem: matchResult?.match || null,
                    success: true
                });

            } catch (error) {
                results.failed++;
                results.errors.push({
                    fileInfo: fileInfo,
                    error: error.message
                });
                
                results.matchingDetails.push({
                    originalPath: fileInfo.originalPath,
                    referenceKey: fileInfo.reference.referenceKey,
                    action: 'error',
                    error: error.message,
                    success: false
                });
                
                console.error(`导入文件失败:`, error, fileInfo);
            }
        }

        return results;
    }

    /**
     * 智能导入文件存储数据（兼容原有的JSON格式）
     * @param {Object} importData - 导入的数据
     * @param {Object} options - 导入选项
     * @returns {Object} 导入结果
     */
    async smartImport(importData, options = {}) {
        await this.init();
        
        const {
            autoMatch = true,
            overwrite = false,
            createMissing = true,
            matchTolerance = 0.8,
            progressCallback = null
        } = options;

        try {
            // 验证数据格式
            const validation = this.validateImportData(importData);
            if (!validation.valid) {
                throw new Error(`数据验证失败: ${validation.error}`);
            }

            const importResults = {
                totalFiles: 0,
                processed: 0,
                matched: 0,
                created: 0,
                skipped: 0,
                failed: 0,
                errors: [],
                matchingDetails: {},
                summary: {}
            };

            // 获取现有数据用于匹配
            const existingData = await this.getExistingData();
            
            // 计算总数
            importResults.totalFiles = Object.values(importData.files)
                .reduce((sum, files) => sum + files.length, 0);

            // 按类型处理导入
            for (const [groupKey, files] of Object.entries(importData.files)) {
                if (progressCallback) {
                    progressCallback({
                        phase: 'processing',
                        groupKey,
                        totalGroups: Object.keys(importData.files).length,
                        currentGroup: Object.keys(importResults.summary).length + 1
                    });
                }

                const groupResult = await this.processFileGroup(
                    groupKey,
                    files,
                    existingData,
                    {
                        autoMatch,
                        overwrite,
                        createMissing,
                        matchTolerance,
                        progressCallback
                    }
                );

                // 合并结果
                importResults.processed += groupResult.processed;
                importResults.matched += groupResult.matched;
                importResults.created += groupResult.created;
                importResults.skipped += groupResult.skipped;
                importResults.failed += groupResult.failed;
                importResults.errors.push(...groupResult.errors);
                importResults.matchingDetails[groupKey] = groupResult.matchingDetails;
                importResults.summary[groupKey] = groupResult;
            }

            console.log('智能导入完成:', importResults);
            return { success: true, results: importResults };

        } catch (error) {
            console.error('智能导入失败:', error);
            throw new Error(`导入失败: ${error.message}`);
        }
    }

    /**
     * 处理一组文件的导入
     */
    async processFileGroup(groupKey, files, existingData, options) {
        const results = {
            processed: 0,
            matched: 0,
            created: 0,
            skipped: 0,
            failed: 0,
            errors: [],
            matchingDetails: []
        };

        const matchingRule = this.getMatchingRule(groupKey);
        
        for (const fileRecord of files) {
            try {
                results.processed++;
                
                if (options.progressCallback) {
                    options.progressCallback({
                        phase: 'importing',
                        groupKey,
                        current: results.processed,
                        total: files.length,
                        file: fileRecord
                    });
                }

                // 尝试匹配现有数据
                const matchResult = options.autoMatch ? 
                    await this.findBestMatch(fileRecord, existingData, groupKey, matchingRule) :
                    null;

                let importAction = 'create';
                let shouldImport = true;
                let matchingDetails = null;

                if (matchResult && matchResult.score >= options.matchTolerance) {
                    matchingDetails = matchResult;
                    
                    // 检查是否已存在文件
                    const existingReference = await this.fileManager.getFileReference(
                        fileRecord.reference.category,
                        matchResult.match.referenceKey || fileRecord.reference.referenceKey
                    );

                    if (existingReference) {
                        if (options.overwrite) {
                            // 删除现有文件
                            await this.fileManager.deleteFile(existingReference.fileId);
                            await this.fileManager.deleteFileReference(
                                fileRecord.reference.category,
                                existingReference.referenceKey
                            );
                            importAction = 'replace';
                        } else {
                            // 跳过已存在的文件
                            results.skipped++;
                            results.matched++;
                            shouldImport = false;
                            importAction = 'skip';
                        }
                    } else {
                        importAction = 'match_create';
                        results.matched++;
                    }
                } else if (!options.createMissing && !matchingRule.autoCreate) {
                    // 没有匹配且不允许创建新文件
                    results.skipped++;
                    shouldImport = false;
                    importAction = 'skip_no_match';
                }

                if (shouldImport) {
                    // 执行导入
                    await this.importSingleFile(fileRecord, matchResult);
                    
                    if (importAction === 'create' || importAction === 'match_create') {
                        results.created++;
                    }
                }

                // 记录匹配详情
                results.matchingDetails.push({
                    fileId: fileRecord.fileId,
                    referenceKey: fileRecord.reference.referenceKey,
                    action: importAction,
                    matchScore: matchResult?.score || 0,
                    matchedItem: matchResult?.match || null,
                    success: true
                });

            } catch (error) {
                results.failed++;
                results.errors.push({
                    fileRecord: fileRecord,
                    error: error.message
                });
                
                results.matchingDetails.push({
                    fileId: fileRecord.fileId,
                    referenceKey: fileRecord.reference.referenceKey,
                    action: 'error',
                    error: error.message,
                    success: false
                });
                
                console.error(`导入文件失败:`, error, fileRecord);
            }
        }

        return results;
    }

    /**
     * 导入单个文件（从Blob）
     */
    async importSingleFileFromBlob(fileInfo, blob, matchResult) {
        // 存储文件
        const storeResult = await this.fileManager.storeFile(blob, fileInfo.metadata || {});
        
        // 确定引用键（可能来自匹配结果）
        const referenceKey = matchResult?.match?.referenceKey || fileInfo.reference.referenceKey;
        
        // 创建引用
        await this.fileManager.createFileReference(
            storeResult.fileId,
            fileInfo.reference.category,
            referenceKey,
            {
                ...fileInfo.reference.metadata,
                importedAt: new Date().toISOString(),
                matchScore: matchResult?.score || null,
                originalReferenceKey: fileInfo.reference.referenceKey,
                originalPath: fileInfo.originalPath
            }
        );

        return storeResult;
    }

    /**
     * 导入单个文件（兼容原有JSON格式）
     */
    async importSingleFile(fileRecord, matchResult) {
        // 转换base64为Blob
        const blob = this.base64ToBlob(fileRecord.data);
        
        // 存储文件
        const storeResult = await this.fileManager.storeFile(blob, fileRecord.metadata);
        
        // 确定引用键（可能来自匹配结果）
        const referenceKey = matchResult?.match?.referenceKey || fileRecord.reference.referenceKey;
        
        // 创建引用
        await this.fileManager.createFileReference(
            storeResult.fileId,
            fileRecord.reference.category,
            referenceKey,
            {
                ...fileRecord.reference.metadata,
                importedAt: new Date().toISOString(),
                matchScore: matchResult?.score || null,
                originalReferenceKey: fileRecord.reference.referenceKey
            }
        );

        return storeResult;
    }

    /**
     * 查找最佳匹配
     */
    async findBestMatch(fileRecord, existingData, groupKey, matchingRule) {
        const candidates = this.getCandidatesForMatching(existingData, groupKey);
        
        if (!candidates || candidates.length === 0) {
            return null;
        }

        let bestMatch = null;
        let bestScore = 0;

        for (const candidate of candidates) {
            const score = this.calculateMatchScore(fileRecord, candidate, matchingRule);
            
            if (score > bestScore && score >= matchingRule.tolerance) {
                bestScore = score;
                bestMatch = candidate;
            }
        }

        return bestMatch ? { match: bestMatch, score: bestScore } : null;
    }

    /**
     * 计算匹配分数
     */
    calculateMatchScore(fileRecord, candidate, matchingRule) {
        let totalScore = 0;
        let weightSum = 0;

        const referenceKey = fileRecord.reference.referenceKey;
        const metadata = fileRecord.reference.metadata;

        // 基于关键字段计算匹配分数
        for (const field of matchingRule.keyFields) {
            const weight = this.getFieldWeight(field);
            let fieldScore = 0;

            // 直接键匹配
            if (candidate[field] && candidate[field] === referenceKey) {
                fieldScore = 1.0;
            }
            // 元数据匹配
            else if (metadata[field] && candidate[field]) {
                fieldScore = this.calculateStringsimilarity(
                    String(metadata[field]),
                    String(candidate[field])
                );
            }
            // ID匹配
            else if (candidate.id && candidate.id === referenceKey) {
                fieldScore = 0.9;
            }

            totalScore += fieldScore * weight;
            weightSum += weight;
        }

        return weightSum > 0 ? totalScore / weightSum : 0;
    }

    /**
     * 计算字符串相似度
     */
    calculateStringsimilarity(str1, str2) {
        if (str1 === str2) return 1.0;
        
        const longer = str1.length > str2.length ? str1 : str2;
        const shorter = str1.length > str2.length ? str2 : str1;
        
        if (longer.length === 0) return 1.0;
        
        const editDistance = this.levenshteinDistance(longer, shorter);
        return (longer.length - editDistance) / longer.length;
    }

    /**
     * 编辑距离算法
     */
    levenshteinDistance(str1, str2) {
        const matrix = [];
        
        for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
        
        return matrix[str2.length][str1.length];
    }

    /**
     * 获取现有数据用于匹配
     */
    async getExistingData() {
        const existingData = {
            contacts: [],
            emojis: [],
            backgrounds: null,
            moments: [],
            userProfile: null
        };

        try {
            // 获取联系人数据
            const contactsRequest = await this.getStoreData('contacts');
            existingData.contacts = contactsRequest || [];

            // 获取表情包数据
            const emojisRequest = await this.getStoreData('emojis');
            existingData.emojis = emojisRequest || [];

            // 获取背景数据
            const backgroundsRequest = await this.getStoreData('backgrounds');
            existingData.backgrounds = backgroundsRequest?.[0] || null;

            // 获取朋友圈数据
            const momentsRequest = await this.getStoreData('moments');
            existingData.moments = momentsRequest || [];

            // 获取用户资料
            const userProfileRequest = await this.getStoreData('userProfile');
            existingData.userProfile = userProfileRequest?.[0] || null;

        } catch (error) {
            console.error('获取现有数据失败:', error);
        }

        return existingData;
    }

    /**
     * 获取存储数据
     */
    async getStoreData(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 获取候选匹配项
     */
    getCandidatesForMatching(existingData, groupKey) {
        switch (groupKey) {
            case 'avatars':
                return [...existingData.contacts];
            case 'user_avatars':
                return existingData.userProfile ? [existingData.userProfile] : [];
            case 'backgrounds':
                // 背景数据结构特殊，需要转换
                if (existingData.backgrounds) {
                    return Object.keys(existingData.backgrounds)
                        .filter(key => key !== 'id')
                        .map(contactId => ({ id: contactId, referenceKey: contactId }));
                }
                return [];
            case 'emojis':
                return existingData.emojis;
            case 'moments':
                return existingData.moments;
            default:
                return [];
        }
    }

    /**
     * 根据文件夹名获取匹配规则
     */
    getMatchingRuleByFolder(folderName) {
        const folderToRuleMapping = {
            'avatars': 'avatars',
            'user_avatars': 'avatars',
            'backgrounds': 'backgrounds',
            'emojis': 'emojis',
            'moments': 'moments'
        };
        
        const ruleKey = folderToRuleMapping[folderName] || 'avatars';
        return this.matchingRules[ruleKey] || {
            keyFields: ['id'],
            tolerance: 0.8,
            autoCreate: true
        };
    }

    /**
     * 从文件信息中查找最佳匹配
     */
    async findBestMatchFromFileInfo(fileInfo, existingData, folderName, matchingRule) {
        // 将文件信息转换为匹配格式
        const pseudoFileRecord = {
            reference: fileInfo.reference
        };
        
        return await this.findBestMatch(pseudoFileRecord, existingData, folderName, matchingRule);
    }

    /**
     * 获取匹配规则
     */
    getMatchingRule(groupKey) {
        return this.matchingRules[groupKey] || {
            keyFields: ['id'],
            tolerance: 0.8,
            autoCreate: true
        };
    }

    /**
     * 获取字段权重
     */
    getFieldWeight(field) {
        const weights = {
            id: 1.0,
            tag: 1.0,
            contactId: 0.9,
            name: 0.8,
            meaning: 0.7,
            momentId: 1.0,
            timestamp: 0.6
        };
        return weights[field] || 0.5;
    }

    // === 辅助方法 ===

    /**
     * base64转Blob
     */
    base64ToBlob(base64String) {
        try {
            const [header, data] = base64String.split(',');
            const mimeMatch = header.match(/data:([^;]+);base64/);
            const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';
            
            const byteCharacters = atob(data);
            const byteNumbers = new Array(byteCharacters.length);
            
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (error) {
            throw new Error(`base64转换失败: ${error.message}`);
        }
    }

    /**
     * 验证导入数据
     */
    validateImportData(importData) {
        if (!importData || typeof importData !== 'object') {
            return { valid: false, error: '数据格式无效' };
        }

        if (!importData._metadata) {
            return { valid: false, error: '缺少元数据' };
        }

        if (importData._metadata.format !== 'file_storage_export') {
            return { valid: false, error: '文件格式不匹配，这不是文件存储导出文件' };
        }

        if (!importData.files || typeof importData.files !== 'object') {
            return { valid: false, error: '缺少文件数据' };
        }

        return { valid: true };
    }

    /**
     * 生成导入预览
     */
    async generateImportPreview(importData) {
        const preview = {
            totalFiles: 0,
            categories: {},
            potentialMatches: {},
            warnings: []
        };

        // 获取现有数据
        const existingData = await this.getExistingData();

        for (const [groupKey, files] of Object.entries(importData.files)) {
            preview.totalFiles += files.length;
            
            const categoryPreview = {
                fileCount: files.length,
                samples: files.slice(0, 3), // 显示前3个样本
                estimatedMatches: 0,
                estimatedNew: 0
            };

            // 估算匹配情况
            const matchingRule = this.getMatchingRule(groupKey);
            let estimatedMatches = 0;

            for (const file of files.slice(0, 10)) { // 只检查前10个作为估算
                const matchResult = await this.findBestMatch(file, existingData, groupKey, matchingRule);
                if (matchResult && matchResult.score >= 0.8) {
                    estimatedMatches++;
                }
            }

            categoryPreview.estimatedMatches = Math.round(estimatedMatches * files.length / Math.min(files.length, 10));
            categoryPreview.estimatedNew = files.length - categoryPreview.estimatedMatches;

            preview.categories[groupKey] = categoryPreview;
        }

        return preview;
    }
}

// 创建全局实例
const fileStorageImporter = new FileStorageImporter();

// 导出到window对象
window.FileStorageImporter = fileStorageImporter;
</script>
    
    <!-- 工具模块 -->
    <script>
/**
 * 系统工具集 - 包含公告管理、日志系统和系统级功能
 */

// === 公告管理系统 ===
const announcementManager = (() => {
    const STORAGE_KEY = 'whale-llt-seen-announcements';
    const OLD_STORAGE_KEY = 'update-20250805-seen';
    const ANNOUNCEMENT_DIR = 'announcements/';

    // To add a new announcement:
    // 1. Create a new .md file in the /announcements/ directory.
    // 2. Add the filename (without .md) to the TOP of this list.
    const ANNOUNCEMENT_IDS = [
        '20250806',
        '20250805'
    ];

    function getSeenIds() {
        let seenIds = [];
        try {
            const storedValue = localStorage.getItem(STORAGE_KEY);
            if (storedValue) {
                seenIds = JSON.parse(storedValue);
            }
        } catch (e) {
            console.error("Failed to parse seen announcements:", e);
            seenIds = [];
        }

        // Migration from old system for existing users
        if (localStorage.getItem(OLD_STORAGE_KEY) === 'true') {
            if (!seenIds.includes('20250805')) {
                seenIds.push('20250805');
            }
            localStorage.removeItem(OLD_STORAGE_KEY);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(seenIds));
        }
        
        return seenIds;
    }

    async function getUnread() {
        const seenIds = getSeenIds();
        const unreadIds = ANNOUNCEMENT_IDS.filter(id => !seenIds.includes(id));

        if (unreadIds.length === 0) {
            return [];
        }

        try {
            const fetchPromises = unreadIds.map(id => 
                fetch(`${ANNOUNCEMENT_DIR}${id}.md`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Announcement ${id}.md not found.`);
                        }
                        return response.text();
                    })
                    .then(text => ({ id, content: text }))
            );
            
            const unreadAnnouncements = await Promise.all(fetchPromises);
            return unreadAnnouncements;

        } catch (error) {
            console.error("Failed to fetch announcements:", error);
            return []; // Return empty if any fetch fails
        }
    }

    function markAsSeen(idsToMark) {
        const seenIds = getSeenIds();
        const newSeenIds = [...new Set([...seenIds, ...idsToMark])]; 
        localStorage.setItem(STORAGE_KEY, JSON.stringify(newSeenIds));
    }

    return {
        getUnread,
        markAsSeen
    };
})();

// === 控制台日志捕获系统 ===
let consoleLogs = [];
const maxLogEntries = 500; // 限制日志条目数量避免内存过大

/**
 * 重写console方法来捕获日志
 */
function setupConsoleCapture() {
    const originalConsole = {
        log: console.log,
        error: console.error,
        warn: console.warn,
        info: console.info,
        debug: console.debug
    };

    function captureLog(level, args) {
        const timestamp = new Date().toISOString();
        const message = args.map(arg => {
            if (typeof arg === 'object') {
                try {
                    return JSON.stringify(arg, null, 2);
                } catch (e) {
                    return String(arg);
                }
            }
            return String(arg);
        }).join(' ');
        
        consoleLogs.push({
            timestamp,
            level,
            message
        });
        
        // 限制日志数量
        if (consoleLogs.length > maxLogEntries) {
            consoleLogs = consoleLogs.slice(-maxLogEntries);
        }
    }

    console.log = function(...args) {
        captureLog('log', args);
        originalConsole.log.apply(console, args);
    };

    console.error = function(...args) {
        captureLog('error', args);
        originalConsole.error.apply(console, args);
    };

    console.warn = function(...args) {
        captureLog('warn', args);
        originalConsole.warn.apply(console, args);
    };

    console.info = function(...args) {
        captureLog('info', args);
        originalConsole.info.apply(console, args);
    };

    console.debug = function(...args) {
        captureLog('debug', args);
        originalConsole.debug.apply(console, args);
    };
}

/**
 * 传统下载方式的辅助函数
 */
function fallbackDownload(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * 导出日志功能
 */
function exportConsoleLogs() {
    try {
        if (consoleLogs.length === 0) {
            if (typeof showToast === 'function') showToast('没有日志可导出');
            return;
        }

        const logContent = consoleLogs.map(log => 
            `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`
        ).join('\n');
        
        const filename = `console-logs-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
        
        // 检查是否支持Web Share API（移动端分享）
        if (navigator.share && navigator.canShare) {
            const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
            const file = new File([blob], filename, { type: 'text/plain' });
            
            // 检查是否可以分享文件
            if (navigator.canShare({ files: [file] })) {
                navigator.share({
                    title: '调试日志',
                    text: '应用调试日志文件',
                    files: [file]
                }).then(() => {
                    if (typeof showToast === 'function') showToast('分享成功');
                }).catch((error) => {
                    console.log('分享取消或失败:', error);
                    // 如果分享失败，回退到传统下载方式
                    fallbackDownload(logContent, filename);
                    if (typeof showToast === 'function') showToast(`已导出 ${consoleLogs.length} 条日志`);
                });
                return;
            }
        }
        
        // 回退到传统下载方式（PC端或不支持分享的移动端）
        fallbackDownload(logContent, filename);
        if (typeof showToast === 'function') showToast(`已导出 ${consoleLogs.length} 条日志`);
    } catch (error) {
        console.error('导出日志失败:', error);
        if (typeof showToast === 'function') showToast('导出日志失败: ' + error.message);
    }
}

/**
 * 调试日志页面功能
 */
function showDebugLogPage() {
    if (typeof showPage === 'function') {
        showPage('debugLogPage');
        updateDebugLogDisplay();
    }
}

function updateDebugLogDisplay() {
    const logContent = document.getElementById('debugLogContent');
    const logCount = document.getElementById('logCount');
    
    if (!logContent) return;
    
    if (consoleLogs.length === 0) {
        logContent.innerHTML = '<div class="debug-log-empty">暂无日志记录</div>';
        if (logCount) logCount.textContent = '0';
        return;
    }
    
    if (logCount) logCount.textContent = consoleLogs.length.toString();
    
    const logsHtml = consoleLogs.map(log => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        const levelClass = `debug-log-${log.level}`;
        return `
            <div class="debug-log-item ${levelClass}">
                <div class="debug-log-header">
                    <span class="debug-log-time">${time}</span>
                    <span class="debug-log-level">${log.level.toUpperCase()}</span>
                </div>
                <div class="debug-log-message">${escapeHtml(log.message)}</div>
            </div>
        `;
    }).join('');
    
    logContent.innerHTML = logsHtml;
    
    // 滚动到底部显示最新日志
    logContent.scrollTop = logContent.scrollHeight;
}

function clearDebugLogs() {
    consoleLogs.length = 0;
    updateDebugLogDisplay();
    if (typeof showToast === 'function') showToast('已清空调试日志');
}

function copyDebugLogs() {
    if (consoleLogs.length === 0) {
        if (typeof showToast === 'function') showToast('没有日志可复制');
        return;
    }
    
    const logText = consoleLogs.map(log => 
        `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`
    ).join('\n');
    
    // 尝试使用现代的Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(logText).then(() => {
            if (typeof showToast === 'function') showToast(`已复制 ${consoleLogs.length} 条日志到剪贴板`);
        }).catch(err => {
            console.error('复制失败:', err);
            fallbackCopyTextToClipboard(logText);
        });
    } else {
        fallbackCopyTextToClipboard(logText);
    }
}

function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        const successful = document.execCommand('copy');
        if (successful) {
            if (typeof showToast === 'function') showToast(`已复制 ${consoleLogs.length} 条日志到剪贴板`);
        } else {
            if (typeof showToast === 'function') showToast('复制失败，请手动选择文本');
        }
    } catch (err) {
        console.error('Fallback: 复制失败', err);
        if (typeof showToast === 'function') showToast('复制失败: ' + err.message);
    }
    
    document.body.removeChild(textArea);
}

function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

// === 系统状态和错误处理 ===

/**
 * 全局错误处理 - 捕获未处理的Promise拒绝
 */
function initializeGlobalErrorHandling() {
    window.addEventListener('unhandledrejection', function(event) {
        console.error('未处理的Promise拒绝:', {
            reason: event.reason,
            promise: event.promise,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        });
        
        // 记录到全局错误日志
        if (!window.errorLog) window.errorLog = [];
        window.errorLog.push({
            type: 'unhandledrejection',
            reason: event.reason?.toString() || 'Unknown',
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        });
        
        // 检查是否是API相关的错误，如果是则显示重试对话框
        const errorMessage = event.reason?.message || event.reason?.toString() || '';
        const isAPIError = errorMessage.includes('API请求失败') || 
                          errorMessage.includes('API Error') || 
                          errorMessage.includes('429') ||
                          errorMessage.includes('500') ||
                          errorMessage.includes('503') ||
                          errorMessage.includes('502') ||
                          errorMessage.includes('空回') ||
                          errorMessage.includes('AI回复内容为空') ||
                          errorMessage.includes('AI未返回有效内容');
        
        if (isAPIError && typeof showApiError === 'function') {
            showApiError(event.reason || new Error(errorMessage));
        }
        
        // 防止控制台显示未处理的错误（已记录）
        event.preventDefault();
    });
}

/**
 * Service Worker 注册
 */
function registerServiceWorker() {
    console.log('ServiceWorker disabled in single-file mode');
}



/**
 * 特殊事件检查（如节日特殊处理）
 */
async function checkSpecialEvents() {
    try {
        const today = new Date();
        const month = (today.getMonth() + 1).toString().padStart(2, '0');
        const day = today.getDate().toString().padStart(2, '0');
        const dateString = `${month}-${day}`;
        
        console.log('当前日期检查:', dateString);
        
        // 检查是否为8月29日
        if (month === '08' && day === '29') {
            console.log('今天是七夕节！'); // 保持原有日志，因为这是具体的日期判断
            
            // 检查是否为今日第一次打开应用
            const lastSpecialEventVisit = localStorage.getItem('lastSpecialEventVisit');
            const todayString = today.toDateString();
            
            if (lastSpecialEventVisit !== todayString) {
                console.log('今日第一次打开应用，开始特殊事件流程');
                
                // 记录今日已访问
                localStorage.setItem('lastSpecialEventVisit', todayString);
                
                // 启动特殊事件流程（七夕节）
                if (window.startSpecialEventFlow && typeof window.startSpecialEventFlow === 'function') {
                    await window.startSpecialEventFlow('qixi');
                } else {
                    console.warn('startSpecialEventFlow 函数未找到');
                }
            } else {
                console.log('今日已处理过特殊事件流程');
            }
        }
    } catch (error) {
        console.error('特殊事件检查出错:', error);
    }
}

// 立即启用console捕获和全局错误处理
setupConsoleCapture();
initializeGlobalErrorHandling();

// 创建命名空间并暴露系统工具函数
window.SystemUtils = {
    announcementManager,
    consoleLogs,
    exportConsoleLogs,
    showDebugLogPage,
    updateDebugLogDisplay,
    clearDebugLogs,
    copyDebugLogs,
    escapeHtml,
    setupConsoleCapture,
    checkSpecialEvents,
    registerServiceWorker
};

// 为了向后兼容，保留一些关键的全局引用
// TODO: Remove these global assignments once all code is updated to use SystemUtils.
window.announcementManager = announcementManager;
window.escapeHtml = escapeHtml;

</script>
    <script>
class CharacterMemoryManager {
    constructor() {
        this.isInitialized = false;
        this.conversationCounters = new Map(); // 按角色ID存储对话计数
        this.lastProcessedMessageIndex = new Map(); // 按联系人ID存储最后处理记忆的消息索引
        this.globalMemory = ''; // 全局记忆
    }

    /**
     * 初始化角色记忆管理器
     */
    async init() {
        
        if (this.isInitialized) {
            return;
        }
        
        this.bindEvents();
        
        // 如果数据库已准备好，立即加载数据
        if (window.isIndexedDBReady && window.db) {
            await this.loadConversationCounters();
            await this.loadLastProcessedMessageIndex();
            await this.getGlobalMemory();
        } else {
        }
        
        this.isInitialized = true;
    }

    /**
     * 绑定事件监听器
     */
    bindEvents() {
        // 页面关闭前触发记忆更新检查
        window.addEventListener('beforeunload', async (e) => {
            await this.handlePageUnload();
        });
    }

    /**
     * 页面关闭时的处理逻辑
     */
    async handlePageUnload() {
        const currentContact = this.getCurrentContact();
        if (!currentContact) return;

        console.log('页面关闭，检查是否需要更新角色记忆');
        
        // 检查是否有新的用户消息需要处理
        if (!this.hasNewUserMessages(currentContact)) {
            console.log('没有新的用户消息，跳过记忆更新');
            return;
        }
        
        if (currentContact.type === 'group') {
            // 群聊：检查所有成员
            if (window.contacts && Array.isArray(window.contacts)) {
                for (const memberId of currentContact.members) {
                    const member = window.contacts.find(c => c.id === memberId);
                    if (member && member.type === 'private') {
                        await this.checkAndUpdateMemory(member.id, currentContact, true);
                    }
                }
            }
        } else {
            // 私聊：检查当前角色
            await this.checkAndUpdateMemory(currentContact.id, currentContact, true);
        }
    }

    /**
     * 获取当前联系人
     */
    getCurrentContact() {
        return window.currentContact || window.memoryTableManager?.getCurrentContact();
    }

    /**
     * 检查系统是否准备好执行记忆操作
     */
    isSystemReady() {
        const ready = window.contacts && 
               Array.isArray(window.contacts) && 
               window.apiSettings && 
               (window.apiSettings.url || window.apiSettings.apiUrl) && // 检查两个可能的字段
               window.apiService;
               
        
        return ready;
    }

    /**
     * 检查是否有新的用户消息需要处理
     */
    hasNewUserMessages(contact) {
        if (!contact || !contact.messages || contact.messages.length === 0) {
            return false;
        }
        
        const lastProcessedIndex = this.lastProcessedMessageIndex.get(contact.id) || -1;
        const currentMessageCount = contact.messages.length;
        
        // 从最后处理的位置开始，检查是否有新的用户消息
        for (let i = lastProcessedIndex + 1; i < currentMessageCount; i++) {
            if (contact.messages[i].role === 'user') {
                return true;
            }
        }
        
        return false;
    }

    /**
     * 判断是否为特殊消息类型（不计入用户消息数量）
     */
    isSpecialMessageType(message) {
        // 排除emoji和红包类型的消息
        return message.type === 'emoji' || message.type === 'red_packet';
    }

    /**
     * 统计从最后处理位置开始的用户消息数量
     */
    getNewUserMessageCount(contact) {
        if (!contact || !contact.messages || contact.messages.length === 0) {
            return 0;
        }
        
        const lastProcessedIndex = this.lastProcessedMessageIndex.get(contact.id) || -1;
        const currentMessageCount = contact.messages.length;
        let userMessageCount = 0;
        
        // 从最后处理的位置开始计数用户消息
        for (let i = lastProcessedIndex + 1; i < currentMessageCount; i++) {
            const message = contact.messages[i];
            
            if (message.role === 'user' && !this.isSpecialMessageType(message)) {
                userMessageCount++;
            }
        }
        
        return userMessageCount;
    }

    /**
     * 从IndexedDB加载对话计数器
     */
    async loadConversationCounters() {
        if (!window.isIndexedDBReady || !window.db) {
            return;
        }

        try {
            // 检查数据库中是否存在conversationCounters表
            if (!window.db.objectStoreNames.contains('conversationCounters')) {
                return;
            }

            const transaction = window.db.transaction(['conversationCounters'], 'readonly');
            const store = transaction.objectStore('conversationCounters');
            const data = await this.promisifyRequest(store.get('counters'));
            
            if (data) {
                this.conversationCounters = new Map(Object.entries(data));
            }
        } catch (error) {
            console.error('加载对话计数器失败:', error);
        }
    }

    /**
     * 保存对话计数器到IndexedDB
     */
    async saveConversationCounters() {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDB未准备好，无法保存对话计数器');
            return;
        }

        try {
            const transaction = window.db.transaction(['conversationCounters'], 'readwrite');
            const store = transaction.objectStore('conversationCounters');
            const countersObj = Object.fromEntries(this.conversationCounters);
            await this.promisifyRequest(store.put({ id: 'counters', ...countersObj }));
            console.log('对话计数器已保存');
        } catch (error) {
            console.error('保存对话计数器失败:', error);
        }
    }

    /**
     * 从IndexedDB加载最后处理的消息索引
     */
    async loadLastProcessedMessageIndex() {
        if (!window.isIndexedDBReady || !window.db) {
            return;
        }

        try {
            // 检查数据库中是否存在memoryProcessedIndex表
            if (!window.db.objectStoreNames.contains('memoryProcessedIndex')) {
                return;
            }

            const transaction = window.db.transaction(['memoryProcessedIndex'], 'readonly');
            const store = transaction.objectStore('memoryProcessedIndex');
            const allData = await this.promisifyRequest(store.getAll());
            
            if (allData && allData.length > 0) {
                // 将数组转换为Map
                allData.forEach(record => {
                    this.lastProcessedMessageIndex.set(record.contactId, record.lastIndex);
                });
            }
        } catch (error) {
            console.error('加载消息索引失败:', error);
        }
    }

    /**
     * 保存最后处理的消息索引到IndexedDB
     */
    async saveLastProcessedMessageIndex(contactId, lastIndex) {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDB未准备好，无法保存消息索引');
            return;
        }

        try {
            const transaction = window.db.transaction(['memoryProcessedIndex'], 'readwrite');
            const store = transaction.objectStore('memoryProcessedIndex');
            await this.promisifyRequest(store.put({ 
                contactId: contactId, 
                lastIndex: lastIndex,
                lastUpdated: new Date().toISOString()
            }));
            console.log(`联系人 ${contactId} 的消息索引已保存: ${lastIndex}`);
        } catch (error) {
            console.error('保存消息索引失败:', error);
        }
    }

    /**
     * 获取角色记忆
     */
    async getCharacterMemory(contactId) {
        if (!window.isIndexedDBReady || !window.db) {
            return null;
        }

        try {
            // 检查数据库中是否存在characterMemories表
            if (!window.db.objectStoreNames.contains('characterMemories')) {
                return null;
            }

            const transaction = window.db.transaction(['characterMemories'], 'readonly');
            const store = transaction.objectStore('characterMemories');
            const data = await this.promisifyRequest(store.get(contactId));
            return data ? data.memory : null;
        } catch (error) {
            console.error('获取角色记忆失败:', error);
            return null;
        }
    }

    /**
     * 保存角色记忆（覆盖式）
     */
    async saveCharacterMemory(contactId, memory) {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDB未准备好，无法保存角色记忆');
            return false;
        }

        try {
            // 先获取更新次数，避免在事务中等待导致事务超时
            const currentUpdateCount = await this.getMemoryUpdateCount(contactId);
            
            // 然后创建新的事务进行保存
            const transaction = window.db.transaction(['characterMemories'], 'readwrite');
            const store = transaction.objectStore('characterMemories');
            const memoryData = {
                contactId: contactId,
                memory: memory,
                updateCount: currentUpdateCount + 1,
                lastUpdated: new Date().toISOString()
            };
            
            await this.promisifyRequest(store.put(memoryData));
            console.log(`角色 ${contactId} 的记忆已保存`);
            return true;
        } catch (error) {
            console.error('保存角色记忆失败:', error);
            return false;
        }
    }

    /**
     * 追加角色记忆（累积式，用于自动记忆系统）
     */
    async appendCharacterMemory(contactId, newMemory) {
        if (!window.isIndexedDBReady || !window.db) {
            console.warn('IndexedDB未准备好，无法追加角色记忆');
            return false;
        }

        try {
            // 获取现有记忆
            const existingMemory = await this.getCharacterMemory(contactId);
            
            // 合并记忆
            let combinedMemory;
            if (existingMemory && existingMemory.trim()) {
                // 如果新记忆包含现有记忆的内容，直接使用新记忆（AI已经整合过了）
                if (newMemory.includes(existingMemory.substring(0, Math.min(100, existingMemory.length)))) {
                    combinedMemory = newMemory;
                } else {
                    // 否则追加新记忆
                    combinedMemory = existingMemory + '\n\n' + newMemory;
                }
            } else {
                combinedMemory = newMemory;
            }

            // 保存合并后的记忆
            return await this.saveCharacterMemory(contactId, combinedMemory);
        } catch (error) {
            console.error('追加角色记忆失败:', error);
            return false;
        }
    }

    /**
     * 获取记忆更新次数
     */
    async getMemoryUpdateCount(contactId) {
        if (!window.isIndexedDBReady || !window.db) {
            return 0;
        }

        try {
            const transaction = window.db.transaction(['characterMemories'], 'readonly');
            const store = transaction.objectStore('characterMemories');
            const data = await this.promisifyRequest(store.get(contactId));
            return data ? (data.updateCount || 0) : 0;
        } catch (error) {
            console.error('获取记忆更新次数失败:', error);
            return 0;
        }
    }

    /**
     * 增加对话计数
     */
    incrementConversationCounter(contactId) {
        const current = this.conversationCounters.get(contactId) || 0;
        const newCount = current + 1;
        this.conversationCounters.set(contactId, newCount);
        
        console.log(`角色 ${contactId} 对话计数: ${newCount}`);
        
        // 异步保存，避免阻塞
        this.saveConversationCounters();
        
        return newCount;
    }

    /**
     * 重置对话计数
     */
    resetConversationCounter(contactId) {
        this.conversationCounters.set(contactId, 0);
        this.saveConversationCounters();
    }

    /**
     * 获取对话计数
     */
    getConversationCounter(contactId) {
        return this.conversationCounters.get(contactId) || 0;
    }

    /**
     * 确保数据已从数据库加载（延迟加载机制）
     */
    async ensureDataLoaded() {
        if (!this.isInitialized && window.isIndexedDBReady && window.db) {
            await this.loadConversationCounters();
            await this.loadLastProcessedMessageIndex();
            await this.getGlobalMemory();
            this.isInitialized = true;
        }
    }

    /**
     * 检查并更新记忆（主入口）
     */
    async checkAndUpdateMemory(contactId, currentContact, forceCheck = false) {
        // 确保数据已加载
        await this.ensureDataLoaded();

        // 系统准备度检查
        if (!this.isSystemReady()) {
            return;
        }

        const contact = window.contacts.find(c => c.id === contactId);
        if (!contact) {
            console.warn('未找到联系人:', contactId);
            return;
        }

        // 根据联系人类型设置不同的触发条件
        const newUserMessageCount = this.getNewUserMessageCount(currentContact);
        let triggerThreshold;
        if (currentContact?.type === 'group') {
            triggerThreshold = 1; // 群聊：1条用户消息触发
        } else {
            triggerThreshold = 3; // 私聊：3条用户消息触发
        }
        const shouldCheck = forceCheck || newUserMessageCount >= triggerThreshold;

        if (!shouldCheck) {
            return;
        }
        
        try {
            // 第一步：使用次要模型判断是否需要更新记忆
            const shouldUpdate = await this.checkMemoryUpdateNeeded(contact, currentContact);
            
            if (shouldUpdate) {
                // 第二步：使用主要模型生成/更新记忆
                const updateSuccess = await this.generateAndUpdateMemory(contact, currentContact);
                
                // 只有记忆更新成功时才标记消息已处理
                if (updateSuccess) {
                    await this.markMessagesProcessed(currentContact);
                    console.log('记忆更新成功，lastProcessedIndex已更新');
                } else {
                    console.warn('记忆更新失败，lastProcessedIndex保持不变');
                }
            } else {
                // 判断为不需要更新时，仍然标记消息已处理
                await this.markMessagesProcessed(currentContact);
                console.log('无需更新记忆，lastProcessedIndex已更新');
            }
        } catch (error) {
            console.error('检查更新记忆时发生错误:', error);
            console.warn('由于错误，lastProcessedIndex保持不变');
        }
    }

    /**
     * 清空指定角色的记忆
     */
    async clearCharacterMemory(contactId) {
        if (!contactId) {
            console.warn('contactId为空，无法清空记忆');
            return false;
        }

        try {
            // 清空内存中的数据
            this.lastProcessedMessageIndex.delete(contactId);
            this.conversationCounters.delete(contactId);
            
            // 清空数据库中的数据
            if (window.isIndexedDBReady && window.db) {
                const transaction = window.db.transaction([
                    'characterMemories', 
                    'memoryProcessedIndex', 
                    'conversationCounters'
                ], 'readwrite');
                
                // 删除角色记忆
                const memoryStore = transaction.objectStore('characterMemories');
                await this.promisifyRequest(memoryStore.delete(contactId));
                
                // 删除消息处理索引
                const indexStore = transaction.objectStore('memoryProcessedIndex');
                await this.promisifyRequest(indexStore.delete(contactId));
                
                // 更新对话计数器（删除该角色的计数）
                const counterStore = transaction.objectStore('conversationCounters');
                const counterData = await this.promisifyRequest(counterStore.get('counters'));
                if (counterData && counterData[contactId]) {
                    delete counterData[contactId];
                    await this.promisifyRequest(counterStore.put({ id: 'counters', ...counterData }));
                }
            }
            
            return true;
        } catch (error) {
            console.error(`清空角色 ${contactId} 记忆失败:`, error);
            return false;
        }
    }

    /**
     * 清空所有角色记忆（危险操作）
     */
    async clearAllCharacterMemories() {
        try {
            // 清空内存数据
            this.lastProcessedMessageIndex.clear();
            this.conversationCounters.clear();
            
            // 清空数据库数据
            if (window.isIndexedDBReady && window.db) {
                const transaction = window.db.transaction([
                    'characterMemories', 
                    'memoryProcessedIndex', 
                    'conversationCounters'
                ], 'readwrite');
                
                // 清空所有表
                await this.promisifyRequest(transaction.objectStore('characterMemories').clear());
                await this.promisifyRequest(transaction.objectStore('memoryProcessedIndex').clear());
                await this.promisifyRequest(transaction.objectStore('conversationCounters').clear());
            }
            
            return true;
        } catch (error) {
            console.error('清空所有角色记忆失败:', error);
            return false;
        }
    }

    /**
     * 标记消息已处理
     */
    async markMessagesProcessed(contact) {
        if (contact && contact.messages && contact.messages.length > 0) {
            const newIndex = contact.messages.length - 1;
            this.lastProcessedMessageIndex.set(contact.id, newIndex);
            console.log(`标记联系人 ${contact.id} 的消息已处理到索引 ${newIndex}`);
            
            // 异步保存到数据库，避免阻塞
            this.saveLastProcessedMessageIndex(contact.id, newIndex);
        }
    }

    /**
     * 获取全局记忆
     */
    async getGlobalMemory() {
        if (!window.isIndexedDBReady || !window.db) {
            return this.globalMemory;
        }

        try {
            // 检查数据库中是否存在globalMemory表
            if (!window.db.objectStoreNames.contains('globalMemory')) {
                return this.globalMemory;
            }

            const transaction = window.db.transaction(['globalMemory'], 'readonly');
            const store = transaction.objectStore('globalMemory');
            const data = await this.promisifyRequest(store.get('memory'));
            this.globalMemory = data ? data.content : '';
            return this.globalMemory;
        } catch (error) {
            console.error('获取全局记忆失败:', error);
            return this.globalMemory;
        }
    }

    /**
     * 保存全局记忆
     */
    async saveGlobalMemory(memory) {
        if (!window.isIndexedDBReady || !window.db) {
            this.globalMemory = memory;
            console.warn('IndexedDB未准备好，全局记忆仅保存在内存中');
            return false;
        }

        try {
            const transaction = window.db.transaction(['globalMemory'], 'readwrite');
            const store = transaction.objectStore('globalMemory');
            await this.promisifyRequest(store.put({
                id: 'memory',
                content: memory,
                lastUpdated: new Date().toISOString()
            }));
            this.globalMemory = memory;
            console.log('全局记忆已保存');
            return true;
        } catch (error) {
            console.error('保存全局记忆失败:', error);
            return false;
        }
    }

    /**
     * 检查并更新删除消息后的记忆
     */
    async checkAndUpdateMemoryAfterDeletion(contactId, deletedMessages, currentContact) {
        // 确保数据已加载
        await this.ensureDataLoaded();

        // 系统准备度检查
        if (!this.isSystemReady()) {
            return;
        }

        const contact = window.contacts.find(c => c.id === contactId);
        if (!contact) {
            console.warn('未找到联系人:', contactId);
            return;
        }

        // 提取被删除的用户文本消息
        const deletedUserTexts = this.extractDeletedUserTexts(deletedMessages);
        
        if (deletedUserTexts.length === 0) {
            return;
        }

        try {
            // 第一步：使用次要模型判断是否需要删除记忆
            const shouldDelete = await this.checkMemoryDeletionNeeded(contact, deletedUserTexts);
            
            if (shouldDelete) {
                // 第二步：使用主要模型删除相关记忆
                await this.deleteMemoryContent(contact, deletedUserTexts);
            }
        } catch (error) {
            console.error('检查删除记忆时发生错误:', error);
        }
    }

    /**
     * 提取被删除的用户文本消息
     */
    extractDeletedUserTexts(deletedMessages) {
        const userTexts = [];
        
        deletedMessages.forEach((message, index) => {
            // 只收集用户的普通文本消息，排除emoji和红包
            if (message.role === 'user' && !this.isSpecialMessageType(message)) {
                userTexts.push(message.content);
            }
        });
        
        return userTexts;
    }

    /**
     * 检查是否需要删除记忆内容（调用次要模型）
     */
    async checkMemoryDeletionNeeded(contact, deletedUserTexts) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        
        // 构建删除判断提示词
        const prompt = this.buildMemoryDeletionCheckPrompt(currentMemory, deletedUserTexts, contact);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.1, // 降低随机性，让判断更稳定
                    max_tokens: 5000
                }
            );
            console.log('记忆删除判断API完整返回:', JSON.stringify(response, null, 2));
            
            // 安全检查API响应格式
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('记忆删除判断API响应格式异常:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('记忆删除判断API响应内容为空或格式错误:', content);
                return false;
            }
            
            const result = content.trim();
            console.log('记忆删除判断结果:', result);
            
            // 如果模型回复"需要"或"是"，则认为需要删除
            return result.includes('需要') || result.includes('是');
        } catch (error) {
            console.error('调用次要模型判断记忆删除失败:', error);
            return false; // 出错时保守处理，不删除
        }
    }

    /**
     * 删除记忆内容（调用主要模型）
     */
    async deleteMemoryContent(contact, deletedUserTexts) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        
        // 构建记忆删除提示词
        const prompt = this.buildMemoryDeletionPrompt(currentMemory, deletedUserTexts, contact);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 10000
                }
            );
            console.log('删除记忆内容API完整返回:', JSON.stringify(response, null, 2));
            
            // 安全检查API响应格式
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('删除记忆API响应格式异常:', response);
                return;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('删除记忆API响应内容为空或格式错误:', content);
                return;
            }
            
            const newMemory = content.trim();
            console.log('更新后的记忆:', newMemory);
            
            // 保存更新后的记忆
            await this.saveCharacterMemory(contact.id, newMemory);
            
        } catch (error) {
            console.error('删除记忆内容失败:', error);
        }
    }

    /**
     * 检查并更新全局记忆
     */
    async checkAndUpdateGlobalMemory(forumContent, forceCheck = false) {
        console.log('开始检查全局记忆更新');
        
        // 检查必要的依赖是否准备好（全局记忆不需要contacts数组）
        if (!window.apiSettings || !window.apiSettings.url || !window.apiService) {
            console.log('系统未准备好，跳过全局记忆更新');
            return;
        }
        
        try {
            // 第一步：使用次要模型判断是否需要更新全局记忆
            const shouldUpdate = await this.checkGlobalMemoryUpdateNeeded(forumContent);
            
            if (shouldUpdate) {
                console.log('需要更新全局记忆');
                // 第二步：使用主要模型生成/更新全局记忆
                await this.generateAndUpdateGlobalMemory(forumContent);
            } else {
                console.log('无需更新全局记忆');
            }
        } catch (error) {
            console.error('检查更新全局记忆时发生错误:', error);
        }
    }

    /**
     * 检查是否需要更新记忆（调用次要模型）
     */
    async checkMemoryUpdateNeeded(contact, currentContact) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        const completeMessageContext = this.buildCompleteMessageContext(currentContact);
        
        // 构建判断提示词
        const prompt = this.buildMemoryCheckPrompt(currentMemory, completeMessageContext, contact);
        
        try {
            // 使用次要模型进行判断
            const modelToUse = this.getSecondaryModel();
            const response = await window.apiService.callOpenAIAPI(
                window.apiSettings.url,
                window.apiSettings.key,
                modelToUse,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.1, // 降低随机性，让判断更稳定
                    max_tokens: 5000
                }
            );
            console.log('记忆更新判断API完整返回:', JSON.stringify(response, null, 2));
            
            // 安全检查API响应格式
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('API响应格式异常:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('API响应内容为空或格式错误:', content);
                return false;
            }
            
            const result = content.trim();
            console.log('记忆更新判断结果:', result);
            
            // 如果模型有回复且不含"不"或"否"，则认为满足条件
            return result.length > 0 && !result.includes('不') && !result.includes('否');
        } catch (error) {
            console.error('调用次要模型判断记忆更新失败:', error);
            return false; // 出错时保守处理，不更新
        }
    }

    /**
     * 检查是否需要更新全局记忆（调用次要模型）
     */
    async checkGlobalMemoryUpdateNeeded(forumContent) {
        const currentGlobalMemory = await this.getGlobalMemory();
        
        // 构建判断提示词
        const prompt = this.buildGlobalMemoryCheckPrompt(currentGlobalMemory, forumContent);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.1,
                    max_tokens: 7000
                }
            );
            console.log('全局记忆更新判断API完整返回:', JSON.stringify(response, null, 2));
            
            // 安全检查API响应格式
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('全局记忆API响应格式异常:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('全局记忆API响应内容为空或格式错误:', content);
                return false;
            }
            
            const result = content.trim();
            console.log('全局记忆更新判断结果:', result);
            
            // 如果模型有回复且不含"不"或"否"，则认为满足条件
            return result.length > 0 && !result.includes('不') && !result.includes('否');
        } catch (error) {
            console.error('调用次要模型判断全局记忆更新失败:', error);
            return false;
        }
    }

    /**
     * 生成并更新记忆（调用主要模型）
     */
    async generateAndUpdateMemory(contact, currentContact) {
        const currentMemory = await this.getCharacterMemory(contact.id);
        const completeMessageContext = this.buildCompleteMessageContext(currentContact);
        
        // 构建记忆生成提示词
        const prompt = this.buildMemoryGeneratePrompt(currentMemory, completeMessageContext, contact);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 10000
                }
            );
            console.log('生成记忆API完整返回:', JSON.stringify(response, null, 2));
            
            // 安全检查API响应格式
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('生成记忆API响应格式异常:', response);
                return false;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('生成记忆API响应内容为空或格式错误:', content);
                return false;
            }
            
            const newMemory = content.trim();
            console.log('生成的新记忆:', newMemory);
            
            // 追加新记忆（累积式保存）
            const saveSuccess = await this.appendCharacterMemory(contact.id, newMemory);
            return saveSuccess;
            
        } catch (error) {
            console.error('生成记忆失败:', error);
            return false;
        }
    }

    /**
     * 生成并更新全局记忆（调用主要模型）
     */
    async generateAndUpdateGlobalMemory(forumContent) {
        const currentGlobalMemory = await this.getGlobalMemory();
        
        // 构建记忆生成提示词
        const prompt = this.buildGlobalMemoryGeneratePrompt(currentGlobalMemory, forumContent);
        
        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            const response = await window.apiService.callOpenAIAPI(
                connection.url,
                connection.key,
                connection.primaryModel,
                [{ role: 'user', content: prompt }],
                { 
                    temperature: 0.3,
                    max_tokens: 10000
                }
            );
            console.log('生成全局记忆API完整返回:', JSON.stringify(response, null, 2));
            
            // 安全检查API响应格式
            if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
                console.warn('生成全局记忆API响应格式异常:', response);
                return;
            }
            
            const content = response.choices[0].message.content;
            if (!content || typeof content !== 'string') {
                console.warn('生成全局记忆API响应内容为空或格式错误:', content);
                return;
            }
            
            const newGlobalMemory = content.trim();
            console.log('生成的新全局记忆:', newGlobalMemory);
            
            // 保存新全局记忆
            await this.saveGlobalMemory(newGlobalMemory);
            
        } catch (error) {
            console.error('生成全局记忆失败:', error);
        }
    }

    /**
     * 构建完整消息上下文（从lastProcessedIndex开始的所有消息）
     */
    buildCompleteMessageContext(contact) {
        if (!contact.messages || contact.messages.length === 0) {
            return '暂无对话记录';
        }

        const lastProcessedIndex = this.lastProcessedMessageIndex.get(contact.id) || -1;
        const contextLines = [];
        
        // 从最后处理位置开始，收集所有消息
        for (let i = lastProcessedIndex + 1; i < contact.messages.length; i++) {
            const message = contact.messages[i];
            
            const sender = message.role === 'user' ? 
                (window.userProfile?.name || '用户') : 
                (window.contacts && Array.isArray(window.contacts) ? 
                    window.contacts.find(c => c.id === message.senderId)?.name || contact.name : 
                    contact.name);
                
            let content = message.content;
            
            // 处理特殊消息类型
            if (message.type === 'red_packet') {
                try {
                    const packet = JSON.parse(content);
                    content = `[发送红包: ${packet.message}, 金额: ${packet.amount}元]`;
                } catch (e) {
                    content = '[发送红包]';
                }
            } else if (message.type === 'emoji') {
                const emoji = window.emojis && Array.isArray(window.emojis) ? 
                    window.emojis.find(e => e.url === message.content) : null;
                content = `[表情: ${emoji?.meaning || '未知表情'}]`;
            }
            
            contextLines.push(`${sender}: ${content}`);
        }
        
        if (contextLines.length === 0) {
            return '暂无新的对话记录';
        }
        
        return contextLines.join('\n');
    }

    /**
     * 构建最近对话上下文
     */
    buildRecentContext(contact) {
        if (!contact.messages || contact.messages.length === 0) {
            return '暂无对话记录';
        }

        const recentMessages = contact.messages.slice(-20); // 获取最近20条消息
        const contextLines = [];
        
        recentMessages.forEach(msg => {
            const sender = msg.role === 'user' ? 
                (window.userProfile?.name || '用户') : 
                (window.contacts && Array.isArray(window.contacts) ? 
                    window.contacts.find(c => c.id === msg.senderId)?.name || contact.name : 
                    contact.name);
                
            let content = msg.content;
            
            // 处理特殊消息类型
            if (msg.type === 'red_packet') {
                try {
                    const packet = JSON.parse(content);
                    content = `[发送红包: ${packet.message}, 金额: ${packet.amount}元]`;
                } catch (e) {
                    content = '[发送红包]';
                }
            } else if (msg.type === 'emoji') {
                const emoji = window.emojis && Array.isArray(window.emojis) ? 
                    window.emojis.find(e => e.url === msg.content) : null;
                content = `[表情: ${emoji?.meaning || '未知表情'}]`;
            }
            
            contextLines.push(`${sender}: ${content}`);
        });
        
        return contextLines.join('\n');
    }

    /**
     * 构建记忆检查提示词
     */
    buildMemoryCheckPrompt(currentMemory, completeMessageContext, contact) {
        return `你是一个记忆分析助手。请判断最近的对话内容是否需要更新角色记忆。

当前角色记忆：
${currentMemory || '暂无记忆'}

最近的对话内容：
${completeMessageContext}

判断标准：
1. 对话中是否涉及到当前记忆中没有的个人信息？
2. 用户是否主动说明自身的形象、生活状态、个人情况？（例如：用户正在接受心理治疗、用户正在准备演讲比赛、用户喜欢你称呼他为...等）
3. 对话中是否包含值得记住的事件、约定或重要细节？

请仅回答"是"或"否"，不要其他解释。`;
    }

    /**
     * 构建记忆生成提示词
     */
    buildMemoryGeneratePrompt(currentMemory, completeMessageContext, contact) {
        const userName = window.userProfile?.name || '用户';
        
        return `你是一个记忆整理助手。请根据原有记忆和最近的对话内容，更新角色记忆。

角色信息：
- 姓名：${contact.name}
- 人设：${contact.personality}

用户信息：
- 姓名：${userName}
- 人设：${window.userProfile?.personality || '未设置'}

原有记忆：
${currentMemory || '暂无原有记忆'}

最近的对话内容：
${completeMessageContext}

请整合原有记忆和最近的对话内容，生成更新后的完整记忆。记忆应该符合以下任意一条条件：
1. 用户主动说明的个人信息、生活状态、兴趣爱好
2. 用户主动提到的事件、计划或约定
3. 用户主动说明的自己的态度、偏好和个性特征
4. 其他值得记住的细节、约定等

记忆不要太琐碎！！要具体！

请直接输出更新后的纯Markdown记忆列表，所有记忆平级，不要其他说明：`;
    }

    /**
     * 构建记忆删除检查提示词
     */
    buildMemoryDeletionCheckPrompt(currentMemory, deletedUserTexts, contact) {
        const deletedTextsContent = deletedUserTexts.join('\n---\n');
        
        return `你是一个记忆分析助手。用户删除了一些消息，请判断是否需要从角色记忆中删除相关内容。

当前角色记忆：
${currentMemory || '暂无记忆'}

用户删除的消息内容：
${deletedTextsContent}

判断标准：
1. 被删除的消息内容是否在当前记忆中有对应的记录？
2. 删除这些消息是否意味着用户不希望这些信息被记住？

请仅回答"需要删除"不需要删除"，不需要其他解释。`;
    }

    /**
     * 构建记忆删除提示词
     */
    buildMemoryDeletionPrompt(currentMemory, deletedUserTexts, contact) {
        const deletedTextsContent = deletedUserTexts.join('\n---\n');
        const userName = window.userProfile?.name || '用户';
        
        return `你是一个记忆整理助手。用户删除了一些消息，请从角色记忆中删除相关内容。

角色信息：
- 姓名：${contact.name}
- 人设：${contact.personality}

用户信息：
- 姓名：${userName}
- 人设：${window.userProfile?.personality || '未设置'}

当前记忆：
${currentMemory || '暂无记忆'}

用户删除的消息内容：
${deletedTextsContent}

请从当前记忆中删除与被删除消息相关的内容，生成更新后的记忆。注意：
1. 删除与被删除消息直接相关的信息
2. 保留其他不相关的信息
3. 如果删除后记忆变空，请输出"暂无记忆"
4. 保持记忆的完整性和逻辑性

请直接输出更新后的纯Markdown记忆列表，所有记忆平级，不要其他解释：`;
    }

    /**
     * 构建全局记忆检查提示词
     */
    buildGlobalMemoryCheckPrompt(currentGlobalMemory, forumContent) {
        return `你是一个全局记忆分析助手。请判断以下论坛内容是否需要更新全局记忆。

当前全局记忆：
${currentGlobalMemory || '暂无记忆'}

论坛内容：
${forumContent}

判断标准：
1. 论坛内容是否涉及到全局记忆中没有的信息？
2. 论坛内容是否涉及到用户本身的形象，或现实生活中的事件？

请仅回答"满足"或"不满足"，不要其他解释。`;
    }

    /**
     * 构建全局记忆生成提示词
     */
    buildGlobalMemoryGeneratePrompt(currentGlobalMemory, forumContent) {
        const userName = window.userProfile?.name || '用户';
        
        return `你是一个记忆整理助手。请根据原有记忆和提供的用户发送的论坛内容，更新全局记忆。

用户信息：
- 姓名：${userName}
- 人设：${window.userProfile?.personality || '未设置'}

原有全局记忆：
${currentGlobalMemory || '暂无原有记忆'}

用户发送的论坛内容：
${forumContent}

请整合原有全局记忆和论坛内容，生成更新后的完整全局记忆。全局记忆需要满足以下要求：
- 分条的精炼概括
- 内容满足以下任意1条
    - 用户表达的观点、兴趣和态度
    - 用户主动提及的个人信息、生活状态、经历等
    - 其他重要的记忆

生成的记忆不要太琐碎！！要具体！

请直接输出更新后的纯Markdown记忆列表，所有记忆平级，不要其他解释：`;
    }

    /**
     * Promise化IndexedDB请求
     */
    promisifyRequest(request) {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 导出角色记忆数据
     */
    async exportMemoryData() {
        if (!window.isIndexedDBReady || !window.db) {
            return {
                characterMemories: {},
                globalMemory: this.globalMemory
            };
        }

        try {
            const transaction = window.db.transaction(['characterMemories', 'globalMemory'], 'readonly');
            
            // 导出角色记忆
            const memoryStore = transaction.objectStore('characterMemories');
            const allMemories = await this.promisifyRequest(memoryStore.getAll());
            
            const characterMemories = {};
            allMemories.forEach(memory => {
                characterMemories[memory.contactId] = {
                    memory: memory.memory,
                    updateCount: memory.updateCount,
                    lastUpdated: memory.lastUpdated
                };
            });
            
            // 导出全局记忆
            const globalStore = transaction.objectStore('globalMemory');
            const globalData = await this.promisifyRequest(globalStore.get('memory'));
            const globalMemory = globalData ? globalData.content : '';
            
            return {
                characterMemories: characterMemories,
                globalMemory: globalMemory
            };
        } catch (error) {
            console.error('导出记忆数据失败:', error);
            return {
                characterMemories: {},
                globalMemory: this.globalMemory
            };
        }
    }

    /**
     * 导入角色记忆数据
     */
    async importMemoryData(memoryData) {
        if (!window.isIndexedDBReady || !window.db || !memoryData) {
            return false;
        }

        try {
            const transaction = window.db.transaction(['characterMemories', 'globalMemory'], 'readwrite');
            
            // 导入角色记忆
            if (memoryData.characterMemories) {
                const memoryStore = transaction.objectStore('characterMemories');
                
                for (const [contactId, data] of Object.entries(memoryData.characterMemories)) {
                    const memoryRecord = {
                        contactId: contactId,
                        memory: data.memory,
                        updateCount: data.updateCount || 0,
                        lastUpdated: data.lastUpdated || new Date().toISOString()
                    };
                    await this.promisifyRequest(memoryStore.put(memoryRecord));
                }
            }
            
            // 导入全局记忆
            if (memoryData.globalMemory !== undefined) {
                const globalStore = transaction.objectStore('globalMemory');
                await this.promisifyRequest(globalStore.put({
                    id: 'memory',
                    content: memoryData.globalMemory,
                    lastUpdated: new Date().toISOString()
                }));
                this.globalMemory = memoryData.globalMemory;
            }
            
            console.log('记忆数据导入成功');
            return true;
        } catch (error) {
            console.error('导入记忆数据失败:', error);
            return false;
        }
    }

    /**
     * 获取次要模型
     */
    getSecondaryModel() {
        const secondaryModel = window.apiSettings?.secondaryModel;
        if (secondaryModel && secondaryModel !== 'sync_with_primary') {
            return secondaryModel;
        }
        // 如果没有配置次要模型，使用主要模型
        return window.modelSettings?.primaryModel || 'gpt-3.5-turbo';
    }

    /**
     * 从localStorage迁移记忆数据到indexedDB
     */
    async migrateLocalStorageMemories() {
        try {
            console.log('开始检查localStorage记忆数据迁移...');
            
            // 检查localStorage中是否有characterMemories数据
            const localStorageData = localStorage.getItem('characterMemories');
            if (!localStorageData) {
                console.log('localStorage中没有角色记忆数据，跳过迁移');
                return { migrated: false, reason: 'no_data' };
            }

            const characterMemories = JSON.parse(localStorageData);
            if (!characterMemories || typeof characterMemories !== 'object' || Object.keys(characterMemories).length === 0) {
                console.log('localStorage中的角色记忆数据为空，清理localStorage');
                localStorage.removeItem('characterMemories');
                return { migrated: false, reason: 'empty_data' };
            }

            console.log(`发现localStorage中有${Object.keys(characterMemories).length}个角色的记忆数据，开始详细迁移...`);

            // 确保IndexedDB已准备好
            if (!window.isIndexedDBReady || !window.db) {
                console.log('IndexedDB未准备好，暂时跳过迁移');
                return { migrated: false, reason: 'db_not_ready' };
            }

            let migratedCount = 0;
            let errors = [];

            // 遍历每个角色的记忆
            for (const [contactId, memories] of Object.entries(characterMemories)) {
                try {
                    if (!Array.isArray(memories) || memories.length === 0) {
                        console.log(`角色${contactId}的记忆数据为空，跳过`);
                        continue;
                    }

                    console.log(`处理角色${contactId}，发现${memories.length}条记忆`);

                    // 获取indexedDB中该角色的现有记忆
                    const existingMemory = await this.getCharacterMemory(contactId);
                    console.log(`角色${contactId}在indexedDB中${existingMemory && existingMemory.trim() ? '已有' : '没有'}记忆，将逐条检查重复性`);

                    // 过滤有效记忆内容
                    const validMemories = memories.filter(memory => memory.content && memory.content.trim());
                    console.log(`角色${contactId}有${validMemories.length}条有效记忆`);
                    
                    if (validMemories.length === 0) {
                        console.log(`角色${contactId}没有有效记忆内容，跳过`);
                        continue;
                    }

                    // 检查每条记忆的重复性
                    const newMemories = [];
                    let duplicateCount = 0;
                    
                    for (let i = 0; i < validMemories.length; i++) {
                        const memory = validMemories[i];
                        const memoryContent = memory.content.trim();
                        
                        console.log(`  检查记忆${i + 1}(ID:${memory.id}): ${memoryContent.substring(0, 50)}${memoryContent.length > 50 ? '...' : ''}`);
                        
                        // 检查是否与现有记忆完全重复
                        if (existingMemory && existingMemory.includes(memoryContent)) {
                            console.log(`    - 发现重复记忆，跳过`);
                            duplicateCount++;
                        } else {
                            console.log(`    - 新记忆，将添加`);
                            newMemories.push(memoryContent);
                        }
                    }

                    console.log(`角色${contactId}：跳过${duplicateCount}条重复记忆，准备添加${newMemories.length}条新记忆`);

                    if (newMemories.length > 0) {
                        // 如果有现有记忆，将新记忆追加到现有记忆后面
                        let combinedMemory;
                        if (existingMemory && existingMemory.trim()) {
                            combinedMemory = existingMemory + '\n\n' + newMemories.join('\n\n');
                        } else {
                            combinedMemory = newMemories.join('\n\n');
                        }

                        // 保存到indexedDB
                        const success = await this.saveCharacterMemory(contactId, combinedMemory);
                        if (success) {
                            migratedCount++;
                            console.log(`✓ 角色${contactId}成功迁移${newMemories.length}条新记忆（跳过${duplicateCount}条重复）`);
                            console.log(`  最终记忆内容长度: ${combinedMemory.length}字符`);
                        } else {
                            errors.push(`角色${contactId}记忆保存失败`);
                            console.error(`✗ 角色${contactId}记忆保存失败`);
                        }
                    } else {
                        console.log(`角色${contactId}所有记忆都已存在，无需迁移`);
                    }
                } catch (error) {
                    console.error(`迁移角色${contactId}的记忆时出错:`, error);
                    errors.push(`角色${contactId}: ${error.message}`);
                }
            }

            // 处理全局记忆迁移
            let globalMigrated = false;
            const globalMemoriesData = localStorage.getItem('globalMemories');
            if (globalMemoriesData) {
                try {
                    const globalMemories = JSON.parse(globalMemoriesData);
                    if (Array.isArray(globalMemories) && globalMemories.length > 0) {
                        console.log(`发现${globalMemories.length}条全局记忆，开始迁移...`);
                        
                        // 获取现有全局记忆
                        const existingGlobalMemory = await this.getGlobalMemory();
                        console.log(`indexedDB中${existingGlobalMemory && existingGlobalMemory.trim() ? '已有' : '没有'}全局记忆，将逐条检查重复性`);
                        
                        // 过滤有效全局记忆
                        const validGlobalMemories = globalMemories.filter(memory => memory.content && memory.content.trim());
                        console.log(`有${validGlobalMemories.length}条有效全局记忆`);
                        
                        // 检查每条全局记忆的重复性
                        const newGlobalMemories = [];
                        let globalDuplicateCount = 0;
                        
                        for (let i = 0; i < validGlobalMemories.length; i++) {
                            const memory = validGlobalMemories[i];
                            const memoryContent = memory.content.trim();
                            
                            console.log(`  检查全局记忆${i + 1}(ID:${memory.id}): ${memoryContent.substring(0, 50)}${memoryContent.length > 50 ? '...' : ''}`);
                            
                            // 检查是否与现有全局记忆完全重复
                            if (existingGlobalMemory && existingGlobalMemory.includes(memoryContent)) {
                                console.log(`    - 发现重复全局记忆，跳过`);
                                globalDuplicateCount++;
                            } else {
                                console.log(`    - 新全局记忆，将添加`);
                                newGlobalMemories.push(memoryContent);
                            }
                        }

                        console.log(`全局记忆：跳过${globalDuplicateCount}条重复记忆，准备添加${newGlobalMemories.length}条新记忆`);
                        
                        if (newGlobalMemories.length > 0) {
                            // 如果有现有全局记忆，将新记忆追加到现有记忆后面
                            let combinedGlobalMemory;
                            if (existingGlobalMemory && existingGlobalMemory.trim()) {
                                combinedGlobalMemory = existingGlobalMemory + '\n\n' + newGlobalMemories.join('\n\n');
                            } else {
                                combinedGlobalMemory = newGlobalMemories.join('\n\n');
                            }
                            
                            const success = await this.saveGlobalMemory(combinedGlobalMemory);
                            if (success) {
                                globalMigrated = true;
                                console.log(`✓ 成功迁移${newGlobalMemories.length}条新全局记忆（跳过${globalDuplicateCount}条重复）`);
                                console.log(`  最终全局记忆内容长度: ${combinedGlobalMemory.length}字符`);
                            } else {
                                console.error('✗ 全局记忆保存失败');
                                errors.push('全局记忆保存失败');
                            }
                        } else {
                            console.log('所有全局记忆都已存在，无需迁移');
                        }
                    }
                } catch (error) {
                    console.error('迁移全局记忆时出错:', error);
                    errors.push(`全局记忆: ${error.message}`);
                }
            }
            
            // 迁移完成后清空localStorage
            if (migratedCount > 0 || globalMigrated) {
                if (migratedCount > 0) {
                    localStorage.removeItem('characterMemories');
                    console.log(`角色记忆迁移完成：成功迁移${migratedCount}个角色的记忆`);
                }
                if (globalMigrated) {
                    localStorage.removeItem('globalMemories');
                }
                
                return { 
                    migrated: true, 
                    migratedCount, 
                    globalMigrated,
                    errors: errors.length > 0 ? errors : null 
                };
            } else {
                return { 
                    migrated: false, 
                    reason: 'no_valid_data',
                    errors: errors.length > 0 ? errors : null 
                };
            }

        } catch (error) {
            console.error('localStorage记忆迁移失败:', error);
            return { migrated: false, reason: 'migration_error', error: error.message };
        }
    }
}

// 创建全局实例
window.characterMemoryManager = new CharacterMemoryManager();

// 暴露主要函数到全局作用域
window.checkAndUpdateMemory = function(contactId, currentContact, forceCheck = false) {
    return window.characterMemoryManager.checkAndUpdateMemory(contactId, currentContact, forceCheck);
};

window.incrementConversationCounter = function(contactId) {
    return window.characterMemoryManager.incrementConversationCounter(contactId);
};

window.checkAndUpdateGlobalMemory = function(forumContent, forceCheck = false) {
    return window.characterMemoryManager.checkAndUpdateGlobalMemory(forumContent, forceCheck);
};

window.checkAndUpdateMemoryAfterDeletion = function(contactId, deletedMessages, currentContact) {
    return window.characterMemoryManager.checkAndUpdateMemoryAfterDeletion(contactId, deletedMessages, currentContact);
};

window.clearCharacterMemory = function(contactId) {
    return window.characterMemoryManager.clearCharacterMemory(contactId);
};

window.clearAllCharacterMemories = function() {
    return window.characterMemoryManager.clearAllCharacterMemories();
};

// 暴露迁移函数用于手动测试
window.testMigrateLocalStorageMemories = function() {
    return window.characterMemoryManager.migrateLocalStorageMemories();
};

// 自动初始化 - 仅绑定事件，数据加载在数据库准备好后自动执行
document.addEventListener('DOMContentLoaded', function() {
    if (window.characterMemoryManager) {
        window.characterMemoryManager.bindEvents();
        // 注意：数据加载将在 script.js 中数据库准备好后自动执行
    }
});

// 导出模块（如果使用ES6模块）
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        CharacterMemoryManager
    };
}
</script>
    <script>
/**
 * 图片关键词生成器
 * 使用AI将中文图片描述转换为更精准的英文搜索关键词，提升Unsplash图片搜索效果
 */

class ImageKeywordGenerator {
    constructor() {
        this.initialized = false;
    }

    /**
     * 初始化关键词生成器
     * @param {Object} apiSettings - API配置
     * @param {Object} apiService - API服务实例
     */
    init(apiSettings, apiService) {
        this.apiSettings = apiSettings;
        this.apiService = apiService;
        this.initialized = true;
    }

    /**
     * 使用AI生成适合Unsplash搜索的关键词
     * @param {string} content 原始内容描述
     * @returns {Promise<string>} 生成的搜索关键词
     */
    async generateKeyword(content) {
        // 检查初始化状态
        if (!this.initialized) {
            console.warn('ImageKeywordGenerator未初始化，使用原始内容作为搜索关键词');
            return content;
        }

        // 检查并获取API配置
        try {
            const apiConnection = await window.apiConfigManager.getCurrentApiConnection();

            if (!apiConnection.url || !apiConnection.key || !apiConnection.primaryModel) {
                console.warn('AI API未配置，使用原始内容作为搜索关键词');
                return content;
            }

            const prompt = `Generate 2-5 English keywords for Unsplash photo search based on this description: "${content}"

Requirements:
- Only return keywords separated by spaces
- Focus on visual, concrete elements
- Avoid abstract concepts
- Prefer landscapes, objects, scenes over people
- Maximum 50 characters total

Keywords:`;

            // 处理次要模型选择逻辑
            const modelToUse = apiConnection.secondaryModel === 'sync_with_primary'
                ? apiConnection.primaryModel
                : (apiConnection.secondaryModel || apiConnection.primaryModel);

            console.log(`[ImageKeywordGenerator] 使用模型: ${modelToUse} (secondaryModel配置: ${apiConnection.secondaryModel})`);

            const response = await this.apiService.callOpenAIAPI(
                apiConnection.url,
                apiConnection.key,
                modelToUse,
                [{ role: 'user', content: prompt }],
                {
                    temperature: 0.7,
                    max_tokens: 3000
                },
                (this.apiSettings.timeout * 1000) || 30000
            );
            
            // 检查响应的完整性
            const choice = response.choices[0];
            if (!choice) {
                console.warn('[ImageKeywordGenerator] API响应中没有choices，使用原始内容');
                return content;
            }
            
            // 检查是否被截断
            if (choice.finish_reason === 'length') {
                console.warn('[ImageKeywordGenerator] API响应被截断，使用原始内容');
                return content;
            }
            
            // 检查是否有错误
            if (choice.finish_reason !== 'stop' && choice.finish_reason !== null) {
                console.warn(`[ImageKeywordGenerator] API响应异常结束 (${choice.finish_reason})，使用原始内容`);
                return content;
            }
            
            const keyword = choice.message?.content?.trim();
            if (!keyword || keyword.length === 0) {
                console.warn('[ImageKeywordGenerator] AI返回空关键词，使用原始内容');
                return content;
            }
            
            // 验证关键词是否为有效的英文
            const isValidKeyword = /^[a-zA-Z0-9\s\-.,!?]+$/.test(keyword) && 
                                 keyword.length > 0 && 
                                 keyword.length < 200 && 
                                 !keyword.includes('{') && 
                                 !keyword.includes('}');
            
            if (!isValidKeyword) {
                console.warn(`[ImageKeywordGenerator] 生成的关键词格式无效: "${keyword.substring(0, 100)}..."，使用原始内容`);
                return content;
            }
            
            console.log(`[ImageKeywordGenerator] AI生成关键词: "${keyword}" (原始: "${content}")`);
            return keyword;
            
        } catch (error) {
            console.warn('[ImageKeywordGenerator] 生成关键词失败，使用原始内容:', error);
            return content;
        }
    }

    /**
     * 批量生成关键词（用于同时处理多个描述）
     * @param {Array<string>} contents 原始内容描述数组
     * @returns {Promise<Array<string>>} 生成的搜索关键词数组
     */
    async generateKeywords(contents) {
        if (!Array.isArray(contents)) {
            throw new Error('contents必须是数组');
        }

        const results = [];
        for (const content of contents) {
            const keyword = await this.generateKeyword(content);
            results.push(keyword);
        }
        return results;
    }

    /**
     * 检查是否已初始化并可用
     * @returns {boolean}
     */
    async isReady() {
        if (!this.initialized) return false;

        try {
            const connection = await window.apiConfigManager.getCurrentApiConnection();
            return connection.url && connection.key && connection.primaryModel;
        } catch (error) {
            return false;
        }
    }
}

// 创建全局实例
window.imageKeywordGenerator = new ImageKeywordGenerator();

/**
 * 向后兼容的全局函数
 * @param {string} content 原始内容描述
 * @returns {Promise<string>} 生成的搜索关键词
 */
async function generateImageSearchKeyword(content) {
    return await window.imageKeywordGenerator.generateKeyword(content);
}

// 导出到全局作用域以保持向后兼容
window.generateImageSearchKeyword = generateImageSearchKeyword;
</script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker disabled in single-file mode: ', err);
                    });
            });
        }
    </script>
    
    <!-- 持久化存储说明模态框 -->
    <div id="persistentStorageInfoModal" class="info-modal modal-overlay hidden" onclick="if(event.target === this) StorageManager.closePersistentStorageInfo()">
        <div class="modal-content">
            <div class="modal-header">
                📚 数据持久化存储说明
            </div>
            <div class="modal-body">
                <p><strong>什么是数据持久化存储？</strong></p>
                <p>数据持久化存储，代表数据不会轻易被设备/浏览器清除。</p>
                
                <p><strong>为什么需要？</strong></p>
                <p>若未持久存储，则可能会被随时清理，导致数据丢失。</p>
                
                <p><strong>如何获得？</strong></p>
                <p>请尝试"申请持久化数据库"按钮。若申请未通过，可以尝试：</p>
                <ul>
                    <li>多访问网页，增加使用频率</li>
                    <li>等几天再尝试申请</li>
                    <li>将网站添加到书签</li>
                </ul>
                
                <p><strong>期间建议</strong></p>
                <p>申请期间，请频繁备份数据以防丢失。</p>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn" onclick="StorageManager.closePersistentStorageInfo()">
                    我知道了
                </button>
            </div>
        </div>
    </div>
</body>
</html>
